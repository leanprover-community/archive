[
    {
        "content": "<p>This question is a bit messed up so I don't expect there to be a good answer. The PMF type in mathlib which is marked <code>noncomputable</code>, for good reason, but I want to execute PMF's using an external function binding (like in SampCert), and remove <code>noncomputable</code> marking. Is there any way to do this?</p>",
        "id": 480269582,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1730601085
    },
    {
        "content": "<p>What's SampCert? How do you want to represent reals?</p>",
        "id": 480272915,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730604244
    },
    {
        "content": "<p>We don't represent reals, we're (currently) using it to represent randomly sampled values. <a href=\"https://github.com/leanprover/SampCert/blob/main/ffi.cpp\">This</a> is the SampCert FFI code, which is used for the external definitions <a href=\"https://github.com/leanprover/SampCert/blob/main/SampCert/SLang.lean\">here</a></p>",
        "id": 480274068,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1730605541
    },
    {
        "content": "<p>It works in SampCert because the monadic bind and return are defined inside the project, but if you want to do the same thing with Lean PMF's you need to somehow instruct Lean to use an extern binding for mathlib code. I'm wondering if this is at all possible.</p>",
        "id": 480274189,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1730605678
    },
    {
        "content": "<p>I don't think that, e.g., <code>extern prob_Pure</code> does what you think it does.</p>",
        "id": 480277423,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730608866
    },
    {
        "content": "<p><code>probPure</code> is defined as a function <code>T → T → ENNReal</code> but you implement it as a function <code>T → T → T</code> that returns the first argument.</p>",
        "id": 480277550,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730608922
    },
    {
        "content": "<p>That's exactly what it's supposed to do :) It's the imperative way to sample from the dirac distribution. You'll see that the other externed distributions involve eg. nondeterministic and nonterminating code, which is why SampCert does it that way. </p>\n<p>I'm wondering if I can tell Lean to compile certain PMF's from mathlib using a similar technique. The main is telling Lean to attach an extern definition to library code, and marking noncomputable library code as computable.</p>",
        "id": 480308104,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1730641102
    },
    {
        "content": "<p>That's not what<code>extern</code> is supposed to do.</p>",
        "id": 480314931,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730647265
    },
    {
        "content": "<p>You should write a function <code>PMF.sample</code> with a correct type signature and use <code>extern</code> on it.</p>",
        "id": 480315071,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1730647369
    }
]