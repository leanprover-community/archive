[
    {
        "content": "<p>(See mwe below) I am building a tactic that manipulates expressions in a reified intermediate representations similar to <code>bv_decide</code>. It operates on <code>iN n</code>, which is similar to a <code>BitVec n</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bitvec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">poison</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">bits</span>\n</code></pre></div>\n<p>How it would generally work is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>(reify) Expr -&gt; IR, returns a proof that IR.eval = expr\n(denote) IR -&gt; Expr, returns a proof that IR.eval = expr\n\ngiven opt : IR -&gt; IR and lhs:\n\n  ir  = reify lhs     (IR.eval ir = lhs)\n  ir' = opt ir        (IR.eval ir ~&gt; IR.eval ir')   (use opt.wf)\n  rhs = denote ir'    (IR.eval ir' = rhs)\n\nchain the proofs to end up with lhs ~&gt; rhs\n</code></pre></div>\n<p>I'm having issues creating my reify function. It currently accepts expressions of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>and builds up two assignments</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PackediN</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Assignment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">RArray</span><span class=\"w\"> </span><span class=\"n\">PackediN</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">WidthAssignment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">RArray</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>such that if <code>fun {n} (x : iN n) =&gt; x</code>, it should assign</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WidthAssignment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Assignment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ir</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>and return a value <code>⟨IR.var 0, x_expr, pure none⟩ : ReifiedIR 0</code> where</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ReifiedIR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">irExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span>\n<span class=\"w\">  </span><span class=\"n\">originalExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> proof that IR.eval irExpr = originalExpr, or by rfl if none  -/</span>\n<span class=\"w\">  </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Evaluating the <code>ir</code> given the two assignments assigns semantics to it. When reifying, similar to <code>bv_decide</code>, it assumes that the evaluation of the <code>IR.var</code> is definitionally equal to <code>x</code>. However, this is not the case, as you can see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WidthAssignment</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Assignment</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ξ.get</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pack</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">σ.get</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> h is always true, this if is for totality -/</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pack.n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ξ.get</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">pack.x</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">pack.truncate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ξ.get</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const_poison</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">poison</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">defeq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR.eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray.leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray.leaf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray.leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR.var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  Tactic `rfl` failed: The left-hand side</span>\n<span class=\"cm\">    IR.eval (RArray.leaf n) (RArray.leaf { n := (RArray.leaf n).get 0, x := x }) (IR.var 0)</span>\n<span class=\"cm\">  is not definitionally equal to the right-hand side</span>\n<span class=\"cm\">    x</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IR.eval</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- this works!</span>\n</code></pre></div>\n<p>Taking a look at the proofs that <code>bv_decide</code> creates, the difference between my tactic and <code>bv_decide</code> is shown. Since I want my tactic to work on rewriting quantified bitvectors in the IR, not just bitvectors with a fixed width, I need to introduce two different assignments. One set of assignments for the variables, and one set of assignments for the bitwidths.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">t8</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span><span class=\"bp\">.</span><span class=\"n\">BVExpr</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span><span class=\"bp\">.</span><span class=\"n\">BVExpr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> when you introduce a quantifier, it fails to be definitionally equal! -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">tn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span><span class=\"bp\">.</span><span class=\"n\">BVExpr</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">})</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span><span class=\"bp\">.</span><span class=\"n\">BVExpr</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails!</span>\n</code></pre></div>\n<p>Creating a general theorem to prove this works as well, as you can see inlining the <code>ξ : WidthAssignment</code> makes this theorem type nice as <code>ξ.get 0 = n</code> holds as a definitional equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">reflect_var_eval_var</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Assignment</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Furthermore, <code>hb</code> and <code>h</code> are definitional equalities as well when you inline <code>σ</code> in the \"evals at <del>atoms</del> assignments\" part of reify.</p>\n<p>I guess the question I am asking is that how would I formulate this in a nice way in my tactic given that they're not definitionally equal? Or, maybe they are definitionally equal and I am formulating it wrongly?</p>\n<p>An mwe is attached: <a href=\"/user_uploads/3121/aVMkj5a18XgkcAWobPYwISM8/mwe.lean\">mwe.lean</a>, it doesn't depend on anything but <code>Lean</code> and <code>Qq</code>. I'm quite new to metaprogramming tactics in this style, so some guidance would be greatly appreciated!</p>",
        "id": 565536079,
        "sender_full_name": "l1mey",
        "timestamp": 1766878260
    },
    {
        "content": "<p>Maybe someone might be able to answer why the theorem <code>defeq</code> isn't provable by just definitional equality, is it because of the variables on the type?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">defeq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iN</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RArray</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IR</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IR</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  Tactic `rfl` failed: The left-hand side</span>\n<span class=\"cm\">    IR.eval (RArray.leaf n) (RArray.leaf { n := (RArray.leaf n).get 0, x := x }) (IR.var 0)</span>\n<span class=\"cm\">  is not definitionally equal to the right-hand side</span>\n<span class=\"cm\">    x</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 565542421,
        "sender_full_name": "l1mey",
        "timestamp": 1766887960
    },
    {
        "content": "<p>it's because you have a <code>if h : pack.n = (ξ.get idx)</code></p>",
        "id": 565542811,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766888655
    },
    {
        "content": "<p>the way <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decEq#doc\">docs#Nat.decEq</a> reduces this will only definitionally reduce to true when both sides are definitionally the same numeral (not a variable)</p>",
        "id": 565542849,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766888742
    },
    {
        "content": "<p>I understand. I guess instead of definitional equality it would just suffice to create a simp context and do the equivalent of <code>simp [IR.eval]</code> to prove the goal. I'll add in caching as well like <code>bv_decide</code>.</p>\n<p>Last question, what is the interaction with definitional equality and decidable equality? I thought definitional equality does reduction based on the definition, I didn't know it called out to decidable instances.</p>",
        "id": 565544614,
        "sender_full_name": "l1mey",
        "timestamp": 1766892595
    },
    {
        "content": "<p>Ah, nevermind. <code>dite</code> requires a decidable <code>h</code>.</p>",
        "id": 565544661,
        "sender_full_name": "l1mey",
        "timestamp": 1766892729
    },
    {
        "content": "<p>I see above the if statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> h is always true, this if is for totality -/</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pack</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n</code></pre></div>\n<p>so maybe if you pass in a proof instead of making the function total, then you can still get definitional equality?</p>",
        "id": 565545224,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1766894035
    },
    {
        "content": "<p>The issue is I can't do such a thing, because the <code>IR.eval</code> function is meant to work for things that aren't <code>.var</code> as well. In the mwe and code snippets, I include cases for <code>.const_poison</code> with the rest of the cases omitted. It wouldn't work in general.</p>",
        "id": 565547087,
        "sender_full_name": "l1mey",
        "timestamp": 1766897622
    }
]