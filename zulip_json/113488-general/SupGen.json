[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span> released a demo for a symbolic theorem prover called SupGen for (dependent?) type theory.  See the post below for a demo video.</p>\n<p><del>https://x.com/VictorTaelin/status/1881088337408377007</del><br>\n<a href=\"https://x.com/VictorTaelin/status/1881392823246729640\">https://x.com/VictorTaelin/status/1881392823246729640</a></p>",
        "id": 494692341,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737329982
    },
    {
        "content": "<p>I think out of the Lean projects, it is most similar to Canonical (<span class=\"user-mention\" data-user-id=\"346696\">@Chase Norman</span>), but probably holds a similar space to Duper (<span class=\"user-mention\" data-user-id=\"436568\">@Josh Clune</span>) and LeanSMT (<span class=\"user-mention\" data-user-id=\"417967\">@Abdalrhman M Mohamed</span>).  And to be honest, I have no idea how it works or if it is any good.</p>",
        "id": 494692350,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737329996
    },
    {
        "content": "<p>Victor talks a lot about how this sort of thing could be used in place of neural AI.  While I think he has some points on symbolic AI not being given enough credit, I also think something like this alone would have a limited use case.  But it would be fun to find ways to test this (and the other symbolic solvers) out.</p>",
        "id": 494692385,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737330003
    },
    {
        "content": "<p>There was a previous discussion on this sort of thing at <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Duper.20and.20Program.20Synthesis\">#general &gt; Duper and Program Synthesis</a></p>",
        "id": 494692400,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737330005
    },
    {
        "content": "<p>I can confirm that at a high level we appear to be building the same functionality.</p>",
        "id": 494693518,
        "sender_full_name": "Chase Norman",
        "timestamp": 1737330935
    },
    {
        "content": "<p>The link above doesn’t seem to work for me. Is there another link I could try?</p>",
        "id": 494701080,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737336485
    },
    {
        "content": "<p>he deleted it for now: <a href=\"https://x.com/VictorTaelin/status/1881135609823289766\">https://x.com/VictorTaelin/status/1881135609823289766</a></p>",
        "id": 494701181,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737336565
    },
    {
        "content": "<p>Hopefully, he will post a new one soon.</p>",
        "id": 494701209,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737336596
    },
    {
        "content": "<p><a href=\"https://x.com/VictorTaelin/status/1881392823246729640\">https://x.com/VictorTaelin/status/1881392823246729640</a></p>",
        "id": 494904016,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737403714
    },
    {
        "content": "<p>Why a limited usecase?</p>",
        "id": 495585254,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737666321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"734274\">@Gridiron Player</span>  It doesn't have premise/lemma selection, so I can't see how it would be able to find and use relevant theorems and definitions in a library.  It wouldn't make sense to prove everything from axioms/definitions.  (The cut elimination theorem says that doing so can lead to more than exponential increases in proof size.)  But at the same time, other symbolic solvers have the same problem and the solution is just to build a machine learning lemma selector.  So if it had that, or if it was narrowly used in cases where the lemmas are known, then it could be powerful.  (Similarly with Canonical, Duper, and LeanSAT.)  Indeed if it could be hooked up to Auto then it could take advantage of whatever lemma selector is planned for auto.  (Auto IIRC is an interface between Lean and symbolic solvers.)</p>",
        "id": 495585851,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737666577
    },
    {
        "content": "<p>Of course, this is more opinion than fact, and I'd be happy to be proved wrong.</p>",
        "id": 495586008,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737666632
    },
    {
        "content": "<p>Thats probably a question for Victor, but couldn't you just wrap already existing theorems as a type and use them for search?</p>\n<p>Just me thinking out loud here. I have no idea.</p>",
        "id": 495586143,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737666684
    },
    {
        "content": "<p>Happy to have Victor (<span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span>) engage here.  (Also, here is a recent reply of mine to him on X: <a href=\"https://x.com/JasonRute/status/1882393233701171671\">https://x.com/JasonRute/status/1882393233701171671</a>)</p>",
        "id": 495586631,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737666863
    },
    {
        "content": "<p>In programming its kind of the same problem. You need to be able to synthesize functions that use other functions. I was under the assumption that that will be possible with SupGen. If not, then it might be of limited usability.</p>",
        "id": 495586658,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737666881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734274\">Gridiron Player</span> <a href=\"#narrow/channel/113488-general/topic/SupGen/near/495586143\">said</a>:</p>\n<blockquote>\n<p>Thats probably a question for Victor, but couldn't you just wrap already existing theorems as a type and use them for search?</p>\n<p>Just me thinking out loud here. I have no idea.</p>\n</blockquote>\n<p>Yes. All of those tactics use theorem types for search. It's just a question of which existing theorem is going to be useful. Any ATP will get lost in proof search if it gets overwhelmed with a large search space if given useless theorems (though some are more robust to this others)</p>",
        "id": 495586984,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1737667007
    },
    {
        "content": "<p>Isn't that what Victor's HVM solves for? It's fast... HVM is kind of what makes SupGen so special, not the proof synthesis itself.</p>",
        "id": 495587127,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737667079
    },
    {
        "content": "<p><a href=\"https://github.com/HigherOrderCO/HVM\">https://github.com/HigherOrderCO/HVM</a></p>",
        "id": 495588568,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737667708
    },
    {
        "content": "<p><a href=\"https://x.com/VictorTaelin/status/1876458776980578596/photo/1\">https://x.com/VictorTaelin/status/1876458776980578596/photo/1</a></p>",
        "id": 495588619,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737667723
    },
    {
        "content": "<p>See explanation video about interaction nets on <a href=\"https://higherorderco.com/\">https://higherorderco.com/</a></p>",
        "id": 495588816,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737667804
    },
    {
        "content": "<p>Victor is a good salesman, but it is hard to evaluate twitter posts.  The idea isn't completely novel, as for example <span class=\"user-mention\" data-user-id=\"346696\">@Chase Norman</span>'s Canonical is similar.  But maybe it is underexplored and maybe he has good ideas and tech.  Also the current performance is hard to evaluate.  There is no technical report/paper with benchmarks that I'm aware of.  And it isn't clear that it is available to use.</p>",
        "id": 495589369,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737668040
    },
    {
        "content": "<p>As for interaction nets, they have been discussed here before: <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Kind.20lang\">#general &gt; Kind lang</a></p>",
        "id": 495589423,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737668045
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 495589643,
        "sender_full_name": "Chase Norman",
        "timestamp": 1737668141
    },
    {
        "content": "<p>Oh okay. Understood.</p>",
        "id": 495590022,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737668296
    },
    {
        "content": "<p>This is the first time I've encountered HVM. From what I read, it's not clear to me why or how it can improve proof search or type checking...</p>",
        "id": 495590027,
        "sender_full_name": "Abdalrhman M Mohamed",
        "timestamp": 1737668300
    },
    {
        "content": "<p>I guess we'll see how it plays out. I don't have the time to do a deep dive into interaction nets. All I understand is that he claims that HVM makes program synthesis / type checking faster, as well as everything else that can be parallelized.</p>",
        "id": 495590186,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737668387
    },
    {
        "content": "<p>(Actually, maybe I'm mistaken about no benchmarks.  Victor mentions something on X about it, <a href=\"https://x.com/VictorTaelin/status/1882171887704236227\">https://x.com/VictorTaelin/status/1882171887704236227</a>, but it is hard to skim through a 30-minute video.)</p>",
        "id": 495590868,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737668680
    },
    {
        "content": "<p>(this this how you reply a thread here? zulip is so confusing)</p>\n<p>just to clarify, the speedup doesn't come from parallelism, but from HVM's beta optimality. we use superpositions to share computations on the enumerated space. we tested against SOTA program synthesizers \"by example\" and it is considerably faster. I'm not focused on ATP yet as I want to first optimize for this use case. it will take a while for a paper and benchmarks, but it will come. this was an early demo. yes, it is similar to Canonical, and I expect it will greatly outperform it, for the same reasons it outperforms all other bruteforce-like solutions for program synthesis by example. but don't quote me on it until there is a paper...</p>",
        "id": 495593136,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737669702
    },
    {
        "content": "<p>Welcome, and thanks for the engagement!  I look forward to the paper.</p>",
        "id": 495593308,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737669779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span>  For SOTA program synthesizers, does that include LELO?  <a href=\"https://arxiv.org/abs/2310.19791\">https://arxiv.org/abs/2310.19791</a></p>",
        "id": 495593870,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737670025
    },
    {
        "content": "<p>Also, when you get to theorem proving (and maybe also program synthesis), how do you handle having a large library of possibly relevant theorems and definitions?  Or are you side stepping this for now?</p>",
        "id": 495593875,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737670027
    },
    {
        "content": "<p>For example, in program synthesis is there any context besides the definitions used in the type signature?</p>",
        "id": 495594009,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737670084
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> no, I'm specifically comparing to LLM-free synthesizers. I believe that extending this with the ability to learn will outperform LLMs, but this isn't what we have (yet).</p>",
        "id": 495594235,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737670197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> you can use a context! So yes, this is compatible with a library of relevant theorems and definitions; it significantly speeds up the search, <em>and</em> your definitions compute optimally, so it is really, really fast at that. That's how we expect to beat LLMs (by dynamically learning such library, which would be the \"model\").</p>",
        "id": 495594480,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737670300
    },
    {
        "content": "<p>Note that our synthesizer can already prove theorems (because it is just an enumerator in a dependently typed language), but that was almost by accident; there are some minor things missing to make this useful for APT (like the ability to synthesize types, which I didn't implement yet since I was focusing on programs by example). That's not hard to add though</p>",
        "id": 495594646,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737670364
    },
    {
        "content": "<p>There are some important limitations though, currently we only recurse via folds etc., and it only finds linear programs.</p>",
        "id": 495594746,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737670407
    },
    {
        "content": "<p>Lean has decrimination tree for searching over the full global context.  It is used in tactics like apply? and exact?  Are you using something similar?  Also when you do ATP, can it be hooked up to Lean with an interface similar to what Canonical will use?</p>",
        "id": 495595106,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737670575
    },
    {
        "content": "<p>there is no discrimination tree, the apply/exact tactics merely select from a <em>superposition</em> of the entire library - no fancy structure. there is no unification either (as usually understood); instead, metavariables are just superpositions of all possible terms of their type. due to optimal evaluation, every branch that doesn't type-check is discarded efficiently, so I believe we don't need a hardcoded structure to get the desired asymptotics. that said, adding one might be an interesting experiment to try, although I suspect it will be an anti-optimization due to the overhead of the tree itself...</p>\n<p>I'm not very familiar with Lean or the interface that Canonical will use, but it is a separate language / type checker, so there would need to be some translation layer from Lean to SupGen and back for it to work?</p>",
        "id": 495596261,
        "sender_full_name": "Victor Maia",
        "timestamp": 1737671197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span> Im confused on the part where you said that SupGen can dybamically learn the Lean Library. I thought it would just be an enumerator. How so without deep learning?</p>\n<p>Would the library contents just be added as a type or something?</p>\n<p>Update: Nevermind, you said you would add the library as a superposition which is also really fast obviously</p>",
        "id": 495698261,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737720161
    },
    {
        "content": "<p>What do you mean “added as a type”?</p>",
        "id": 495698662,
        "sender_full_name": "Jason Rute",
        "timestamp": 1737720297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>  I misunderstood it. I reread his post and realized that all the theorems will just be added in a superposition.</p>\n<p><span class=\"user-mention\" data-user-id=\"372571\">@Victor Maia</span> Can you add superpositions to another superposition \"recursively\"?</p>\n<p>Like</p>\n<p>(1 , (2,3))</p>\n<p>or would that not be necessary to add theorems to superpositions?</p>",
        "id": 495698791,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737720335
    },
    {
        "content": "<p>Nevermind, realizing that superpositions are (I think) just a result of how computations are shared in an inet, I think my question doesnt matter as much, as a theorem definition would just be added as computations to the graph, Im assuming.</p>\n<p>Im a noob,  just thinking outloud here lol.</p>",
        "id": 495700554,
        "sender_full_name": "Gridiron Player",
        "timestamp": 1737720932
    },
    {
        "content": "<p>what does superpostition mean in this case?</p>",
        "id": 495737602,
        "sender_full_name": "Jared green",
        "timestamp": 1737731969
    },
    {
        "content": "<p><a href=\"https://x.com/VictorTaelin/status/1884971947131314319?t=MSciy6PxTTK5uDbkOGhPyA&amp;s=19\">https://x.com/VictorTaelin/status/1884971947131314319?t=MSciy6PxTTK5uDbkOGhPyA&amp;s=19</a></p>\n<p>Very sorry to see this. I assume \"not open source\" also means \"only available as a service over the Internet\", which would definitely make this much less exciting.</p>",
        "id": 497186243,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1738434082
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 497186399,
        "sender_full_name": "Chase Norman",
        "timestamp": 1738434217
    },
    {
        "content": "<p>(Could I suggest not posting screenshots without explanation of what they are, or why you are posting them?)</p>",
        "id": 497298363,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738535985
    }
]