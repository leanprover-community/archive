[
    {
        "content": "<p>Hi, I noticed something weird about Lp spaces. </p>\n<p>If I run the code </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">LpSpace</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lp</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)))</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lp</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>I get the error </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">f</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Lp</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑↑</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Lp</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>I think this is happening because for some reason ((1 : ℕ+) : ℝ≥0∞) and (1 : ℝ≥0∞) are not definitionally equal, which they need to be in the argument of Lp?</p>\n<p>Does anyone know any way to circumvent this or get Lean to recognize that those are the same thing?</p>",
        "id": 506052057,
        "sender_full_name": "Strategist _",
        "timestamp": 1742192935
    },
    {
        "content": "<p>What's weird about it?</p>",
        "id": 506057159,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1742194521
    },
    {
        "content": "<p>I would expect the coercion of 1 from ℕ+ to  ℝ≥0∞ to behave the same way as just 1 in ℝ≥0∞ since they should in principle be the same thing. Is there some way to get Lean to interpret it that way?</p>",
        "id": 506057770,
        "sender_full_name": "Strategist _",
        "timestamp": 1742194774
    },
    {
        "content": "<p>Is <code>((1 : PNat) : ENNReal) = 1</code> a <code>rfl</code>?</p>",
        "id": 506154892,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742218871
    },
    {
        "content": "<p>BTW, you need a newline after the first <code> ``` </code> to get syntax highlighting.</p>",
        "id": 506155191,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742218939
    },
    {
        "content": "<p>Found it: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.instOne#doc\">docs#Real.instOne</a> uses an irreducible <code>private def Real.one</code>.</p>",
        "id": 506156556,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742219254
    },
    {
        "content": "<p>You can move <code>NatCast</code> instance earlier, then redefine <code>One Real</code> using <code>one := (1 : Nat)</code>, similarly for <code>Zero Real</code>.</p>",
        "id": 506156773,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742219304
    },
    {
        "content": "<p>This will make <code>Nat.cast 1 = 1</code> a <code>rfl</code> for <code>Real</code>s.</p>",
        "id": 506156863,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742219328
    },
    {
        "content": "<p>Or we just change <code>Real.one</code> to not be irreducible, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.instNatCast#doc\">docs#Real.instNatCast</a> is</p>",
        "id": 506157782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742219524
    },
    {
        "content": "<p>Probably we have the same problem with <code>Real.zero</code></p>",
        "id": 506157825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742219533
    },
    {
        "content": "<p>How much performance do we lose if we drop all the <code>irreducible_</code>s in that file?</p>",
        "id": 506158128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1742219602
    },
    {
        "content": "<p>AFAIR, Lean used to unfold <code>Real</code>-related semireducible definitions during hard-to-unify <code>apply</code>, <code>convert</code> etc.</p>",
        "id": 506159900,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742219961
    },
    {
        "content": "<p>So just to clarify, you'd recommend modifying my local copy of Mathlib to get that to be a rfl?</p>",
        "id": 506229084,
        "sender_full_name": "Strategist _",
        "timestamp": 1742235535
    },
    {
        "content": "<p>If you modify your local mathlib then your code can't be used by anyone else. You could make a WIP PR removing all the <code>irreducible</code>s in that file and then benchmark it to see what happens.</p>",
        "id": 506233188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742236705
    },
    {
        "content": "<p>There are 2 ways you can deal with this issue:</p>\n<ul>\n<li>make <code>((1 : Nat) : Real) = 1</code> a <code>rfl</code>;</li>\n<li>define <code>Lp.cast (h : p = q)</code> as a continuous linear equivalence between <code>Lp</code> with <code>p</code> and <code>Lp</code> with <code>q</code> (hint: reuse <code>Equiv.subtypeEquivRight</code> for the equivalence), then apply it explicitly to get from 1 term to another; pros and cons compared to the \"make it <code>rfl</code>\" approach:<ul>\n<li>pros:<ul>\n<li>it works even if <code>rfl</code> breaks again;</li>\n<li>you don't have to recompile half of Mathlib.</li>\n</ul>\n</li>\n<li>cons: it needs explicit <code>Lp.cast</code>s here and there.</li>\n</ul>\n</li>\n</ul>\n<p>With each approach, you have 2 ways to deal with your additions/modifications to the library:</p>\n<ul>\n<li>modify your local copy of Mathlib and use it; pros and cons compared to the next one:<ul>\n<li>pros: no need to go through the review process;</li>\n<li>cons:<ul>\n<li>if you ever want to upgrade Mathlib, then you'll have to merge the changes;</li>\n<li>you don't get precompiled <code>olean</code>s from <code>lake exe cache</code> (if you go with \"make it <code>rfl</code>\");</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>open a PR with your modifications.</li>\n</ul>",
        "id": 506608323,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1742345080
    }
]