[
    {
        "content": "<p>I've implemented selection sort by using List.unfold!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Create a list that collects the `a` values from `some (a, b)` by</span>\n<span class=\"sd\">repeatedly applying the argument function `f` until it returns `none`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">reverse</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">partial_fixpoint</span>\n\n<span class=\"bp\">#</span><span class=\"n\">guard</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">SelectionSort</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">separateMin</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">min?</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">selectionSort</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">separateMin</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- this is actually a sort algorithm!</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">selectionSort</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mergeSort</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SelectionSort</span>\n</code></pre></div>",
        "id": 499128523,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739323871
    },
    {
        "content": "<p>As far as I searched on Loogle, it seems that <code>List.unfold</code> doesn't exist yet. If I submit a PR, will it be accepted?</p>",
        "id": 499128679,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739323944
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.filterMap#doc\">docs#List.filterMap</a> that may be similar to <code>List.unfold</code>.</p>",
        "id": 499148082,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739335672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Thank you but I don’t t think flatMap is similar to unfold. flatMap f returns list from list, but unfold f returns list from element.</p>",
        "id": 499151318,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739337677
    },
    {
        "content": "<p>It's not a very convincing application yet? (a slow algorithm, not the easiest to reason about)</p>",
        "id": 499195193,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739355694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> </p>\n<p>That’s right. I’ll explore a bit more to see what can be done with <code>List.unfold</code>.</p>",
        "id": 499215252,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1739361785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 499216817,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739362302
    },
    {
        "content": "<p>it looks similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.Seq.corec#doc\">docs#Stream'.Seq.corec</a>... perhaps <code>List.corec</code> would be a better name?</p>",
        "id": 499295033,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739382942
    },
    {
        "content": "<p>I think that usually we prefer to define recursive functions using a recursion scheme directly, rather than to go through a named recursion scheme. I this case <code>List.unfold</code> is an <a href=\"https://en.wikipedia.org/wiki/Anamorphism\">anamorphism</a> for example. (<span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span>, thanks for pointing out corec, I just learned that anamorphisms are a way to corecursively construct data.)</p>\n<p>Something I've told people regarding Lean/mathlib is that I appreciate how the style tends to avoid recursion schemes (other than, say, folds and maps). Lean is hard enough as it is, why make it harder? :-) That's just my own opinion.</p>\n<p>That's a neat example of <code>partial_fixpoint</code> however <span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span>. I hadn't appreciated that this sort of function is now possible due to this feature.</p>",
        "id": 499296445,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739383355
    },
    {
        "content": "<p>cf <a href=\"https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List.html#v:unfoldr\">https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List.html#v:unfoldr</a>, so I think a name relating to unfold or otherwise making it clear that this is dual to fold is nice!</p>",
        "id": 499301735,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1739385100
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<blockquote>\n<p>I think that usually we prefer to define recursive functions using a recursion scheme directly, rather than to go through a named recursion scheme. I this case <code>List.unfold</code> is an <a href=\"https://en.wikipedia.org/wiki/Anamorphism\">anamorphism</a> for example.</p>\n</blockquote>\n<p>However, isn't abstraction important when it comes to proofs? I haven't tried it yet, but by proving a theorem about <code>List.unfold</code>, wouldn't the proof that selection sort is a sorting algorithm become clearer?</p>",
        "id": 501296459,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1740254147
    },
    {
        "content": "<p>I think you'll have to try it and see.</p>\n<p>I'm not seeing what theorems <code>List.unfold</code> would have that wouldn't already be there because of equation lemmas, other than perhaps some <code>acc</code> elimination lemma about <code>List.unfold.aux</code> (the lemma <code>List.unfold.aux f b acc = List.unfold.aux f b [] ++ acc</code>).</p>\n<p>There's also an issue that since <code>List.unfold</code> is partially defined (in the sense that it will infinite loop on some <code>f</code>),  you can't guarantee that <code>selectionSort</code> terminates using a proof, even though you can prove that mathematically <code>selectionSort</code> sorts the list.</p>",
        "id": 501305451,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740261651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I see. Thank you!</p>",
        "id": 501305658,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1740261805
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Is some sort of nested recursion transformation on the roadmap? Sort of like how nested inductive types are processed by the kernel? I was wondering about whether this <code>List.unfold separateMin</code> could somehow inline itself so that <code>selectionSort</code> has a <code>match</code> for which termination can be proved non-partially. Maybe using some attribute on <code>List.unfold</code>, to tell the system that it should be inlined? Potentially this is a way to get a memoization combinator to work without disrupting the termination checker.)</p>",
        "id": 501306134,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740262125
    },
    {
        "content": "<blockquote>\n<p>That’s right. I’ll explore a bit more to see what can be done with <code>List.unfold</code>.</p>\n</blockquote>\n<p>I have a thought about the application of partial_fixpoint.<br>\nCan we implement the many/some methods of Haskell's Alternative type class?</p>\n<p>see: &gt; <a href=\"#narrow/channel/113488-general/topic/many.2Fsome.20in.20Haskell.20Alternative.20class\">many/some in Haskell Alternative class</a></p>",
        "id": 504244235,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1741417355
    }
]