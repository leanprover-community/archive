[
    {
        "content": "<p>Hello!  I'm still attempting to learn Lean for the purpose of verifying PL-related proofs, so I'm interested in inductive propositions over other types.  However, I seem to keep combining features of the language in ways that aren't supported.  (If there's somewhere else a novice like me should go to ask questions about my failures, please let me know; I don't want to clutter the channel!)</p>\n<p>For instance, I've just encountered this example in writing a simple inductive proof that a list's elements are all the same value:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">CloneListProof</span>\n<span class=\"w\">      </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">PNil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CloneListProof</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">POne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CloneListProof</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">PCons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">            </span><span class=\"n\">CloneListProof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">            </span><span class=\"n\">CloneListProof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">CloneListWithProof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mappings</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">CloneListProof</span><span class=\"w\"> </span><span class=\"n\">mappings</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">         </span><span class=\"n\">CloneListWithProof</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"c1\">-- Error on the following line: \"(kernel) unknown constant 'NestedCloneList'\"</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NestedCloneList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CloneListWithProof</span><span class=\"w\"> </span><span class=\"n\">NestedCloneList</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NestedCloneList</span>\n</code></pre></div>\n<p>I'm inferring that error messages that begin with \"(kernel)\" seem to arise from an analysis that occurs after the code is simplified in some way.  Is there an easy way for me to look at the simplified code?  Also: am I wrong in expecting the code above to work?  Have I missed another rule or limitation somewhere?</p>\n<p>Thank you for reading!</p>",
        "id": 540326555,
        "sender_full_name": "Zach",
        "timestamp": 1758232597
    },
    {
        "content": "<p>that probably should not happen</p>",
        "id": 540327027,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758232698
    },
    {
        "content": "<p>My guess is that since you passed recursively to the parameter</p>",
        "id": 540327169,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758232720
    },
    {
        "content": "<p>In order to do this you need some complicated nested mutual thing</p>",
        "id": 540328029,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758232890
    },
    {
        "content": "<p>yeah this is probably not doable in Lean with just an inductive</p>",
        "id": 540328707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233041
    },
    {
        "content": "<p>Thanks for taking a look at it.  I felt like I was going mad.  :)</p>",
        "id": 540328832,
        "sender_full_name": "Zach",
        "timestamp": 1758233062
    },
    {
        "content": "<p>Since <code>CloneListWithProof NestedCloneList</code> depends on <code>List NestedCloneList</code> but <code>CloneListProof</code> references the constructors of <code>List</code></p>",
        "id": 540329118,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233158
    },
    {
        "content": "<p>So the <em>real</em> example isn't a list of lists of lists.  It's an eagerly-evaluated lambda calculus.  I want to define an AST where one of the value forms is a closure.  Closures have environments which are mappings from variables onto values and those values may themselves be closures.  But I'd very much like to have the guarantee that my environments are proper dictionaries: association lists with an invariant that each key appears at most once in the list.</p>",
        "id": 540329169,
        "sender_full_name": "Zach",
        "timestamp": 1758233184
    },
    {
        "content": "<p>ok what's a closure</p>",
        "id": 540329215,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233219
    },
    {
        "content": "<p>it's a lambda</p>",
        "id": 540329271,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1758233241
    },
    {
        "content": "<p>(iirc)</p>",
        "id": 540329302,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1758233249
    },
    {
        "content": "<p>Here, a pairing between an environment and a lambda, the latter of which is a variable and an expression.</p>",
        "id": 540329325,
        "sender_full_name": "Zach",
        "timestamp": 1758233259
    },
    {
        "content": "<p>why not just use a lambda is that not possible</p>",
        "id": 540329331,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233264
    },
    {
        "content": "<p>I'm writing an operational semantics, so the data type I'm creating is for a language that isn't Lean.  For instance, the following would almost work just fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">EValue</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">EVar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ELambda</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">EAppl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">VClosure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Env</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Value</span>\n<span class=\"w\">  </span><span class=\"c1\">-- other values in my little pet language go here</span>\n\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Env</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>The only trouble with the above is that the <code>List</code> in the <code>Env</code> type should really be a finite mapping from variables to values: no variable should appear on the left side of a pair in that list twice.  But when I tried to use <code>AList</code> or <code>Finmap</code> for this, I ran into other trouble.</p>",
        "id": 540329681,
        "sender_full_name": "Zach",
        "timestamp": 1758233494
    },
    {
        "content": "<p>that's why I used debruijn indices</p>",
        "id": 540329728,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233528
    },
    {
        "content": "<p>(Someone else pointed out why <code>Finmap</code> wasn't going to work for me earlier today.  I tried using <code>AList</code> instead but ran into a similar problem.)</p>",
        "id": 540329733,
        "sender_full_name": "Zach",
        "timestamp": 1758233534
    },
    {
        "content": "<p>you can try bundling in the nodup requirement afterwards</p>",
        "id": 540329783,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233565
    },
    {
        "content": "<p>With <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a></p>",
        "id": 540329796,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758233579
    },
    {
        "content": "<p>I definitely see the appeal of DeBruijn indices in this situation.  I've been trying to avoid it because the on-paper version of this theory is using identifiers and I'm hoping to have as little gap between it and this as possible.</p>\n<p>I think I see what you're suggesting: one could have an <code>Expr</code> bundled together with a proof that all <code>Env</code> within that <code>Expr</code> have the appropriate constraint.  Is that right?</p>\n<p>Because I don't want to have to keep bugging you fine folks: is there a way for me to decipher messages like this myself?  My hypothesis is that this kernel error is arising from how the induction principle for these data types is being defined internally by the kernel.  If I could see the generated code, I might be able to understand better what is likely to work and what won't.  And is there any way I could just write the induction principle myself?  That's what I had to do in a previous experiment in Rocq.</p>",
        "id": 540330331,
        "sender_full_name": "Zach",
        "timestamp": 1758233757
    },
    {
        "content": "<p>you can check the requirements lean asks of <code>inductive</code>s <a href=\"https://lean-reference-manual-review.netlify.app/The-Type-System/Inductive-Types/#well-formed-inductives\">here</a> (&lt;- link to the language reference)</p>",
        "id": 540330714,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1758233853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113488-general/topic/.22.28kernel.29.3A.20Unknown.20constant.22.20in.20inductive.20type/near/540329118\">said</a>:</p>\n<blockquote>\n<p>Since <code>CloneListWithProof NestedCloneList</code> depends on <code>List NestedCloneList</code> but <code>CloneListProof</code> references the constructors of <code>List</code></p>\n</blockquote>\n<p>Indeed, this is a particular case of <a href=\"https://github.com/leanprover/lean4/pull/6371\">lean4#6371</a>. The translation from nested to mutual makes a type of the inductive block appear in an index, meaning that the translation constructs an inductive-inductive type, which lean does not support.</p>",
        "id": 540330831,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1758233872
    },
    {
        "content": "<p>Thanks so much, everyone, for your help and explanations.  :)  The linked bug report definitely helps me understand how what I've done here breaks the assumptions that the translation process is using (though I'd be lying if I claimed to completely comprehend it).</p>\n<p>This feels weirdly like the sort of thing that one would fix in another language (e.g. Haskell) by injecting an explicit constructor somewhere to prevent a definition from expanding unnecessarily.  But that's probably not going to help here.</p>\n<p>I'll give this some thought, but the suggested approach of imposing the invariant on environments from outside of the <code>Expr</code> type seems to be the best bet.  Thanks again!</p>",
        "id": 540333444,
        "sender_full_name": "Zach",
        "timestamp": 1758234460
    }
]