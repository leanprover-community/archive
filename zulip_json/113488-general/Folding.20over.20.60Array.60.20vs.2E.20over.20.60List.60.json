[
    {
        "content": "<p>I've recently switched to arrays for a performance-critical use case and I'm trying to see to what extent I can preserve the intuitions I've built up on <code>List</code>. In general, when I'm working with a list I can usually achieve whatever transformation I want by either directly pattern matching on <code>.cons</code> or by first matching on a pseudo coalgebra <code>match pseudoCoalg mylist with | ...</code> then using the constructors of the resulting datatype to recurse on the list. Since we're at all using <code>Array</code> instead of <code>List</code>, I'm wondering what methods of recursing over <code>Array</code> preserves the time complexity advantages that <code>Array</code> has over <code>List</code>? If we hack a pattern-match-like method using <code>get</code> to simulate the way we recurse on <code>List</code>, will we lose the benefits of using <code>Array</code> at all? Is there a recommended way of recursing over <code>Array</code>s, or are we relatively unconstrained?</p>",
        "id": 482242212,
        "sender_full_name": "nrs",
        "timestamp": 1731525075
    },
    {
        "content": "<p>I think you'll have to ask a more specific/concrete question to get a useful response, since this is a very open-ended topic.</p>",
        "id": 482251863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731528638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Folding.20over.20.60Array.60.20vs.2E.20over.20.60List.60/near/482251863\">said</a>:</p>\n<blockquote>\n<p>I think you'll have to ask a more specific/concrete question to get a useful response</p>\n</blockquote>\n<p>hm I was afraid it would come off as slightly rambling-ish. as an example, <a href=\"https://hackage.haskell.org/package/vector-0.13.2.0/docs/Data-Vector.html\">https://hackage.haskell.org/package/vector-0.13.2.0/docs/Data-Vector.html</a> has annotations for the time complexity of most functions so you can have a more-or-less general ideas of what sort of operations will be costly. since Lean is in its infancy still we obviously can't expect such detail but I was wondering whether people had general guidelines they sticked to for consuming/transforming Lean arrays or recursing over them, as opposed to the straightforward ways of recursing over <code>List</code>. Any general thoughts on the subjects are appreciated!</p>\n<p>as a side node, there are (scarce) comments about time complexity here and there in the docs if you grep for <code>O(</code></p>",
        "id": 482253042,
        "sender_full_name": "nrs",
        "timestamp": 1731529044
    },
    {
        "content": "<p>I still think you need to give specific examples of recursion strategies to get a useful response there, but the basic operations for Array are well-understood. You have to ensure that you only have one reference to the Array, and then pushing and popping from the end is O(1). An Array is represented as a contiguous block of memory, so for other operations you need to know what interacting with such data structures are like. For example, deleting the first element is O(n) since it needs to shift all the elements over.</p>",
        "id": 482254760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731529611
    },
    {
        "content": "<p>There's a very small amount of information at <a href=\"https://lean-lang.org/lean4/doc/array.html\">https://lean-lang.org/lean4/doc/array.html</a>, which mentions that it's a contiguous block of memory (\"it is similar to C++ <code>std::vector&lt;T&gt;</code>\"). I'm not sure if this manual says anything about \"functional but in-place\" (FBIP), the compiler optimization that makes it possible to work with Array like a functional data structure even though it's being mutated at runtime.</p>",
        "id": 482255335,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731529807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <br>\nIs the FBIP not relevant to the List?  Is the List immutable when there is only one reference to it?</p>",
        "id": 482255560,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1731529897
    },
    {
        "content": "<p>(Matching on pseudo coalgebras is a foreign concept here, which is one reason I'm suggesting that you should give specific applications rather than ask for a general overview.)</p>",
        "id": 482255582,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731529904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span> It's certainly relevant, but that's only for reusing individual cons cells, which is just an O(1) optimization. The Array.push optimization saves O(n) time.</p>",
        "id": 482255745,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731529947
    },
    {
        "content": "<p>In fact, if I'm interpreting the IR correctly for <code>List.reverse</code>, if every cell of the list has just one reference, it will not allocate any new memory — it reuses the old list.</p>",
        "id": 482256182,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731530136
    },
    {
        "content": "<p>edit: fixing an implementation detail</p>",
        "id": 482256386,
        "sender_full_name": "nrs",
        "timestamp": 1731530209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reverseAux</span><span class=\"bp\">._</span><span class=\"n\">rarg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">of</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"w\">  </span><span class=\"c1\">-- returns accumulated reversed list</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isShared</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">x_3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u8</span><span class=\"w\"> </span><span class=\"n\">of</span>\n<span class=\"w\">    </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proj</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"c1\">-- extract the tail of the list</span>\n<span class=\"w\">      </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x_2</span><span class=\"bp\">;</span><span class=\"w\">   </span><span class=\"c1\">-- reuses x_1, setting its tail to the accumulated reversed list</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x_5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">reverseAux</span><span class=\"bp\">._</span><span class=\"n\">rarg</span><span class=\"w\"> </span><span class=\"n\">x_4</span><span class=\"w\"> </span><span class=\"n\">x_1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"c1\">-- tail call, continues with tail of list and x_1 as accumulated reversed list</span>\n<span class=\"w\">      </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">x_5</span>\n<span class=\"w\">    </span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"c\">/-</span><span class=\"cm\"> ... shared case, constructs a new cell ... -/</span>\n</code></pre></div>\n<p>There are no reference count increases or decreases in this code either.</p>",
        "id": 482256661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731530301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> </p>\n<p>is this Lean code? what is <code>ret</code>?</p>",
        "id": 482256906,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1731530386
    },
    {
        "content": "<p>This is IR (\"intermediate representation\"). It's what the compiler transforms the Lean code into before emitting C.</p>",
        "id": 482257025,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731530412
    },
    {
        "content": "<p>There are many stages of it, but this is the last one.</p>",
        "id": 482257062,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731530431
    },
    {
        "content": "<p><code>set_option trace.compiler.ir true</code> enables seeing it.</p>",
        "id": 482257121,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731530452
    },
    {
        "content": "<p><del>how can I see IR?</del> Thank you.</p>",
        "id": 482257129,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1731530454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113488-general/topic/Folding.20over.20.60Array.60.20vs.2E.20over.20.60List.60/near/482255582\">said</a>:</p>\n<blockquote>\n<p>(Matching on pseudo coalgebras is a foreign concept here, which is one reason I'm suggesting that you should give specific applications rather than ask for a general overview.)</p>\n</blockquote>\n<p>here's an example of what I mean by pseudo coalgebra, it's not an official term or anything, it's just meant to indicate that it's very loosely inspired by the haskell anamorphism/unfold recursion scheme but eager evaluation and the fact that induction and coinduction don't coincide in Lean types makes it such that we can't use the terminology literally. what is captured by using lists in this manner is just the fact of being able to pattern match at all, which (unless i just don't fully understand arrays yet) doesn't happen with arrays, which are more meant to be thought of as datatypes one uses a <code>for</code> loop to consume instead of a pattern match.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">printer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\"\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ta</span><span class=\"w\"> </span><span class=\"n\">tb</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"s2\">\" ( \"</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">printer</span><span class=\"w\"> </span><span class=\"n\">ta</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"w\">  </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">printer</span><span class=\"w\"> </span><span class=\"n\">tb</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"s2\">\" ) \"</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">printer</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partition</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">keepWhile</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">keepWhile</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"w\">  </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pcoalg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree'</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">pcoalg</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">la</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">lb</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">la</span><span class=\"w\"> </span><span class=\"n\">pcoalg</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">lb</span><span class=\"w\"> </span><span class=\"n\">pcoalg</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">partition</span>\n</code></pre></div>\n<p>A fold following this sort-of-anamorphism/unfold will flatten the list into a sorted list (the way the printer is implemented as a fold, when combined with the unfold, kind of reminds of the hylomorphism recursion scheme)</p>",
        "id": 482263742,
        "sender_full_name": "nrs",
        "timestamp": 1731532967
    },
    {
        "content": "<p>I think if you're wanting to write code like this you should use List, since there's not much point using Array if the first step is to explode it into a Tree, or to allocate new Arrays in <code>partition</code>.</p>\n<p>With Array, you could write <code>partition</code> to partition the array in-place with a for loop (or with recursion if you prefer, that's common in Lean) like you would in an imperative algorithm. The imperative way would also avoid doing 2n comparisons instead of just n.</p>",
        "id": 482265285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731533525
    },
    {
        "content": "<p>But yes, you don't do pattern matches on Array, it shouldn't be thought of as being an inductive datatype for programming purposes. (For proving purposes however, it's defined to be a wrapper around List.)</p>",
        "id": 482265524,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731533638
    },
    {
        "content": "<p>I see thanks a lot for the comments!! it helps to have an idea that thinking in these terms is counterproductive and precisely the whole point is to achieve performance improvements over <code>List</code></p>",
        "id": 482266116,
        "sender_full_name": "nrs",
        "timestamp": 1731533869
    },
    {
        "content": "<p>List does have its place to be sure. For example, if you want to have a reference to both <code>xs</code> and <code>ys := x :: xs</code> at the same time, there is no problem, but if you want a reference to both <code>as</code> and <code>bs := Array.push as a</code>, this will copy the whole array.</p>",
        "id": 482268104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731534676
    },
    {
        "content": "<p>Though you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subarray#doc\">docs#Subarray</a> for that use-case, right?</p>",
        "id": 482269803,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731535369
    },
    {
        "content": "<p>Not for pushing, but yeah, you can use it for having multiple views into the same Array</p>",
        "id": 482269898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731535413
    }
]