[
    {
        "content": "<p>The Fano plane is the smallest projective plane, comprising seven points and seven lines. Three points lie on each line and three lines pass through each point. I am trying to model this structure in lean4 as a pair of types <code>P, L</code> satisfying <code>Membership P L</code>, but my first attempt is turning out extremely tedious and verbose.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">FanoPoints</span> <span class=\"n\">where</span>\n  <span class=\"bp\">&lt;</span><span class=\"n\">seven</span> <span class=\"n\">constructors</span> <span class=\"n\">p1</span> <span class=\"bp\">…</span> <span class=\"n\">p7</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FanoLines</span> <span class=\"n\">where</span>\n  <span class=\"bp\">&lt;</span><span class=\"n\">seven</span> <span class=\"n\">constructors</span> <span class=\"n\">l1</span> <span class=\"bp\">…</span> <span class=\"n\">l7</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>Then for the <code>Membership</code> instance I just write down formulas for each of the lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">FanoPoints</span> <span class=\"n\">FanoLines</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"n\">p</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">p2</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=.</span><span class=\"n\">p3</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">p6</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">p1</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=.</span><span class=\"n\">p3</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">p4</span>\n    <span class=\"o\">[</span><span class=\"bp\">…</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This is not very elegant, but bearable. The real problem starts when I try to prove the formula <code>∀(p q : FanoPoints), ∃ (l : FanoLines), p ∈ l ∧ q ∈ l</code>, i.e. there is a line connecting any two points. I currently have a big case distinction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">match</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">l2</span><span class=\"o\">,</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p2</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">l3</span><span class=\"o\">,</span> <span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">Or.inr</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)⟩</span>\n    <span class=\"o\">[</span><span class=\"bp\">…</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>with 49 cases (I haven't written all of them yet).</p>\n<p>Is my basic approach sound? Is there a significantly simpler way to do it? Are there ways I can at least have Lean auto-infer the proof part of the existentials I am building in my case distinction, if not the witnesses?</p>",
        "id": 323208305,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674554561
    },
    {
        "content": "<p>I think you can derive <code>DecidableEq</code> for <code>FanoPoints</code>. After that, your proofs should hopefully be <code>by decide</code>.</p>",
        "id": 323209190,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674554817
    },
    {
        "content": "<p>I added the annotation to <code>FanoPoints</code> and <code>FanoLines</code>, but when I try</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>     <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">l2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I get <code>Failed to synthesize Decidable (p1 ∈ FanoLines.l2)</code>.</p>",
        "id": 323210321,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674555181
    },
    {
        "content": "<p>Right, so after you define membership, you should prove that it's decidable</p>",
        "id": 323210421,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1674555220
    },
    {
        "content": "<p>Ah, I see. So something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">fanoMemDecidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span><span class=\"o\">):</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">Membership.mem</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"bp\">…</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Would I have to write out every case of (point, line) in this proof?</p>",
        "id": 323213388,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674556047
    },
    {
        "content": "<p>I got it to work, thank you very much for your help :)</p>",
        "id": 323220324,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674558087
    },
    {
        "content": "<p>You might be interested in <a href=\"https://drops.dagstuhl.de/opus/volltexte/2022/16734/\">Proof Pearl: Formalizing Spreads and Packings of the Smallest Projective Space PG(3,2) Using the Coq Proof Assistant</a> to see how they do it in Coq.</p>",
        "id": 323224086,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1674559203
    },
    {
        "content": "<p>My personal opinion is that it is terribly ugly and <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> reimplemented some of Magaud's paper in Lean without the case bashs.</p>",
        "id": 323224443,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1674559309
    },
    {
        "content": "<p>isn't there a way to present the fano plane as consisting of the nonzero points of <code>{0,1}^3</code>? (Maybe that's <code>F_2</code>.) I would imagine that using a more uniform representation like that would help to describe the different kinds of lines and points more than a 7-way enumeration</p>",
        "id": 323266145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674570595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460941\">@Sebastian Zivota</span> It'd probably be better to use an algebraic formulation of the Fano plane, but given your original question this is what I came up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">FanoPoints</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">p1</span> <span class=\"bp\">|</span> <span class=\"n\">p2</span> <span class=\"bp\">|</span> <span class=\"n\">p3</span> <span class=\"bp\">|</span> <span class=\"n\">p4</span> <span class=\"bp\">|</span> <span class=\"n\">p5</span> <span class=\"bp\">|</span> <span class=\"n\">p6</span> <span class=\"bp\">|</span> <span class=\"n\">p7</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">FanoLines</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">l1</span> <span class=\"bp\">|</span> <span class=\"n\">l2</span> <span class=\"bp\">|</span> <span class=\"n\">l3</span> <span class=\"bp\">|</span> <span class=\"n\">l4</span> <span class=\"bp\">|</span> <span class=\"n\">l5</span> <span class=\"bp\">|</span> <span class=\"n\">l6</span> <span class=\"bp\">|</span> <span class=\"n\">l7</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">FanoLines.points</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">FanoPoints</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p2</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p4</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l2</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p2</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p3</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p5</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l3</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p3</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p4</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p6</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l4</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p4</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p5</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p7</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l5</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p5</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p6</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l6</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p6</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p7</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p2</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">l7</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">p7</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p3</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">FanoMembership</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">FanoPoints</span> <span class=\"n\">FanoLines</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"n\">p</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l.points</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">FanoMembership</span><span class=\"o\">]</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l1</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l2</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l3</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l4</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l5</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l6</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">l7</span> <span class=\"k\">then</span>\n    <span class=\"n\">isTrue</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"n\">repeat</span>\n        <span class=\"n\">try</span> <span class=\"n\">rename_i</span> <span class=\"n\">h</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">intro</span> <span class=\"n\">l</span>\n      <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">H</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span>\n      <span class=\"n\">repeat</span>\n        <span class=\"n\">try</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">try</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> mathlib -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_forall</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> mathlib -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_exists</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> mathlib -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_not</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"n\">l</span> <span class=\"k\">then</span>\n    <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_exists</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">isTrue</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_forall</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_line</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 323290326,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674576092
    },
    {
        "content": "<p>The key Decidable instance here is one for deciding universal quantifiers <code>∀ (l : FanoLines), P l</code>, which can be done since <code>FanoLines</code> has only finitely many terms.</p>\n<p>Then this gives a decidable instance for existentials, and in the end you don't need to go through each of the cases by hand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">exists_line</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 323292006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674576465
    },
    {
        "content": "<p>That is really cool, thanks. It didn't occur to me to just use lists for the lines, nor to derive <code>Decidable</code> instances for the quantified formulas. One question though, don't <code>not_forall</code> and <code>not_not</code> turn the entire theory classical (or require it to be such)?</p>",
        "id": 323298159,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674578032
    },
    {
        "content": "<p>There are some decidable versions of these in Mathlib that can apply here instead, but I personally don't mind using classical proofs.</p>",
        "id": 323298524,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674578122
    },
    {
        "content": "<p>The Decidable instances you get are still computable even if they depend on classical arguments.</p>",
        "id": 323298758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674578186
    },
    {
        "content": "<p>Floris pointed out to me that you can go further and decide the entire proposition with one more instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p1</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p2</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p3</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p4</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p5</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p6</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"bp\">.</span><span class=\"n\">p7</span> <span class=\"k\">then</span>\n    <span class=\"n\">isTrue</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"n\">repeat</span>\n        <span class=\"n\">try</span> <span class=\"n\">rename_i</span> <span class=\"n\">h</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">intro</span> <span class=\"n\">l</span>\n      <span class=\"n\">cases</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">isFalse</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">H</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span>\n      <span class=\"n\">repeat</span>\n        <span class=\"n\">try</span> <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">try</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">FanoPoints</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">FanoLines</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 323299156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674578273
    },
    {
        "content": "<p>Don't we have that instance already for fintypes?</p>",
        "id": 323307022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674580270
    },
    {
        "content": "<p>Or does <code>deriving Fintype</code> not work yet?</p>",
        "id": 323307040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674580277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Modeling.20the.20Fano.20Plane/near/323266145\">said</a>:</p>\n<blockquote>\n<p>isn't there a way to present the fano plane as consisting of the nonzero points of <code>{0,1}^3</code>? (Maybe that's <code>F_2</code>.) I would imagine that using a more uniform representation like that would help to describe the different kinds of lines and points more than a 7-way enumeration</p>\n</blockquote>\n<p>Yeah, it's the projective plane over <code>zmod 2</code>. If you use Lean 3 there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/projectivization\">docs#projectivization</a> for the points and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/projectivization.subspace\">docs#projectivization.subspace</a> for the lines in mathlib.</p>",
        "id": 323307315,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1674580346
    },
    {
        "content": "<p>Awesome, with that I now have a proof that the Fano plane is indeed a projective plane. (<code>FanoPoints</code> and <code>FanoLines</code> renamed to <code>Fano.Points</code> and <code>Fano.Lines</code>, respectively):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Fano.exists_connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Points</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Lines</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fano.exists_intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Lines</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Points</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.triangle123</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">Lines</span> <span class=\"n\">_</span> <span class=\"n\">Points.p1</span> <span class=\"n\">Points.p2</span> <span class=\"n\">Points.p3</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">collinear</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.triangle126</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">Lines</span> <span class=\"n\">_</span> <span class=\"n\">Points.p1</span> <span class=\"n\">Points.p2</span> <span class=\"n\">Points.p6</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">collinear</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.triangle136</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">Lines</span> <span class=\"n\">_</span> <span class=\"n\">Points.p1</span> <span class=\"n\">Points.p3</span> <span class=\"n\">Points.p6</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">collinear</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.triangle236</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">Lines</span> <span class=\"n\">_</span> <span class=\"n\">Points.p2</span> <span class=\"n\">Points.p3</span> <span class=\"n\">Points.p6</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">collinear</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.quadrangle1236</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">isQuadrangle</span> <span class=\"n\">_</span> <span class=\"n\">Lines</span> <span class=\"n\">_</span> <span class=\"n\">Points.p1</span> <span class=\"n\">Points.p2</span> <span class=\"n\">Points.p3</span> <span class=\"n\">Points.p6</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Fano.triangle123</span><span class=\"o\">,</span> <span class=\"n\">Fano.triangle126</span><span class=\"o\">,</span> <span class=\"n\">Fano.triangle136</span><span class=\"o\">,</span> <span class=\"n\">Fano.triangle236</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Fano.point_line_uniq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Points</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Lines</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">decide</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ProjectivePlane</span> <span class=\"n\">Points</span> <span class=\"n\">Lines</span> <span class=\"n\">where</span>\n  <span class=\"n\">exists_connecting_line</span> <span class=\"o\">:=</span> <span class=\"n\">Fano.exists_connecting_line</span>\n  <span class=\"n\">exists_intersection_point</span> <span class=\"o\">:=</span> <span class=\"n\">Fano.exists_intersection_point</span>\n  <span class=\"n\">exists_quadrangle</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p2</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p3</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">p6</span><span class=\"o\">,</span> <span class=\"n\">Fano.quadrangle1236</span><span class=\"o\">⟩</span>\n  <span class=\"n\">point_line_uniq</span> <span class=\"o\">:=</span> <span class=\"n\">Fano.point_line_uniq</span>\n</code></pre></div>\n<p>Having to spell out some of these <code>collinear</code>s and <code>quadrangle</code>s is a bit annoying, Lean can't seem to figure out that I want <code>Fano.Lines</code> as the lines type.</p>",
        "id": 323318469,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674583404
    },
    {
        "content": "<p>If you find yourself using @ to set an implicit argument (lines) every time you call a function, this is telling you that it should be an explicit argument</p>",
        "id": 323515445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674660608
    },
    {
        "content": "<p>It's hard to suggest better fixes without seeing the rest of your code.</p>",
        "id": 323516348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1674660819
    },
    {
        "content": "<p>Did you define <code>collinear</code> and the other notions yourself? If so, I would change the definitions and start with a structure <code>GeometryData</code> like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">GeometryData</span> <span class=\"n\">where</span>\n  <span class=\"n\">Points</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">Lines</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fano</span> <span class=\"o\">:</span> <span class=\"n\">GeometryData</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Next define <code>collinear</code> to take an implicit argument of type <code>GeometryData</code>. Then, if you apply <code>collinear</code> to <code>p : fano.Points</code>, we know what the corresponding type of lines is.</p>",
        "id": 323517199,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1674661029
    },
    {
        "content": "<p>I defined <code>collinear</code> and <code>isQuadrangle</code> purely in terms of membership:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">collinear</span> <span class=\"o\">[</span><span class=\"n\">Membership</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isQuadrangle</span> <span class=\"o\">[</span><span class=\"n\">Membership</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"bp\">@</span><span class=\"n\">collinear</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Then later on I have a type class axiomatizing projective planes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ProjectivePlane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"o\">(</span><span class=\"n\">Membership</span> <span class=\"n\">P</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">exists_connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n  <span class=\"n\">exists_intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span>\n  <span class=\"n\">point_line_uniq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n  <span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">isQuadrangle</span> <span class=\"n\">_</span> <span class=\"n\">L</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>If I understand you correctly, Floris, I guess I should introduce the class <code>GeometryData</code> in between <code>Membership</code> and <code>ProjectivePlane</code>?</p>",
        "id": 323533457,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674665073
    },
    {
        "content": "<p>If you want to define <code>collinear</code> in terms of <code>Membership</code>, then the type <code>L</code> has to be explicit: there is no way for Lean to mean what you mean otherwise. However, with <code>GeometryData</code> you have an alternative. Here is a more worked out example (I forgot to add the <code>membership</code> predicate to <code>GeometryData</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">GeometryData</span> <span class=\"n\">where</span>\n  <span class=\"n\">Points</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">Lines</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">membership</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">Points</span> <span class=\"n\">Lines</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">GeometryData.membership</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">collinear</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">GeometryData</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">G.Points</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">G.Lines</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isQuadrangle</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">GeometryData</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G.Points</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fano</span> <span class=\"o\">:</span> <span class=\"n\">GeometryData</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 323536069,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1674665805
    },
    {
        "content": "<p>I see. I don't really have good intuition for when to use type classes vs structures in Lean yet.</p>\n<p>In any case, thank you very much for your help!</p>",
        "id": 323538456,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674666433
    },
    {
        "content": "<p>Rule of thumb: a class should only have one term, but a structure is allowed to have several terms. For example <code>group G</code> is a class, because it's vanishingly rare that we want to put two different group structures on a type both using <code>*</code> notation, but <code>subgroup G</code> is a structure and not a class, because a general group <code>G</code> can have many subgroups.</p>",
        "id": 323539699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674666760
    },
    {
        "content": "<p>I suppose that means it makes sense for <code>ProjectivePlane</code> to be a class, right? I wouldn't expect there to be more than one projective plane with the same  points and lines.</p>",
        "id": 323546207,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674668455
    },
    {
        "content": "<p>Here's a plausible set of definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">Geometry</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">line</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span>\n  <span class=\"n\">instMem</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">P</span> <span class=\"n\">line</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Geometry.instMem</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Geometry.collinear</span> <span class=\"o\">[</span><span class=\"n\">Geometry</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Geometry.isQuadrangle</span> <span class=\"o\">[</span><span class=\"n\">Geometry</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n  <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">collinear</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ProjectivePlane</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">Geometry</span> <span class=\"n\">P</span> <span class=\"o\">:=</span>\n  <span class=\"n\">exists_connecting_line</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">line</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n  <span class=\"n\">exists_intersection_point</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">line</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span>\n  <span class=\"n\">point_line_uniq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">line</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n  <span class=\"n\">exists_quadrangle</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">),</span> <span class=\"n\">Geometry.isQuadrangle</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 323548061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674668995
    },
    {
        "content": "<p>The idea is that (likely) if you have a particular type for your points, you will have a particular type in mind for your lines, so the points type determines the lines type.</p>\n<p>In general, the binder that introduces a line of points of type <code>P</code> is <code>(l : line P)</code>, which reads nicely as \"<code>l</code> is a line of points from <code>P</code>\".</p>",
        "id": 323548396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674669094
    },
    {
        "content": "<p>Setting up the definitions in a way which makes progress painless is a very hard part of Lean for beginners. Once people are proving theorems they can have lots of fun, but if the definitions are wrong then the theorems can be nigh-on impossible to prove.</p>",
        "id": 323549018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1674669267
    },
    {
        "content": "<p>One weakness with my suggestion is that it might be more awkward to state things that involve swapping the roles of points and lines in a projective plane, versus exposing both the points and lines as parameters to <code>ProjectivePlane</code>.</p>",
        "id": 323549648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674669444
    },
    {
        "content": "<p>where \"wrong\" does not mean \"mathematically wrong\"! It might be that a definition is totally correct from a mathematical perspective but still hell to work with</p>",
        "id": 323549711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1674669461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Modeling.20the.20Fano.20Plane/near/323549648\">said</a>:</p>\n<blockquote>\n<p>One weakness with my suggestion is that it might be more awkward to state things that involve swapping the roles of points and lines in a projective plane.</p>\n</blockquote>\n<p>Yes, duality is indeed something I have been tinkering with.</p>",
        "id": 323549935,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674669505
    },
    {
        "content": "<p>It seems fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Geometry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ProjectivePlane</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ProjectivePlane</span> <span class=\"o\">(</span><span class=\"n\">line</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">line</span> <span class=\"o\">:=</span> <span class=\"n\">P</span>\n  <span class=\"n\">instMem</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exists_connecting_line</span> <span class=\"o\">:=</span> <span class=\"n\">ProjectivePlane.exists_intersection_point</span>\n  <span class=\"n\">exists_intersection_point</span> <span class=\"o\">:=</span> <span class=\"n\">ProjectivePlane.exists_connecting_line</span>\n  <span class=\"n\">point_line_uniq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ProjectivePlane.point_line_uniq</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">exists_quadrangle</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 323551763,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674670011
    },
    {
        "content": "<p>This would have been one of the things I'd have worried about, but it's true by definition (thanks Lean 4!):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ProjectivePlane</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">ProjectivePlane</span> <span class=\"o\">(</span><span class=\"n\">line</span> <span class=\"o\">(</span><span class=\"n\">line</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(The structure of the projective plane of the double dual is the exact same as the original projective plane structure.)</p>",
        "id": 323552104,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674670115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> with your definition of <code>Geometry</code> and <code>ProjectivePlane</code>, is it possible to write the following definition without explicitly naming the instance? I can't figure out how to get access to <code>line</code> otherwise.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">connectingLine</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">ProjectivePlane</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inst.line</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.choose</span> <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Also, this restructuring somehow breaks the proof that 1236 is a quadrangle in the Fano plane.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Fano.quadrangle1236</span> <span class=\"o\">:</span> <span class=\"n\">Geometry.isQuadrangle</span> <span class=\"n\">Points.p1</span> <span class=\"n\">Points.p2</span> <span class=\"n\">Points.p3</span> <span class=\"n\">Points.p6</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Geometry.collinear</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Geometry.collinear</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Geometry.collinear</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Geometry.collinear</span><span class=\"o\">]⟩</span>\n\n<span class=\"n\">unsolved</span> <span class=\"n\">goals</span>\n<span class=\"n\">P</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Geometry.line</span> <span class=\"n\">Points</span><span class=\"o\">),</span> <span class=\"n\">Points.p1</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Points.p2</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">Points.p3</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Also, I pushed the whole thing to github now: <a href=\"https://github.com/loewenheim/projective-plane\">https://github.com/loewenheim/projective-plane</a></p>",
        "id": 323566650,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674674401
    },
    {
        "content": "<p>I haven't tested it, but I'd expect it to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">connectingLine</span> <span class=\"o\">[</span><span class=\"n\">ProjectivePlane</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">line</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.choose</span> <span class=\"o\">(</span><span class=\"n\">exists_connecting_line</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 323568724,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674675035
    },
    {
        "content": "<p>That might be <code>Geometry.line</code> if you haven't done <code>open Geometry</code></p>",
        "id": 323568769,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674675049
    },
    {
        "content": "<p>Yeah I just realized that I only had to <code>open Geometry</code> for it to work</p>",
        "id": 323568819,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674675068
    },
    {
        "content": "<p>With <code>Fano.quadrangle1236</code> it might be that the decidability instances aren't seeing they can apply to <code>Geometry.line Points</code> universal quantification. Maybe you can just change those simps to <code>simp [Geometry.collinear, Geometry.line]</code>? (I haven't tested this)</p>",
        "id": 323569249,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674675216
    },
    {
        "content": "<p>(What I'm thinking is that <code>Geometry.line Points</code> isn't literally <code>Lines</code>, and typeclass inference is syntactically driven.)</p>",
        "id": 323569438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1674675275
    },
    {
        "content": "<p>Yup, that fixed it! Thanks so much!</p>",
        "id": 323569461,
        "sender_full_name": "Sebastian Zivota",
        "timestamp": 1674675283
    }
]