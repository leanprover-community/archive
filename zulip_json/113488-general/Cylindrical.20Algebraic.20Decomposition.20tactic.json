[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420730316\">said</a>:</p>\n<blockquote>\n<p>To return to the topic of the thread, a more ambitious missing tactic would be something that <a href=\"https://en.wikipedia.org/wiki/Tarski%E2%80%93Seidenberg_theorem\">resolves statements in the first-order theory of the reals</a>. I seem to recall watching a video of a talk someone gave about work formalizing CAD algorithms but I unfortunately am having trouble finding the link.</p>\n</blockquote>\n<p>The thing with CAD is that Collins' algorithm is kinda monstrous. There were two separate attempts (by some experienced users too) to make a Coq tactic but neither came to completion. Also if you consider the theoretical complexity  and the fact that it hasn't really been tried extensively in practice (so someone might implement it only to come to the conclusion it's too slow), I doubt that it will get done any time soon</p>",
        "id": 420731110,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707512525
    },
    {
        "content": "<p>At least not by one or two people. Maybe as a bigger team effort? But then the problem is finding volunteers</p>",
        "id": 420731257,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707512594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420731110\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420730316\">said</a>:</p>\n<blockquote>\n<p>To return to the topic of the thread, a more ambitious missing tactic would be something that <a href=\"https://en.wikipedia.org/wiki/Tarski%E2%80%93Seidenberg_theorem\">resolves statements in the first-order theory of the reals</a>. I seem to recall watching a video of a talk someone gave about work formalizing CAD algorithms but I unfortunately am having trouble finding the link.</p>\n</blockquote>\n<p>The thing with CAD is that Collins' algorithm is kinda monstrous. There were two separate attempts (by some experienced users too) to make a Coq tactic but neither came to completion. Also if you consider the theoretical complexity  and the fact that it hasn't really been tried extensively in practice (so someone might implement it only to come to the conclusion it's too slow), I doubt that it will get done any time soon</p>\n</blockquote>\n<p>Very good points. Although I would point out that, in theory, the problem that <code>polyrith</code> solves is apparently also doubly-exponential. <code>polyrith</code> is still useful though, I presume because:</p>\n<ul>\n<li>Heuristics make it fast in many cases</li>\n<li>Perhaps people are simply using the tactic on very small problem instances and still getting usefulness out of the tactic that way.</li>\n</ul>",
        "id": 420731814,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707512817
    },
    {
        "content": "<p>Yes, that's why I mentioned the fact that (unlike Buchberger's &amp; co) CAD hasn't really been tried extensively, so you don't have that \"it sucks in theory but it's not bad in practice\" defense. As far as I know of course</p>",
        "id": 420732433,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707513104
    },
    {
        "content": "<p>Maybe getting a tactic for computing Grobner bases or something similar into Lean first might be a good trial for trying something for CAD later</p>",
        "id": 420732678,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707513231
    },
    {
        "content": "<p>Regarding a CAD tactic, I've wanted to embark on that on multiple occasions, but the big missing piece is sufficient theory regarding the algebraic numbers. Last I checked we still don't have a proof that the algebraic numbers are a field</p>",
        "id": 420734420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707513985
    },
    {
        "content": "<p>I don't think implementation concerns are the blocker</p>",
        "id": 420734681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707514105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you mean with <em>computable</em> field operations? Otherwise I'm sure we have it</p>",
        "id": 420768309,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707537906
    },
    {
        "content": "<p>We don't</p>",
        "id": 420768329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707537933
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicClosure.commRing#doc\">docs#AlgebraicClosure.commRing</a> is the algebraic closure of a field a field in general?</p>",
        "id": 420768496,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707538107
    },
    {
        "content": "<p>the ring axioms are the hard ones anyway</p>",
        "id": 420768519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707538161
    },
    {
        "content": "<p>it's not clear that this can be used to prove that the algebraic numbers, as a subset of the complex numbers, are closed under addition and multiplication</p>",
        "id": 420768582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707538214
    },
    {
        "content": "<p><code>AlgebraicClosure</code> constructs a completely new set with unclear relation to the original</p>",
        "id": 420768594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707538243
    },
    {
        "content": "<p>I seem to recall that Descartes' rule of signs was a prerequisite to this.</p>",
        "id": 420768728,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707538416
    },
    {
        "content": "<p><a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/A.20simple.20result.20that.20.60omega.60.20fails.20to.20prove/near/411008506\">last time I looked into this</a> we couldn't find anything in present mathlib</p>",
        "id": 420768734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707538433
    },
    {
        "content": "<p>Can we take the normal closure, or the integral closure? Those are relative constructions so they give a subtype of C</p>",
        "id": 420769147,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707538975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Are these helpful?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isAlgebraic_iff_isIntegral</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx.add</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isAlgebraic_iff_isIntegral</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx.mul</span> <span class=\"n\">hy</span>\n</code></pre></div>",
        "id": 420769683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707539642
    },
    {
        "content": "<p>yes, what are the imports there?</p>",
        "id": 420769834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707539789
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">integralClosure</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">|</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isAlgebraic_iff_isIntegral</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"n\">Subalgebra.toCommRing</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 420769932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707539940
    },
    {
        "content": "<p>Ooh, can't shake tell you the imports?</p>",
        "id": 420769940,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707539952
    },
    {
        "content": "<p>I don't know, you didn't write a MWE</p>",
        "id": 420769951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707539969
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Algebraic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">integralClosure</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">|</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isAlgebraic_iff_isIntegral</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"n\">Subalgebra.toCommRing</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isAlgebraic_iff_isIntegral</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx.add</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isAlgebraic_iff_isIntegral</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx.mul</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 420770001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707540013
    },
    {
        "content": "<p>I had <code>import Mathlib</code> before</p>",
        "id": 420770005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707540019
    },
    {
        "content": "<p>Note that <code>AlgNums</code> is even computable</p>",
        "id": 420770140,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707540209
    },
    {
        "content": "<p>Is addition on it computable?</p>",
        "id": 420770151,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707540233
    },
    {
        "content": "<p>well, I guess it is since it's complex addition</p>",
        "id": 420770198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707540247
    },
    {
        "content": "<p>We do need computable addition and multiplication for this application, so now I'm seeing whether the proof method supports this at all</p>",
        "id": 420770240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707540327
    },
    {
        "content": "<p>Having the noncomputable proof is the main thing though since you can turn it into a constructive proof fairly mechanically and use pieces from the original proof for any parts that aren't part of the computation</p>",
        "id": 420770392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707540488
    },
    {
        "content": "<p>It looks like most of the magic is in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul#doc\">docs#LinearMap.exists_monic_and_coeff_mem_pow_and_aeval_eq_zero_of_range_le_smul</a></p>",
        "id": 420770415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707540531
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.IntermediateField</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Algebraic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">integralClosure</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">|</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isAlgebraic_iff_isIntegral</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">AlgNums</span> <span class=\"o\">:=</span> <span class=\"n\">Subalgebra.toCommRing</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">AlgNums.add_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">AlgNums.mul_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">baz</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">AlgNums.neg_mem</span> <span class=\"n\">hx</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">qux</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsAlgebraic</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">hx₀</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">x</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">inv_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">isAlgebraic_zero</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">h₀</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">φ.reverse</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Polynomial.reverse_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h₀</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Invertible</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">hx₀.isUnit.invertible</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">invOf_eq_inv</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.eval₂_reverse_eq_zero_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlgebraicNumber</span> <span class=\"o\">:</span> <span class=\"n\">IntermediateField</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">AlgNums</span> <span class=\"k\">with</span>\n    <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">qux</span> <span class=\"n\">hx</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Field</span> <span class=\"n\">AlgebraicNumber</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 420770946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707540971
    },
    {
        "content": "<p>Voila, there you have your field.</p>",
        "id": 420771243,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707541233
    },
    {
        "content": "<p>33 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list\">#general &gt; \"Missing Tactics\" list</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 420771505,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707541457
    },
    {
        "content": "<p>Is the fact that <code>AlgNum</code> is algebraically closed also needed?</p>",
        "id": 420822156,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707589630
    },
    {
        "content": "<p>How hard would that be?</p>",
        "id": 420822167,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707589644
    },
    {
        "content": "<p>Cylindrical Algebraic Decomposition is close to my research interests - I’m busy right now, but if someone gets a project going, I’d definitely volunteer</p>",
        "id": 420822480,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1707589898
    },
    {
        "content": "<p>Shouldn't be hard. If a complex number <code>x</code> is algebraic over <code>AlgNum</code> then by transitivity it is algebraic over Q. Hence it is already an element of AlgNum</p>",
        "id": 420826084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707592590
    },
    {
        "content": "<p>Do we have the appropriate notion of transitivity?</p>",
        "id": 420826201,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707592686
    },
    {
        "content": "<p>I hope so!</p>",
        "id": 420826215,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707592704
    },
    {
        "content": "<p>I.e. over the field generated by the coefficients in the polynomial equation…</p>",
        "id": 420826221,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707592708
    },
    {
        "content": "<p>Or do you have something else in mind?</p>",
        "id": 420826247,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707592731
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Algebraic.html#Algebra.IsAlgebraic.trans\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Algebraic.html#Algebra.IsAlgebraic.trans</a> is the best I can find</p>",
        "id": 420826893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707593320
    },
    {
        "content": "<p>I suppose AlgNum could(should?) be defined using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=integralClosure#doc\">docs#integralClosure</a> ?</p>",
        "id": 420830481,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707596830
    },
    {
        "content": "<p>It was, above</p>",
        "id": 420831505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707597899
    },
    {
        "content": "<p>I did a deep dive with Johan on the proof here to find out how to make it constructive, and we found that the construction essentially uses <code>A.charpoly</code> where <code>A</code> is the matrix which describes how to express <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><mi>i</mi></msup><msup><mi>y</mi><mi>j</mi></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)x^iy^j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0747em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span></span></span></span></span></span></span> in terms of the basis elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup><msup><mi>y</mi><mi>j</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^iy^j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0191em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span></span></span></span></span></span></span> for i,j less than the degree of their respective minimal polynomials. Unfortunately this seems quite a bit less efficient than <a href=\"https://en.wikipedia.org/wiki/Resultant\">https://en.wikipedia.org/wiki/Resultant</a> which is the standard reference for the proof that algebraic numbers are closed under addition, and it's also not obviously related (one is the determinant of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi><mo>×</mo><mi>m</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mn\\times mn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">mn</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span></span></span></span> matrix, the other one is the determinant of a completely different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(m+n)\\times(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> matrix)</p>",
        "id": 420831780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707598166
    },
    {
        "content": "<p>So if we want the resultant construction there is still some mathlib theory work to be done here</p>",
        "id": 420831906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707598276
    },
    {
        "content": "<p>The resultant has a few interesting properties and also comes up in the definition of the discriminant, so I think there are independent reasons to want to have its basic theory</p>",
        "id": 420832015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707598362
    },
    {
        "content": "<p>Wikipedia also mentions an n-ary version of the resultant called \"Macaulay's resultant\" which also might be interesting, although it's not as computationally motivated since it's a ridiculously large polynomial</p>",
        "id": 420832115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707598458
    },
    {
        "content": "<p>Another thing that is missing for turning this into a practical algorithm is that <code>det</code> uses the O(n!) definition and we don't have a proof of the gauss definition of the determinant yet</p>",
        "id": 420832463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707598826
    },
    {
        "content": "<p>Do we have LU decomposition, QR decomposition or Cholesky decomposition? Apparently they can all be used for computing determinants</p>",
        "id": 420832680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707599043
    },
    {
        "content": "<p>Fields Medallist Alan Baker used to teach the explicit resultant proof that the sum of two algebraic numbers was algebraic in his Cambridge Part III course and we all used to laugh at him for not using the \"subspace of a finite-dimensional vector space is finite-dimensional\" proof -- he claimed that he didn't like to use \"modern concepts\" when dealing with the material (this was in the 1980s).</p>",
        "id": 420834339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707600914
    },
    {
        "content": "<p>I think the mental model here may be that everything needs to be rewritten to be not just computational but actually fast, so the existence of current theory gives you only so much.  You'll also likely want approximate arithmetic to speed things up, as in practice working with exact algebraic numbers is very slow (you need them, but you also need shortcuts).</p>",
        "id": 420835698,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707602330
    },
    {
        "content": "<p>The interval arithmetic I currently have is one component, though for CAD you almost certainly need the arbitrary precision version.  If it seems like that's useful I can do the conversion: the code actually gets <em>easier</em> going from fixed precision to infinite precision due to side conditions disappearing.</p>",
        "id": 420836027,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707602582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Cylindrical.20Algebraic.20Decomposition.20tactic/near/420831906\">said</a>:</p>\n<blockquote>\n<p>So if we want the resultant construction there is still some mathlib theory work to be done here</p>\n</blockquote>\n<p>Do resultants allow to prove that the product of two algebraic elements is algebraic ? — I'm not sure…</p>",
        "id": 420839408,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1707606002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> , your code indicates that mathlib is missing IsAlgebraic.add, etc.</p>",
        "id": 420839619,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1707606166
    },
    {
        "content": "<p>Yes resultants also do products.</p>",
        "id": 420840572,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707607165
    },
    {
        "content": "<p>The resultant is in flt-reg, iirc</p>",
        "id": 420872010,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707640066
    },
    {
        "content": "<p>There's been a big need to port it for a while but it's still not been done</p>",
        "id": 420872011,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707640066
    },
    {
        "content": "<p>I finally remembered <a href=\"https://youtu.be/iLv4zqscBHI?si=q4WPtYCAHxC9YR2I&amp;t=762\">the talk I saw about CAD</a>, it was James Davenport's talk at the IPAM conference.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"iLv4zqscBHI\" href=\"https://youtu.be/iLv4zqscBHI?si=q4WPtYCAHxC9YR2I&amp;t=762\"><img src=\"https://uploads.zulipusercontent.net/71d3722abe3bcaddb6775484806128afa4c15a23/68747470733a2f2f692e7974696d672e636f6d2f76692f694c76347a7173634248492f64656661756c742e6a7067\"></a></div>",
        "id": 421180520,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707803440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Cylindrical.20Algebraic.20Decomposition.20tactic/near/420831780\">said</a>:</p>\n<blockquote>\n<p>I did a deep dive with Johan on the proof here to find out how to make it constructive, and we found that the construction essentially uses <code>A.charpoly</code> where <code>A</code> is the matrix which describes how to express <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy=\"false\">)</mo><msup><mi>x</mi><mi>i</mi></msup><msup><mi>y</mi><mi>j</mi></msup></mrow><annotation encoding=\"application/x-tex\">(x+y)x^iy^j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0747em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span></span></span></span></span></span></span> in terms of the basis elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup><msup><mi>y</mi><mi>j</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^iy^j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0191em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span></span></span></span></span></span></span> for i,j less than the degree of their respective minimal polynomials. Unfortunately this seems quite a bit less efficient than <a href=\"https://en.wikipedia.org/wiki/Resultant\">https://en.wikipedia.org/wiki/Resultant</a> which is the standard reference for the proof that algebraic numbers are closed under addition, and it's also not obviously related (one is the determinant of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>n</mi><mo>×</mo><mi>m</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mn\\times mn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">mn</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">mn</span></span></span></span> matrix, the other one is the determinant of a completely different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(m+n)\\times(m+n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> matrix)</p>\n</blockquote>\n<p>I may have missed something, but why is it necessary to prove these facts constructively? Is it for users that want to use the tactic to produce constructive proofs?</p>",
        "id": 431512938,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1712319850
    },
    {
        "content": "<p>it's not, but having a constructive proof means that it is really easy to make some light modifications and recombine the lemmas to obtain a verified algorithm instead</p>",
        "id": 431513357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712320024
    },
    {
        "content": "<p>For example, if I wanted to write an algebraic numbers representation, I'd want to use minimal polynomials and add them using resultants, but then I'd get stuck either defining the operation or proving correctness without having a proof that the resultant has the required properties. If there was a constructive proof of closure of algebraic numbers which used resultants, the necessary lemma would be right there and I could reuse it</p>",
        "id": 431513652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712320136
    },
    {
        "content": "<p>the existing proof is \"constructive enough\", but the actual algorithm that it implicates is kind of bad</p>",
        "id": 431513764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712320194
    },
    {
        "content": "<p>Hey! I’ve been thinking of trying my hand at some kind of implementation of CAD. Could someone give me an overview of what the current progress in this direction is? Have constructive algebraic numbers been worked out?</p>",
        "id": 543380730,
        "sender_full_name": "Dhruv Bhatia",
        "timestamp": 1759774228
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"228705\">@Haniel Barbosa</span> has some student(s) working in this direction?</p>",
        "id": 543878650,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1759991049
    },
    {
        "content": "<p>Hi, yes, I am Haniel's student working on this direction. There is also another PhD student (Pedro Saccomani) working on it. We don't plan to formally verify one specific implementation of CAD though, we are working on modifying cvc5 so its implementation of Cylindrical Algebraic Coverings (a flavor of CAD) emits proofs, following the approach of <a href=\"https://arxiv.org/abs/2212.09309\">this recent work by Nalbach et al</a>. We also plan to formalize the proof calculus in Lean, so proofs emitted by this implementation could potentially be reconstructed by a tool like <a href=\"https://github.com/ufmg-smite/lean-smt\">lean-smt</a> and we could have a CAD tactic.</p>\n<p>We've been working on it for around 6 months. So far we are getting close to have the univariate case working; it required proving Sturm's theorem, which we're close to finish. We will also PR it to mathlib once it is done.</p>",
        "id": 543972090,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1760019242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360938\">@Tomaz Mascarenhas</span> <br>\nI am (slowly) formalising some real algebra in Lean, ie real closed fields and so on. Does this work relate to that? As in, do you think your material could contribute to this formalisation?</p>",
        "id": 544846167,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1760480363
    },
    {
        "content": "<p>Hi Artie, yes sure! Right now we are proving Sturm's theorem only for the real numbers, but I believe that, by combining with your work, we could potentially have it for any real closed field. Also, I believe that in the future, assuming we have a CAD tactic for the reals (which is what we are working towards now) we would also be able to use your work to extend this tactic to any real closed field. So yes, your work could make our tactics much more powerful.</p>",
        "id": 544846705,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1760480708
    }
]