[
    {
        "content": "<p>What are the implications of writing instance bounds on structures e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BinaryHeap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BinaryHeap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>From my Rust background, my default is to opt for the former as it seems strictly more flexible, and it allows you to write some methods (such as <code>empty</code>) without supplying an instance at all. However, I notice that e.g. in the standard library <code>HashTable</code> has class bounds for BEq and Hashable in the structure definition.  Is there a reason to prefer the latter over the former?</p>",
        "id": 569965282,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769358663
    },
    {
        "content": "<p>Ah, I guess this is a difference. Without Ord in the type signature the following compiles</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">example</span><span class=\"w\">  </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">heap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinaryHeap</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">instOrdNat</span><span class=\"bp\">.</span><span class=\"n\">opposite</span>\n<span class=\"w\">    </span><span class=\"n\">heap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>while with it, it doesn't.</p>",
        "id": 569976820,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769369429
    },
    {
        "content": "<p>your example doesn't seem to compile either way?</p>",
        "id": 569977533,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769370020
    },
    {
        "content": "<p>There's a third option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BinaryHeap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>Please make a mwe to illustrate.</p>",
        "id": 569977691,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769370207
    },
    {
        "content": "<p><a href=\"https://live.lean-lang.org/#codez=M4FwTgrgxiFgpgAgBLwIYAcCqiAUhG4EQC5EAVATwyQgEpEB3AC3gQChFE0wxjEBBbmnKJ8rVgBN4AMxTpsAOngBbDCGElUmHISIBeRMAD23cmMkzNCgJYA7YCxCIA2gHkw4kQF08jXpe10uAAevPh0GnLaxPpGJmKsoJAwcEiWAEJ4OmSU1HSu7l4MzGwcXDwkAmBCImbSsphpiipqzm4e+N4RDSLRBsZgphJ16fK29mCO+e3euL5dGBlheCEkS/OLvbED8fBBaCoANki97IhHjsyYfpGIAHJojnr1CsqqphznAJK9YyBt9yB5IYMBhDMArCB4KdLhhRnYHIgAEzxAD0AFo0awWGBjCRgOQbCBmOCAF7wDxqKiIKAHNDAYCIX5oGxQJBWBk2QyOcy2CFWQw2NAHA7CeAARwgQsQIEMiF2GAQ9P5NkZNik2PJiAARsJKbYAOaISBHYAAGgMBKJ8FJ5NORPZrFs6u4to4v3+D1YaJRrAAxPrJe4APpKYD6hm2LF7Q5IJ6nc6IGHXboA3ojV5qePwEDfJ7u9wAoEgsEQqEcGFw8aORFAA\">Here</a> is a mwe</p>",
        "id": 569977735,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769370249
    },
    {
        "content": "<p>Try the third option.</p>",
        "id": 569977796,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769370312
    },
    {
        "content": "<p><del>The third option requires that 'empty' have an Ord constraint</del>, but permits the example above. <a href=\"https://live.lean-lang.org/#codez=M4FwTgrgxiFgpgAgBLwIYAcCqiAUhG4EQC5EAVATwyQgEpEB3AC3gQChFE0wxjEBBbmnKJ8rVgBN4AMxTpsAOngBbDCGElUmHISIBeRMAD23cmMkzNCgJYA7YCxCIA2gHkw4kQF08jXpe10uAAevPh0GnLaxPpGJmKsoJAwcEiWAEJ4OmSU1HSu7l4MzGwcXDwkAmBCImbSsphpiipqzm4e+N4RDSLRBsZgphJ16fK29mCO+e3euL5dGBlheCEkS/OLvbED8fBBaCoANki97IhHjsyYfpGIAHJojnr1CsqqphznAJK9YyBt9yB5IYMBhDMArCB4KdLhhRnYHIgAEzxAD0AFo0awWGBjCRgOQbCBmOCAF7wDxqKiIKAHNDAYCIX5oGxQJBWBk2QyOcy2CFWQw2NAHA7CeAARwgQsQIEMiF2GAQ9P5NkZNik2PJiAARsJKbYAOaISBHYAAGgMBKJ8FJ5NORPZrFs6u4to4v3+D1YaJRrAAxPrJe4APpKYD6hm2LF7Q5IJ6nc6IGHXboA3ojV5qePwEDfJ7u9wAoEgsEQqEcGFw8aOZFiRLQWAIZ4AUUyvAoVPodF2kJs4gZbR6TBYZc43F4lWqoiGFjkTaab1aBQ6yYwLZ0MX6g3MzcrCKmhVmK7XgRWInCzw2Ty2g12+wwRw4cY+2cTciPdwevXnmefOZ+dj+AsHiLUFwUhaE5F3CYkSAA\">Here's</a> the MWE with this version also</p>\n<p>edit: sorry I was wrong, it does not require that empty have an ord constraint</p>",
        "id": 569977948,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769370478
    },
    {
        "content": "<p>It requires it for the implementation</p>",
        "id": 569978053,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769370561
    },
    {
        "content": "<p>But that's expected.</p>",
        "id": 569978104,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769370616
    },
    {
        "content": "<p>Ah you're right, that makes sense. If I actually give a non sorry definition for the rhs of empty, then it gives an error if there is no Ord instance</p>",
        "id": 569978107,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769370618
    },
    {
        "content": "<p>Do you expect <code>empty</code> to work without an <code>Ord</code> instance?</p>",
        "id": 569978150,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769370672
    },
    {
        "content": "<p>I think it's fine if it does (but like I said I'm coming from Rust where the idiomatic thing is usually to put the minimum trait bounds required to make the implementation works). That said, Rust does not allow multiple trait implementations for the same type, so in light of that I think it makes sense to put the [Ord a] bound on the structure definition</p>\n<p>edit: just so I don't seem crazy, for example <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.new\">HashMap::new</a> works for any key and value types, regardless of whether the key is hashable or not</p>",
        "id": 569978236,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769370790
    },
    {
        "content": "<p>I think the third option is something done more often in other programming languages (for example Java uses this principle for TreeMaps) where the empty map constructor requires a comparator but the other operations don't. But I don't think it fits well for Lean, in particular since it's very awkward to use this <code>Ord</code> instance, you'd need something like <code>heap.toOrd.compare a b</code> or <code>let := heap.toOrd</code> instead of just <code>compare a b</code>.<br>\nThe second option is the safest because it ensures that you don't do any operations like <code>insert</code> with a different instance (in the sense of <code>=</code> since you can still cast).<br>\nThe first option is most flexible but also loses wellformedness guarantees pretty quickly (and note that it is also not possible to embed a wellformedness invariant into the structure definition because of the lack of instance). Use this one if you don't care about wellformedness.<br>\nIn Lean, the first option is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap.Raw#doc\">docs#Std.HashMap.Raw</a> and all other similar variants and the second option is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap#doc\">docs#Std.HashMap</a> and all other variants.<br>\nAlso, as you said <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap.Raw.instEmptyCollection#doc\">docs#Std.HashMap.Raw.instEmptyCollection</a> has no hashable constraints:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">({}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">Raw</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 569978915,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769371485
    },
    {
        "content": "<p>Does this also have implications for runtime performance? I assume option 3 requires storing the actual comparator function at runtime. Does that have implications for inlining, etc?</p>",
        "id": 569979108,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769371635
    },
    {
        "content": "<p>Regarding well-formedness, this comes up in a PR I have open in Batteries which adds formal verification to the BinaryHeap implementation. My current approach has been to just add extrinsic lemmas that verify the well-formedness properties (i.e. the well-formedness property is not bundled with the binary heap). I suppose one could imagine having a similar Raw dichotomy as in HashMap. What is the reasoning for having a \"bundled\" version as opposed to just a raw implementation and lemmas that prove the wellformedness property is preserved?</p>",
        "id": 569979638,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769372165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/113488-general/topic/Implication.20of.20adding.20typeclass.20bounds.20on.20structures/near/569979108\">schrieb</a>:</p>\n<blockquote>\n<p>Does this also have implications for runtime performance?</p>\n</blockquote>\n<p>Option 3 has performance implications by requiring more memory and the use of closure calls, option 1 and option 2 are identical in terms of performance.</p>",
        "id": 569979819,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769372391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1006649\">cmlsharp</span> <a href=\"#narrow/channel/113488-general/topic/Implication.20of.20adding.20typeclass.20bounds.20on.20structures/near/569979638\">schrieb</a>:</p>\n<blockquote>\n<p>What is the reasoning for having a \"bundled\" version as opposed to just a raw implementation</p>\n</blockquote>\n<p>The proofs for the raw version require an additional wellformedness hypothesis while the bundled version has simpler lemmas that don't require such additional assumptions. Also, having a wellformedness guarantee can sometimes allow for faster paths (e.g. <code>Std.TreeMap</code> makes heavy use of balancing invariants to eliminate impossible cases in matches)</p>",
        "id": 569980105,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769372656
    },
    {
        "content": "<p>So actually, I take it back, option 2 + wellformedness can also have performance benefits over option 1</p>",
        "id": 569980178,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1769372727
    },
    {
        "content": "<p>Ah, I see, the non-raw version is easier to work with in proofs because you don't have to manually thread through the well-formedness condition. That makes sense. <span class=\"user-mention\" data-user-id=\"119741\">@François G. Dorais</span> , do you have a thought about whether Batteries ought to have a similar raw/bundled dichotomy for BinaryHeap?</p>",
        "id": 569980306,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769372847
    },
    {
        "content": "<p>I think we've come full circle why the original implementation used an <code>lt</code> parameter instead of an <code>Ord</code> instance. Your verification work is excellent and I would not recommend moving back to <code>lt</code>. Using <code>Ord</code> should be just as efficient but there needs to be some library and compiler work upstream to make it work efficiently. This is a long term goal. In the shorter term, there are thoughts about reimplementing structures in core that could make option 3 behave mostly like option 1 but with the major benefits of option 2.</p>\n<p>In any case, whatever you pick right now could be updated to a better option later so long as you don't commit too much to implementation details.</p>\n<p>PS: Note that many <code>Ord</code> implementations are very inefficient. Most require two or three comparisons that could be optimized to just one. A good backend could optimize these out but we can't rely on that.</p>",
        "id": 569981349,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1769373897
    },
    {
        "content": "<p>Ok, I think the implementation I will go with for the moment is option 2.</p>\n<p>Fwiw, I wrote a quick benchmarking <a href=\"https://live.lean-lang.org/#codez=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\">script</a> to test an 'lt function' an Ord instance and an 'extends Ord' based heap, and timed heapSort on arrays (of Nats) of increasing size. (times are the median of 20 trials, with a 5 trial warmup). [Ord Nat] and lt seem to be pretty comparable, but extends Ord is definitely slower.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">===</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\"> </span><span class=\"bp\">===</span>\n<span class=\"n\">Name</span><span class=\"w\">                 </span><span class=\"n\">Time</span>\n<span class=\"c1\">-------------------  ---------------</span>\n<span class=\"n\">Heap1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"mf\">62.030611</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n<span class=\"n\">Heap2</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">])</span><span class=\"w\">      </span><span class=\"mf\">64.925203</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n<span class=\"n\">Heap3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"mf\">178.244899</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n\n<span class=\"bp\">===</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">100000</span><span class=\"w\"> </span><span class=\"bp\">===</span>\n<span class=\"n\">Name</span><span class=\"w\">                 </span><span class=\"n\">Time</span>\n<span class=\"c1\">-------------------  ---------------</span>\n<span class=\"n\">Heap1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"mf\">802.539662</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n<span class=\"n\">Heap2</span><span class=\"w\"> </span><span class=\"o\">([</span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">])</span><span class=\"w\">      </span><span class=\"mf\">826.494604</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n<span class=\"n\">Heap3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"mf\">1288.743552</span><span class=\"w\"> </span><span class=\"n\">ms</span>\n</code></pre></div>\n<p>(edit: also with larger numbers of trials this difference between lt and [Ord \\a] shrinks)</p>",
        "id": 569983128,
        "sender_full_name": "cmlsharp",
        "timestamp": 1769375745
    }
]