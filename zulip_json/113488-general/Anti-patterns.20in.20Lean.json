[
    {
        "content": "<p>What are some examples of <a href=\"https://en.wikipedia.org/wiki/Anti-pattern\">anti-patterns</a> is Lean?<br>\nOne example I can think of is using equality of types</p>",
        "id": 465625779,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724819543
    },
    {
        "content": "<ol>\n<li>defeq abuse (this is likely what you meant by \"using equality of types\"). That is, given a type <code>X : Type</code>, create a new type <code>def Y : Type := X</code>. Then prove theorems about elements of <code>Y</code> by allowing Lean to \"see through\" the definitional equality and using a theorem about terms of type <code>X</code>.</li>\n<li>Using subtypes of subtypes. It's almost always a bad idea to start with a type <code>X</code>, some predicate <code>p : X → Prop</code>, create the subtype <code>Y := { x // p x }</code>, then take a predicate <code>q : Y → Prop</code> and create a subtype <code>Z := { y // q y }</code>. It's almost certainly better to use a predicate <code>q' : X → Prop</code> such that <code>∀ x, q' x ↔ ∃ hx : p x, q ⟨x, hx⟩</code> and create the subtype <code>Z' := { x // q' x}</code> instead.</li>\n<li>Sets of sets. This is related to the previous one, but it is rarely the case that you actually want to consider <code>s : Set X</code> and <code>t : Set ↥s</code>; although it does happen occasionally. One of the issues is that if you have <code>s s' : Set X</code> with <code>h : s = s'</code> but <code>h</code> is not <code>rfl</code> (i.e., propeq but not defeq), then it's relatively hard to talk meaningfully about the equality of <code>t : Set ↥s</code> and <code>t' : Set ↥s'</code> and have it do anything useful for you. (Of course, you can say that <code>Subtype.val '' t = Subtype.val '' t'</code>, but this probably doesn't buy you much.</li>\n<li>Over-typing. This comes up a lot when you try to do things \"precisely\" or avoid junk values. For instance, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=divp#doc\">docs#divp</a>, but it is used relatively rarely compared to the usual <code>/</code>. I would argue that's because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=divp#doc\">docs#divp</a> is <em>over-typed</em> (i.e., too much information is required at the time the function is used); of course, there are always a few instances where this level of type safety is actually a good thing, but most of the time it isn't. The solution is often to embrace junk values, and use hypotheses in theorems to specify an input isn't junk. Another example could be the (over-typed) definition of <code>Vector</code> as an inductive definition, versus <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mathlib.Vector#doc\">docs#Mathlib.Vector</a> which is just a subtype of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List#doc\">docs#List</a>. Of course, there is a balance that needs to be struck here.</li>\n<li>Not utilizing forgetful inheritance when designing class hierarchies. I'll just point to <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> for the explanation here. It's often easier at first to avoid forgetful inheritance, but it bites you later.</li>\n<li>More generally, failing to make instances canonical, thereby ending up with non-defeq (or worse, non-propeq) diamonds. Again, it's natural to just declare an instance whenever you want it, but without careful thought you end up in this situation.</li>\n<li>marking lemmas as <code>simp</code> because they are \"obvious\". This might be bad for a whole host of reasons (they have side conditions, they point in the wrong direction, they don't help reduce to a \"normal form\" even informally).</li>\n</ol>",
        "id": 465633654,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1724822428
    },
    {
        "content": "<p>By equality of types I meant using HEq and cast</p>",
        "id": 465634131,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724822641
    },
    {
        "content": "<p>There was also a <a href=\"#narrow/stream/113489-new-members/topic/Code.20smell.3F\">similar thread</a> with more suggestions.</p>",
        "id": 465657979,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1724828285
    }
]