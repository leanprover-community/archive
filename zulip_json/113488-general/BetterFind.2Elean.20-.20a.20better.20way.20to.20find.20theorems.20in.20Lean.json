[
    {
        "content": "<p>Hi Lean Folks! Pleased to announce a release of <code>BetterFind.lean</code>, a tactic for an improved search experience for Lean.</p>\n<p>Available at: <a href=\"https://github.com/kiranandcode/BetterFind.lean\">https://github.com/kiranandcode/BetterFind.lean</a></p>\n<h1>BetterFind.lean -  a better find tactic for lean</h1>\n<p>This is a work in progress tactic for Lean, based on mathlib's find tactic that provides more functionalities closer to Rocq.</p>\n<h2>Features</h2>\n<ol>\n<li>Recreates <code>#find</code> -- Running <code>bfind &lt;pattern&gt;</code> does the same thing as the <code>#find</code> you're used to.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">myThm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">bfind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Messages here:</span>\n<span class=\"sd\">Std.HashMap.getElem_insertManyIfNewUnit_list: ...</span>\n<span class=\"sd\">Nat.add_comm: ...</span>\n<span class=\"sd\">String.set_next_add.foo: ..</span>\n<span class=\"sd\">...</span>\n<span class=\"sd\">--/</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Adds support for filtering results, by Ident -- <code>bfind &lt;pattern&gt; : &lt;ident&gt;</code> filters generated results to only those that contain the ident</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">myThm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">bfind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- only those involving Nats</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Messages here:</span>\n<span class=\"sd\">Std.HashMap.getElem_insertManyIfNewUnit_list: ...</span>\n<span class=\"sd\">Nat.add_comm: ...</span>\n<span class=\"sd\">String.set_next_add.foo: ..</span>\n<span class=\"sd\">...</span>\n<span class=\"sd\">--/</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>Adds support for filtering results, by fuzzy match</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">searching</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">myThm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">bfind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"comm\"</span><span class=\"w\"> </span><span class=\"c1\">-- only lemmas whose name fuzzy matches comm (commutativity?)</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">searching for [\"comm\"]</span>\n<span class=\"sd\">Nat.add_comm: ...</span>\n<span class=\"sd\">Lean.Grind.AddCommMonoid.add_comm: ...</span>\n<span class=\"sd\">Int.add_right_comm: ...</span>\n<span class=\"sd\">Lean.Grind.Fin.add_comm: ...</span>\n<span class=\"sd\">Lean.Grind.AddCommMonoid.add_left_comm: ...</span>\n<span class=\"sd\">--/</span>\n</code></pre></div>\n<ol start=\"4\">\n<li>Combining constraints -- these constraints can be arbitrarily combined</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">myThm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">bfind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"comm\"</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- only lemmas whose name fuzzy matches comm and involve Nats (commutativity?)</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Nat.add_comm: ...</span>\n<span class=\"sd\">Lean.Grind.Fin.add_comm:  ...</span>\n<span class=\"sd\">Nat.add_right_comm: ...</span>\n<span class=\"sd\">Nat.add_left_comm:  ...</span>\n<span class=\"sd\">BitVec.sub_add_comm: ...</span>\n<span class=\"sd\">--/</span>\n</code></pre></div>\n<ol start=\"5\">\n<li>No mathlib dependency</li>\n</ol>",
        "id": 532811522,
        "sender_full_name": "Kiran",
        "timestamp": 1754351004
    },
    {
        "content": "<p>Looking forward to having this in a form we could depend on in Mathlib. :-)</p>\n<p>How does this compare to <a href=\"https://loogle.lean-lang.org/\">#loogle</a>? How fast is it after <code>import Mathlib</code>? Why do the messages above say \"<code>Messages here:</code>\"? Are the results above real? (If so, what is <code>String.set_next_add.foo</code>?)</p>\n<p>The colon syntax reads strangely to me, we always use that for typing in Lean.</p>",
        "id": 532834053,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1754369729
    },
    {
        "content": "<p>Maybe <code>with</code> instead of the colon?</p>",
        "id": 532857415,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1754380854
    },
    {
        "content": "<p>To make things more confusing <code>#find</code> is overridden with a better version if you import Loogle!</p>",
        "id": 532894816,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754393164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113488-general/topic/BetterFind.2Elean.20-.20a.20better.20way.20to.20find.20theorems.20in.20Lean/near/532894816\">said</a>:</p>\n<blockquote>\n<p>To make things more confusing <code>#find</code> is overridden with a better version if you import Loogle!</p>\n</blockquote>\n<p>Oh that's really annoying. Yes, you're exactly right, the version of find exported by loogle is closer to what I've implemented:</p>\n<p><a href=\"https://github.com/nomeata/loogle/blob/master/Loogle/Find.lean\">https://github.com/nomeata/loogle/blob/master/Loogle/Find.lean</a></p>\n<p>There's some major discovery problems with the loogle readme, there's no mention it provides an additional #find tactic, only mentions of loogle integration and <a href=\"https://loogle.lean-lang.org/\">#loogle</a>, when a dedicated tactic closer to #find was what I wanted</p>",
        "id": 532915554,
        "sender_full_name": "Kiran",
        "timestamp": 1754400067
    },
    {
        "content": "<p>The <code>#find</code> tactic from loogle looks very nice, but I have troubles getting it to work. I created a separate thread for that here: <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/How.20to.20use.20the.20.23find.20tactic.20from.20Loogle.20in.20a.20custom.20project.3F/near/533041839\">#general &gt; How to use the #find tactic from Loogle in a custom project? @ ðŸ’¬</a></p>",
        "id": 533042017,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1754465816
    }
]