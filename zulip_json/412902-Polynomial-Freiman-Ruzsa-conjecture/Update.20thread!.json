[
    {
        "content": "<p>Hi everyone!  The project is now quite active with a lot of parallel advances going on, so I thought it would be good to have a thread where people update the rest of the group on where they are at.</p>\n<p>I'll start the ball rolling and then others can chime in.  The blueprint is now in pretty good shape, with all the main steps described more or less completely in LaTeX, and formulated as statements in Lean.  The bubbles are mostly green and blue!  There are two key definitions that need to be formalized, <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#cond-dist-def\">https://teorth.github.io/pfr/blueprint/sect0003.html#cond-dist-def</a> and <a href=\"https://teorth.github.io/pfr/blueprint/sect0002.html#uniform-def\">https://teorth.github.io/pfr/blueprint/sect0002.html#uniform-def</a> , but I think some of the participants are close to this goal (maybe they can report in on this thread).</p>\n<p>Right now I'm working on formalizing the proof of <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#kv\">https://teorth.github.io/pfr/blueprint/sect0003.html#kv</a> , which is a very typical application of the \"entropic Ruzsa calculus\" that will be needed to fill in most of the other remaining blue bubbles.  I've been able to successfully use many of the tools (e.g., submodularity) that have already been developed to achieve this, and am only running into some very minor technical issues (mostly involving how to handle vectors such as <code>![X,Y,Z]</code>) that I hope to resolve soon.  When I do, I'll open a separate thread to deconstruct the proof: what I have now is definitely clunky, and figuring out how to do this smoothly will facilitate the dozen or so other similar calculations that will be needed elsewhere.  One of the ingredients was how to easily verify entropy identities such as <code>H[⟨⟨X, Y⟩, Z⟩; μ] = H[⟨X, ⟨Z, X + (Y + Z)⟩⟩; μ]</code> without a lot of \"Rubik's cube\" type chaining together of a half-dozen lemmas in a <code>rw</code>; I think I arrived at a somewhat workable solution to that following <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/.40simp.20lemmas.20for.20entropy.20of.20sums.3F/near/403088157\">https://leanprover.zulipchat.com/#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/.40simp.20lemmas.20for.20entropy.20of.20sums.3F/near/403088157</a> , but there could be a better way still.</p>\n<p>Anyway, that's my update.  What else has been going on?</p>",
        "id": 403208868,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700499177
    },
    {
        "content": "<p>For the Ruzsa distance, I've made a measure and a kernel definition at <a href=\"https://github.com/RemyDegenne/pfr/blob/master/PFR/Entropy/KernelRuzsa.lean\">https://github.com/RemyDegenne/pfr/blob/master/PFR/Entropy/KernelRuzsa.lean</a> . I have not specialized it yet to get the conditional distance, nor have I proved any properties of it. This is the thing I am investigating now. <br>\nApart from that, everything I've done was merged to master (a minute ago for the last part).</p>",
        "id": 403212124,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700500359
    },
    {
        "content": "<p>I've changed the main part of the argument to use <code>[MeasureSpace]</code> instead of <code>[MeasurableSpace]</code> variables, so that the measure is always called <code>ℙ</code> and can be hidden from most notations. It went very smoothly, and now formulas are slightly more readable.</p>\n<p>I've also worked on the compactness of the space of probability measures, and reformulated a little bit the existence of minimizers of the tau functional in terms of random variables (although the existence will be done using measures). All this has already been merged. To complete the existence of minimizers, we need continuity statements for entropy and Rusza distance, which <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> is working on if I understand correctly.</p>",
        "id": 403214755,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700501376
    },
    {
        "content": "<p>Yes, sorry, I got distracted from the continuity --- by considerations of the spelling of uniformity of probability measures <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>.</p>\n<p>Thanks for phrasing <code>tau_min_exists_measure</code> in terms of the measures, <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>! That makes this a lot easier. I think just <code>[MeasurableSingletonClass G]</code> needs to be added in hypotheses, to get to use your compactness proof.</p>\n<p>The main remaining thing for <code>tau_min_exists_measure</code> is <code>continuous_tau_restrict_probabilityMeasure</code>, for which I added the statement. The proof requires measure-spellings of Rusza distance and entropies, but the basic case (to which things should essentially reduce) of the continuity of the entropy in terms of measures exists in <code>FiniteMeasureFintype.lean</code>: it is <code>continuous_measureEntropy_probabilityMeasure</code>.</p>",
        "id": 403227886,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700506609
    },
    {
        "content": "<p>The continuity / existence of tau minimizer proofs are essentially done, except:</p>\n<ul>\n<li>There are two \"funny\" type class instance inference <code>sorry</code>es in <code>tau_min_exists_measure</code>.</li>\n<li>There is one <code>sorry</code> in <code>continuous_rdist_restrict_probabilityMeasure</code>, which requires API about products of <code>ProbabilityMeasure</code>s, and especially the fact that taking products is continuous in the topology of convergence in distribution. (The same sorry also needs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure.continuous_map#doc\">docs#MeasureTheory.ProbabilityMeasure.continuous_map</a>, which fortunately exists since September.)</li>\n</ul>\n<p>The API in the second point should definitely go to Mathlib, too. I'd be happy to work on it, although I'm not sure I'd get anything done before the weekend.</p>",
        "id": 403263720,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700523261
    },
    {
        "content": "<p>And I kind of wanted to say something about the spelling of uniformity of a probability measure.</p>\n<p>I was not super happy about the spelling with PMFs, although <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PMF.uniformOfFinset#doc\">docs#PMF.uniformOfFinset</a>  is in principle an option (it would be specific to discrete uniform distributions anyway and seems to moreover require countability of the underlying space).</p>\n<p>I think prefer a version via <span class=\"user-mention silent\" data-user-id=\"243312\">Jason KY.</span>'s <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.pdf.IsUniform#doc\">docs#MeasureTheory.pdf.IsUniform</a>, although I haven't carried out the necessary testing to be totally sure yet...</p>\n<p>For this PFR project only discrete uniform measures on finite sets are needed. If the preference is to get things done rather than wait for the best or most general way to write this mathematical triviality, that would also make sense... So while I still plan to do some testing on my own, I don't want to claim uniform measures (not before the weekend, at least). There is a tiny bit of messy testing in the file <code>FiniteMeasureFintype.lean</code>, if that helps someone else make a choice of spelling.</p>",
        "id": 403264545,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700523731
    },
    {
        "content": "<p>By the way, I'm of course super excited about the project in general, and specifically because it is leading to so much development and improvements in probability in particular!</p>\n<p>(Just a mixed feeling, since in doing that it is revealing so many things that are not yet what they should be in Mathlib...)</p>",
        "id": 403264787,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700523890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403264545\">said</a>:</p>\n<blockquote>\n<p>And I kind of wanted to say something about the spelling of uniformity of a probability measure.</p>\n<p>I was not super happy about the spelling with PMFs, although <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PMF.uniformOfFinset#doc\">docs#PMF.uniformOfFinset</a>  is in principle an option (it would be specific to discrete uniform distributions anyway and seems to moreover require countability of the underlying space).</p>\n<p>I think prefer a version via <span class=\"user-mention silent\" data-user-id=\"243312\">Jason KY.</span>'s <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.pdf.IsUniform#doc\">docs#MeasureTheory.pdf.IsUniform</a>, although I haven't carried out the necessary testing to be totally sure yet...</p>\n<p>For this PFR project only discrete uniform measures on finite sets are needed. If the preference is to get things done rather than wait for the best or most general way to write this mathematical triviality, that would also make sense... So while I still plan to do some testing on my own, I don't want to claim uniform measures (not before the weekend, at least). There is a tiny bit of messy testing in the file <code>FiniteMeasureFintype.lean</code>, if that helps someone else make a choice of spelling.</p>\n</blockquote>\n<p>For the purposes of the project, I think the main things that are needed are to be able to use the lemmas  <a href=\"https://teorth.github.io/pfr/docs/PFR/entropy_basic.html#ProbabilityTheory.exists_uniform\"><code>exists_uniform</code></a>,  <a href=\"https://teorth.github.io/pfr/docs/PFR/entropy_basic.html#ProbabilityTheory.prob_of_uniform_of_in\"><code>prob_of_uniform_of_in</code></a>, <a href=\"https://teorth.github.io/pfr/docs/PFR/entropy_basic.html#ProbabilityTheory.prob_of_uniform_of_not_in\"><code>prob_of_uniform_of_not_in</code></a>, and <a href=\"https://teorth.github.io/pfr/docs/PFR/entropy_basic.html#ProbabilityTheory.entropy_of_uniform\"><code>entropy_of_uniform</code></a>.  If you feel confident that your final version of <code>isUniform</code> would be compatible with these four lemmas, then it would be possible to develop a definition of uniform distribution independently for the rest of the project, since I believe these four lemmas can be used as black boxes for everything else.</p>\n<p><del>[Side note: is it possible to combine URLs with backtick notation in Zulip?] </del></p>",
        "id": 403266480,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700524926
    },
    {
        "content": "<p>Zulip has the capability to setup linkifiers such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat#doc\">docs#Nat</a>, which could definitely be done for this project (cc <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> maybe?) but they won't have the monospace formatting. Alternatively you could do backticks and a unicode link like <a href=\"http://example.com\"><code>test</code></a>, written as:</p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>[<span class=\"sb\">`test`</span>](example.com)\n</code></pre></div>",
        "id": 403268200,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1700525834
    },
    {
        "content": "<p><a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.prob_of_uniform_of_in#doc\">pfr#ProbabilityTheory.prob_of_uniform_of_in</a></p>",
        "id": 403269835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700526629
    },
    {
        "content": "<p>Hello everyone! I'd like to get started on the project and wondered if there is any lemma in particular that could be suitable for this purpose. My formalization experience is mainly in Isabelle, but I've used Lean as a functional programming language before and would like to gain more experience formalizing in Lean as well. My mathematical background is in probability theory so I think this project could be an ideal start for this.</p>",
        "id": 403365511,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1700567854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"605003\">Jonas Bayer</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403365511\">said</a>:</p>\n<blockquote>\n<p>Hello everyone! I'd like to get started on the project and wondered if there is any lemma in particular that could be suitable for this purpose. My formalization experience is mainly in Isabelle, but I've used Lean as a functional programming language before and would like to gain more experience formalizing in Lean as well. My mathematical background is in probability theory so I think this project could be an ideal start for this.</p>\n</blockquote>\n<p>Welcome Jonas!  Here are some lemmas that should have fairly short and doable proofs, and which I don't think anyone else is claiming right now: you (or anyone else) are welcome to claim one or more of them to work on.</p>\n<ol>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0002.html#bound-conc\">Bounded entropy implies concentration</a>.  This should follow from a pigeonhole principle argument and the monotonicity of the logarithm.  It may help to take contrapositives (using <code>contrapose!</code>) in which case one should be able to use either the tactic <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/GCongr/Core.html\"><code>gcongr</code></a> or finite set sum monotonicity laws (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_le_sum#doc\">docs#Finset.sum_le_sum</a> ) together with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/SpecialFunctions/Log/Basic.html\">basic properties of the logarithm or exponential</a>. <strong>Claimed by <span class=\"user-mention\" data-user-id=\"605003\">@Jonas Bayer</span></strong> </li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0002.html#cond-trial-ent\">Entropy of conditionally independent variables</a>. This should follow by routine algebra from the indicated lemmas in the proofs. (One of these lemmas is still not yet proven, but that does not affect the task of locally proving this lemma.) <strong>Established by <span class=\"user-mention\" data-user-id=\"325367\">@Mauricio Collares</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-diff\">Distance controls entropy difference</a> This should follow from the indicated lemmas by routine manipulation of inequalities (and the properties of the absolute value). <strong>Established by <span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-growth\">Distance controls entropy growth</a> Similar to previous lemma.  <strong>Established by <span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#second-useful\">Comparison of Ruzsa distances, II</a> Although this is a moderately complex statement, its deduction from previous lemmas should be straightforward. <strong>Established by <span class=\"user-mention\" data-user-id=\"398581\">@Mantas Baksys</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0004.html#lem:100pc\">General 100% inverse theorem</a> Similar to previous lemma: the complete proof here is rather tricky, but the deduction from the previous lemma (Symmetric 100% inverse theorem) and the [Ruzsa triangle inequality] (<a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-triangle\">https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-triangle</a>) should be straightforward.  <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n</ol>\n<p>Note: many of the statements are missing some basic hypotheses, such as measurability, or that the measure is a probability measure.    Part of the task of formalizing is to determine the necessary side conditions that need to be inserted into the statement.</p>\n<p>Slightly more ambitious:</p>\n<ol>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#first-useful\">Comparison of Ruzsa distances, I</a>  Here the one tricky thing is the need to introduce independent copies at the beginning of the argument.  It may help to split this lemma into two, one establishing the independent case, and the other deducing the general case from the independent case. <strong>Established by <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></strong> </li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0005.html#fibring-ident\">General fibring identity</a> This will be an application of a large number of the entropic Ruzsa calculus lemmas, a bit similar to how the <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#kv\">Kaimonovich-Vershik lemma</a> is proven for instance, or the <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-triangle-improved\">improved Ruzsa triangle inequality</a>.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0005.html#cor-fibre\">Special case of Fibring identity</a> Again, mostly a large number of applications of preceding entropy identities.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#cond-dist-fact\">Relating conditional Ruzsa distance to Ruzsa distance</a>  Again the one tricky thing is to first set up independent copies (we have a <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#independent-exist\">lemma for this</a>, though) <strong>Claimed (and partially completed) by <span class=\"user-mention\" data-user-id=\"646363\">@Ben Eltschig</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#entropy-pfr\">Entropy version of PFR</a>  Although this is one of the main theorems in the project, deriving it from previous propositions is actually rather short; the main issue is conceptually understanding what this result, and its predecessor results, mean. <strong>Established by <span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span> </strong></li>\n</ol>\n<p>Other claims, for the record:</p>\n<ol>\n<li><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> established <a href=\"https://teorth.github.io/pfr/blueprint/sect0004.html#lem:100pc-self\">Symmetric 100% inverse theorem</a></li>\n<li><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> claim <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#lem-bsg\">Entropic Balog-Szemeredi-Gowers</a></li>\n<li><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> claims what is left to prove for <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#tau-min\">tau has a minimizer</a></li>\n<li><span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> claims (I think?) <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#cond-dist-def\">conditioned Ruzsa distance</a></li>\n<li><span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> established <a href=\"https://teorth.github.io/pfr/blueprint/sect0003.html#ruzsa-triangle\">Ruzsa triangle inequality</a></li>\n</ol>\n<p>And feel free to ask questions about Lean while formalizing, everyone here is very helpful and responsive!</p>",
        "id": 403414620,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700582530
    },
    {
        "content": "<p>I'd like to claim the 100% version of PFR, i.e. if <code>d[X, X]=0</code> then <code>X</code> is uniform on a translate of a subgroup (Lemma 4.1), unless someone is working on it. Tell me if it's the case, so that we don't waste efforts!</p>",
        "id": 403446399,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700593994
    },
    {
        "content": "<p>Thanks a lot for this detailed list! I had a look at the very first one and would like to claim it (others to follow, potentially). So I just forked the repository and tried to <code>lake build</code>, but there seems to be an issue with <code>Entropy/MeasureCompProb.lean</code>. Probably these lemmas have been included in Mathlib already; deleting them solved the issue.</p>",
        "id": 403446453,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1700594020
    },
    {
        "content": "<p>I'm working on <code>Comparison of Ruzsa distances, I</code>.</p>",
        "id": 403446741,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700594153
    },
    {
        "content": "<p>Jonas, I have no errors in that file on the current version...</p>",
        "id": 403446994,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700594248
    },
    {
        "content": "<p>Did you run <code>lake update</code>(which you generally shouldn't do)?</p>",
        "id": 403447080,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700594284
    },
    {
        "content": "<p>Yes, I did run it and now that you mention it, it makes sense why that could lead to problems. So the safe thing to do is to get the cache using the GUI button \"Fetch Mathlib Build Cache\"?</p>",
        "id": 403447691,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1700594580
    },
    {
        "content": "<p>If you haven't started editing the project then you should use the menu item that allows to download a project. It should then get the cache for you.</p>",
        "id": 403449458,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700595212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403446399\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim the 100% version of PFR, i.e. if <code>d[X, X]=0</code> then <code>X</code> is uniform on a translate of a subgroup (Lemma 4.1), unless someone is working on it. Tell me if it's the case, so that we don't waste efforts!</p>\n</blockquote>\n<p>Ah, good!  I was just in the process of trying to break up this proof into simpler lemmas to encourage someone to work on this component.  I just pushed a proof outline to github but it may take a while for the docs to update; in the meantime the raw LaTeX of the sketch is at <a href=\"https://github.com/teorth/pfr/blob/master/blueprint/src/chapter/100_percent.tex\">https://github.com/teorth/pfr/blob/master/blueprint/src/chapter/100_percent.tex</a> and some stubs for the file are at <a href=\"https://github.com/teorth/pfr/blob/master/PFR/HundredPercent.lean\">https://github.com/teorth/pfr/blob/master/PFR/HundredPercent.lean</a> .  It's not the only way to proceed but I think this way may be slightly simpler than the previous version I proposed.</p>",
        "id": 403452011,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700596000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403446741\">said</a>:</p>\n<blockquote>\n<p>I'm working on <code>Comparison of Ruzsa distances, I</code>.</p>\n</blockquote>\n<p>I finished half of the lemma: <a href=\"https://github.com/teorth/pfr/pull/53\">#53</a>. See the PR for some remarks.</p>",
        "id": 403482818,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700611371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403482818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403446741\">said</a>:</p>\n<blockquote>\n<p>I'm working on <code>Comparison of Ruzsa distances, I</code>.</p>\n</blockquote>\n<p>I finished half of the lemma: <a href=\"https://github.com/teorth/pfr/pull/53\">#53</a>. See the PR for some remarks.</p>\n</blockquote>\n<p>Thanks for this!  I think you're right that the characteristic 2 hypothesis is required, I will update the blueprint to reflect this. [EDIT: This is actually also a typo in the paper, see Lemma 5.2 of <a href=\"https://arxiv.org/pdf/2311.05762.pdf\">https://arxiv.org/pdf/2311.05762.pdf</a> .  I will also inform my coauthors!]</p>\n<p>The fact that the probability spaces are now required to lie in the same universe is a weird little quirk, but I'm sure we can live with it for our application.  Maybe there is an elegant workaround.</p>\n<p>The fact that setting up three independent copies was so difficult is slightly worrying, since for the main argument one needs to set up four independent random variables (all with the same codomain, fortunately).  Can you talk a bit more about exactly what made it painful?  Again there might be workarounds.</p>",
        "id": 403483702,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700611896
    },
    {
        "content": "<p>We can get rid of the universe requirement by lifting all probability spaces to the same universe level using <code>ULift</code>, but that will require proving a bunch of annoying little lemmas about how <code>ULift</code> interacts with <code>iIndepFun</code> (and other things).</p>\n<p>The reason that setting up 3 independent random variables was painful, since it's painful to define dependent functions <code>(i : Fin 3 ) -&gt; X i</code>. You can do it by repeatedly applying <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cases#doc\">docs#Fin.cases</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.cons#doc\">docs#Fin.cons</a> (which are the same definition), but it doesn't look very nice. Also the tactic <code>fin_cases</code> doesn't support constructing data, only proving propositions. You can see a partial attempt that I removed <a href=\"https://github.com/teorth/pfr/pull/53/commits/dbf8e0cae3a0ba450b5e455a61df35e91ed60af0\">in this commit</a><br>\nWhat I did was quickly define an inductive type <code>Triple</code> with 3 elements, so that I can use <code>Triple.rec</code> to define function <code>(i : Triple) -&gt; X i</code> and prove things about them using <code>induction</code>. Since I still want that <code> ![X₁', X₂', X₃']</code> are independent in the conclusion, I defined and used the equivalence <code>Triple ≃ Fin 3</code>.</p>\n<p>Doing it again with 4 will not be bad at all, you can just copy-paste the version for 3 variables and adapt it a bit. It's not the most elegant solution, but it will work.</p>",
        "id": 403485251,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700612734
    },
    {
        "content": "<p>OK.  So I guess for the short-term goal of getting PFR formalized, we will be okay, we can adapt what you did to create a custom version of <code>independent_copies</code> for two, three, and four variables (where in the latter two cases we also assume the codomains are all the same) and this is enough for our application.  (It's also possible to painstakingly concatenate the two-independent-copies lemma together to create a three and four-independent copies lemma with some additional independence lemmas (e.g., if <code>&lt;X,Y&gt;</code> is independent of <code>Z</code>, and <code>X</code> is independent of <code>Y</code>, then <code>X</code>, <code>Y</code>, <code>Z</code> are jointly independent), but this is even less elegant, i think.)</p>\n<p>Going beyond our project, I wonder if there is some way to build notation that can easily construct (using some analogue of matrix vector notation) a dependent type <code>(i : Fin n) -&gt; X i</code> for small values of n without having to go through this sort of workaround.  Hopefully it's not a fundamental limitation of Lean's parser to be unable to handle this level of dependency in the types.</p>\n<p>In any event, the lemma <code>independent_copies3_nondep</code> you already proved will be useful for many of the other Ruzsa calculus bounds that are still outstanding, such as the Ruzsa triangle inequality.</p>",
        "id": 403489445,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700614392
    },
    {
        "content": "<p>Why not use a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector.html#Vector\">vector</a> here?</p>",
        "id": 403496069,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700617092
    },
    {
        "content": "<p>I think the problem is that one can't build a vector <code>![ Ω₁, Ω₂, Ω₃ ]</code> of three different probability spaces <code>Ω₁</code>, <code>Ω₂</code> <code>Ω₃</code>, because they are not necessarily all of the same type.  Nor can one build a vector <code>![ X₁, X₂, X₃ ]</code> of three different random variables <code>X₁: Ω₁ → G</code>, <code>X₂: Ω₂ → G</code> <code>X₃: Ω₃ → G</code>, for the same reason, with the situation even worse if the random variables have different codomains.  The solution should be to build some more flexible vector construct that can iterate to arbitrary length in a way that Lean can parse, but I'm struggling to figure out how to do this.</p>",
        "id": 403497770,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700618015
    },
    {
        "content": "<p>You want a heterogenous list. These are not easy to build and work with.</p>",
        "id": 403499382,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700618862
    },
    {
        "content": "<p>Something like this (very roughly):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">HetList</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">HNil</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">HCons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">αs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">HetList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">::</span> <span class=\"n\">αs</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">HetList</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">Bool</span><span class=\"o\">,</span> <span class=\"n\">Nat</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">HCons</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">HCons</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"n\">HCons</span> <span class=\"mi\">3</span> <span class=\"n\">HNil</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I am certain some list like notation can be created for this.</p>",
        "id": 403500058,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700619174
    },
    {
        "content": "<p>The difficulties start arising when you want to extract elements from this list.</p>",
        "id": 403501461,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700619780
    },
    {
        "content": "<p>I came up with a brief demo to <a href=\"https://live.lean-lang.org/#code=import%20Mathlib%0D%0A%0D%0Ainductive%20NEList%20(%CE%B1%20%3A%20Type%20u)%0D%0A%7C%20NEOne%20(x%20%3A%20%CE%B1)%20%3A%20NEList%20%CE%B1%0D%0A%7C%20NECons%20(x%20%3A%20%CE%B1)%20(xs%20%3A%20NEList%20%CE%B1)%20%3A%20NEList%20%CE%B1%20%0D%0Aopen%20NEList%20%0D%0A%0D%0Adef%20nlength%20(l%20%3A%20NEList%20%CE%B1)%20%3A%20%E2%84%95%20%3A%3D%20%0D%0A%20%20match%20l%20with%0D%0A%20%20%7C%20NEOne%20_%20%3D%3E%201%0D%0A%20%20%7C%20NECons%20_%20xs%20%3D%3E%201%20%2B%20nlength%20(xs)%0D%0A%0D%0A%0D%0Adef%20nhead%20(ls%20%3A%20NEList%20%CE%B1)%20%3A%20%CE%B1%20%20%3A%3D%20%0D%0A%20%20match%20ls%20with%0D%0A%20%20%7C%20NEOne%20x%20%3D%3E%20x%0D%0A%20%20%7C%20NECons%20x%20_%20%3D%3E%20x%0D%0A%0D%0Adef%20NEget%20(l%20%3A%20NEList%20%CE%B1)%20(n%20%3A%20Nat)%20(h%20%3A%20n%20%E2%89%A4%20nlength%20l)%20%3A%20%CE%B1%20%3A%3D%20%0D%0A%20%20match%20l%20with%0D%0A%20%20%7C%20NEOne%20x%20%3D%3E%20x%20%0D%0A%20%20%7C%20NECons%20x%20xs%20%3D%3E%20match%20hn%20%3A%20n%20with%0D%0A%20%20%20%20%20%20%7C%200%20%3D%3E%20x%0D%0A%20%20%20%20%20%20%7C%20n'%20%2B%201%20%3D%3E%0D%0A%20%20%20%20%20%20%20%20%20%20have%20h'%20%3A%20n'%20%E2%89%A4%20nlength%20xs%20%3A%3D%20by%20%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20rw%20%5B%E2%86%90Nat.add_one%5D%20at%20hn%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20unfold%20nlength%20at%20h%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20linarith%20%5Bh%5D%0D%0A%20%20%20%20%20%20%20%20%20%20NEget%20xs%20n'%20h'%0D%0A%0D%0A%0D%0A%0D%0Ainductive%20HetList%20%3A%20NEList%20Type%20%E2%86%92%20Type%201%0D%0A%7C%20HOne%20(x%20%3A%20%CE%B1)%20%3A%20HetList%20(NEOne%20%CE%B1)%0D%0A%7C%20HCons%20%7B%CE%B1%20%3A%20Type%7D%20%3A%20(x%20%3A%20%CE%B1)%20%E2%86%92%20(xs%20%3A%20HetList%20%CE%B1s)%20%E2%86%92%20HetList%20(NECons%20%CE%B1%20%CE%B1s)%0D%0Aopen%20HetList%0D%0A%0D%0Aexample%20%3A%20HetList%20(NECons%20Nat%20(NECons%20Bool%20(NEOne%20Nat)))%20%3A%3D%20HCons%201%20(HCons%20true%20(HOne%203))%0D%0A%0D%0Adef%20hhead%20(h%20%3A%20HetList%20tl)%20%3A%20nhead%20tl%3A%3D%20%0D%0A%20%20match%20h%20with%20%0D%0A%20%20%7C%20HOne%20x%20%3D%3E%20x%0D%0A%20%20%7C%20HCons%20x%20xs%20%3D%3E%20x%0D%0A%0D%0A%0D%0Adef%20hLength%20(l%20%3A%20HetList%20%CE%B1)%20%3A%20%E2%84%95%20%3A%3D%20%0D%0A%20%20match%20l%20with%0D%0A%20%20%7C%20HOne%20_%20%3D%3E%201%0D%0A%20%20%7C%20HCons%20_%20xs%20%3D%3E%201%20%2B%20hLength%20xs%0D%0A%0D%0A%0D%0A--%20incomplete%0D%0Adef%20hget%20%7Btl%20%3A%20NEList%20Type%7D%20(v%20%3A%20HetList%20tl)%20(i%20%3A%20%E2%84%95)%20(h%20%3A%20i%20%E2%89%A4%20nlength%20tl)%20%20%3A%20(NEget%20tl%20i%20(by%20exact%20h))%20%3A%3D%20%0D%0A%20%20match%20hv%20%3A%20v%20with%0D%0A%20%20%7C%20HOne%20x%20%3D%3E%20x%20--%20dependent%20type%20hell%0D%0A%20%20%7C%20HCons%20x%20xs%20%3D%3E%20%0D%0A%20%20%20%20%20%20match%20hi%20%3A%20i%20with%0D%0A%20%20%20%20%20%20%7C%200%20%3D%3E%20x%0D%0A%20%20%20%20%20%20%7C%20i'%20%2B%201%20%3D%3E%20%0D%0A%20%20%20%20%20%20%20%20%20%20have%20h'%20%3A%3D%20by%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20sorry%0D%0A%20%20%20%20%20%20%20%20%20%20hget%20v%20(i-1)%20h'%0D%0A--%20see%20the%20difficulty%20here%0D%0A%0D%0A%0D%0Adef%20HetVector%20n%20(tl%20%3A%20NEList%20Type)%20%3A%3D%20%7Bx%20%3A%20HetList%20tl%20%2F%2F%20hLength%20x%20%3D%20n%7D%0D%0A%0D%0\">show where the difficulties arise</a>)</p>",
        "id": 403507300,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700622332
    },
    {
        "content": "<p>Your demo isn't loading for me for some reason... is the code long, can you just post it here?</p>",
        "id": 403507621,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700622487
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">NEList</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">NEOne</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">NECons</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span>\n<span class=\"kn\">open</span> <span class=\"n\">NEList</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nlength</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NEOne</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NECons</span> <span class=\"n\">_</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">nlength</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">nhead</span> <span class=\"o\">(</span><span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>  <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">ls</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NEOne</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NECons</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NEget</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">nlength</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NEOne</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">NECons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n      <span class=\"bp\">|</span> <span class=\"n\">n'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">n'</span> <span class=\"bp\">≤</span> <span class=\"n\">nlength</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Nat.add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hn</span>\n            <span class=\"n\">unfold</span> <span class=\"n\">nlength</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n            <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n          <span class=\"n\">NEget</span> <span class=\"n\">xs</span> <span class=\"n\">n'</span> <span class=\"n\">h'</span>\n\n\n\n<span class=\"kd\">inductive</span> <span class=\"n\">HetList</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">HOne</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"o\">(</span><span class=\"n\">NEOne</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">HCons</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">αs</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">HetList</span> <span class=\"o\">(</span><span class=\"n\">NECons</span> <span class=\"n\">α</span> <span class=\"n\">αs</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span> <span class=\"n\">HetList</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"o\">(</span><span class=\"n\">NECons</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">NECons</span> <span class=\"n\">Bool</span> <span class=\"o\">(</span><span class=\"n\">NEOne</span> <span class=\"n\">Nat</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"n\">HCons</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">HCons</span> <span class=\"n\">true</span> <span class=\"o\">(</span><span class=\"n\">HOne</span> <span class=\"mi\">3</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hhead</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nhead</span> <span class=\"n\">tl</span><span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HOne</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HCons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">hLength</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HOne</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HCons</span> <span class=\"n\">_</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">hLength</span> <span class=\"n\">xs</span>\n\n\n<span class=\"c1\">-- incomplete</span>\n<span class=\"kd\">def</span> <span class=\"n\">hget</span> <span class=\"o\">{</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">nlength</span> <span class=\"n\">tl</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">NEget</span> <span class=\"n\">tl</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HOne</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"c1\">-- dependent type hell</span>\n  <span class=\"bp\">|</span> <span class=\"n\">HCons</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n      <span class=\"bp\">|</span> <span class=\"n\">i'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n            <span class=\"gr\">sorry</span>\n          <span class=\"n\">hget</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h'</span>\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">HetVector</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">NEList</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">HetList</span> <span class=\"n\">tl</span> <span class=\"bp\">//</span> <span class=\"n\">hLength</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 403507720,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700622550
    },
    {
        "content": "<p>Is there a way to make the message a collapsible code block?</p>",
        "id": 403507745,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700622575
    },
    {
        "content": "<p>use spoilers... as in</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lean</span> <span class=\"n\">code.</span>\n</code></pre></div>\n</div></div>",
        "id": 403507841,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700622608
    },
    {
        "content": "<p>Click the three dots and \"view source\" to see how I made that.</p>",
        "id": 403507881,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700622632
    },
    {
        "content": "<p>done. The key thing I wanted to show is the dependent type hell in <code>hget</code>. I am guessing there is some (congr based?) fix, which isn't easy on the eye.</p>",
        "id": 403508134,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700622759
    },
    {
        "content": "<p>I filled in <code>condDist_le</code> / the first variant of Lemma 3.22; see <a href=\"https://github.com/teorth/pfr/pull/54\">#54</a>. I can try doing the other variant too tomorrow, but don't yet quite see how it follows from the first.</p>",
        "id": 403511285,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1700624296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"646363\">Ben Eltschig</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403511285\">said</a>:</p>\n<blockquote>\n<p>I filled in <code>condDist_le</code> / the first variant of Lemma 3.22; see <a href=\"https://github.com/teorth/pfr/pull/54\">#54</a>. I can try doing the other variant too tomorrow, but don't yet quite see how it follows from the first.</p>\n</blockquote>\n<p>Well there are basically two options here; one is to introduce some constant random variable like 0 and show that $latex d[X|0;Y|W] = d[X;Y|W]$ and $I[X:0]=0$; or else just redo the whole proof deleting various terms.  The latter may end up being the path of least resistance (though a lemma that constant random variables have zero entropy and zero mutual information is potentially a useful @simp lemma or something if the entropy stuff ends up being repurposed for mathlib).</p>\n<p>For the identDistrib stuff, shouldn't both lemmas follow rather quickly from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IdentDistrib.comp%3F#doc\">docs#ProbabilityTheory.IdentDistrib.comp?</a></p>",
        "id": 403513264,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700625470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I'm only loosely following this thread, but rather than <code>Triple</code>, could you define a custom induction lemma for <code>Fin 3</code>?</p>\n<p>Not sure if it's useful at all, but I was messing around with defining a version of <code>Fin</code> that still lets you sort of automate proofs using the built-in induction principle.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Fin'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Empty</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Unit</span> <span class=\"bp\">⊕</span> <span class=\"n\">Fin'</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">k</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin'</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">()</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Fin'</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"mi\">4</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin'</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n  <span class=\"n\">repeat</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n    <span class=\"n\">try</span> <span class=\"n\">obtain</span> <span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">i</span>\n</code></pre></div>\n</div></div>",
        "id": 403514911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1700626314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> You could alternatively define <code>Fin'</code> as an inductive family as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Fin'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Fin'</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Fin'</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Fin'</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which would allow you to easily use induction as well.</p>",
        "id": 403518922,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700628879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403483702\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403482818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403446741\">said</a>:</p>\n<blockquote>\n<p>I'm working on <code>Comparison of Ruzsa distances, I</code>.</p>\n</blockquote>\n<p>I finished half of the lemma: <a href=\"https://github.com/teorth/pfr/pull/53\">#53</a>. See the PR for some remarks.</p>\n</blockquote>\n<p>Thanks for this!  I think you're right that the characteristic 2 hypothesis is required, I will update the blueprint to reflect this. [EDIT: This is actually also a typo in the paper, see Lemma 5.2 of <a href=\"https://arxiv.org/pdf/2311.05762.pdf\">https://arxiv.org/pdf/2311.05762.pdf</a> .  I will also inform my coauthors!]</p>\n<p>The fact that the probability spaces are now required to lie in the same universe is a weird little quirk, but I'm sure we can live with it for our application.  Maybe there is an elegant workaround.</p>\n<p>The fact that setting up three independent copies was so difficult is slightly worrying, since for the main argument one needs to set up four independent random variables (all with the same codomain, fortunately).  Can you talk a bit more about exactly what made it painful?  Again there might be workarounds.</p>\n</blockquote>\n<p>A bit late to the conversation, but I'd been having some trouble with setting up the same type of thing in the proof I'm currently working on, and also came to the conclusion that a 3 variable version of <code>independent_copies</code> was probably the easiest way to go</p>",
        "id": 403537629,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700639331
    },
    {
        "content": "<p>The current version I have of this proof uses the general version of <code>independent_copies</code>, but is rather painful and <code>sorry</code> I haven't fully figured out yet (something to do with Lean not parsing an instance correctly)</p>",
        "id": 403538005,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700639518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403538005\">said</a>:</p>\n<blockquote>\n<p>The current version I have of this proof uses the general version of <code>independent_copies</code>, but is rather painful and <code>sorry</code> I haven't fully figured out yet (something to do with Lean not parsing an instance correctly)</p>\n</blockquote>\n<p>Would you be able to use the new lemma <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.independent_copies3_nondep#doc\">pfr#ProbabilityTheory.independent_copies3_nondep</a> that Floris proved as a substitute?</p>",
        "id": 403539812,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700640441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403539812\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403538005\">said</a>:</p>\n<blockquote>\n<p>The current version I have of this proof uses the general version of <code>independent_copies</code>, but is rather painful and <code>sorry</code> I haven't fully figured out yet (something to do with Lean not parsing an instance correctly)</p>\n</blockquote>\n<p>Would you be able to use the new lemma <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.independent_copies3_nondep#doc\">pfr#ProbabilityTheory.independent_copies3_nondep</a> that Floris proved as a substitute?</p>\n</blockquote>\n<p>Sure! I tried that out at some point and I think I still have a copy of that code locally.</p>",
        "id": 403545287,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700642719
    },
    {
        "content": "<p>This makes it a lot easier!</p>",
        "id": 403545329,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700642743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> : isn't that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fin/Fin2.html#Fin2\">Fin2</a>?</p>",
        "id": 403563487,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1700648867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403514911\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> I'm only loosely following this thread, but rather than <code>Triple</code>, could you define a custom induction lemma for <code>Fin 3</code>?</p>\n<p>Not sure if it's useful at all, but I was messing around with defining a version of <code>Fin</code> that still lets you sort of automate proofs using the built-in induction principle.</p>\n</blockquote>\n<p>Actually, I tried again, and working directly with <code>Fin 3</code> also works. It's a little more verbose to construct a dependent function by giving the 3 function values, but it works fine.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> This is neither `Fin.elim0` nor `Fin.elim0'` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Fin.rec0</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">absurd</span> <span class=\"n\">i.2</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">independent_copies3_nondep</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">mS</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"bp\">Ω₁</span> <span class=\"bp\">Ω₂</span> <span class=\"bp\">Ω₃</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₁</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₂</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₃</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₃</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">X₁</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₁</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₂</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X₃</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₃</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₃</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₃</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">μ₁</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ₂</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ₃</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₃</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">mA</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μA</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">X₁'</span> <span class=\"n\">X₂'</span> <span class=\"n\">X₃'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n    <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">μA</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"n\">iIndepFun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">mS</span><span class=\"o\">)</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">X₁'</span><span class=\"o\">,</span> <span class=\"n\">X₂'</span><span class=\"o\">,</span> <span class=\"n\">X₃'</span><span class=\"o\">]</span> <span class=\"n\">μA</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">Measurable</span> <span class=\"n\">X₁'</span> <span class=\"bp\">∧</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₂'</span> <span class=\"bp\">∧</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₃'</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₁'</span> <span class=\"n\">X₁</span> <span class=\"n\">μA</span> <span class=\"n\">μ₁</span> <span class=\"bp\">∧</span> <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₂'</span> <span class=\"n\">X₂</span> <span class=\"n\">μA</span> <span class=\"n\">μ₂</span> <span class=\"bp\">∧</span> <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₃'</span> <span class=\"n\">X₃</span> <span class=\"n\">μA</span> <span class=\"n\">μ₃</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">Ω₁</span><span class=\"o\">,</span> <span class=\"bp\">Ω₂</span><span class=\"o\">,</span> <span class=\"bp\">Ω₃</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MeasurableSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Fin.cons</span> <span class=\"n\">m</span><span class=\"bp\">Ω₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">m</span><span class=\"bp\">Ω₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">m</span><span class=\"bp\">Ω₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Ω</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">X₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">X₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">X₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"k\">have</span> <span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">Measurable</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">mS</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₃</span> <span class=\"n\">Fin.rec0</span>\n    <span class=\"c1\">-- by intro i; fin_cases i &lt;;&gt; (dsimp; assumption)</span>\n  <span class=\"k\">let</span> <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">@</span><span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">μ₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">μ₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cons</span> <span class=\"n\">μ₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">mA</span><span class=\"o\">,</span> <span class=\"n\">μA</span><span class=\"o\">,</span> <span class=\"n\">X'</span><span class=\"o\">,</span> <span class=\"n\">hμ</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hX'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">independent_copies'</span> <span class=\"o\">(</span><span class=\"n\">mS</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">mS</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">Ω</span> <span class=\"o\">:=</span> <span class=\"n\">m</span><span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">hX</span> <span class=\"n\">μ</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">mA</span><span class=\"o\">,</span> <span class=\"n\">μA</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">hμ</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hi</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n</div></div>",
        "id": 403569237,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700650896
    },
    {
        "content": "<p>Proving the version with three different codomains for the random variables is not harder (however, stating it <em>is</em> harder)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> This is neither `Fin.elim0` nor `Fin.elim0'` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Fin.rec0</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">absurd</span> <span class=\"n\">i.2</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A version with exactly 3 random variables that have the same codomain.</span>\n<span class=\"sd\">It's unfortunately incredibly painful to prove this from the general case. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">independent_copies3</span> <span class=\"o\">{</span><span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">S₃</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">mS₁</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">S₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mS₂</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">S₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mS₃</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">S₃</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"bp\">Ω₁</span> <span class=\"bp\">Ω₂</span> <span class=\"bp\">Ω₃</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₁</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₂</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"bp\">Ω₃</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω₃</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">X₁</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₁</span> <span class=\"bp\">→</span> <span class=\"n\">S₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X₂</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₂</span> <span class=\"bp\">→</span> <span class=\"n\">S₂</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X₃</span> <span class=\"o\">:</span> <span class=\"bp\">Ω₃</span> <span class=\"bp\">→</span> <span class=\"n\">S₃</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hX₁</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₂</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX₃</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₃</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">μ₁</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ₂</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ₃</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω₃</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">S₁</span><span class=\"o\">,</span> <span class=\"n\">S₂</span><span class=\"o\">,</span> <span class=\"n\">S₃</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">mS</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MeasurableSpace</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n      <span class=\"n\">Fin.cases</span> <span class=\"n\">mS₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">mS₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">mS₃</span> <span class=\"n\">Fin.rec0</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">mA</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μA</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">X₁'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X₂'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">S₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X₃'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">S₃</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₁'</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₂'</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₃'</span> <span class=\"n\">Fin.rec0</span>\n    <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">μA</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">iIndepFun</span> <span class=\"n\">mS</span> <span class=\"n\">X'</span> <span class=\"n\">μA</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">Measurable</span> <span class=\"n\">X₁'</span> <span class=\"bp\">∧</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₂'</span> <span class=\"bp\">∧</span> <span class=\"n\">Measurable</span> <span class=\"n\">X₃'</span> <span class=\"bp\">∧</span>\n      <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₁'</span> <span class=\"n\">X₁</span> <span class=\"n\">μA</span> <span class=\"n\">μ₁</span> <span class=\"bp\">∧</span> <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₂'</span> <span class=\"n\">X₂</span> <span class=\"n\">μA</span> <span class=\"n\">μ₂</span> <span class=\"bp\">∧</span> <span class=\"n\">IdentDistrib</span> <span class=\"n\">X₃'</span> <span class=\"n\">X₃</span> <span class=\"n\">μA</span> <span class=\"n\">μ₃</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">S</span> <span class=\"n\">mS</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">Ω₁</span><span class=\"o\">,</span> <span class=\"bp\">Ω₂</span><span class=\"o\">,</span> <span class=\"bp\">Ω₃</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">MeasurableSpace</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Fin.cases</span> <span class=\"n\">m</span><span class=\"bp\">Ω₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">m</span><span class=\"bp\">Ω₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">m</span><span class=\"bp\">Ω₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"k\">let</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Ω</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">X₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"k\">have</span> <span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">),</span> <span class=\"n\">Measurable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">hX₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"k\">let</span> <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"bp\">Ω</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">Fin.cases</span> <span class=\"n\">μ₁</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">μ₂</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Fin.cases</span> <span class=\"n\">μ₃</span> <span class=\"n\">Fin.rec0</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">mA</span><span class=\"o\">,</span> <span class=\"n\">μA</span><span class=\"o\">,</span> <span class=\"n\">X'</span><span class=\"o\">,</span> <span class=\"n\">hμ</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">hX'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">independent_copies'</span> <span class=\"n\">X</span> <span class=\"n\">hX</span> <span class=\"n\">μ</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">mA</span><span class=\"o\">,</span> <span class=\"n\">μA</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">X'</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">hμ</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX'</span> <span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hi</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">fin_cases</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n</div></div>\n<p>However, this version is not \"better\", since it's still painful to get the 'non-dependent' version from this (where the codomain is <code>S</code> for each random variable). The reason is that the latter is stated using the type family <code>(fun _ : Fin 3 ↦ S)</code> with measurable space structure <code>(fun _ : Fin 3 ↦ mS)</code>, and the former is stated using the type family <code>![S, S, S]</code> with measurable space structure <code>Fin.cases mS &lt;| Fin.cases mS &lt;| Fin.cases mS Fin.rec0</code>. Those are equal (or heterogeneously equal in the second case), but not definitionally so, which makes it easier to just prove the non-depedent version directly.</p>",
        "id": 403572711,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700652286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403446399\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim the 100% version of PFR, i.e. if <code>d[X, X]=0</code> then <code>X</code> is uniform on a translate of a subgroup (Lemma 4.1), unless someone is working on it. Tell me if it's the case, so that we don't waste efforts!</p>\n</blockquote>\n<p>Completed at <a href=\"https://github.com/teorth/pfr/pull/56\">https://github.com/teorth/pfr/pull/56</a></p>",
        "id": 403605743,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700663873
    },
    {
        "content": "<p>I <a href=\"https://github.com/teorth/pfr/pull/58\">finished Lemma 3.23</a></p>",
        "id": 403622521,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700668995
    },
    {
        "content": "<p>I just finished proving the improved triangle inequality for the kernel version of the Ruzsa distance, because I thought we needed it for the conditional distance, but now I don't see it in the blueprint. I will make a pr with this and the definitions of the conditional distances in a few hours (I am now boarding a plane).</p>",
        "id": 403630386,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700671707
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 403635136,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1700673451
    },
    {
        "content": "<p>Is anyone currently working on <em>Comparison of Ruzsa distances, II</em> (Lemma 3.24)? If not I'd like to claim it.</p>",
        "id": 403637043,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700674239
    },
    {
        "content": "<p>I've done the final argument of <a href=\"https://github.com/teorth/pfr/pull/61\">the entropy version of PFR</a>. </p>\n<p>Nothing terribly exciting, as expected, but I did discover one very minor typo in the original paper.</p>",
        "id": 403641998,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1700676337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403637043\">said</a>:</p>\n<blockquote>\n<p>Is anyone currently working on <em>Comparison of Ruzsa distances, II</em> (Lemma 3.24)? If not I'd like to claim it.</p>\n</blockquote>\n<p>I'm not aware of any competing claims, so I've marked your claim on my previous post tracking these things.  (I will probably have to send out an updated version soon, as most of the ones on this list are now already done.)</p>",
        "id": 403642317,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700676473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403642317\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403637043\">said</a>:</p>\n<blockquote>\n<p>Is anyone currently working on <em>Comparison of Ruzsa distances, II</em> (Lemma 3.24)? If not I'd like to claim it.</p>\n</blockquote>\n<p>I'm not aware of any competing claims, so I've marked your claim on my previous post tracking these things.  (I will probably have to send out an updated version soon, as most of the ones on this list are now already done.)</p>\n</blockquote>\n<p>Actually... in the last few minutes I got a PR from <span class=\"user-mention\" data-user-id=\"398581\">@Mantas Baksys</span> that establishes this lemma.  Sorry for the duplication of effort!</p>",
        "id": 403645866,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700678017
    },
    {
        "content": "<p>Hi everyone! I would also like to join this amazing formalization project and as my first contribution, I've proved <a href=\"https://github.com/teorth/pfr/pull/62\">Lemma 3.24</a>. I didn't see <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span>'s message claiming to prove it in time and already messaged him to apologise (thankfully Paul hadn't started working on it).</p>",
        "id": 403645916,
        "sender_full_name": "Mantas Baksys",
        "timestamp": 1700678038
    },
    {
        "content": "<p>No worries at all! <br>\n<span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Are there any similar lemmas I could work on that haven't been claimed yet?</p>",
        "id": 403646338,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700678214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403646338\">said</a>:</p>\n<blockquote>\n<p>No worries at all! <br>\n<span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> Are there any similar lemmas I could work on that haven't been claimed yet?</p>\n</blockquote>\n<p>I'm in a meeting right now, but I'll make a new post in an hour or so with a new set of outstanding lemmas to prove.</p>",
        "id": 403650002,
        "sender_full_name": "Terence Tao",
        "timestamp": 1700679616
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> aren't you supposed to be formalising stacks as part of your computing project? ;-)</p>",
        "id": 403657164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700683019
    },
    {
        "content": "<p>Advisors should be forbidden from reading Zulip <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 403657469,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1700683199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403657164\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> aren't you supposed to be formalising stacks as part of your computing project? ;-)</p>\n</blockquote>\n<p>That is a good point - hopefully we should be done by tomorrow-ish! ;)</p>",
        "id": 403658144,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1700683446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Update.20thread!/near/403630386\">said</a>:</p>\n<blockquote>\n<p>I just finished proving the improved triangle inequality for the kernel version of the Ruzsa distance, because I thought we needed it for the conditional distance, but now I don't see it in the blueprint. I will make a pr with this and the definitions of the conditional distances in a few hours (I am now boarding a plane).</p>\n</blockquote>\n<p>PR: <a href=\"https://github.com/teorth/pfr/pull/63\">https://github.com/teorth/pfr/pull/63</a></p>",
        "id": 403675371,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700692716
    }
]