[
    {
        "content": "<p>For proving <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=sum_dist_diff_le#doc\">pfr#sum_dist_diff_le</a> I need to show that I can deduce</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">iIndepFun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">hG</span><span class=\"o\">)</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">X₁</span><span class=\"o\">,</span> <span class=\"n\">X₂</span><span class=\"o\">,</span> <span class=\"n\">X₁'</span> <span class=\"bp\">+</span> <span class=\"n\">X₂'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>from <code>iIndepFun (fun x ↦ hG) ![X₁, X₂, X₁', X₂']</code>. Is there already a lemma which can do this? I've not found one so I started trying to state the result, but I find it hard to come up with an idiomatic way to do this.</p>",
        "id": 404641640,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701180069
    },
    {
        "content": "<p><del> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IndepFun.comp#doc\">docs#ProbabilityTheory.IndepFun.comp</a> should be what you are looking for.</del></p>",
        "id": 404642685,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1701180355
    },
    {
        "content": "<p>Oh sorry no, you ask about <code>iIndepFun</code></p>",
        "id": 404642795,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1701180385
    },
    {
        "content": "<p><a href=\"https://teorth.github.io/pfr/docs/PFR/ForMathlib/Independence.html#ProbabilityTheory.iIndepFun.comp\">https://teorth.github.io/pfr/docs/PFR/ForMathlib/Independence.html#ProbabilityTheory.iIndepFun.comp</a> and <a href=\"https://teorth.github.io/pfr/docs/PFR/ForMathlib/Independence.html#ProbabilityTheory.iIndepFun.reindex\">https://teorth.github.io/pfr/docs/PFR/ForMathlib/Independence.html#ProbabilityTheory.iIndepFun.reindex</a> are very close, but won't get you quite there, I think. The proofs should transfer though.</p>",
        "id": 404643187,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701180529
    },
    {
        "content": "<p>You probably want to prove a <code>iIndepFun.prod</code> that pairs up two variables, and then you can use <code>comp</code> to add them.</p>",
        "id": 404643594,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701180661
    },
    {
        "content": "<p>Hmm.  Is it essential that you need joint independence of all three variables?  Pairwise independence can be obtained from existing tools such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.iIndepFun.indepFun_prod#doc\">docs#ProbabilityTheory.iIndepFun.indepFun_prod</a> or <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.iIndepFun.indepFun_prod_prod#doc\">pfr#ProbabilityTheory.iIndepFun.indepFun_prod_prod</a> , but right now there aren't so many tools to establish joint independence.  Ideally, we should have a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.iIndepFun.indepFun_finset#doc\">docs#ProbabilityTheory.iIndepFun.indepFun_finset</a> that allows for more than two disjoint sets (and then one can use <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.iIndepFun.comp#doc\">pfr#ProbabilityTheory.iIndepFun.comp</a> to conclude).  If joint independence is really what you need, one option is to write up such a variant and add it back to the task list, and establish what you need from that variant; it could be a useful addition to the independence portion of MathLib.</p>",
        "id": 404672800,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701189137
    },
    {
        "content": "<p>I'm not sure how to best do this without getting type theory problems. I started by writing a function that changes the value of <code>f i</code> to <code>(f i, f j)</code>, but of course, that also changes the type of <code>f</code>. So I wrote a function that calculates what the new type should be as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Change α' such that α' i becomes α' i × α' j  -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pairIndicesOfSpaces</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">α'</span> <span class=\"n\">k</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">α'</span> <span class=\"n\">i</span> <span class=\"bp\">×</span> <span class=\"n\">α'</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Change f such that f i becomes (f i × f j) -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">pairIndices</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">pairIndicesOfSpaces</span> <span class=\"n\">α</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">k</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But this doesn't type check and I'm not convinced it can be made to work. What would be the right setup for defining <code>iIndepFun.prod</code> as <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> proposes?</p>\n<p>The correct function would of course also have to <em>delete</em> the index j but I think this should be the easier part.</p>",
        "id": 404673762,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701189418
    },
    {
        "content": "<p>Joint independence is necessary for using <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=condDist_diff_ofsum_le#doc\">pfr#condDist_diff_ofsum_le</a> <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span>. Unless one can change the hypotheses of that lemma to pairwise independence I don't see a way around the issue.</p>",
        "id": 404674387,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701189595
    },
    {
        "content": "<p>And yes, having <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.iIndepFun.indepFun_finset#doc\">docs#ProbabilityTheory.iIndepFun.indepFun_finset</a> for multiple disjoint sets would help. I'll try to state this now.</p>",
        "id": 404675302,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701189867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"605003\">Jonas Bayer</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Independence.20of.20A.2C.20B.2C.20C.20implies.20independence.20of.20A.2C.20B.2BC/near/404675302\">said</a>:</p>\n<blockquote>\n<p>And yes, having <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.iIndepFun.indepFun_finset#doc\">docs#ProbabilityTheory.iIndepFun.indepFun_finset</a> for multiple disjoint sets would help. I'll try to state this now.</p>\n</blockquote>\n<p>By the way, there is a hacky alternate way to proceed, which is to establish a lemma that if <code>(A, B)</code> is independent of <code>C</code> and <code>A</code> is independent of <code>B</code>, then <code>A</code>, <code>B</code>, <code>C</code> are jointly independent; this is not too difficult from <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map%27#doc\">pfr#ProbabilityTheory.indepFun_iff_map_prod_eq_prod_map_map'</a> and <a href=\"https://teorth.github.io/pfr/docs/find/?pattern=ProbabilityTheory.iIndepFun_iff_map_prod_eq_prod_map_map#doc\">pfr#ProbabilityTheory.iIndepFun_iff_map_prod_eq_prod_map_map</a> and would allow one to leverage the pairwise independence lemmas to get back to joint independence.  But I think having a <code>ProbabilityTheory.iIndepFun.iIndepFun_finset</code> lemma for Mathlib is the better long-term solution, even if it would be a bit more work (hopefully someone will volunteer to fill it in though).</p>",
        "id": 404676274,
        "sender_full_name": "Terence Tao",
        "timestamp": 1701190188
    },
    {
        "content": "<p>That's a good point. I'll remember the hack but try to do it in the more general way for now.</p>",
        "id": 404679834,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701191259
    },
    {
        "content": "<p>When stating <code>iIndepFun.iIndepFun_finset</code> one gets the same problem that I had above. Initially, one has a function f such that the <code>f i</code> are jointly independent and the values of <code>f i</code> are in <code>α i</code> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">i \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>. One then chooses disjoint sets <code>T_j</code>  where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>∈</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">j \\in J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> and wants to consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><msub><mi>T</mi><mi>j</mi></msub></mrow></msub><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f&#x27; (j) := \\prod_{i \\in T_j} f(T_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.247em;vertical-align:-0.497em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.497em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> where the product is to be understood as forming a tuple. However, it is not clear to me how the type of <code>f'</code> could be written in Lean. </p>\n<p>A solution would be to consider the case where all the <code>α i</code> are the same type <code>β</code>. Then the type of <code>f' j</code> could simply be <code>List β</code>. This would be sufficient for the lemma that I need to prove, but still wouldn't solve the problem in general.</p>",
        "id": 404681876,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701192056
    },
    {
        "content": "<p>One way to write the general lemma is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">Pairwise</span> <span class=\"o\">(</span><span class=\"n\">Disjoint</span> <span class=\"n\">on</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iIndepFun.prod'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">iIndepFun</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"k\">let</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span>\n    <span class=\"n\">iIndepFun</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">↦</span> <span class=\"n\">MeasurableSpace.pi</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(this compiles in the <code>Independence</code> file)</p>",
        "id": 404691783,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701195872
    },
    {
        "content": "<p>It will still take a bit of work to instantiate this general version to your application.</p>",
        "id": 404691844,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701195905
    },
    {
        "content": "<p>Thanks a lot for writing this lemma! I tried to instantiate it but it is already difficult to satisfy the MeasurableSpace condition. The way you wrote the lemma it becomes necessary to prove<code>MeasurableSpace ((a : { x // x ∈ S k }) → α ↑a)</code> for any <code>k : ι'</code>. But I only have that the <code>α i</code> are measurable spaces, can one even prove the necessary hypothesis from this? What is the right way to think about the type <code>(a : { x // x ∈ S k }) → α ↑a</code>?</p>",
        "id": 404909623,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701276761
    },
    {
        "content": "<p>Seems like the product of the measurable spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\alpha_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> over all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> in the finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 404910750,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701277097
    },
    {
        "content": "<p>And I certainly think that we should have much better notation for that. Because I agree that in its current form it is quite hard to parse.</p>",
        "id": 404910941,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701277158
    },
    {
        "content": "<p>Thanks, this is very helpful!</p>",
        "id": 404913859,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1701277972
    }
]