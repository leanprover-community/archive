[
    {
        "content": "<p>The second phase of the PFR project is well and truly underway!  Previous outstanding tasks thread can be found <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/PFR.20extensions\">here</a>.</p>\n<p>A. Existing claims</p>\n<ol>\n<li><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> is gradually porting various stable PFR files over to Mathlib.  Expect <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Mathlib.20bump\">frequent Mathlib bumps</a> during this process.  It should be possible to work on extensions concurrently with this porting.</li>\n<li><span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> has formalized <a href=\"https://teorth.github.io/pfr/blueprint/sect0009.html#energy-def\">Additive energy</a> and <a href=\"https://teorth.github.io/pfr/blueprint/sect0009.html#cs-bound\">Cauchy-Schwarz bound</a>, and has completed the proof of the latter.</li>\n<li><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> claim the proof of <a href=\"https://teorth.github.io/pfr/blueprint/sect0009.html#bsg\">Balog-Szemeredi-Gowers</a></li>\n<li><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> has established <a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#pfr'\">Improved PFR</a>.</li>\n</ol>\n<p>B. Outstanding proof formalization tasks:</p>\n<ol>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0009.html#approx-hom-pfr\">Approximate homomorphism form of PFR</a>.  This is a variant of the already-proven <a href=\"https://teorth.github.io/pfr/blueprint/sect0008.html#hom-pfr\">Homomorphism form of PFR</a> and should be relatively straightforward to prove by an adaptation of that proof.   <strong>Claimed by <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#construct-good-prelim'\">Constructing good variables, I'</a> This should be a slight modification of <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#construct-good-prelim\">Constructing good variables, I</a>.   <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#construct-good'\">Constructing good variables, II'</a> This should be a routine variant of <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#construct-good\">Constructing good variables, II</a>. Awaits C.1. <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#averaged-construct-good\">Constructing good variables, III'</a> Should follow from preceding result and the arguments used to prove <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#de-prop\">tau decrement</a>. Awaits C.1, C.2. <strong>Establishedby <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#gen-ineq\">General inequality</a> Mostly taking linear combinations of other inequalities.  There is one tricky new thing, which is to show that a certain conditioned random variable has identical distribution to the sum of two other conditioned random variables.  <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#dist-diff-bound\">Bound on distance differences</a>  Mostly taking linear combinations of other inequalities.  A slight refactoring of <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#second-estimate\">Second estimate</a> will be needed.  Awaits C.3. <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#de-prop'\">Improved tau decrement</a> A straightforward variant of (the second half of the proof of) <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#de-prop\">tau decrement</a>.  Awaits C.2, C.3. <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#entropy-pfr'\">Entropy form of PFR'</a> Straightforward modification of <a href=\"https://teorth.github.io/pfr/blueprint/sect0006.html#entropy-pfr\">Entropy form of PFR</a>.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#torsion-free-doubling\">Torsion-free doubling</a>  This is similar to many other entropy inequalities already in PFR, though somewhat lengthy.  Awaits C.4.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#torsion-dist-shrinking\">Torsion distance shrinking</a> Easy corollary of B.9. Awaits C.4, C.5.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#app-ent-pfr\">Apply entropic PFR</a> Easy application of existing PFR lemmas. Awaits C.6.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#pfr-projection\">PFR projection</a> One tricky thing is to locate a maximal subgroup H obeying a certain property, and show that the quotient is still an elementary abelian 2-group. Awaits C.6, C.7.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#single-fibres\">Single fibres</a> Involves some manipulations of finite sums, but nothing too intimidating I think. Awaits C.8.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-asymm\">Asymmetric weak PFR</a> Involves a strong induction, but should be doable. Awaits C.7, C.8, C.9, C.10.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-symm\">Symmetric weak PFR</a> Easy corollary of B.14. Awaits C.9, C.10, C.11.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-int\">Weak PFR over integers</a> Easy corollary of B.15. Awaits C.11, C.12.</li>\n<li>Refactor existing entropy / Ruzsa distance machinery to handle cases when <code>G</code> is not a <code>Fintype</code>, but instead <code>X</code> is assumed to be of <code>FiniteRange</code>. <strong>Established by <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> </strong></li>\n</ol>\n<p>C. Outstanding documentation/blueprint/examples/statement formalization tasks:</p>\n<ol>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#construct-good'\">Constructing good variables, II'</a> Here the sum involves 12 terms, one may need to think about the cleanest way to express this formula. <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#averaged-construct-good\">Constructing good variables, III'</a> Similar issue to preceding. <strong>Established by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0010.html#dist-diff-bound\">Bound on distance differences</a> Involves the sum of 12 terms appearing in C.3, but should otherwise be simple to state. <strong>Claimed by <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#torsion-free-doubling\">Torsion-free doubling</a>  This is similar to many other entropy inequalities already in PFR and should be easy to formalize.  <strong>Claimed by <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#torsion-dist-shrinking\">Torsion distance shrinking</a> Also should be easy to formalize.  <strong>Claimed by <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#app-ent-pfr\">Apply entropic PFR</a> Also straightforward to formalize. </li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#pfr-projection\">PFR projection</a> Also straightforward. </li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#single-fibres\">Single fibres</a> A bit messy, but straightforward. </li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#dimension-def\">Dimension</a> Should be definable using linear algebra methods in Mathlib. <strong>Established by <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> </strong></li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-asymm\">Asymmetric weak PFR</a> Straightforward to formalize. Awaits C.9.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-symm\">Symmetric weak PFR</a> Also straightforward. Awaits C.9.</li>\n<li><a href=\"https://teorth.github.io/pfr/blueprint/sect0011.html#weak-pfr-int\">Weak PFR over integers</a> Also straightforward. Awaits C.9.</li>\n<li>Introduce a notion of <code>FiniteRange</code> and state some of its basic properties. <strong>Established by <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> </strong></li>\n</ol>\n<p>D. Outstanding administrative tasks:</p>\n<ol>\n<li>Create a new Lean file for Weak PFR over Z and put in stubs for all the new definitions and lemmas. <strong>Established by <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> </strong></li>\n<li>Add example showcasing weak PFR to examples.lean.  Awaits C.12.</li>\n<li>Update <code>HomPFR</code>, <code>ApproxHomPFR</code>, <code>PFR_conjecture'</code>, <code>examples.lean</code> to accommodate the improvement of constants from 12 to 11.</li>\n</ol>",
        "id": 407269769,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702310232
    },
    {
        "content": "<p>I'd be happy to try B.1!</p>",
        "id": 407273472,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702311266
    },
    {
        "content": "<p>I'd like to claim C4 and C5!</p>",
        "id": 407576845,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1702417944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/407576845\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim C4 and C5!</p>\n</blockquote>\n<p>Great!  There is one catch right now, which is our definition of entropy requires that the range <code>G</code> is a <code>Fintype</code>, which is not the case over the integers.  I'm working right now to extend the definition of entropy (assuming instead that random variables have finite range) without breaking the build, but I have only achieved the first task so far (i.e., I have extended the definition, but at the cost of breaking the build; you can see the broken version at <a href=\"https://github.com/teorth/pfr/tree/entropy_refactor\">https://github.com/teorth/pfr/tree/entropy_refactor</a> ).  One may have to temporarily introduce a placeholder notion of entropy in order to formalize the lemmas, and switch them back to the actual notion of entropy when they are formalized.  (I did formalize the notion of finite range though, see <a href=\"https://github.com/teorth/pfr/blob/master/PFR/ForMathlib/FiniteRange.lean\">https://github.com/teorth/pfr/blob/master/PFR/ForMathlib/FiniteRange.lean</a> ).</p>",
        "id": 407581081,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702419235
    },
    {
        "content": "<p>Here is the precise definition I am using; the difference from the previous version is that a <code>Finset.sum</code> is now a <code>tsum</code>, and the <code>Fintype S</code> hypothesis has now been removed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">PFR.ForMathlib.MeasureReal</span>\n<span class=\"kn\">import</span> <span class=\"n\">PFR.ForMathlib.FiniteRange</span>\n<span class=\"kn\">import</span> <span class=\"n\">PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog</span>\n<span class=\"kn\">import</span> <span class=\"n\">PFR.Mathlib.Data.Fintype.Card</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span> <span class=\"n\">Topology</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ProbabilityTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measureEntropy</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">volume_tac</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑'</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">negMulLog</span> <span class=\"o\">(((</span><span class=\"n\">μ</span> <span class=\"n\">Set.univ</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">•</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">toReal</span>\n</code></pre></div>",
        "id": 407581503,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702419427
    },
    {
        "content": "<p>Okay noted! I'm quite happy to wait a bit until you're done</p>",
        "id": 407582803,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1702420048
    },
    {
        "content": "<p>In the meantime I can do C9 since that one doesn't depend on anything</p>",
        "id": 407583791,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1702420559
    },
    {
        "content": "<p>I'll use this message to update on the status of the entropy refactoring.  The following files potentially need refactoring, in rough order of dependency:</p>\n<ol>\n<li>PFR.ForMathlib.Entropy.Measure <strong>refactored</strong></li>\n<li>PFR.Mathlib.Probability.Kernel.Disintegration <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Kernel.Basic <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Kernel.MutualInfo <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Uniform <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Basic  <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Kernel.Group  <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Group <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.Kernel.RuzsaDist <strong>refactored</strong></li>\n<li>PFR.Mathlib.Probability.IdentDistrib <strong>refactored</strong></li>\n<li>PFR.ForMathlib.Entropy.RuzsaDist <strong>refactored</strong></li>\n<li>PFR.Fibring <strong>refactored</strong></li>\n<li>PFR.TauFunctional <strong>refactored</strong></li>\n<li>PFR.FirstEstimate <strong>refactored</strong></li>\n<li>PFR.SecondEstimate <strong>refactored</strong></li>\n<li>PFR.Endgame <strong>refactored</strong></li>\n<li>PFR.HundredPercent <strong>refactored</strong></li>\n<li>PFR.Main <strong>refactored</strong></li>\n<li>PFR.improvedPFR <strong>refactored</strong></li>\n<li>Merging back into master <strong>done</strong></li>\n</ol>\n<p>I will be going down the list one by one.  The first one took me the better part of a day, but I am hoping that the later ones will be quicker as they rarely involve the low-level implementation of entropy directly.</p>\n<p>Some other files that ended up being modified (mostly by adding variants of existing lemmas):</p>\n<ol>\n<li>PFR.Mathlib.MeasureTheory.Integral.Bochner</li>\n<li>PFR.Mathlib.MeasureTheory.Integral.Lebesgue</li>\n<li>PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas</li>\n<li>PFR.ForMathlib.FiniteRange</li>\n<li>PFR.Mathlib.Probability.Independence.Basic</li>\n<li>PFR.Mathlib.Probability.Independence.Kernel</li>\n<li>PFR.Mathlib.Data.Fin.VecNotation</li>\n</ol>\n<p>In refactoring Disintegration.lean I found it convenient to impose countability conditions on the various measure spaces, which is slightly unsatisfactory, but good enough for our applications since the integers are countable.</p>\n<p>Some other changes: a few of the lemmas about <code>isUniform</code> now require that the set <code>H</code> that one is uniform over is a <code>Finset</code> rather than a <code>Set</code>, which causes some slightly annoying changes to existing code using this concept (a couple appearances of <code>.toFinite.toFinset</code> show up).</p>\n<p>Many applications of <code>integral_eq_sum</code> should now use <code>integral_eq_finset'</code> instead.  This latter method pairs well with <code>FiniteRange.null_of_compl</code>.  For instance, I had to adjust <code>integral_eq_sum</code> to <code>integral_eq_sum_finset' _ _ (FiniteRange.null_of_compl hT₃ _)</code> in the preliminary version of PFR.improvedPFR.</p>\n<p>Any new entropy lemmas that don't assume the random variables take values in a <code>Fintype</code> will most probably need to register <code>FiniteRange</code> instances for the random variables instead.</p>\n<p>There is also some weird <code>motive</code> issue I don't understand that forced me to replace some <code>rw</code> with <code>simp_rw</code>.</p>",
        "id": 407586871,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702422072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/407586871\">said</a>:</p>\n<blockquote>\n<ol start=\"10\">\n<li>PFR.ForMathlib.Entropy.RuzsaDist <strong>in progress</strong></li>\n</ol>\n</blockquote>\n<p>Ugh,  I have hit a snag at the very end of the refactoring progress.</p>\n<p>I managed to successfully refactor the first nine files to allow for random variables with finite range in a <code>Countable</code> type, as opposed to ranging in a <code>Fintype</code>.  Along the way I developed an API for <code>FiniteRange</code> vraiables, as well as the related concept of a measure having <code>FiniteSupport</code>, and a probability kernel having <code>FiniteKernelSupport</code>.  So far, so good.  In particular, instances of <code>FiniteRange</code> propagate very nicely with respect to operations such as adding or subtracting two random variables.</p>\n<p>However, there is a technical issue: when taking independent copies of two random variables <code>X: Ω → G</code>, <code>Y: Ω' → G</code> of finite range, the current construction gives variables <code>X' : Ω' → G</code>, <code>Y' : Ω' → G</code> that technically can be of infinite range.  Indeed we are taking the sample space <code> Ω'</code> to be <code>G × G</code>, with <code>X' ω = ω.1</code> and <code>Y' ω = ω.2</code>, and these random variables have infinite range when <code>G</code> is infinite.</p>\n<p>One way out is to try to develop a notion of <code>EssentialFiniteRange</code> for a random variable, so that it is finitely valued outside of a null set.  But then the notion depends on the measure <code>μ</code> as well as the function <code>X</code>.  But then it is hard to automatically grant instances to such an object unless one packages it into a single <code>RandomVariable</code> class - but then there are a lot of coercions between <code>RandomVariable</code>s and the underlying function which become unpleasant.</p>\n<p>The other way out is to create alternate versions of the independence construction part of the project in which that one trims the sample space down to the product of ranges.  This is not too bad for products of two spaces, but to take products of multiple spaces one starts to enter the infamous \"dependent type hell\".  And unfortunately we will need to take products of three or four spaces here.  (A possible inelegant compromise here would be to still work with the product of the original <code>G</code> spaces, modify the projection operators <code>x ↦ x.1</code>, <code>x ↦ x.2</code> outside of the ranges of the random variables to send them to some dummy value, such as <code>G.choose</code>, purely in order to recover the <code>FiniteRange</code> property.)</p>\n<p>I am thinking of working with an alternate approach to jointly independent copies that which one gets a triple or quadruple of independent copies by iterating the pair construction a few times, and introducing an additional independence lemma to deduce joint independence of say <code>X</code>, <code>Y</code>, <code>Z</code> from pairwise independence of <code>X</code> and <code>Y</code>, as well as pairwise independence of <code>⟨ X, Y ⟩</code> and <code>Z</code>.  It's doable, but it may take some effort. </p>\n<p>Will have to think about how best to proceed here.  Any suggestions would of course be welcome.</p>",
        "id": 408122969,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702622449
    },
    {
        "content": "<p>OK, I think I see a path forward.  We keep the existing independent copy constructions, but add corollaries that if all the input variables are <code>FiniteRange</code> then one can modify the independent copies on a null probability event to also be of <code>FiniteRange</code>.  There are existing <code>Mathlib</code> methods that show that such modifications preserve joint independence.  One then has to replace the appeal to independent copy constructions to ones that also guarantee <code>FiniteRange</code>.</p>",
        "id": 408125844,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702623600
    },
    {
        "content": "<p>That second approach sounds reasonable, yes.</p>",
        "id": 408128525,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702624523
    },
    {
        "content": "<p>It took longer than expected, but I finally managed to refactor all the entropy files (and the PFR files that depend on entropy) so that they no longer require the codomain of the random variables to be finite, but instead that the random variables have <code>FiniteRange</code>.  (So instances of the form <code>[FiniteRange X]</code> will be needed throughout the weak PFR file, since they can't be gained automatically from the finiteness of the codomain.)</p>\n<p>I've merged things back into the master branch, and now formalization can begin on weak PFR.  There are some residual build issues coming from trying to align <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> 's partial progress on improved_PFR into the new framework, but I'm almost done with cleaning that up. (Sebastien, I hope this doesn't cause too many merge conflict headaches on your end...)</p>",
        "id": 408314010,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702711337
    },
    {
        "content": "<p>I've finally finished the exponent improvement to the main result, getting from <code>2K^{12}</code> to <code>2K^{11}</code>. Some parts were quite painful (when arguing by symmetry over 6 permutations, I had to do a lot more by hand than would be reasonable). But the final part of the argument went like a breeze (just copy-pasting the argument for <code>2K^{12}</code>, and replacing a constant here or there when Lean was complaining).</p>",
        "id": 408453476,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702829755
    },
    {
        "content": "<p>Would it make sense to improve the constants in the file <code>HomPFR</code>, just for the sake of definiteness?</p>",
        "id": 408453587,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702829854
    },
    {
        "content": "<p>Also, I've linted the project, and the <code>simpNF</code> linter complains that we use <code>Nat.card s</code> instead of <code>Set.ncard s</code>. I wasn't aware that we had these two equivalent definitions in the library (the difference is that in <code>Nat.card s</code> then <code>s</code> is first coerced to a type, but one always has <code>Nat.card s = Set.ncard s</code>). Is it an oversight that we have both in the library, or is there a good reason to keep both?</p>",
        "id": 408453780,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702830031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408453587\">said</a>:</p>\n<blockquote>\n<p>Would it make sense to improve the constants in the file <code>HomPFR</code>, just for the sake of definiteness?</p>\n</blockquote>\n<p>Sure, it should be easy now to improve the constants in <code>HomPFR</code> and also <code>PFR_conjecture'</code> and <code>ApproxHomPFR</code> (and update <code>examples.lean</code> accordingly).</p>",
        "id": 408456218,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702832178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408453780\">said</a>:</p>\n<blockquote>\n<p>Also, I've linted the project, and the <code>simpNF</code> linter complains that we use <code>Nat.card s</code> instead of <code>Set.ncard s</code>. I wasn't aware that we had these two equivalent definitions in the library (the difference is that in <code>Nat.card s</code> then <code>s</code> is first coerced to a type, but one always has <code>Nat.card s = Set.ncard s</code>). Is it an oversight that we have both in the library, or is there a good reason to keep both?</p>\n</blockquote>\n<p>Huh.  I guess there's no inherent reason we have to use <code>Nat.card</code> (actually I was toying with the idea of trying to use <code>Finset.card</code> instead, but then <code>A</code> needs to be made a <code>Finset</code> and suddenly Lean wants <code>DecidableEq G</code> in order to make sumsets work, and I mostly abandoned the idea, although some of the <code>IsUniform</code> code still works with <code>Finset</code>s which is perhaps a bit inefficient as it causes some annoying coercion workarounds, and one should probably work instead with <code>Finite</code> <code>Set</code>s, but the code was compiling so I didn't try to fix it).  I don't see any downside to replacing <code>Nat.card</code> with <code>Set.ncard</code> throughout (and then we get to also use dot notation), but maybe some people more familiar with Mathlib will have a more informed opinion.</p>",
        "id": 408456687,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702832432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408453476\">said</a>:</p>\n<blockquote>\n<p>I've finally finished the exponent improvement to the main result, getting from <code>2K^{12}</code> to <code>2K^{11}</code>. Some parts were quite painful (when arguing by symmetry over 6 permutations, I had to do a lot more by hand than would be reasonable). But the final part of the argument went like a breeze (just copy-pasting the argument for <code>2K^{12}</code>, and replacing a constant here or there when Lean was complaining).</p>\n</blockquote>\n<p>Thanks so much for pushing through that entire argument!  In particular I'm glad that the entropy refactor didn't disrupt the process.  And this is the one place in the project where there could conceivably have been numerical errors in the argument (and indeed the original blueprint version contained some nontrivial typos) - this argument didn't undergo the same round of repeated review by myself and my three coauthors - so the formal verification really counts for something here.</p>",
        "id": 408456898,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702832532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> was the one defining <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.ncard#doc\">docs#Set.ncard</a> and I'm not entirely sure why we have it.</p>",
        "id": 408456899,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702832532
    },
    {
        "content": "<p>I would understand we could have it for set notation if it were to be an abbreviation for <code>Nat.card ↥s</code>, but instead it goes through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PartENat#doc\">docs#PartENat</a> !</p>",
        "id": 408457093,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702832640
    },
    {
        "content": "<p>I don't think we should use it in PFR, at least not before it's actually seen some use in mathlib.</p>",
        "id": 408457238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702832686
    },
    {
        "content": "<p>For context, I was aware of the situation and decided to stick with <code>Nat.card</code>.</p>",
        "id": 408457714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702832867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408457714\">said</a>:</p>\n<blockquote>\n<p>For context, I was aware of the situation and decided to stick with <code>Nat.card</code>.</p>\n</blockquote>\n<p>I guess we should be consistent with what the additive combinatorics portion of Mathlib uses.</p>",
        "id": 408457981,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702833035
    },
    {
        "content": "<p>Then we should use <code>Finset.card</code>!</p>",
        "id": 408458022,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702833067
    },
    {
        "content": "<p>But Bhavik and I agree that this is not optimal once you start talking about subgroups. There's some figuring out to be done.</p>",
        "id": 408458070,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702833101
    },
    {
        "content": "<p>Oh good point.  Easier to work with a <code>Finite</code> <code>AddSubgroup G</code> than create a new <code>FinAddSubgroup G</code> class.</p>",
        "id": 408458295,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702833205
    },
    {
        "content": "<p>Maybe some lemmas in the additive combinatorics library should have two versions, one for <code>Finset</code>s and one for <code>Finite</code> <code>Set</code>s.</p>",
        "id": 408458656,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702833346
    },
    {
        "content": "<p>It was <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  who suggested changing the definition of <code>ncard</code> to be in terms of <code>encard</code> (and therefore indirectly via <code>PartENat.card</code>) rather than <code>Nat.card</code>. This was so that deriving the <code>ncard</code> API from the <code>encard</code> API went the smoothest.</p>",
        "id": 408458674,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702833353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408458656\">said</a>:</p>\n<blockquote>\n<p>Maybe some lemmas in the additive combinatorics library should have two versions, one for <code>Finset</code>s and one for <code>Finite</code> <code>Set</code>s.</p>\n</blockquote>\n<p>Yes - the <code>Set</code> API is so much nicer than <code>Finset</code> for many reasons.</p>",
        "id": 408458825,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702833408
    },
    {
        "content": "<p>I strongly disagree with that!</p>",
        "id": 408458868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702833425
    },
    {
        "content": "<p><code>Finset</code> has horrible notation for intersections (with sets) and interaction with subtypes, forces <code>Decidable</code> fluff in lemma statements, and nothing is definitional.</p>",
        "id": 408459068,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702833487
    },
    {
        "content": "<p>The main advantage of <code>Finset</code> I encountered in the PFR project is that one gets to use <code>sum</code> instead of <code>tsum</code>.</p>",
        "id": 408459255,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702833568
    },
    {
        "content": "<p>Notation we're working on it. Definitionality I have a PR in the works. <code>DecidableEq</code>, point given, but it's actually pretty easy to get it right.</p>",
        "id": 408459271,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702833574
    },
    {
        "content": "<p>note: I think <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  was going to refactor to remove <code>PartENat</code> in favor of just <code>ENat</code>, but I'm not sure if there is a PR yet.</p>",
        "id": 408459661,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702833711
    },
    {
        "content": "<p>During the entropy refactor this issue annoyed me a fair bit until I learned about <code>.toFinite.toFinset</code> which mostly solved my coercion issues.</p>",
        "id": 408459681,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702833719
    },
    {
        "content": "<p>I get distracted every time.</p>",
        "id": 408459786,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702833746
    },
    {
        "content": "<p>Too many refactors I want to do.</p>",
        "id": 408459812,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702833756
    },
    {
        "content": "<p>Yes <code>Finite.toFinset</code> does help. But then you get underscores in the infoview (or you can turn them off, and suddenly referring to a set  cardinality takes 20 characters). And simple things then become a cascade of <code>simp only</code>.</p>",
        "id": 408459970,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702833818
    },
    {
        "content": "<p>For me, the defeq in the way that <code>Set</code> is defined is intuitively priceless. </p>\n<p>Part of my problem with <code>Finset.card</code> is how awkward it is to make statements like 'there are at most 100 Fermat primes'.</p>",
        "id": 408460272,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702833917
    },
    {
        "content": "<p>I guess <code>Finset</code>s are intended only for sets that are \"definitionally\" finite, as opposed to ones that are only \"accidentally\" finite.</p>",
        "id": 408460959,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702834150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408460959\">said</a>:</p>\n<blockquote>\n<p>I guess <code>Finset</code>s are intended only for sets that are \"definitionally\" finite, as opposed to ones that are only \"accidentally\" finite.</p>\n</blockquote>\n<p>Yes, or 'maybe finite'.</p>",
        "id": 408461034,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702834182
    },
    {
        "content": "<p>It all seems to me to be an artefact of Lean's preference for avoiding dependent types.  Otherwise we could replace <code>Finset</code>s with <code>Finite</code> <code>Set</code>s everywhere.</p>",
        "id": 408461182,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702834260
    },
    {
        "content": "<p>Actually, while on this topic: why do we have both <code>Finite</code> and <code>Set.Finite</code>?</p>",
        "id": 408461309,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702834357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408461182\">said</a>:</p>\n<blockquote>\n<p>It all seems to me to be an artefact of Lean's preference for avoiding dependent types.  Otherwise we could replace <code>Finset</code>s with <code>Finite</code> <code>Set</code>s everywhere.</p>\n</blockquote>\n<p>For maths, I think that'd be a decent state of affairs, but it means we'd lose computability of (some) finite sets, which can be useful in many circumstances (usually, exactly the same ones where we'd want to evaluate a \"sufficiently small\" set in paper maths). In programming, Sets are almost useless, as far as I understand</p>",
        "id": 408461354,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702834406
    },
    {
        "content": "<p>Ah, right, finiteness is definitely more subtle in constructivist settings than classical ones.</p>",
        "id": 408461520,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702834519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408461309\">said</a>:</p>\n<blockquote>\n<p>Actually, while on this topic: why do we have both <code>Finite</code> and <code>Set.Finite</code>?</p>\n</blockquote>\n<p>We had <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> before we've got <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a>. We should redefine <code>Set.Finite s</code> as <code>_root_.Finite s</code> some day.</p>",
        "id": 408472736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702839948
    },
    {
        "content": "<p>I don't know whether we should completely drop <code>Set.Finite</code> because <code>_root_.Finite (s ∪ t)</code> tries to interpret <code>∪</code> as an operation on types.</p>",
        "id": 408472826,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840004
    },
    {
        "content": "<p>Or we can leave it as an <code>abbrev</code>.</p>",
        "id": 408472856,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840028
    },
    {
        "content": "<p>One of the reasons this wasn't done before is because it would have made <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite\">docs3#set.finite</a> a class, and that would have prevented rewriting <code>set.finite</code> hypotheses in the infoview because of the frozen instance cache (it's not a thing in Lean 4). We had the same problem with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_closed\">docs3#is_closed</a>.</p>",
        "id": 408472910,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702840082
    },
    {
        "content": "<p><code>abbrev</code> sounds like a good compromise.  Certainly the current situation is unwieldy.  I had to write a conversion matrix between the six different types of finiteness - a finite <code>Set</code>, a <code>Finset</code>, a finite<code>Type</code>, a <code>Fintype</code> instance, a <code>Set.Finite</code> instance, and a <code>Finite</code> instance - to understand what was going on (see the \"Finite sets\" tab at <a href=\"https://docs.google.com/spreadsheets/d/1Gsn5al4hlpNc_xKoXdU6XGmMyLiX4q-LFesFVsMlANo/edit#gid=0\">https://docs.google.com/spreadsheets/d/1Gsn5al4hlpNc_xKoXdU6XGmMyLiX4q-LFesFVsMlANo/edit#gid=0</a>).</p>",
        "id": 408473006,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702840153
    },
    {
        "content": "<p>I only count five. <code>Type</code> is not finiteness by itself. You have either <code>{α : Type*}, [Fintype α]</code> or <code>{α : Type*} [Finite α]</code>. So you can get rid of one row and one column.</p>",
        "id": 408473182,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702840288
    },
    {
        "content": "<p>Actually, <code>Set</code> and <code>Set.finite</code> also belong together. So that's rather four.</p>",
        "id": 408473273,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702840345
    },
    {
        "content": "<p>Technically they are referred to by different names though: a finite set <code>A</code> is not the same thing as an instance <code>hA : Set.Finite A</code> of the finiteness of <code>A</code>, and similarly for <code> { x // x ∈ A }</code> and <code>hf: Finite  { x // x ∈ A }</code>.</p>",
        "id": 408473349,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702840426
    },
    {
        "content": "<p>nit: you may have <code>{α : Sort*} [Finite α]</code>, not only <code>{α : Type*} [Finite α]</code></p>",
        "id": 408473350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840426
    },
    {
        "content": "<p>Ah, you mean <code>Finite α</code>, <code>Fintie (s : Set α)</code>, and <code>Set.Finite s</code>.</p>",
        "id": 408473438,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840473
    },
    {
        "content": "<p>IMHO, we should hide <code>Fintype</code> from math users.</p>",
        "id": 408473463,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408473349\">said</a>:</p>\n<blockquote>\n<p>Technically they are referred to by different names though: a finite set <code>A</code> is not the same thing as an instance <code>hA : Set.finite A</code> of the finiteness of <code>A</code>, and similarly for <code> { x // x ∈ A }</code> and <code>hf: Finite  { x // x ∈ A }</code>.</p>\n</blockquote>\n<p>Yes, but you cannot \"convert\" from <code>(s : Set α)</code> to <code>(s : Set α) (hs : s.Finite)</code>, nor can you convert from <code>{α : Type*}</code> to <code>{α : Type*} [Fintype α]</code> or <code>{α : Type*} [Finite α]</code>.</p>",
        "id": 408473484,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702840530
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408473463\">said</a>:</p>\n<blockquote>\n<p>IMHO, we should hide <code>Fintype</code> from math users.</p>\n</blockquote>\n<p>That's... very controversial. <code>Fintype</code> brings in many niceties for mathematicians.</p>",
        "id": 408473557,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702840575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Here are six reasonable finiteness assumptions: <code>[Finite α]</code>, <code>[Fintype α]</code>, <code>Finite s</code>, <code>Fintype s</code>, <code>Set.Finite s</code>, <code>s : Finset α</code>.</p>",
        "id": 408473579,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702840604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408473484\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408473349\">said</a>:</p>\n<blockquote>\n<p>Technically they are referred to by different names though: a finite set <code>A</code> is not the same thing as an instance <code>hA : Set.finite A</code> of the finiteness of <code>A</code>, and similarly for <code> { x // x ∈ A }</code> and <code>hf: Finite  { x // x ∈ A }</code>.</p>\n</blockquote>\n<p>Yes, but you cannot \"convert\" from <code>(s : Set α)</code> to <code>(s : Set α) (hs : s.Finite)</code>, nor can you convert from <code>{α : Type*}</code> to <code>{α : Type*} [Fintype α]</code> or <code>{α : Type*} [Finite α]</code>.</p>\n</blockquote>\n<p>Ah, good point.  I can concatenate two rows and two columns of my table.</p>",
        "id": 408473621,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702840641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Outstanding.20tasks.2C.20version.207.2E0/near/408473579\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> Here are six reasonable finiteness assumptions: <code>[Finite α]</code>, <code>[Fintype α]</code>, <code>Finite s</code>, <code>Fintype s</code>, <code>Set.Finite s</code>, <code>s : Finset α</code>.</p>\n</blockquote>\n<p><code>Fintype s</code> we do use (but it's really fringe), <code>Finite s</code> I've only ever seen when you want to restrict to a finite subspace.</p>",
        "id": 408474467,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702841424
    },
    {
        "content": "<p>Four is still a lot!</p>",
        "id": 408501523,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702862384
    },
    {
        "content": "<p>Yeah, but computability is sometimes <em>very</em> convenient.</p>",
        "id": 408501626,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702862451
    },
    {
        "content": "<p>I’ve only ever been exposed to the cost, rather than the convenience. And I’m a combinatorialist.</p>",
        "id": 408501735,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702862524
    },
    {
        "content": "<p>Perhaps that’s not 100% true - there are a few times I’ve been annoyed at formalizing some small case analysis that could probably have been decidably knocked off.</p>",
        "id": 408501799,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702862579
    },
    {
        "content": "<p>That's exactly the kind of thing I'm talking about. When there are more than just a few cases, it's very handy.</p>",
        "id": 408501848,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702862627
    },
    {
        "content": "<p>I care much more about sets that may or may not be finite, and making statements about the cardinality when they are finite.</p>",
        "id": 408501933,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1702862685
    },
    {
        "content": "<p>No need to choose, that's the plus :)</p>",
        "id": 408502359,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702863031
    },
    {
        "content": "<p>It was <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Balog-Szemer.C3.A9di-Gowers/near/405990726\">this final piece</a> of the original PFR project supplied by <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  that sold me on the usefulness of being able to work with small decidable types.</p>",
        "id": 408512853,
        "sender_full_name": "Terence Tao",
        "timestamp": 1702867993
    }
]