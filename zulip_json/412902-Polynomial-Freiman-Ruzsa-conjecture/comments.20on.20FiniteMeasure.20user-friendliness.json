[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/mathlib-only.20approach.20to.20entropy/near/402282628\">said</a>:</p>\n<blockquote>\n<p>In my (now obsolete) build, notation like <code>P[E]</code> is automatically unfolded for some reason to <code>(fun s ↦ ENNReal.toNNReal (↑↑↑(finiteMeasure Ω) s)) E</code> in the infoview.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/mathlib-only.20approach.20to.20entropy/near/402282913\">said</a>:</p>\n<blockquote>\n<p>I suspect it has something to do with the <code>finiteMeasure</code> class, which seems like it is held together with Lean's equivalent of duct tape</p>\n</blockquote>\n<p>I fully agree that <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> implementations are bad at the moment, and they should definitely be fixed/improved! There is in fact some ongoing work in that direction, starting with <a href=\"https://github.com/leanprover-community/mathlib4/pull/8375\">#8375</a>, but let me give some background to explain the duct tape.</p>\n<p>Probability measures and finite measures were essentially my first contribution to Mathlib3; my goal was to provide basics of weak convergence / convergence in distribution. This meant that the contributions were perhaps not the most mature to start with.</p>\n<p>Then in the porting Mathlib3 -&gt; Mathlib4 something happened with how coercions are dealt with that I don't yet understand. In Mathlib4 we started seeing the \"pretty\"-printed forms such as <code>(fun s =&gt; ENNReal.toNNReal (↑↑↑P s)) x : NNReal</code>; see <a href=\"#narrow/stream/287929-mathlib4/topic/Bad.20CoeFun.20instances.20on.20FiniteMeasure.20and.20ProbabilityMeasure/near/401656710\">this discussion</a>. There is a PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8375\">#8375</a> to start fixing the coe-handling for <code>Measure</code>, after which I hope one could fix it for finite measures and probability measures.</p>\n<p>Finally, I care about making the user interface of <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> good, but there is some disagreement on what will be good for the user, especially regarding where to use <code>Real</code>, <code>NNReal</code>, and <code>ENNReal</code>. Some relevant discussion can be found <a href=\"#narrow/stream/287929-mathlib4/topic/Pmf.3A.20ENNReal.20vs.2E.20NNReal/near/382768556\">here</a>. I was leaning towards changing the probabilities to be real numbers, contrary to my original choice of making them <code>NNReal</code>s. But more experienced users were not convinced of this. In my mind the best choice is still an open problem, so I have not embarked on refactors yet.</p>\n<p>And as a comment about this PFR project, I agree with <span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span>'s  <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401700497\">comment</a>, which advices against using <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> here, unless one needs the topology of weak convergence of measures. Using the type classes <code>IsFiniteMeasure</code> and <code>IsProbabilityMeasure</code> one gets more generally applicable statements and direct access to the <code>Measure</code> API.</p>\n<p>By the way, I'm super excited about this new formalization project of yours! (And I was excited about the previous one and the insightful frequent posts about it.)</p>",
        "id": 402412986,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700123498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kytölä</span> , <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> , do you think it is finally time to wrap up some API to be able to use seamlessly measures as real-valued objects? I imagine something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Measure</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Measure.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Measure.nnreal</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNNReal</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">μ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">measure_union_real</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">μ.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ.real</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">μ.real</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Measure.real</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">measure_union</span> <span class=\"n\">h</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.toReal_add</span> <span class=\"o\">(</span><span class=\"n\">measure_ne_top</span> <span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">measure_ne_top</span> <span class=\"n\">μ</span> <span class=\"n\">t</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>and so on. It would mean duplicating (or triplicating if we go for both real and nnreal versions) many measure lemmas, but I would guess not so many. Opinions?</p>",
        "id": 402415954,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700124583
    },
    {
        "content": "<p>Of course, one would need some notation to hide this from the user in common probability situations. For instance like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">scoped</span><span class=\"o\">[</span><span class=\"n\">ProbabilityTheory</span><span class=\"o\">]</span> <span class=\"kd\">notation</span> <span class=\"s2\">\"ℙᵣ\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MeasureTheory.MeasureSpace.volume.real</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ProbabilityTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasureSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">β</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n     <span class=\"n\">ℙ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ℙ</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">ℙ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">measure_union</span> <span class=\"n\">h</span> <span class=\"n\">ht</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ℙ</span><span class=\"bp\">ᵣ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ℙ</span><span class=\"bp\">ᵣ</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">ℙ</span><span class=\"bp\">ᵣ</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">measure_union_real</span> <span class=\"n\">h</span> <span class=\"n\">ht</span>\n</code></pre></div>",
        "id": 402419084,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700125578
    },
    {
        "content": "<p>Perhaps you can reuse the API for vector valued measures in this case</p>",
        "id": 402420786,
        "sender_full_name": "Jason KY.",
        "timestamp": 1700126158
    },
    {
        "content": "<p>I agree that it is time to introduce a definition for real-valued measures. I don't think we should introduce the NNReal one. Computing with NNReal is as painful as with ENNReal (or even more because we don't get summability for free) and the info that the number is nonnegative can be handled as well by the positivity tactic (if we tell it that Measure.real is nonnegative).</p>",
        "id": 402421021,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700126231
    },
    {
        "content": "<p>I am very much in favor of developing these and I agree that now is probably a good time for it. I expect I will have some time for this during the weekend.</p>\n<p>It is currently unclear to me whether the <code>FunLike</code> refactor of <code>Measure</code> (at least) needs to happen before the duplication or triplication of the API, though.</p>",
        "id": 402421098,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700126259
    },
    {
        "content": "<p>I also feel the same way as <span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> about working with <code>NNReal</code> (i.e., better to avoid it!). But at least <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> disagreed on that issue <a href=\"#narrow/stream/287929-mathlib4/topic/Pmf.3A.20ENNReal.20vs.2E.20NNReal/near/382768556\">here</a>.</p>",
        "id": 402421404,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700126352
    },
    {
        "content": "<p>I also agree about avoiding <code>NNReal</code>. The main pitfall I can see is that when writing <code>ℙᵣ s - ℙᵣ t</code> you would use the badly behaved subtraction. Also, <code>ring</code> and friends don't work well there.</p>",
        "id": 402422153,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700126565
    },
    {
        "content": "<p>(As a small caveat, I think there are some reasons for working with <code>NNReal</code>-valued bounded continuous functions for weak convergence and Riesz representation theorem, because this is more seamless with <code>lintegral</code>. But that is irrelevant to the coercions we are discussing here, so let's maybe have any differing opinions on that elsewhere.)</p>",
        "id": 402422298,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700126617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/comments.20on.20FiniteMeasure.20user-friendliness/near/402421021\">said</a>:</p>\n<blockquote>\n<p>I agree that it is time to introduce a definition for real-valued measures. </p>\n</blockquote>\n<p>Do you really want to introduce a new definition of a new class of measures, or only API around the good old measures we already have as I was advocating above?</p>",
        "id": 402422346,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700126636
    },
    {
        "content": "<p>I mean your <code>Measure.real</code></p>",
        "id": 402422459,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700126662
    },
    {
        "content": "<p>I think this is also a good idea.<br>\nIdeally I would like <code>Measure.real</code> to also work well with measures applied to sets with finite measure, e.g. <code>μ (ball x r)</code> assuming <code>[IsFiniteMeasureOnCompacts μ]</code>. It would be nice to have a <code>finiteness</code> tactic, similar to (but simpler than) the <code>positivity</code> tactic that can prove goals of the form <code>μ t ≠ ⊤</code> and then we could have lemmas like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">measure_union_real</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">μ.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ.real</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">μ.real</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 402426404,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700127909
    },
    {
        "content": "<p>But maybe we should go with the simpler idea for finite measures first.</p>",
        "id": 402426582,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700127952
    },
    {
        "content": "<p>Great idea, having a finiteness discharger like this would be awesome! If you know how to set up such a discharger in the simplest situation of finite measures (it would just <code>apply measure_ne_top</code>), we could start using it right away when setting up the theory, and then extend the discharger to more interesting situations.</p>",
        "id": 402429428,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700128848
    },
    {
        "content": "<p>Here is a small example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Measure</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"finiteness\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">apply</span> <span class=\"n\">measure_ne_top</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Measure.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">measure_union_real</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">s</span> <span class=\"bp\">≠</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2t</span> <span class=\"o\">:</span> <span class=\"n\">μ</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span><span class=\"o\">)</span>  <span class=\"o\">:</span>\n    <span class=\"n\">μ.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ.real</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">μ.real</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Measure.real</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">measure_union</span> <span class=\"n\">h</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.toReal_add</span> <span class=\"n\">hs</span> <span class=\"n\">h2t</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">μ.real</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ.real</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">μ.real</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">measure_union_real</span> <span class=\"n\">h</span> <span class=\"n\">ht</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MeasureTheory</span>\n</code></pre></div>",
        "id": 402438506,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1700131327
    },
    {
        "content": "<p>Let me try to cook up a basic API using this. I propose to do it in the FPR project, to see what we need and add it progressively to the file. Of course, the goal in the end is to move it back to mathlib once things have stabilized.</p>",
        "id": 402445458,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700133341
    },
    {
        "content": "<p>I think a <code>finiteness</code> tactic could be built quickly with <code>aesop</code> (with backtracking turned off). The reason <code>positivity</code> isn't built with<code>aesop</code> is the slightly nontrivial interaction of &lt; and &lt;= proofs of subexpressions, but there is no such issue for <code>finiteness</code>.</p>",
        "id": 402458215,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1700137663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243312\">Jason KY.</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/comments.20on.20FiniteMeasure.20user-friendliness/near/402420786\">said</a>:</p>\n<blockquote>\n<p>Perhaps you can reuse the API for vector valued measures in this case</p>\n</blockquote>\n<p>To elaborate on this,  you can define <code>Measure.real</code> as a signed measure (which already exist in mathlib) with a positivity condition. In this case, all the lemmas for vector measure will still apply and there is also existing API for transforming between measures and signed measures.</p>",
        "id": 402469969,
        "sender_full_name": "Jason KY.",
        "timestamp": 1700141324
    },
    {
        "content": "<p>I think I'd prefer to have a mechanism to talk about the real values of ordinary measures under suitable hypotheses (finite measure, probability measure, or perhaps even locally finite measure of some kind like in <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span>'s comment above --- this last one is particularly problematic for vector measures). Then all other objects such as <code>FiniteMeasure</code> and <code>ProbabilityMeasure</code> can access the real-valuedness API of <code>Measure</code>. To me this is the most direct advantage of <span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span>'s proposed approach with <code>Measure.real</code> etc.</p>",
        "id": 402472651,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700142186
    },
    {
        "content": "<p>The basic API is now available at <a href=\"https://github.com/teorth/pfr/pull/14\">https://github.com/teorth/pfr/pull/14</a>. Comments welcome!</p>",
        "id": 402514498,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700153729
    },
    {
        "content": "<p>This looks great to me, and honestly I'd love to have it in Mathlib soon!</p>",
        "id": 402522103,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700156032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/comments.20on.20FiniteMeasure.20user-friendliness/near/402458215\">said</a>:</p>\n<blockquote>\n<p>I think a <code>finiteness</code> tactic could be built quickly with <code>aesop</code> (with backtracking turned off).</p>\n</blockquote>\n<p>Prototype version in <a href=\"https://github.com/teorth/pfr/pull/20\">https://github.com/teorth/pfr/pull/20</a>.</p>",
        "id": 402807311,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1700268860
    },
    {
        "content": "<p>Here are some things it can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ENNReal.ofReal</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ENNReal.ofReal</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">∞</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finiteness</span>\n</code></pre></div>",
        "id": 402807733,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1700269019
    },
    {
        "content": "<p>That is in fact the <em>entirety</em> of the current test set :)  please test more ...</p>",
        "id": 402807928,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1700269085
    },
    {
        "content": "<p>This looks very useful, but I think it would be also nice to have a tactic which can prove that Sets are finite (to improve the auto-param that's used a lot in Nat.card, for example). And that one could also be called <code>finiteness</code>! It's probably not sensible for this one to do both, so how should we resolve the naming?</p>",
        "id": 402901929,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700332451
    },
    {
        "content": "<p><code>set_finiteness</code>?</p>",
        "id": 402902874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700333175
    },
    {
        "content": "<p>It's a pretty cheap dispatch to just look at the goal and decide whether to call <code>numeric_finiteness</code> or <code>set_finiteness</code> under the hood.</p>",
        "id": 402945678,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700361879
    },
    {
        "content": "<p>Contrary to what I said before, I think there is a place for <code>FiniteMeasure</code> in PFR after all: a small part of the argument is topological (continuity of the entropy-like quantities and compactness for the existence of minimizers) and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.FiniteMeasure#doc\">docs#MeasureTheory.FiniteMeasure</a> has a topology instance, which for finite types (with discrete topology) coincides with the natural topology. I think rather than introducing any other topology, it would be good to use the exsisting one. I have intended (for a long time) to include this in the API of weak convergence in finite spaces anyway.</p>\n<p>I still think it is good to do most other parts in just <code>Measure</code>.</p>\n<p>Here is a quick and dirty \"continuity of the singleton measures\" assuming <code>[DiscreteTopology Ω]</code>, when <code>FiniteMeasure Ω</code> has the topology of weak convergence. That should easily give continuity of the entropy-like quantities with <span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span>'s definitions. I would next prove that with <code>[Fintype Ω]</code> we have that <code>FiniteMeasure Ω</code> is homeomorphic to <code>Ω → ℝ≥0</code>, and compactness should then be easy.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Portmanteau</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Count</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">PFR.MeasureReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Topology</span> <span class=\"n\">Metric</span> <span class=\"n\">Filter</span> <span class=\"n\">Set</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Topology</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NNReal</span> <span class=\"n\">BoundedContinuousFunction</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"c1\">--[Fintype Ω]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DiscreteTopology</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OpensMeasurableSpace</span> <span class=\"bp\">Ω</span><span class=\"o\">]</span>\n\n<span class=\"c1\">--#check IsolatedPoint -- Does not exist. What is the Mathlib-spelling?</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">auxiliary</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_indicator_const</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Zero</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">indicator</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">continuous_def</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span> <span class=\"n\">_</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">indicator_const_preimage_eq_union</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsOpen.union</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ite_true</span><span class=\"o\">,</span> <span class=\"n\">s_open</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ite_false</span><span class=\"o\">,</span> <span class=\"n\">isOpen_empty</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ite_true</span><span class=\"o\">,</span> <span class=\"n\">isOpen_compl_iff</span><span class=\"o\">,</span> <span class=\"n\">s_closed</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">ite_false</span><span class=\"o\">,</span> <span class=\"n\">isOpen_empty</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_indicator_singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T1Space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">indicator</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">continuous_indicator_const</span> <span class=\"n\">ha</span> <span class=\"o\">(</span><span class=\"n\">T1Space.t1</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_integral_finiteMeasure</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OpensMeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→ᵇ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">continuous_iff_continuousAt.mpr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">μ</span>\n  <span class=\"n\">apply</span> <span class=\"n\">continuousAt_of_tendsto_nhds</span>\n  <span class=\"n\">exact</span> <span class=\"n\">FiniteMeasure.tendsto_iff_forall_integral_tendsto.mp</span> <span class=\"n\">tendsto_id</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">indicatorBCF</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">BoundedContinuousFunction</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n      <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">s.indicator</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span>\n      <span class=\"n\">continuous_toFun</span> <span class=\"o\">:=</span> <span class=\"n\">continuous_indicator_const</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span>\n      <span class=\"n\">map_bounded'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">use</span> <span class=\"mi\">1</span>\n        <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n        <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n        <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_mem</span><span class=\"o\">,</span> <span class=\"n\">dist_self</span><span class=\"o\">,</span> <span class=\"n\">zero_le_one</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_mem</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_not_mem</span><span class=\"o\">,</span>\n                       <span class=\"n\">dist_zero_right</span><span class=\"o\">,</span> <span class=\"n\">norm_one</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span><span class=\"o\">]</span>\n        <span class=\"bp\">·</span> <span class=\"n\">by_cases</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_not_mem</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_mem</span><span class=\"o\">,</span>\n                       <span class=\"n\">dist_zero_left</span><span class=\"o\">,</span> <span class=\"n\">norm_one</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span><span class=\"o\">]</span>\n          <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span> <span class=\"n\">indicator_of_not_mem</span><span class=\"o\">,</span> <span class=\"n\">dist_self</span><span class=\"o\">,</span> <span class=\"n\">zero_le_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">indicatorBCF_apply</span>  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">indicatorBCF</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">s.indicator</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_indicatorBCF</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_mble</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.ofReal</span> <span class=\"o\">(</span><span class=\"n\">indicatorBCF</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">lintegral_indicator_one</span> <span class=\"n\">s_mble</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">x</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">integral_indicatorBCF</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_mble</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">indicatorBCF</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">integral_indicator_one</span> <span class=\"n\">s_mble</span>\n\n<span class=\"sd\">/-- The measure of any connected component depends continuously on the `FiniteMeasure`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_finiteMeasure_apply_of_isOpen_of_isClosed</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OpensMeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s_closed</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">real</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">continuous_integral_finiteMeasure</span> <span class=\"o\">(</span><span class=\"n\">indicatorBCF</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">s_mble</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">IsOpen.measurableSet</span> <span class=\"n\">s_open</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">integral_indicatorBCF</span> <span class=\"n\">_</span> <span class=\"n\">s_open</span> <span class=\"n\">s_closed</span> <span class=\"n\">s_mble</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">auxiliary</span> <span class=\"c1\">-- section</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">pmf</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">FiniteMeasure</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pmf</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">real</span> <span class=\"o\">{</span><span class=\"n\">ω</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Q: Why doesn't the spelling `μ.pmf` work?</span>\n\n<span class=\"cm\">invalid field 'pmf', the environment does not contain 'Subtype.pmf'</span>\n<span class=\"cm\">  μ</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  { μ // IsFiniteMeasure μ }</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_pmf_apply</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">FiniteMeasure</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">FiniteMeasure.pmf</span> <span class=\"n\">μ</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">continuous_finiteMeasure_apply_of_isOpen_of_isClosed</span> <span class=\"o\">(</span><span class=\"n\">isOpen_discrete</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">T1Space.t1</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">FiniteMeasure</span> <span class=\"c1\">-- namespace</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pmf</span> <span class=\"c1\">--section</span>\n</code></pre></div>",
        "id": 402978560,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700380487
    },
    {
        "content": "<p>Can I push to the repo? I'd like to work on these continuity / compactness aspects (although not before today evening), I have intended to include the API for the topology of weak convergence in finite spaces anyway.</p>",
        "id": 402979343,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700380882
    },
    {
        "content": "<p>You should fork the repo, work on your fork, then make a PR</p>",
        "id": 402980693,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1700381486
    },
    {
        "content": "<p>I have started to work on the compactness of the space of probability measures on a finite space (it's true more generally on compact spaces, but one would need Riesz representation theorem, but here there is a shortcut that it's equivalent to a standard simplex, and the equivalence is good to have anyway). To coordinate a little bit, would you agree to let me complete the proof of compactness, while you do the continuity of entropy and of the tau functional?</p>",
        "id": 402994312,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700388788
    },
    {
        "content": "<p>I have PRed the compactness at <a href=\"https://github.com/teorth/pfr/pull/33\">https://github.com/teorth/pfr/pull/33</a>. It relies on a sorried result that values of a probability measure at a point depend continuously on the measure, a result which is in your post above, so when you PR you will as well complete the compactness proof!</p>",
        "id": 403009562,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1700399989
    },
    {
        "content": "<p>Thanks! I will clean up a bit and try to fork &amp; PR the continuity part.</p>\n<p>By the way, I'd be really happy if your <code>MeasureReal.lean</code> was PR'd to Mathlib. I'd like to fix the <code>CoeFun</code> of <code>FiniteMeasure</code> to a <code>Funlike</code> (I hope this would fix the pretty-printing issue) using your <code>Measure.real</code>. Since this replaces an existing coercion, I think this refactor needs to happen directly in Mathlib. I have read at least one version of your code, so could do a quick review (although I'm clearly all the time slower than anyone else here; the for example the whole compactness thing happened while I was away from my computer for the day).</p>",
        "id": 403026604,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1700410391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/comments.20on.20FiniteMeasure.20user-friendliness/near/402945678\">said</a>:</p>\n<blockquote>\n<p>It's a pretty cheap dispatch to just look at the goal and decide whether to call <code>numeric_finiteness</code> or <code>set_finiteness</code> under the hood.</p>\n</blockquote>\n<p>That's true, but it feels to me like it goes against modularity of tactics. But I'd be happy to have either, ultimately this is the kind of proof I'd never like to write myself in Lean!</p>",
        "id": 403033917,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1700414845
    }
]