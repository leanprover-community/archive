[
    {
        "content": "<p>The Shannon entropy notation used in the paper frequently involves pairs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\"> X, Y </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> of random variables, e.g., <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\"> H[ X, Y ].</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">]</span><span class=\"mord\">.</span></span></span></span>  Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\"> X, Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> live on the same probability space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\"> \\Omega </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> but could take values in different ranges <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo separator=\"true\">,</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\"> S, T </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>.  The way I was thinking of implementing this in Lean was to have an operation <code>pair</code> that pairs together two random variables, something like this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pair</span> <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">×</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"o\">(</span> <span class=\"n\">X</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">Y</span> <span class=\"n\">ω</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">100</span> <span class=\"s2\">\"⟨ \"</span> <span class=\"n\">X</span> <span class=\"s2\">\" , \"</span> <span class=\"n\">Y</span> <span class=\"s2\">\" ⟩\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pair</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">example</span>  <span class=\"o\">{</span><span class=\"bp\">Ω</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">T</span> <span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">×</span> <span class=\"n\">T</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Y</span> <span class=\"o\">⟩</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"o\">:</span> <span class=\"bp\">Ω</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"n\">ω</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">ω</span><span class=\"o\">,</span> <span class=\"n\">Y</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and now any notation for single random variables, e.g., Shannon entropy <code>H[ X ]</code>, automatically extends to pairs as <code>H[ ⟨ X , Y ⟩ ]</code>. (Well, ok, one needs a little lemma that if <code>X</code>and <code>Y</code> are measurable, then <code>⟨ X , Y ⟩</code> is also, but this is straightforward.)</p>\n<p>I was wondering if (a) anyone knew of some existing methods in MathLib that duplicate this operation, and (b) if they have better suggestions for notation than <code>⟨ X , Y ⟩</code> (I guess it's not safe to overload the parenthesis pairing operation, especially since it is actually used in the definition of <code>pair</code>!)</p>",
        "id": 402011804,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699976140
    },
    {
        "content": "<p>Your pair is called prod in mathlib lemmas. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Measurable.prod_mk#doc\">docs#Measurable.prod_mk</a> for the statement that this product is measurable. There is already parenthesis notation for it (see lemmas around the one I linked)</p>",
        "id": 402013978,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699976790
    },
    {
        "content": "<p>With some clever macros, it should be possible to arrange for <code>H[...]</code> to work with <code>...</code> being an arbitrary (positive) number of terms.</p>",
        "id": 402014438,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699976943
    },
    {
        "content": "<p>Oh sorry, I may have misunderstood. Is the goal of your code to get rid of <code>fun ω ↦ (X ω, Y ω)</code> in favor of something like <code>⟨ X, Y ⟩</code> ?</p>",
        "id": 402014667,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699977022
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"H[\"</span> <span class=\"n\">term</span><span class=\"o\">,</span><span class=\"bp\">+</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"n\">H</span><span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"o\">])</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">H</span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 402014822,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699977075
    },
    {
        "content": "<p>This <code>H</code> is of course not anything interesting, but just to illustrate the idea</p>",
        "id": 402014888,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699977096
    },
    {
        "content": "<p>This approach for <code>H</code> is likely to have issues with the fact that <code>(a,(b,c))</code> does not have the same type as <code>((a,b),c)</code>, right?</p>",
        "id": 402016700,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699977584
    },
    {
        "content": "<p>right, I'm associating everything to the right, as is the default for products in lean.</p>",
        "id": 402016881,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699977617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Pairing.20together.20two.20random.20variables/near/402014667\">said</a>:</p>\n<blockquote>\n<p>Oh sorry, I may have misunderstood. Is the goal of your goal to get rid of <code>fun ω ↦ (X ω, Y ω)</code> in favor of something like <code>⟨ X, Y ⟩</code> ?</p>\n</blockquote>\n<p>Yeah, that's the intention.  In the paper there are moderately complicated expressions such as <code>I[ X, Y : Z, W | U, V ]</code> appearing (the conditional mutual information of the pair <code>X, Y</code> and the pair <code>Z, W</code> relative to the pair <code>U, V</code> and it would be a lot of clutter to insert a large number of <code>fun ω ↦ ...</code> phrases into the notation.  Having support for arbitrary tuples than just pairs would be nice, but for this paper pairs would suffice, and given the large number of entropy type functionals we consider (entropy, conditional entropy, mutual information, and conditional mutual information, as well as entropic Ruzsa distance) it might be too much to set up notation for each one separately.  (If one were to generalize PFR to higher characteristic, though, a tuple version of this notation would be good, but that we can work out later.)</p>\n<p>Incidentally there are an unusually large number of delimiters that coexist in this paper.  In addition to the comma <code>,</code> used to pair random variables, there is the bar <code>|</code> used to denote conditioning, e.g., <code>H[ X | Y = y ]</code> and also <code>H[ X | Y ]</code> (the two have different meanings but are related by the formula <code>H[ X | Y ] = ∑ y, P[ Y =  y] * H[ X | Y = y ]</code>), and the colon <code>:</code> to denote mutual information <code>I [ X : Y ]</code>.  We had to introduce yet another delimiter, the semicolon <code>;</code>, for Ruzsa distance <code>d[ X ; Y ]</code>, in order to avoid collision with the other delimeters (for instance, we also have a conditional version <code>d[ X | Z ; Y | W]</code> of the Ruzsa distance concept).  It can be a bit confusing unfortunately, but the notation is pretty standard in information theory (except for the semicolon).</p>",
        "id": 402017170,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699977690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Pairing.20together.20two.20random.20variables/near/402016700\">said</a>:</p>\n<blockquote>\n<p>This approach for <code>H</code> is likely to have issues with the fact that <code>(a,(b,c))</code> does not have the same type as <code>((a,b),c)</code>, right?</p>\n</blockquote>\n<p>There is going to be a basic lemma at some point that if one random variable <code>Y</code> is the composition of another <code>X</code> with an injection <code>f</code>, then <code>X</code> and <code>Y</code> have the same entropy (and similarly for other basic entropy functionals).  So as long as there is a canonical injection (or bijection) relating <code>(X,(Y,Z))</code> with <code>((X,Y),Z)</code>, I don't see this as more than a minor inconvenience.  (In this particular paper, we can probably avoid using triples altogether, and certainly don't need quadruples or higher arity tuples, but I guess it's good to think about future uses also.) Certainly we will need the canonical bijection between <code>(X,Y)</code> and <code>(Y,X)</code> to prove basic statements such as <code>H[ X, Y ] = H [ Y, X ]</code> which are implicitly used in the paper.</p>",
        "id": 402018075,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699977853
    },
    {
        "content": "<p>The sort of issue I was alluding to is not mathematical. I was thinking about the code getting cluttered with equivalences between products in every statement. But if there are rarely more than 2 random variables that's not a big issue.</p>",
        "id": 402019127,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699978081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Pairing.20together.20two.20random.20variables/near/402019127\">said</a>:</p>\n<blockquote>\n<p>The sort of issue I was alluding to is not mathematical. I was thinking about the code getting cluttered with equivalences between products in every statement. But if there are rarely more than 2 random variables that's not a big issue.</p>\n</blockquote>\n<p>I don't see any way around this, other than to work with arbitrary tuple notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>α</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mi>α</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">(x_\\alpha)_{\\alpha \\in I}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span></span></span></span> rather than try to build things up from the pair notation.  I doubt one can make <code>(a,(b,c))</code> definitionally equivalent to <code>((a,b),c)</code> without breaking some important things.</p>",
        "id": 402020297,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699978414
    },
    {
        "content": "<p><code>((a,b),c)</code> and <code>(a,(b,c))</code> don't even have the same type :)</p>",
        "id": 402020473,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699978472
    },
    {
        "content": "<p>OTOH, I do think it would be quite easy to make some automation that can automatically create an equivalence between iterated products, and possibly even invisibly insert that equivalence as needed.</p>",
        "id": 402020623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1699978525
    },
    {
        "content": "<p>(Of course, working with arbitrary tuples <em>and</em> with pairs just pushes the problem one level down, in that at some point one needs the canonical equivalence between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>α</mi></msub><msub><mo stretchy=\"false\">)</mo><mrow><mi>α</mi><mo>∈</mo><mrow><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">n</mi><mi mathvariant=\"normal\">g</mi><mi mathvariant=\"normal\">e</mi></mrow><mtext> </mtext><mn>2</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">(x_\\alpha)_{\\alpha \\in \\mathrm{range}\\ 2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span><span class=\"mrel mtight\">∈</span><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">range</span></span><span class=\"mspace mtight\"><span class=\"mtight\"> </span></span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x_0,x_1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, but somehow mathematicians manage to completely ignore the subtleties of this equivalence in their work.)</p>",
        "id": 402020837,
        "sender_full_name": "Terence Tao",
        "timestamp": 1699978579
    },
    {
        "content": "<p>I don't get this <code>(a, (b, c))</code> vs <code>((a, b), c)</code> business. We need to write <em>something</em>, right? And that something is the right-associated version that Adam's notation uses. We can provide an API for iterated products that makes it possible to consider them as left-associated even though they are not, but we need to choose an association for the notation itself.</p>",
        "id": 402021832,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699978843
    },
    {
        "content": "<p>I don't object to the way the products associate. My point was simply this: if we don't need to consider products of many things (not more than 3), using these products of two variables and nesting them is fine. Otherwise, especially if we want to insert or remove variables in the middle,  it will be very inconvenient very fast and we should do something else we usually do in these situations, like index all random variables and let H take a finset as input (like <code>Finset.sum</code> for example). But apparently there is no need for large products in this project, so the first approach is fine.</p>",
        "id": 402023850,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1699979451
    },
    {
        "content": "<p>Ah sure. We certainly can have a pi type or finset version of the notation and relate them to the nested product.</p>",
        "id": 402046478,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699987436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/412902-Polynomial-Freiman-Ruzsa-conjecture/topic/Pairing.20together.20two.20random.20variables/near/402020623\">said</a>:</p>\n<blockquote>\n<p>OTOH, I do think it would be quite easy to make some automation that can automatically create an equivalence between iterated products, and possibly even invisibly insert that equivalence as needed.</p>\n</blockquote>\n<p>This is probably no longer relevant to the project, but I'll mention it just in case it's helpful. Motivated by this discussion, I wrote a little bit of automation that automatically creates equivalences between iterated products, and it was just merged into mathlib. With a fresh copy of mathlib, it's now possible to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">×</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"n\">prod_assoc</span><span class=\"bp\">%</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">×</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span> <span class=\"bp\">×</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"n\">prod_assoc</span><span class=\"bp\">%</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">prod_assoc</span><span class=\"bp\">%</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">),(</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,(</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">z</span><span class=\"o\">),</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">prod_assoc</span><span class=\"bp\">%</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">),(</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 403504048,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1700620949
    }
]