[
    {
        "content": "<p>Discussion thread for the talk.</p>",
        "id": 569050905,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1768921350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> Would you mind sharing your slides? I'm interested in brainstorming further about differential operators.</p>",
        "id": 569062232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1768923754
    },
    {
        "content": "<p>I think we will want many flavors of differential operators. If you're doing analysis, you want them to act pointwise, on functions with a low degree of smoothness that might even not be fixed throughout the discussion, so the sheaf point of view is not viable there. But if you want to play with D-modules, you will need to switch to a more algebraic framework.</p>",
        "id": 569063191,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768923981
    },
    {
        "content": "<p>Hmmmzz, so even something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopCat.LocalPredicate#doc\">docs#TopCat.LocalPredicate</a> is not really useful, because it's too sheafy?<br>\n(I'm also wondering whether it should take unbundled topological spaces as input.)</p>",
        "id": 569063829,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1768924129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> If the degree of smoothness is not fixed, does that immediately rule out sheaves?</p>",
        "id": 569064062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1768924183
    },
    {
        "content": "<p>A comment on the difficulty to define the <em>field</em> of meromorphic functions. This is very much related to the definition of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> space in analysis, which is a space of equivalence classes of functions if you want to do functional analysis, but where you think of the elements as genuine functions when you write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f (x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> (i.e., all the time). This has been a difficulty in the Carleson project, where you really want to use both points of view. In the end, what has worked best is to use the functions as true functions, and only project to equivalence classes when really necessary.</p>",
        "id": 569065068,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768924397
    },
    {
        "content": "<p>To be honest, I'm not really into sheaves, so don't listen to me too much here. For me, an issue with this point of view is that if you look at the Laplacian on C^2 functions, and the Laplacian on C^3 functions, they act on different sheaves so they're not directly related.</p>",
        "id": 569065540,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768924505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Please find my slides here:</p>\n<ul>\n<li><a href=\"https://nextcloud.cplx.vm.uni-freiburg.de/index.php/s/Y2RsGdN7FYpFgSG\">https://nextcloud.cplx.vm.uni-freiburg.de/index.php/s/Y2RsGdN7FYpFgSG</a></li>\n</ul>",
        "id": 569069064,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1768925253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Stefan.20Kebekus.20-.20Project.20VD/near/569065068\">schrieb</a>:</p>\n<blockquote>\n<p>A comment on the difficulty to define the <em>field</em> of meromorphic functions. This is very much related to the definition of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> space in analysis, which is a space of equivalence classes of functions if you want to do functional analysis, but where you think of the elements as genuine functions when you write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f (x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> (i.e., all the time). This has been a difficulty in the Carleson project, where you really want to use both points of view. In the end, what has worked best is to use the functions as true functions, and only project to equivalence classes when really necessary.</p>\n</blockquote>\n<p>I agree. Eventually, we will probably have two objects, \"meromorphic function, the function\" and \"meromorphic function, the field element\". The task is then to devise an API that makes shifting hence and forth between the notions as painless as possible.</p>",
        "id": 569069753,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1768925400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Stefan.20Kebekus.20-.20Project.20VD/near/569065540\">schrieb</a>:</p>\n<blockquote>\n<p>To be honest, I'm not really into sheaves, so don't listen to me too much here. For me, an issue with this point of view is that if you look at the Laplacian on C^2 functions, and the Laplacian on C^3 functions, they act on different sheaves so they're not directly related.</p>\n</blockquote>\n<p>I am a great fan of sheaves. C^3 functions are C^2, so that eventually we need a way to state compatibility. Also, all notions of differential operators I came across </p>\n<ul>\n<li>are local in nature</li>\n<li>are linear over a fixed ring (constants, functions coming from the base of a fibration, …)</li>\n<li>satisfy the iterated Leibniz rule whenever there is enough regularity to even state the rule.<br>\nEven if we end up with different flavors of differential operators, I would expect them to have enough in common to warrant a common API that encapsulates these basic properties.</li>\n</ul>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> Please disagree. I will be more than happy to discuss.</p>",
        "id": 569071214,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1768925735
    },
    {
        "content": "<p>My background in algebraic geometry is essentially inexistent, so please take what I say with a grain of salt. Still, I see at least two issues with the algebraic, sheafy, point of view.</p>\n<p>First, in analysis one needs quite quickly to get out of the realm of differential operators, because they are too rigid (notably when you want to construct some kind of inverses). Instead one uses pseudo-differential operators, which are much more flexible while sharing a lot of the nice algebraic properties of differential operators -- except that they are not exactly local, only up to higher order terms.</p>\n<p>Second, there is this weird fact. Take a nice space (say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>) and a finite differentiability (say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn></mrow><annotation encoding=\"application/x-tex\">10</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span>). Then, on the space of compactly supported <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mn>10</mn></msup></mrow><annotation encoding=\"application/x-tex\">C^{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span></span></span></span> functions on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, there is a derivation at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> (i.e., a linear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>:</mo><msup><mi>C</mi><mn>10</mn></msup><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">D : C^{10} \\to \\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">10</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> satisfying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>D</mi><mi>f</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>D</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">D(fg) = (Df) * g(0) + f(0) * Dg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span>) which is not coming from a tangent vector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, i.e., which can not be written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mi>f</mi><mo>=</mo><msup><mi>f</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">Df = f&#x27;(0) v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span>. This means that algebraic characterisations of differential operators only work well in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">∞</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span></span></span></span></span></span></span></span>, but not in finite smoothness.</p>",
        "id": 569109641,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768936692
    },
    {
        "content": "<p>Doesn't the fact that d on C^2 functions is not d on C^3 functions simply translate into the statement that there's d on C^2 and d on C^3 and inclusions of sheaves from C^3 to C^2 and then there's some commutative square of morphisms of sheaves? </p>\n<p>It's the non-locality comment which is scaring me a lot more though. The sheaf axiom is precisely \"the property which defines me can be checked locally\" and a morphism of sheaves involves a lot of commutative diagrams which again say that the information in the morphism is of a local nature. What is an example of a pseudodifferential operator being \"not exactly local\"?</p>",
        "id": 569119649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768940216
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> coincide around <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, then you may have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo mathvariant=\"normal\">≠</mo><mi>L</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L f (0)\\ne L g (0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">Lg</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is a pseudo-differential operator.</p>",
        "id": 569122631,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768941245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Stefan.20Kebekus.20-.20Project.20VD/near/569119649\">said</a>:</p>\n<blockquote>\n<p>What is an example of a pseudodifferential operator being \"not exactly local\"?</p>\n</blockquote>\n<p>Basically every pseudodifferential operator that is not a differential operator is non-local, so you could take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"script\">F</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi mathvariant=\"normal\">∣</mi><mi>ξ</mi><msup><mi mathvariant=\"normal\">∣</mi><mn>2</mn></msup><msup><mo stretchy=\"false\">)</mo><mrow><mi>s</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow></msup><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}^{-1} (1 + |\\xi|^2)^{s/2} \\mathcal{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.04601em;\">ξ</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mtight\">/2</span></span></span></span></span></span></span></span></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span> from my talk for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>∉</mo><mn>2</mn><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">s \\not \\in 2\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\">2</span><span class=\"mord mathbb\">N</span></span></span></span>. This is related to the fact that a distribution supported at a single point has to be a sum of derivatives of the Dirac delta.<br>\nThe feature of a pseudodifferential operator is that it preserves local regularity, i.e., if a distribution is smooth at a point, then <code>A f</code> (for <code>A</code> psido) is smooth at that point, or even better microlocal regularity (where you measure regularity in directions (using the Fourier transform)).</p>",
        "id": 569128313,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1768943422
    },
    {
        "content": "<p>It sounds like sheaf theory is not set up to handle pseudodifferential operators!</p>",
        "id": 569146615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768952756
    },
    {
        "content": "<p>I also just realized, the classic <em>Sheaves on Manifolds</em> (Kashiwara--Schapira) in algebraic analysis doesn't actually cover pseudo-differential operators.<br>\n<a href=\"/user_uploads/3121/5I7fxZkLYwfLpkTWy1FraB8E/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5I7fxZkLYwfLpkTWy1FraB8E/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1151x841\" src=\"/user_uploads/thumbnail/3121/5I7fxZkLYwfLpkTWy1FraB8E/image.png/840x560.webp\"></a></div>",
        "id": 569148750,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1768954089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> Thanks for pointing this out. I learned something! With that in mind, do you think it might make sense to concentrate on potential implementations of \"differential operators\" for now, and leave \"pseudodifferential operators\" for later? It might already be an achievement if we can come up with a sane API that covers the classical cases (including Lie derivatives of functions and differential forms, the Laplacian on a Riemann manifold, del and delBar on complex manifolds, ...)</p>",
        "id": 569176934,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1768975008
    },
    {
        "content": "<p>It would definitely make sense to build first (or separately) a theory for differential operators. For me, the main question is: does it act on unbundled or bundled objects? I.e., would a differential operators be defined on all functions (or on all sections of a given vector bundle) or only on the ones that are global and with some degree of smoothness? I have a preference for the unbundled design, because it is more flexible and easier to localize (i.e., if a function is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">C^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> around a point but not globally, then its laplacian is well behaved around this point -- which is not something one can get if the laplacian is only defined on the space of globally <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">C^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> functions). So I'd advocate that the main API should be unbundled, but of course one should also deduce bundled versions from them.</p>",
        "id": 569202952,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1768987010
    },
    {
        "content": "<p>Note that in our differential geometry branch, Michael and I defined covariant derivatives on vector bundles and we did you the unbundled approach, for the reasons indicated by Sébastien.</p>",
        "id": 569353142,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1769028642
    },
    {
        "content": "<p>About differential operators and sheaves, remember the theorem of Peetre, <a href=\"https://en.wikipedia.org/wiki/Peetre_theorem\">https://en.wikipedia.org/wiki/Peetre_theorem</a></p>",
        "id": 569450922,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1769076669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> Unable to remember because I was not aware of the theorem <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> </p>\n<p>Thanks for pointing this out! I will definitely carry that with me into the upcoming discussions.</p>",
        "id": 569479490,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1769085715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Stefan.20Kebekus.20-.20Project.20VD/near/569450922\">said</a>:</p>\n<blockquote>\n<p>About differential operators and sheaves, remember the theorem of Peetre, <a href=\"https://en.wikipedia.org/wiki/Peetre_theorem\">https://en.wikipedia.org/wiki/Peetre_theorem</a></p>\n</blockquote>\n<p>Doesn't this suffer from the issue mentionned by Sébastien that it doesn't work for finite regularities?</p>",
        "id": 569485907,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769087524
    },
    {
        "content": "<p>I think it works in finite regularity, see Theorems A and B in <a href=\"https://www.degruyterbrill.com/document/doi/10.1515/forum-2013-0159/html\">https://www.degruyterbrill.com/document/doi/10.1515/forum-2013-0159/html</a> (reference provided by chatGPT, I haven't checked the proofs)</p>",
        "id": 569487227,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1769087936
    },
    {
        "content": "<p>It seems like you can track the regularity needed in the Schwartz kernel theorem (Hörmander does that in the proof, but states the result only for smooth), and then it you end up with a proof for finite regularity (the kernel theorem reduces the result to a fact about distributions with support at a point).</p>",
        "id": 569494737,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1769089878
    },
    {
        "content": "<p>Okay nice, I had only ever heard about it in the smooth case, nice to know.</p>",
        "id": 569540040,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769100243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"679664\">@Stefan Kebekus</span> The link to the slides does not work for me. It's behind a login.</p>",
        "id": 569559093,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1769105528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Apologies, I accidentally moved the file while cleaning up after the talk. Here's a new link</p>\n<ul>\n<li><a href=\"https://nextcloud.cplx.vm.uni-freiburg.de/index.php/s/m8qay7PdZT6QXc5\">https://nextcloud.cplx.vm.uni-freiburg.de/index.php/s/m8qay7PdZT6QXc5</a></li>\n</ul>",
        "id": 569695987,
        "sender_full_name": "Stefan Kebekus",
        "timestamp": 1769168755
    }
]