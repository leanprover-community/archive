[
    {
        "content": "<p>The slides for my talk at <time datetime=\"2026-01-23T13:00:00Z\">2026-01-24T00:00:00+11:00</time> are available here: <br>\n<a href=\"/user_uploads/3121/uKCaOWK4SiTwlnH9SZJvH0jd/grind-Lean-Together-2026.pdf\">grind @ Lean Together 2026.pdf</a></p>\n<p>You can follow along the demo portions of my talk using the links to <a href=\"https://live.lean-lang.org/\">https://live.lean-lang.org/</a> embedded in the slides.</p>",
        "id": 569699864,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769170238
    },
    {
        "content": "<p>I wanted to ask, how does <code>grind</code> compares with other types of proofs in efficiency? I have seen that in Mathlib some proofs are being replaced by grind, and I was wondering if that could slow down Mathlib building time?</p>",
        "id": 569715719,
        "sender_full_name": "Iván Renison",
        "timestamp": 1769175179
    },
    {
        "content": "<p>Absolutely fantastic! Thank you for the exciting talk, Kim. I should probably check this first, but do the grind docs include any of the new capabilities, or is there a cheat sheet for the interactive mode yet? I guess, are there places beyond the walkthrough and your slides to learn about these new features? (I expect the answer is not yet...and the slides link nicely to sources, so I am not at all complaining!)</p>",
        "id": 569716281,
        "sender_full_name": "Jon Bannon",
        "timestamp": 1769175345
    },
    {
        "content": "<p>Great talk! <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<p>Beyond the slides (<span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> thanks!), is <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/grind_guide.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/grind_guide.lean</a> the best reference to learn more about the <code>grind</code> tactic?</p>",
        "id": 569717057,
        "sender_full_name": "Sébastien Boisgérault",
        "timestamp": 1769175534
    },
    {
        "content": "<p>The Lean Language Reference is the main source of documentation for <code>grind</code>:</p>\n<p><a href=\"https://lean-lang.org/doc/reference/latest/The--grind--tactic/#grind-tactic\">https://lean-lang.org/doc/reference/latest/The--grind--tactic/#grind-tactic</a></p>",
        "id": 569719711,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769176253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"764233\">Sébastien Boisgérault</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Kim.20Morrison.20-.20.60grind.60/near/569717057\">said</a>:</p>\n<blockquote>\n<p>Great talk! <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<p>Beyond the slides (<span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> thanks!), is <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/grind_guide.lean\">https://github.com/leanprover/lean4/blob/master/tests/lean/run/grind_guide.lean</a> the best reference to learn more about the <code>grind</code> tactic?</p>\n</blockquote>\n<p>This is a good start, but this was written very early in the development of <code>grind</code>. It shows you how to do a lot of the basic stuff, but it is not complete for newer features.</p>",
        "id": 569719866,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769176294
    },
    {
        "content": "<p>What would you think of a solver that handles integer equalities in a general commutative group? It could be practical for euclidean geometry (<code>Real.angle</code>). As far as I understand, <code>grind</code> doesn't handle it yet, and it can be solved efficiently &amp; completely.<br>\nWhat exactly would I need to do if I want to add it?</p>",
        "id": 569720138,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1769176369
    },
    {
        "content": "<p>In principle yes, however there have been enough revisions of the internal structure of <code>grind</code> that we haven't yet reached the point we have stable user extension points for solvers. It's still on our roadmap.</p>",
        "id": 569720921,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1769176570
    },
    {
        "content": "<p>Ok, then let me know when it is ready for users. Or add integer elimination directly... Here is a basic Lean implementation in 138 lines (without tracing proofs, and I do not guarantee it is bug-free).<br>\n<a href=\"/user_uploads/3121/Qo8tppZuRFAt8mgz2z6CXVSx/IntElim.lean\">IntElim.lean</a></p>",
        "id": 569723811,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1769177283
    },
    {
        "content": "<p>Another person touched on this in the zoom chat, but I wanted to raise it here.</p>\n<p>With \"black box\" tactics like grind and simp, there is no question of the soundness of any proof it generates.  But from a software engineering perspective, couldn't changes in the tactic's implementation break proofs which used to work?  I suppose this could happen if the implementation of any tactic changes, but it strikes me as more of a possibility with higher-level, more opaque tactics.</p>\n<p>What mitigates this risk?  Does software development tend to  mostly only increase a tactic's scope of effectiveness rather than decrease it?  Do these tactics have extensive test suites to check for breakage?  Do the tactics themselves have proofs of their effectiveness in certain domains?</p>",
        "id": 569794243,
        "sender_full_name": "Ryan McCorvie",
        "timestamp": 1769198514
    },
    {
        "content": "<p>there's a <a href=\"https://github.com/leanprover/lean4/tree/master/tests/lean/grind\">whole folder of tests</a>, it seems...</p>",
        "id": 569795466,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1769199077
    },
    {
        "content": "<p><code>grind</code> proofs do break occasionally. My anecdotal experience is that this is relatively limited. I've had it happen a few times, but often I felt it was my own fault for stretching what is reasonable for <code>grind</code> to infer and usually catch these in a nightly testing branch. It seems typical to leave an <code>#adaptation_note</code> in these situations, which you could search for if you're interested in observing stability over time.</p>",
        "id": 569796215,
        "sender_full_name": "Chris Henson",
        "timestamp": 1769199425
    }
]