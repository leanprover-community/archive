[
    {
        "content": "<p>Discussion topic for the talk.</p>",
        "id": 569314998,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1769016789
    },
    {
        "content": "<p>Wait a minute. I am looking through the files in Mathlib/Combinatorics/Quiver/ and out of all the ones I've looked at so far, every single one starts with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why do we not just refactor Quiver so that the arrows are type-valued? What is the counter-argument? It looks like the authors of the quiver files are already thinking this.</p>",
        "id": 569324457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769019456
    },
    {
        "content": "<p>Yes, I agree. The mathematical reason to allow <code>Prop</code> for morphisms in a quiver is to force that there is at most one morphism from <code>X</code> to <code>Y</code>, but we could introduce a typeclass saying exactly that (oh, it already exists: this is <code>Quiver.IsThin</code>).</p>",
        "id": 569324891,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769019587
    },
    {
        "content": "<p>Even <code>Path.lean</code> , which does allow Sort-valued quivers, has <code>inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V → Sort max (u + 1) v</code> and that target Sort can never be Prop (because the max of u+1 and v can't be 0) but I suspect that this is the sort of thing which Lean would be very bad at knowing.</p>",
        "id": 569324943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769019601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/557175-Lean-Together-2026/topic/Sophie.20Morel.20-.20Nori's.20construction.20in.20Lean/near/569324891\">said</a>:</p>\n<blockquote>\n<p>(oh, it already exists: this is <code>Quiver.IsThin</code>).</p>\n</blockquote>\n<p>Even better!</p>",
        "id": 569324987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769019618
    },
    {
        "content": "<p>Ha ha ha, in the docstring of Quiver it says \"For graphs with no repeated edges, one can use <code>Quiver.{0} V</code>, which ensures<br>\n<code>a ⟶ b : Prop</code>. \" but if you search Mathlib for <code>Quiver.{0}</code> there are only two occurrences and they're both in docstrings :-) And even funnier, the second occurrence is in a Digraph file and it basically says \"We could have used Quiver.{0} but actually this doesn't work because <code>Quiver</code> is a class and we don't want this, so we make <code>Digraph V</code> which is just copying the definition of <code>Quiver.{0}</code>.</p>\n<p>So in fact we already have <code>Digraph V</code> for anyone who wants <code>Quiver.{0}</code></p>",
        "id": 569325632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769019849
    },
    {
        "content": "<p>(I'm trying the refactor)</p>",
        "id": 569329913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769021130
    },
    {
        "content": "<p>Then we can talk about <code>NatTrans</code>. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 569571280,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1769109508
    },
    {
        "content": "<p>Do you have slides that you can share?</p>",
        "id": 569714207,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1769174784
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/ZgRZZWe0tDvKd-yB0jIqQVzd/expose.pdf\">expose.pdf</a><br>\nHere. (I did fix a couple of mistakes. One of my arrows was going in the wrong direction. <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span> )</p>",
        "id": 569723633,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1769177232
    },
    {
        "content": "<p>You should not call this a mistake, call it duality.</p>",
        "id": 569731142,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1769179134
    },
    {
        "content": "<p>One of the missing ingredients in Sophie's talk, the fact that the localization of an abelian category with respect to a Serre class is also abelian, is in the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/34444\">#34444</a>.</p>",
        "id": 570077623,
        "sender_full_name": "Joël Riou",
        "timestamp": 1769430193
    }
]