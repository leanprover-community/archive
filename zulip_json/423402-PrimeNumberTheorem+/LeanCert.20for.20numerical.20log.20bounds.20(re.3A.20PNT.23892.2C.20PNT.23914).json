[
    {
        "content": "<p>Following up on <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/914#issuecomment-3867759147\">comment on PNT#914</a> about whether LeanCert could streamline the numerical log evaluations in <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/892\">PNT#892</a>:</p>\n<p>Short answer: yes. </p>\n<p>LeanCert's <code>interval_decide</code> tactic handles <code>Real.log</code> natively via verified Taylor series, so the manual bounds become one-liners.</p>\n<p><strong><code>a_bound</code></strong>, the three helper lemmas (<code>log_five_bounds</code>, <code>log_three_lt</code>, <code>log_three_gt</code>,  55 lines of manual Taylor series with geometric remainder bounding) are eliminated entirely:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Before: 55 lines of exp_bound', Finset.range, sum_le_tsum, geometric series</span>\n<span class=\"c1\">-- After: bounds inlined directly</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">a_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set.Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">92129</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">92130</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Chebyshev.a_simpl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">nlinarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Real.log_two_gt_d9</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real.log_two_lt_d9</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">098612</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Real.log</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real.log</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">098613</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">609437</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Real.log</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real.log</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">609438</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p><strong><code>psi_num</code></strong>: the log bounds for primes 7, 11, 13, 17, 19 (each 4 lines of <code>log_lt_iff_lt_exp</code> + <code>exp_eq_tsum_div</code> + <code>Finset.range</code> + <code>norm_num</code>) become:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">log7bound</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\">  </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">946</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">log11bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">398</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">57</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">84</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">95</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">⟨</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">interval_decide</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Net effect: <strong>-77 lines, +14 lines</strong>. One tradeoff: <code>psi_num</code> needs <code>maxHeartbeats 800000</code> (up from 400000) since <code>interval_decide</code> is doing more computation internally, it still builds in ~23s.</p>\n<p>I have a branch that builds. Happy to PR if there's interest. Credit to ajirving for the actual <code>psi_num</code> proof; this just swaps the numerical plumbing for LeanCert's verified interval arithmetic.</p>",
        "id": 572645400,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770580034
    },
    {
        "content": "<p>This looks good to me (and now the three <code>have</code> statements you listed in <code>psi_num</code> that can be combined into a single conjunction provable <code>by split_ands &lt;;&gt; interval_decide</code>).  The additional heartbeats is a downside, but the increase in conceptual simplicity will be useful when generating variants of these sorts of arguments in the future, and hopefully we can move these sorts of computations into very stable files with minimal imports that rarely need to be rebuilt.  (I am in fact thinking of reviving a centuries-old practice and creating <code>log_tables.lean</code> that does nothing but create high precision logarithms of the first few natural numbers.)</p>",
        "id": 572645830,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770580522
    },
    {
        "content": "<p>Could even be something like this with python, then interval_decide re-verifies <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">leancert</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">math</span>\n\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">var</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">)</span>\n<span class=\"n\">cfg</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">Config</span><span class=\"o\">(</span><span class=\"n\">taylor_depth</span><span class=\"bp\">=</span><span class=\"mi\">20</span><span class=\"o\">)</span>\n\n<span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">19</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">23</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">29</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"o\">]:</span>\n<span class=\"w\">    </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">find_bounds</span><span class=\"o\">(</span><span class=\"n\">lc</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">'</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)},</span><span class=\"w\"> </span><span class=\"n\">config</span><span class=\"bp\">=</span><span class=\"n\">cfg</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">lo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">math</span><span class=\"bp\">.</span><span class=\"n\">floor</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"bp\">.</span><span class=\"n\">min_lo</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e6</span>\n<span class=\"w\">    </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">math</span><span class=\"bp\">.</span><span class=\"n\">ceil</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"bp\">.</span><span class=\"n\">max_hi</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e6</span>\n<span class=\"w\">    </span><span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"s2\">\"lemma log_{n}_gt : {lo} &lt; log {n} := by interval_decide\"</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"s2\">\"lemma log_{n}_lt : log {n} &lt; {hi} := by interval_decide\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>With <code>LogTables.lean</code> imported, Chebyshev just references cached lemmas, the table builds in ~7s and rarely needs rebuilding</p>\n<p>Let me know and I'll PR it</p>",
        "id": 572646671,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770581344
    },
    {
        "content": "<p>This sounds good. Actually there are a few other minor places in the repo where numerical bounds on logs are used, e.g., <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L783\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L783</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L795\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L795</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L1952\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/MediumPNT.lean#L1952</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/BKLNW.lean#L194\">https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/blob/main/PrimeNumberTheoremAnd/BKLNW.lean#L194</a> .  In these cases, the proofs are already quite short, but if there is some streamlined unified way to deal with these sorts of computations via a static <code>LogTables.lean</code> file that looks like a sustainable solution to me.  (The cheap thing to do is simply to move each of these statements into a lemma in <code>LogTables.lean</code> and figure out how to organize that file later.)</p>",
        "id": 572647145,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770581855
    },
    {
        "content": "<p>Someone just pointed out to me that the <code>LeanCert</code> code introduces a large number of additional axioms beyond the standard ones, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">'</span><span class=\"n\">LogTables</span><span class=\"bp\">.</span><span class=\"n\">log_2_gt'</span><span class=\"w\"> </span><span class=\"n\">depends</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">propext</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">ofReduceBool</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">trustCompiler</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">gaussianSq_iteratedDeriv_bound</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">iteratedDeriv_erfInner_zero_div_factorial</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">IntervalRat</span><span class=\"bp\">.</span><span class=\"n\">erfInner_contDiff</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">IntervalRat</span><span class=\"bp\">.</span><span class=\"n\">piRatLo_lt_pi</span><span class=\"o\">,</span>\n<span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"bp\">.</span><span class=\"n\">IntervalRat</span><span class=\"bp\">.</span><span class=\"n\">pi_lt_piRatHi</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>What is the nature of these axioms?  For these sorts of purely numerical and totally non-controversial calculations, dependence on external axioms is not an existential issue (and we will inevitably need to import some very large numerical calculations as axioms at some point), but it would be good to transparently disclose such dependencies whenever necessary.</p>",
        "id": 572660776,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770595766
    },
    {
        "content": "<p>These are just <code>axiom</code> statements in the LeanCert source code, e.g.</p>\n<ul>\n<li><a href=\"https://github.com/alerad/leancert/blob/main/LeanCert/Core/IntervalRat/TrigReduced.lean#L54\">https://github.com/alerad/leancert/blob/main/LeanCert/Core/IntervalRat/TrigReduced.lean#L54</a></li>\n<li><a href=\"https://github.com/alerad/leancert/blob/main/LeanCert/Core/HermiteBounds.lean#L87\">https://github.com/alerad/leancert/blob/main/LeanCert/Core/HermiteBounds.lean#L87</a></li>\n<li><a href=\"https://github.com/alerad/leancert/blob/main/LeanCert/Core/IntervalRat/Taylor.lean#L2040\">https://github.com/alerad/leancert/blob/main/LeanCert/Core/IntervalRat/Taylor.lean#L2040</a></li>\n</ul>",
        "id": 572665191,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770599965
    },
    {
        "content": "<p><code>gaussianSq_iteratedDeriv_bound</code> is False (AI-generated proof):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">IntervalAuto</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LeanCert</span><span class=\"bp\">.</span><span class=\"n\">Core</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">gaussianSq_iteratedDeriv_bound_false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_sq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">deriv</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDeriv_eq_iterate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_half</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">deriv</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDeriv_eq_iterate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hcont</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ContDiff</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hfun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">gaussianHalf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gaussianSq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iteratedDeriv_comp_const_mul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hderiv4_sq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">deriv</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">gaussianSq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_half</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span>\n<span class=\"w\">        </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">deriv_gaussian_eq_hermite_mul_gaussian</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">12</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hderiv4_sq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">gaussianSq_iteratedDeriv_bound</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hderiv4_sq</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: 'gaussianSq_iteratedDeriv_bound_false' depends on axioms: [propext,</span>\n<span class=\"sd\"> Classical.choice,</span>\n<span class=\"sd\"> Quot.sound,</span>\n<span class=\"sd\"> LeanCert.Core.gaussianSq_iteratedDeriv_bound]</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">gaussianSq_iteratedDeriv_bound_false</span>\n</code></pre></div>",
        "id": 572691682,
        "sender_full_name": "Letter",
        "timestamp": 1770620900
    },
    {
        "content": "<p>Oof, that's not good. I think these axioms need to be very clearly communicated, and will need community vetting.<br>\nThis is a strong signal that when combining AI with formalization, it is best to aim for axiom-free (aka only std 3 axioms).</p>",
        "id": 572705417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770625557
    },
    {
        "content": "<p>Hooray for Lean clearly telling us what is broken. :-)</p>",
        "id": 572707543,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1770626204
    },
    {
        "content": "<p>This indeed was critical.</p>\n<p>Some LeanCert-specific placeholders had been introduced (including one false statement for a Gaussian derivative bound). Those placeholders leaked into downstream dependency traces (including logTables.log_2_gt), even for purely log-focused lemmas.</p>\n<p>Fixed:</p>\n<ul>\n<li>Removed all five flagged axioms (<code>gaussianSq_iteratedDeriv_bound</code>, <code>iteratedDeriv_erfInner_zero_div_factorial</code>, <code>erfInner_contDiff</code>, <code>piRatLo_lt_pi</code>, <code>pi_lt_piRatHi</code>).</li>\n<li>Replaced pi bounds with fully proved lemmas.</li>\n<li>Removed the sinc high-derivative placeholder path.</li>\n<li>Removed the erf/Hermite placeholder path from the verified interval-eval route.</li>\n<li>The <code>interval_decide</code> path for log and trig is axiom-free and sorry-free. <code>#print axioms</code> on log table lemmas will show only standard foundations + <code>Lean.trustCompiler</code> / <code>Lean.ofReduceBool</code>.</li>\n</ul>\n<p>Remaining:</p>\n<ul>\n<li>PNT repo is still pinned to an older LeanCert artifact/version. Will shortly update the tag and LeanCert version in PNT.</li>\n<li>Once dependency pin/manifest is updated to the fixed LeanCert revision, those LeanCert-specific axioms should disappear from #print axioms LogTables.log_2_gt.</li>\n<li>Remaining trust will be standard foundations plus native_decide compiler trust (Lean.trustCompiler / Lean.ofReduceBool), which is expected for reflected computation.</li>\n</ul>\n<p>Conservative erf bounds:</p>\n<ul>\n<li>As part of removing unsound placeholders, erfPointComputable was switched to a fully sound sign-aware enclosure ([-1,0], [0,0], [0,1] depending on input sign), replacing the previous unsound Taylor-path dependency.</li>\n<li>Next step is restoring tight, fully proved erf enclosures (no axioms) via a stronger certified bound pipeline. I will work on this today and have it ready as soon as possible. </li>\n</ul>\n<p>Will be submitting a PR to PNT with the updated LeanCert soon.</p>\n<p><strong>Sorry for the oversight, I really should have caught this before releasing.</strong></p>",
        "id": 572708072,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770626356
    },
    {
        "content": "<p>Is there still the keyword <code>axiom</code> anywhere in your repository?</p>",
        "id": 572712910,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1770627609
    },
    {
        "content": "<p>No <code>axiom</code> declarations remain (<code>rg \"^axiom\\s+\"</code> is empty). There are <code>sorry</code> statements in <code>Examples/</code> and one in <code>Core/LogBounds.lean</code> (monotonicity lemma). None are in the <code>interval_decide</code> evaluation path for log/trig.</p>\n<p>Verified via <code>#print axioms</code> on the interval/log/trig core theorems (showing only standard foundations; plus compiler trust when reflected computation is involved)</p>",
        "id": 572713492,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770627757
    },
    {
        "content": "<p>Despite all of us hitting issues with published research during work, I think most mathematicians haven’t viscerally endured the <a href=\"https://arstechnica.com/information-technology/2016/03/rage-quit-coder-unpublished-17-lines-of-javascript-and-broke-the-internet/\">dangers</a> of dependency management</p>",
        "id": 572734486,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770632909
    },
    {
        "content": "<p>Also added <a href=\"https://github.com/alerad/leancert/actions/runs/21826401864/job/62972388828\">CI soundness guards</a> to LeanCert: regex check for axiom declarations, sorry allowlist, and <code>assert_no_sorry</code> on all certified evaluation paths. This kind of regression can't happen again. The conservative erf enclosures have also been tightened.</p>",
        "id": 572769236,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770641828
    },
    {
        "content": "<p>It would be even better to remove all the <code>sorry</code>, except in test and example files.</p>",
        "id": 572769765,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1770641954
    },
    {
        "content": "<p>Outside <code>Examples/</code> and <code>Test/</code>, there are no actual <code>sorry</code> placeholders in LeanCert proofs as of now, I addressed the <code>Core/LogBounds.lean</code> one. The only non-example/test regex match is a documentation snippet in <code>Tactic/Interval.lean</code> (not compiled code, just a docstring, removing it now).</p>\n<p>The allowlist is for <code>Test/</code> and <code>Examples/</code></p>",
        "id": 572771610,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1770642324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572734486\">said</a>:</p>\n<blockquote>\n<p>Despite all of us hitting issues with published research during work, I think most mathematicians haven’t viscerally endured the <a href=\"https://arstechnica.com/information-technology/2016/03/rage-quit-coder-unpublished-17-lines-of-javascript-and-broke-the-internet/\">dangers</a> of dependency management</p>\n</blockquote>\n<p>True, but at least with Lean dependencies that are of a propositional nature, one always has the option of replacing any result proven via an unsafe import with a <code>sorry</code>, thanks to <code>propext</code>, so it is relatively easy to amputate any bad import if need be.  As long as the results proven by such imports are already known (or strongly believed) to be true by non-formalized means (e.g., non-rigorous numerical computation), the downside risk seems containable, and I am comfortable with using an experimental import to prove things like <code>lemma log_2_lt : log 2 &lt; 0.693148</code>.  (But the calculus would change of course if the import was for a foundational resource such as Mathlib.)</p>",
        "id": 572818328,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770652254
    },
    {
        "content": "<p>I understand that reasoning but am perhaps less adventurous with general AI-generated imports running code on \"my\" machine for the relative gain.</p>",
        "id": 572822137,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770653080
    },
    {
        "content": "<p>Beyond the introduction of new axioms, increased heartbeats needed to typecheck, and metaprogramming exploits (of the type that leanchecker etc. are supposed to guard against), what are the known exploits concerning importing malicious Lean files that one should be aware of?</p>",
        "id": 572824056,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770653469
    },
    {
        "content": "<p>I am sure there are more exploits than I can think for the Lean code itself. But my main concern is running code from sources more generally these days.</p>",
        "id": 572825649,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770653831
    },
    {
        "content": "<p>For non-formally verified code, sure, there are an infinite number of potential risks and exploits, but with Lean I would hope that one could actually enumerate all the possible exploits with a very finite list (well, I guess there are always undisclosed kernel-level exploits or something, but this seems like a very remote risk to me).</p>",
        "id": 572826817,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770654102
    },
    {
        "content": "<p>I think there are two separate things here: soundness of a given theorem and arbitrary execution of code. In a non-adversarial situation, I don't worry about the latter nor the former. To guard against the latter, I run things in a VM but even then I am not eager to nuke it and rebuild the configuration.</p>",
        "id": 572830275,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770654779
    },
    {
        "content": "<p>But this applies to anything I pull off github and most things off brew these days.</p>",
        "id": 572831753,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770655086
    },
    {
        "content": "<p>Certainly not particular to Lean</p>",
        "id": 572831999,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770655143
    },
    {
        "content": "<p>Oh, so can adding an external github repository to one's lake manifest result in arbitrary local execution of (non-Lean) code?  That is indeed a significant security risk, and significantly weakens the entire promise of Lean as offering the ability to work with untrusted collaborators to supply code.</p>",
        "id": 572839826,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770656843
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean3/issues/1781\">https://github.com/leanprover/lean3/issues/1781</a></p>",
        "id": 572847371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770658832
    },
    {
        "content": "<p>Lean provides the ability to trust <em>mathematics</em> (i.e., theorems proven) by unknown collaborators, but as it is also a (very flexible) general purpose programming language, executing unreviewed code from an unknown source is subject to all the usual security dangers that come with running code in any language. It should be noted that even <em>opening</em> a Lean file in VS Code is executing Lean code on your machine (because Lean is started when the file is opened).</p>\n<p>More generally, you can have confidence in any formally verified theorems about code. But for something like here which is AI generated and calling Python in the background. It is not possible to verify its behavior completely.</p>",
        "id": 572848050,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770658992
    },
    {
        "content": "<p>Hmm, so at present there is no technical way to implement something like the option 2 of the issue Kevin linked to, in which the imports one adds to the manifest are disallowed from making io calls, or are somehow restricted to a subset of Lean of the type generally used in mathematial proofs?</p>",
        "id": 572849286,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770659365
    },
    {
        "content": "<p>Short of sandboxing your install in some way yourself. I don't know of such. But I might not have the most up to date info.</p>",
        "id": 572849715,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770659503
    },
    {
        "content": "<p>This is actually rather concerning to me.  If I understand this correctly, the entire lake manifest system is in fact a security vulnerability for anyone downloading a local version of the repository?</p>",
        "id": 572850056,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770659625
    },
    {
        "content": "<p>Which repository?</p>",
        "id": 572850369,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770659722
    },
    {
        "content": "<p>This repository (PNT+), which contains an entry for <code>leancert</code> in its <code>lake-manifest.json</code>.  Are you saying that if <code>leancert</code> is somehow compromised to permit arbitrary code execution then PNT+ also becomes compromised?</p>",
        "id": 572850742,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770659842
    },
    {
        "content": "<p>I think there is a slight discrepancy here, if I understand your question correctly. The concern isn't so much that we're concerned about exploiting <code>leancert</code> (and then that being exploited in PNT+), but rather that the <code>leancert</code> code <em>itself</em> is the arbitrary code execution (which even calls out to Python if I understand correctly), and that this code is run in PNT+.</p>",
        "id": 572852103,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770660221
    },
    {
        "content": "<p>I guess I need a quick primer on what lake manifest actually does.  When one includes <code>leancert</code> in <code>lake-manifest.json</code>, does this mean that when one runs <code>lake build</code> or whatever, that all relevant Lean files in <code>leancert</code> are run, including potentially ones which make calls to external software tools that are to be run locally by the user?</p>",
        "id": 572852872,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770660404
    },
    {
        "content": "<p>We also have a python script supplied by <span class=\"user-mention\" data-user-id=\"1010219\">@Alejandro Radisic</span> within PNT+ itself to auto-generate the <code>LogTables.lean</code> file, but this is not directly part of <code>leancert</code> which, as far as I understand, does not make any external Python calls (and given that the user building PNT+ may not have the same version of Python, or any Python at all, it seems it would be quite difficult to have any such external call successfully replicated on an arbitrary local build, without sophisticated malware programming).</p>",
        "id": 572854529,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770660927
    },
    {
        "content": "<p>Yes, when <code>lake build</code> is run any modules from another package (e.g., <code>leancert</code>) that you use and import in yours will be built. Building said modules can result in them running arbitrary code. For example, if that code has <code>#eval launchNukes</code>, then said code would be run (just like it would be if it was in a file you were editing).</p>",
        "id": 572854830,
        "sender_full_name": "Mac Malone",
        "timestamp": 1770661023
    },
    {
        "content": "<p>This makes me significantly less enthusiastic about importing any experimental packages at all.</p>",
        "id": 572855111,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770661108
    },
    {
        "content": "<p>Does this also mean that in the event that Mathlib itself is somehow compromised to include a malicious Lean file in their next version, that every single user of Mathlib could then have their devices vulnerable when they update Mathlib?</p>",
        "id": 572855786,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770661320
    },
    {
        "content": "<p>Yes, and that is something we are very aware of when reviewing PRs and working on mathlib CI.</p>",
        "id": 572856071,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1770661423
    },
    {
        "content": "<p>Yes, that applies to Mathlib too. But what is different about Mathlib is that I know the maintainers are very aware of the responsibility and potential dangers and take serious efforts against that</p>",
        "id": 572856138,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770661446
    },
    {
        "content": "<p>The same goes for FRO and the core language itself</p>",
        "id": 572856463,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770661523
    },
    {
        "content": "<p>It's worth noting that this is the case for a lot of software (not just lean)</p>",
        "id": 572856565,
        "sender_full_name": "Eric Vergo",
        "timestamp": 1770661547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572850742\">said</a>:</p>\n<blockquote>\n<p>Are you saying that if <code>leancert</code> is somehow compromised to permit arbitrary code execution then PNT+ also becomes compromised?</p>\n</blockquote>\n<p>No, not immediately. The commit reference stored in the manifest as a cryptographic hash makes sure of that. Only when running <code>lake update</code> could new malicious code be introduced, so the diff of the dependency should be as closely reviewed as accepting a PR changing the project's own code. But this really is true even outside of meta code if a dependency e.g. changes a <code>def</code> that some theorem's statement is based on.</p>",
        "id": 572856949,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1770661638
    },
    {
        "content": "<p><a href=\"https://cacm.acm.org/opinion/it-takes-a-village-to-teach-privacy/\">https://cacm.acm.org/opinion/it-takes-a-village-to-teach-privacy/</a></p>",
        "id": 572857411,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1770661745
    },
    {
        "content": "<p>Is it technically feasible to create some sort of \"safe\" subset of Lean that is sharply more limited in what it can accomplish and execute, but still expressive enough to generate mathematical proofs, and which can be imported by a project in the full Lean language?</p>",
        "id": 572857764,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770661840
    },
    {
        "content": "<p>I'm in favor of creating a \"safe\" subset of Lean</p>",
        "id": 572857923,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1770661878
    },
    {
        "content": "<p>I guess you would be looking for code that has access to some monads (like MetaM) but not others, like the IO monad.<br>\nBut some part of the system will have to do IO stuff, when importing files. Not sure if/where the boundary could be placed.</p>",
        "id": 572859104,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770662260
    },
    {
        "content": "<p>All the money behind the Java language was not able to make this airtight, as far as I know. This is an acknowledged attack vector behind the packaging systems of virtually any major language. I should also mention our new reference manual page <a href=\"https://lean-lang.org/doc/reference/latest/ValidatingProofs/#validating-proofs\">https://lean-lang.org/doc/reference/latest/ValidatingProofs/#validating-proofs</a> that walks through all the levels of checking a Lean proof and what vectors they do and do not cover.</p>",
        "id": 572859183,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1770662291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> it's a bit of a Project Hail Mary?..sorry, shameless movie plug</p>",
        "id": 572859444,
        "sender_full_name": "Matthew Coke",
        "timestamp": 1770662386
    },
    {
        "content": "<p>Perhaps the standard root Lean file of a project would have access to IO etc. but would be a static file that verifies that all the other Lean files in the project only use whitelisted monads etc. and then imports them?</p>",
        "id": 572859635,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770662458
    },
    {
        "content": "<p>Though I guess it would be infeasible to put all of Mathlib into the whitelisted subset of Lean, so one has to still accept Lean files that internally only use whitelisted operations but import Mathlib.  Ugh, I see the problem with where to draw the boundary.</p>",
        "id": 572860311,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770662715
    },
    {
        "content": "<p>I strongly believe that the OS level, rather than the language level, would be the only feasible isolation approach. Especially on Linux there are mature tools like bubblewrap and firejail that should be able to provide very high guarantees for e.g. <code>lake build</code> not touching anything outside <code>.lake</code>. I would be happy to see people experimenting with and sharing such setups for Lean projects.</p>",
        "id": 572860464,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1770662760
    },
    {
        "content": "<p>This is not user friendly but underlies what I use <a href=\"https://developer.apple.com/documentation/virtualization/running-linux-in-a-virtual-machine\">https://developer.apple.com/documentation/virtualization/running-linux-in-a-virtual-machine</a></p>",
        "id": 572861176,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770663004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572860464\">said</a>:</p>\n<blockquote>\n<p>for e.g. <code>lake build</code> not touching anything outside <code>.lake</code>.</p>\n</blockquote>\n<p>Indeed, but if you're working interactively with Lean in VS Code, then you would also need VS Code to be executed within a jail like this too.</p>",
        "id": 572862052,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770663300
    },
    {
        "content": "<p>Can you get away with a remote codebase and a local VS Code? I don't use VS Code so am not sure.</p>",
        "id": 572862354,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770663390
    },
    {
        "content": "<p>I think you should be able to make this substitution in my claim and it is still valid: VS Code = any IDE that provides interaction with Lean via the LSP</p>",
        "id": 572862600,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770663480
    },
    {
        "content": "<p>Although I indeed don't know how sandboxed is the remote VS Code over ssh setup. I assume not very.</p>",
        "id": 572862779,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1770663526
    },
    {
        "content": "<p>I accept that OS-level security features are the strongest line of defense against these sorts of vulnerabilities.  Still, I am not willing to give up entirely on the untrusted or semi-trusted import ecosystem, as it seems like a natural formal analogue of the existing mechanism of having one paper cite and rely upon a (partially trusted) paper in the literature (though with the additional complication that the cited paper can now potentially execute arbitrary code on one's local device).  </p>\n<p>Would it be possible to create a diagnostic tool that could scan a Lean repository and check that all of the Lean code in that repository contains only whitelisted operations (e.g., calls to Mathlib, no IO functions beyond <code>import</code>, etc.)?  This might not catch all exploits, but could be an additional line of defense (especially against accidental vulnerabilities created by AI generated code, as opposed to exploits inserted by genuinely malicious agents).</p>",
        "id": 572868352,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770665195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Just to confirm, are you trying to defend against:</p>\n<ol>\n<li>untrusted code that makes you believe a theorem is true, even though there isn't actually a valid proof</li>\n<li>untrusted code that uses your machine to mine bitcoin, and upload the contents of your hard drive to <a href=\"http://evil.underground.com\">evil.underground.com</a></li>\n</ol>",
        "id": 572870112,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1770665654
    },
    {
        "content": "<p>To add to this mix (or have someone move this message to a different channel), how bad are things on a) my system and b) the sandbox system if I do all of my work using <a href=\"http://live-lean.org\">live-lean.org</a> (the web interface to lean, or sandbox as I call it)?  Does any of the code I might unintentionally import reach out to files on my system?  Assume I have no github repo and try to rely only on Mathlib and recommended packages.</p>",
        "id": 572885133,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1770670627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572870112\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> Just to confirm, are you trying to defend against:</p>\n<ol>\n<li>untrusted code that makes you believe a theorem is true, even though there isn't actually a valid proof</li>\n<li>untrusted code that uses your machine to mine bitcoin, and upload the contents of your hard drive to <a href=\"http://evil.underground.com\">evil.underground.com</a></li>\n</ol>\n</blockquote>\n<p>Closer to 2, but more precisely untrusted code written by an AI that unwittingly involves dangerous calls to external tools that might theoretically be used by a malicious third party to create an exploit, or at least modify the state of one’s computer in an unwanted fashion.</p>",
        "id": 572886719,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770671180
    },
    {
        "content": "<p>Makes me wonder, if one day we may have a predicate isRestrictedToFolder, which proves that all IO Read / Write are restricted to this Folder and then we can AI-Hammer a proof in CI, whenever Dependencies update. But we are probably still a long way from such level of software verification.</p>\n<p>Btw the terminology for such attacks is Supply Chain Attacks, the Javascript Package Registry NPM is hit like every month with a <a href=\"https://snyk.io/blog/sha1-hulud-npm-supply-chain-incident/\">big attack</a>. Lean probably has to little economic value at the moment to be a big target, but caution is always important.</p>",
        "id": 572894054,
        "sender_full_name": "Franz Huschenbeth",
        "timestamp": 1770673891
    },
    {
        "content": "<p>Personally, I am much more worried about AI that wittingly involves bad calls and is very good at hiding it from human eyes.</p>",
        "id": 572896926,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1770674950
    },
    {
        "content": "<p>Yes, so a tool that can pick up (at least some fraction of the time) such calls, somewhat similar to how <code>#print axioms</code> picked up the clandestine use of additional axioms, would be helpful, even though I acknowledge that such a tool may not detect sufficiently camouflaged calls.</p>",
        "id": 572902486,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770677082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572902486\">said</a>:</p>\n<blockquote>\n<p>Yes, so a tool that can pick up (at least some fraction of the time) such calls, somewhat similar to how <code>#print axioms</code> picked up the clandestine use of additional axioms, would be helpful, even though I acknowledge that such a tool may not detect sufficiently camouflaged calls.</p>\n</blockquote>\n<p>So essentially a Anti Virus / Malware Detection Software for Lean Code. Maybe the Lean FRO, would sponsor such tool at some point. A open source tool might be too insecure in the sense, that we would have to trust the creators.</p>",
        "id": 572907166,
        "sender_full_name": "Franz Huschenbeth",
        "timestamp": 1770679374
    },
    {
        "content": "<p>Or maybe just a low-tech script that at least identifies all such external calls within the lean code.  I would like to think that in any good-faith mathematical Lean package, 99% of the code is either routine statements, definitions, and proofs,plus maybe some metaprogramming of custom tactics, and only 1% would involve calls to external tools like Python or whatever, and perhaps this is a small enough rate that one can just rely on human review of that 1% to see if any red flags are present.</p>",
        "id": 572913189,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770682341
    },
    {
        "content": "<p>Would it be fair to say that pretty much all potential exploits or security vulnerabilities from Lean imports not relating to soundness or excessive heartbeat consumption stem from using IO (e.g., to call external tools)?</p>",
        "id": 572913321,
        "sender_full_name": "Terence Tao",
        "timestamp": 1770682438
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572868352\">said</a>:</p>\n<blockquote>\n<p>Would it be possible to create a diagnostic tool that could scan a Lean repository and check that all of the Lean code in that repository contains only whitelisted operations (e.g., calls to Mathlib, no IO functions beyond <code>import</code>, etc.)?  This might not catch all exploits, but could be an additional line of defense (especially against accidental vulnerabilities created by AI generated code, as opposed to exploits inserted by genuinely malicious agents).</p>\n</blockquote>\n<p>In the limit, it might be interesting to consider providing something like this with some digital signing scheme from within the ecosystem (e.g. reservoir?). Then we can verify before pulling the dependency that the commit is 'trusted' by that verification.</p>",
        "id": 572917353,
        "sender_full_name": "Marcelo Lynch",
        "timestamp": 1770684491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572868352\">said</a>:</p>\n<blockquote>\n<p>natural formal analogue of the existing mechanism of having one paper cite and rely upon a (partially trusted) paper in the literature (though with the additional complication that the cited paper can now potentially execute arbitrary code on one's local device).</p>\n</blockquote>\n<p>How about a paper than can perform \"arbitrary code injection\" in the reader's brain, not just infect another paper with a malicious false result? <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 572918927,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1770685324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/LeanCert.20for.20numerical.20log.20bounds.20.28re.3A.20PNT.23892.2C.20PNT.23914.29/near/572839826\">schrieb</a>:</p>\n<blockquote>\n<p>Oh, so can adding an external github repository to one's lake manifest result in arbitrary local execution of (non-Lean) code?  That is indeed a significant security risk, and significantly weakens the entire promise of Lean as offering the ability to work with untrusted collaborators to supply code.</p>\n</blockquote>\n<p>To follow up on this, I added a (short) entry to our <a href=\"https://lean-lang.org/faq/\">official FAQ</a>:</p>\n<blockquote>\n<h2>Is it safe to build Lean code and libraries?</h2>\n<p>Lean is a general purpose programming language with rich compile-time features. Therefore building a Lean project, opening a Lean file or running commands like <code>lake update</code> can execute arbitrary code from the project or any of its dependencies. This “supply chain attack” vector exists in essentially all programming language ecosystems, <a href=\"https://hovav.net/ucsd/dist/tex-login.pdf\">including LaTeX</a>. If you need to build code that may be actively malicious, do so in a properly isolated environment (e.g. a virtual machine).</p>\n</blockquote>\n<p>I'm sorry that the world is as messy as it is, for now the most important thing is to avoid misconceptions.</p>",
        "id": 573542408,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1770907892
    },
    {
        "content": "<p>The bounds in LogTables.lean look very useful for the explicit numerics we need, for example in the Chebyshev bounds, but I wonder if it would be better to revert the MediumPNT proof to the previous version rather than depending on LeanCert.  The changes to MediumPNT&gt;lean don't really shorten the proof and now MediumPNT depends on native_decide and can't be built until after LeanCert.</p>",
        "id": 573956544,
        "sender_full_name": "Alastair Irving",
        "timestamp": 1771139327
    },
    {
        "content": "<p>Ah, good point, there is value in minimizing dependencies in some portions of the PNT+ project; already people are using results from PNT+ as axioms in other formalizations (e.g., of Erdos problems) and it would be nice if one could reduce the transitive dependencies.   I've made a PR for this reversion now.</p>",
        "id": 573990087,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771174015
    },
    {
        "content": "<p>I agree with at least the minimalization of axioms in PNT+, though I think dependencies should be looked at in a per case basis at the very least.</p>",
        "id": 574190056,
        "sender_full_name": "(Tom de Groot) Tomodovodoo",
        "timestamp": 1771280201
    }
]