[
    {
        "content": "<p>Several people have asked me how I use <a href=\"https://aristotle.harmonic.fun\">Aristotle</a> to contribute to the <code>PNT+</code> / <code>IEANT</code> project so I'm writing this post with two goals in mind:</p>\n<ol>\n<li>To describe the workflow I have developed and made publicly available.</li>\n<li>To invite contributors to use it and help me maintain it.</li>\n</ol>\n<h2>Problem</h2>\n<p>The <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd\">PrimeNumberTheoremAnd</a> repository tracks the latest Lean and Mathlib releases (currently <code>v4.28.0-rc1</code>, but I'll bump it soon I'm afraid <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>) and depends on several packages (e.g. <code>LeanArchitect</code> and <code>LeanCert</code>) that are not available in the Lean version currently supported by Aristotle (<code>v4.24.0</code>).</p>\n<p>This means that, at the moment, you cannot simply point Aristotle at a file from the project repo and expect it to just work. The file needs to be converted into a format that is both compatible with <code>v4.24.0</code> and optimised for Aristotle to make it as likely as possible that Aristotle can prove the theorem.</p>\n<h2>Workaround</h2>\n<p>I maintain a dedicated <a href=\"https://github.com/pitmonticone/PNT/tree/aristotle\"><code>aristotle</code></a> branch on my <a href=\"https://github.com/pitmonticone/PNT\">fork</a>. This branch:</p>\n<ul>\n<li>Pins Mathlib to <code>v4.24.0</code>, the version supported by Aristotle.</li>\n<li>Simplifies <code>lakefile.toml</code></li>\n<li>Is synced with <code>upstream/main</code> when I find the time to do so (help needed here!)</li>\n</ul>\n<p>For every source file <code>Foo.lean</code>, the branch contains a corresponding <code>FooAristotle.lean</code> that has been converted for Aristotle.</p>\n<h2>Workflow</h2>\n<p>The workflow consists of two steps: convert and submit.</p>\n<h3>1. Convert</h3>\n<p>Run the conversion script on any source file:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"go\">scripts/convert_to_aristotle.py PrimeNumberTheoremAnd/CH2.lean</span>\n</code></pre></div>\n<p>This produces <code>PrimeNumberTheoremAnd/CH2Aristotle.lean</code>. The script performs the following transformations:</p>\n<ol>\n<li>\n<p>Replaces specific <code>Mathlib.Foo</code> imports with <code>import Mathlib</code> and converts project-internal imports to their Aristotle equivalents (e.g., <code>PrimeNumberTheoremAnd.Wiener</code> becomes <code>PrimeNumberTheoremAnd.WienerAristotle</code>).</p>\n</li>\n<li>\n<p>Converts <code>blueprint_comment</code> blocks to standard module docstrings (<code>/-! ... -/</code>).</p>\n</li>\n<li>\n<p>Converts <code>@[blueprint ...]</code> attributes to declaration docstrings with a <code>PROVIDED SOLUTION</code> template, so that Aristotle can read the informal proof strategy as context:</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- **CH2 Proposition 2.3, substep 1**</span>\n\n<span class=\"sd\">Let $a_n$ be a sequence with ...</span>\n\n<span class=\"sd\">PROVIDED SOLUTION:</span>\n<span class=\"sd\">Use Lemma first-fourier and Lemma second-fourier, similar to the proof of `limiting_fourier_aux`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prop_2_3_1</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<ol start=\"4\">\n<li>\n<p>Replaces completed proofs with <code>admit</code> so that Aristotle ignores them entirely and focuses its resources on the remaining <code>sorry</code>s.</p>\n</li>\n<li>\n<p>Preserves <code>sorry</code> proofs as-is, which are the targets for Aristotle.</p>\n</li>\n</ol>\n<p>After conversion, a typical file will have some <code>sorry</code>s (the targets) surrounded by many <code>admit</code>s (the already proven results).</p>\n<h3>2. Submit</h3>\n<p>To minimise the amount of time I have to wait for Aristotle to prove a theorem, I submit the file to the Aristotle API in parallel, one <code>sorry</code> at a time running the following submission script which automates this process:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>scripts/aristotle_parallel_public.py<span class=\"w\"> </span>PrimeNumberTheoremAnd/CH2Aristotle.lean<span class=\"w\"> </span>--key<span class=\"w\"> </span>YOUR_API_KEY\n</code></pre></div>\n<p>For each <code>sorry</code> in the file, the script:</p>\n<ol>\n<li>Creates a temporary copy where that specific <code>sorry</code> is preserved and all other <code>sorry</code>s are replaced with <code>admit</code>.</li>\n<li>Submits the copy to the Aristotle API as an independent job.</li>\n<li>Polls until the job moves past <code>NOT_STARTED</code> before submitting the next one.</li>\n</ol>\n<p>This means a file with 12 <code>sorry</code>s will result in 12 parallel Aristotle API requests, each focused on proving exactly one theorem.</p>\n<p>You can also target specific <code>sorry</code>s:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\"># </span>Submit<span class=\"w\"> </span>only<span class=\"w\"> </span>the<span class=\"w\"> </span>first<span class=\"w\"> </span><span class=\"m\">5</span>\n<span class=\"go\">scripts/aristotle_parallel_public.py file.lean -l 5</span>\n\n<span class=\"gp\"># </span>Submit<span class=\"w\"> </span>sorries<span class=\"w\"> </span><span class=\"m\">3</span><span class=\"w\"> </span>through<span class=\"w\"> </span><span class=\"m\">7</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"m\">1</span>-indexed<span class=\"o\">)</span>\n<span class=\"go\">scripts/aristotle_parallel_public.py file.lean -r 3-7</span>\n\n<span class=\"gp\"># </span>Submit<span class=\"w\"> </span>from<span class=\"w\"> </span>sorry<span class=\"w\"> </span><span class=\"m\">10</span><span class=\"w\"> </span>to<span class=\"w\"> </span>the<span class=\"w\"> </span>end\n<span class=\"go\">scripts/aristotle_parallel_public.py file.lean -r 10-</span>\n</code></pre></div>\n<p>Requirements: <code>pip install aristotlelib</code> and an Aristotle API key (via <code>--key</code> flag or <code>ARISTOTLE_API_KEY</code> environment variable).</p>\n<h2>Call for Contributors</h2>\n<p>If you are interested in using Aristotle to contribute to <code>PNT+</code> / <code>IEANT</code>, I would be happy to grant you write access to the <a href=\"https://github.com/pitmonticone/PNT\"><code>pitmonticone/PNT</code></a> fork.</p>\n<p>If you are interested, please reply to this thread or send me a DM, and I will add you as a collaborator!</p>",
        "id": 575003272,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1771611186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"556875\">@Pietro Monticone</span>, I surpised you don't mention any automation to poll for Aristotle results / validate them / incorporate them back into files.</p>",
        "id": 575215254,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771813512
    },
    {
        "content": "<p>Yep, I know… I’ve been stupidly doing that part manually and pedantically reported the amount of manual effort in all PR bodies…</p>",
        "id": 575215697,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1771813830
    },
    {
        "content": "<p>I've been wondering what an ideal Aristotle (/ general offline prover) interface looks like.</p>\n<p>I like tactics, so my thought was:</p>\n<ul>\n<li>Replace a <code>sorry</code> with <code>offline (backend := .aristotle)</code> (or just the macro <code>aristotle</code> for that)</li>\n<li>It doesn't actually send anything off, it just does a sanity check that your local file is suitable for that backend and prints either an actionable error if not, or an info message (with \"Try this:\" suggestion) \"This goal appears to be suitable for &lt;BACKEND&gt;. To send the request, please replace the tactic invocation with <code>aristotle \"a4cd66\"</code>\",  for some specified identifier that tactic has chosen in the background.</li>\n<li>This ensures that we only ever send off a \"vetted\" request, and don't spam the backend as we edit the file.</li>\n<li>That tactic now just displays a warning message, that will display a (cached, with X minute TTL) message about the progress at aristotle. You can edit the file, and it won't send off any new requests.</li>\n<li>Once the <code>aristotle \"a4cd66\"</code> tactic finds that the backend has finished, it changes to a info message with a Try this suggestion, which will attempt to just replace the current file with the Aristotle result (possibly post cleanup), if the file is still identical (or close enough?) to the state when the request was sent (possibly changing some admits in the request back to sorry, etc, possibly ignoring sorries filled in with proofs in the meantime, etc), and if it can't confidently paste in the results, instead it just tells you to the path of the result file, which presumably by now it has dropped in the same directory for you.</li>\n</ul>",
        "id": 575424297,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771892897
    }
]