[
    {
        "content": "<p>Started a quick application of the primes in short intervals machinery already in PNT+: by a standard argument, once one knows some theorems about primes in short intervals, one can bootstrap numerical verification of the even Goldbach conjecture (all even numbers greater than 2 are the sum of two primes) to numerical verification of the odd Goldbach conjecture (all odd numbers greater than 5 are the sum of three primes).  For instance, Ramare and Saouter used a verification of Richter of the even Goldbach conjecture up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>Ã—</mo><msup><mn>10</mn><mn>14</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\times 10^{14}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">14</span></span></span></span></span></span></span></span></span></span></span></span>, together with a short interval theorem, to conclude verification of the odd Goldbach conjecture up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1.13256</mn><mo>Ã—</mo><msup><mn>10</mn><mn>22</mn></msup></mrow><annotation encoding=\"application/x-tex\">1.13256 \\times 10^{22}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1.13256</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">22</span></span></span></span></span></span></span></span></span></span></span></span>.  I have some initial tasks for this at <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/959\">PNT#959</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/960\">PNT#960</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/961\">PNT#961</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/962\">PNT#962</a> and will add a few more later. (EDIT: this is now done: <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/769\">PNT#769</a> <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/770\">PNT#770</a>)</p>",
        "id": 573919400,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771095370
    },
    {
        "content": "<p>The alternative would be to construct a prime-number ladder (as we did in Helfgott-Platt; this is an old strategy). It was a weekend computation on a Mac Mini sitting on my bedroom desk, even back in 2013, so I don't necessarily think that would be unrealistic to formalize.</p>",
        "id": 574001407,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771183794
    },
    {
        "content": "<p>Hmm, suppose for instance we used the even Goldbach verification up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>Ã—</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\times 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span> and wanted to use a ladder to verify up to, say, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>Ã—</mo><msup><mn>10</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\times 10^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">30</span></span></span></span></span></span></span></span></span></span></span></span>.  Then one would need a ladder of about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>10</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">12</span></span></span></span></span></span></span></span></span></span></span></span> primes of size <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>âˆ¼</mo><msup><mn>10</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\"> \\sim 10^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">âˆ¼</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">30</span></span></span></span></span></span></span></span></span></span></span></span>, and to verify the ladder one needs to check that they are all prime (and that they are spaced by less than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>Ã—</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">4 \\times 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span>.  The spacing seems doable within Lean, but I'm not sure that Lean's primality testing algorithms are sufficient for this task (even if using <code>native_decide</code>).   These are the sort of inputs though that I am happy to trust rigorous code (e.g., using interval arithmetic to handle any real numbers that show up) to handle rather than Lean.</p>",
        "id": 574003799,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771186433
    },
    {
        "content": "<p>What are the primality certificates typically used at such a scale?</p>",
        "id": 574049188,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1771226817
    },
    {
        "content": "<p>I've seen <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>  proving numbers are prime in Lean in that range using Pratt certificates IIRC (in a talk at Imperial). Bhavik have I remembered correctly?</p>",
        "id": 574073308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1771236099
    },
    {
        "content": "<p>Yeah, for numbers up to 50 digits Pratt certificates work great. Kenny extended my work to use Pocklington certificates (in <a href=\"https://github.com/b-mehta/PrimeCert\">https://github.com/b-mehta/PrimeCert</a>) so it now comfortably handles 70 digit primes.<br>\nThe (slower) Pratt certificate code is what I used for the LCM highly abundant ladder (here: <a href=\"#narrow/channel/423402-PrimeNumberTheorem.2B/topic/Explicit.20estimates.3A.20.24.24M.28x.29.24.24.2C.20.24.24.5Cpsi.28x.29.24.24/near/558956165\">#PrimeNumberTheorem+ &gt; Explicit estimates: &#36;&#36;M(x)&#36;&#36;, &#36;&#36;\\psi(x)&#36;&#36; @ ðŸ’¬</a>) which is a chain of primes up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>10</mn><mn>40</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^{40}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">40</span></span></span></span></span></span></span></span></span></span></span></span>, and it's reasonably efficient. And (as people who know me well will know) none of this uses <code>native_decide</code>.</p>",
        "id": 574073993,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1771236330
    },
    {
        "content": "<p>I don't have an estimate off the top of my head on how fast a ladder of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>10</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">12</span></span></span></span></span></span></span></span></span></span></span></span> primes of 30 digits would take to verify. But a computation which took under 48 hours on 2013 seems like it should be reasonable to verify in under 48 hours today. I'm on vacation this week, but I can take a look next week.</p>",
        "id": 574074582,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1771236532
    },
    {
        "content": "<p>What Platt and I did was use Proth primes, which are easy to certify.</p>",
        "id": 574138600,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771256784
    },
    {
        "content": "<p>Ah right, the code should already be pretty efficient for those: I think I did a 400 or so digit example a while ago</p>",
        "id": 574139929,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1771257209
    },
    {
        "content": "<p>But one would still need to include a list of 10^{12} primes somewhere in the Lean files, unless one uses the IO functions, right?  This feels a bit too risky to have in the main project, both for build time and for security reasons, but perhaps it would be fine to have in a completely separate Lean repository.  (Harald, I don't know if you have saved the file of primes from your 2013 work with Platt, but presumably with modern computers (and AI) one should be able to regenerate a comparable list relatively quickly.)</p>",
        "id": 574140943,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771257582
    },
    {
        "content": "<p>Hm, I may have access to the backup drive of that ancient Mac Mini in early March, but I can ask Platt. (Each of us wrote a program and ran it separately.) I don't <em>think</em> I kept a list of the primes - that would have been too much memory.</p>",
        "id": 574170757,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771269335
    },
    {
        "content": "<p>I'm sure I still have the code somewhere.</p>",
        "id": 574171176,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771269525
    },
    {
        "content": "<p>Found my code. Right, I'm definitely not storing the list.</p>",
        "id": 574172360,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771270090
    },
    {
        "content": "<p>Yeah, that would be ~40 TB, right? Sounds a bit too large for a random Lean file <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 574176471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1771272199
    },
    {
        "content": "<p>So store differences between consecutive list members.  That should get it down easily to under ~30 TB.</p>",
        "id": 574178166,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1771273011
    },
    {
        "content": "<p>Excuse my ignorance, but why would a proof by brute force via Lean have to store all the primes in the file? Is it because that would necessarily be part of some sort of certificate? I would have thought the code would need to typecheck once and do the computation as part of that process, but not store all of the primes.</p>\n<p>This feels like a newbie question, but also one that will help me understand something about Lean I haven't yet understood.</p>",
        "id": 574229684,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771313176
    },
    {
        "content": "<p>It's not necessary, and indeed probably not a good idea.<br>\nIt's a tradeoff between time and memory. Computing the primes on the fly will be more work but will save a lot on space.</p>",
        "id": 574229835,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1771313258
    },
    {
        "content": "<p>Then don't do it. It's not like computing zeros of zeta(s), where the zeros themselves will be useful for a ton of other things. This isn't a large computation by any stretch of the imagination - and at any rate, having a ladder up to 10^27 (probably a lot less than that, once I am done improving certain things...) will be enough. If that feels like too small a task, then compute a ladder up to 10^27 with smaller gaps. It's the verification of binary Goldbach up to 4*10^18 that is genuinely a large computation.</p>",
        "id": 574232484,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771314697
    },
    {
        "content": "<p>Ah, right, the statement one would be typechecking does not have to retain the proof (thanks to propositional extensionality) and so one does not need to keep the primes around as a certificate.</p>\n<p>It may be premature to actually implement any of this in some lean repository now, but it could be an interesting intellectual exercise to estimate what type of time/memory requirements would be needed to hypothetically verify in Lean that for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>â‰¤</mo><msup><mn>10</mn><mn>30</mn></msup></mrow><annotation encoding=\"application/x-tex\">N \\leq 10^{30}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰¤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">30</span></span></span></span></span></span></span></span></span></span></span></span> (say), there exists a prime between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>+</mo><mn>4</mn><mo>Ã—</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding=\"application/x-tex\">N + 4 \\times 10^{18}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">18</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 574331272,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771345093
    },
    {
        "content": "<p>Not to repeat myself, but, as I just implied, it would make perhaps more sense to estimate up to which point it would be realistic to verify binary Goldbach in Lean (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>=</mo><msup><mn>10</mn><mn>15</mn></msup></mrow><annotation encoding=\"application/x-tex\">L=10^{15}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">15</span></span></span></span></span></span></span></span></span></span></span></span>, say?) and then see what type of requirements would be needed to verify that for every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>â‰¤</mo><msup><mn>10</mn><mn>25</mn></msup></mrow><annotation encoding=\"application/x-tex\">N\\leq 10^{25}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰¤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">25</span></span></span></span></span></span></span></span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>â‰¤</mo><msup><mn>10</mn><mn>27</mn></msup></mrow><annotation encoding=\"application/x-tex\">N\\leq 10^{27}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰¤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">27</span></span></span></span></span></span></span></span></span></span></span></span> there exists a prime between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">N+L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>.</p>",
        "id": 574380194,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771360455
    },
    {
        "content": "<p>I would imagine the former task scales essentially linearly in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> and the latter task scales essentially inversely in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, so the geometric mean between the run time for these two tasks (for a reasonable choice of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>) would be a good proxy for the total optimized run time.</p>\n<p>On the other hand I would imagine that the modern explicit prime number theorems at medium ranges would already handle the latter task without any further numerics, in the spirit of the Kadiri-Lumley paper.</p>",
        "id": 574389593,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771364222
    },
    {
        "content": "<p>Agreed on the scaling. On the second matter: the best explicit prime number theorems will give you the existence of primes between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">N+L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>â‰³</mo><mi>Ï€</mi><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">L\\gtrsim \\pi N/H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9592em;vertical-align:-0.2296em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">â‰³</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">Ï€</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> or so, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> is the height up to which you have verified RH. (You get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>Ï€</mi><mi>N</mi><mi mathvariant=\"normal\">/</mi><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">2\\pi N/H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">Ï€</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> from Chirre-Helfgott off-the-shelf, but perhaps one can lop off that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>.)  The uncertainty principle pays us a visit again.</p>\n<p>Of course then the question is up to where is it realistic to verify RH by formal means nowadays, bearing in mind that that's something in which it is worthwhile to sink resources, compared to a special-purpose computation.</p>",
        "id": 574391785,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1771365054
    }
]