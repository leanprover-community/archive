[
    {
        "content": "<p>I have now approved <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/774\">PNT#774</a> to import <a href=\"https://docs.leancert.io/\">LeanCert</a> into the project for verified numerical tasks, such as numerical integration.  However, we are moving certain computationally intensive LeanCert verifications (such as numerical upper and lower bounds on <code>li 2</code>) outside of the main PNT+ lean files to avoid excessive build times.  The initial building of LeanCert may take some time, but hopefully this will only need to be done once per mathlib bump.  Please let me know if there are any issues with excessively slow build times, or other issues related to this.</p>",
        "id": 571226678,
        "sender_full_name": "Terence Tao",
        "timestamp": 1769889679
    },
    {
        "content": "<p>It seems like that LeanCert can't really deal with inequalities involving the ceiling function, as shown in my PR: <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/980\">PNT#980</a>. In this PR I want to show the following two inequalities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⌈</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">59</span><span class=\"bp\">⌉₊</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">11325</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⌈</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">60</span><span class=\"bp\">⌉₊</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">7785131284000000000000000004</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>These two goals can't be automatically solved by <code>interval_decide</code>, so instead I first proved the following two inequalities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">59</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">11325</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">22</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- solved by interval_decide</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"mi\">60</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">7785131284000000000000000004</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- solved by interval_decide</span>\n</code></pre></div>\n<p>This might be something LeanCert could improve. Nevertheless, I am still quite impressed by this one-tactic proof of <code>Real.exp 59 + 4 + 1 ≤ 11325 * 10 ^ 22</code> produced by LeanCert.</p>",
        "id": 574039959,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1771220481
    },
    {
        "content": "<p>Added Nat.ceil preprocessing in <code>interval_decide</code>: goals like <code>⌈e⌉₊ + k ≤ n</code> are reduced to a real inequality (<code>e ≤ n - k</code>), then closed via <code>Nat.ceil_le</code> + <code>omega</code>.</p>\n<p>So with LeanCert’s tactic import, these should now solve with a single <code>interval_decide</code>.</p>",
        "id": 574366259,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1771355226
    },
    {
        "content": "<p>Summary of changes since the last pinned version:</p>\n<ul>\n<li>Chebyshev psi engine (<code>ChebyshevPsi.lean</code>): certified <code>ψ(N</code>) upper bounds via incremental von Mangoldt accumulation, generalized to arbitrary slopes. All bridge theorems fully proved.</li>\n<li>Dyadic backend optimizations: binary exponentiation, sign-based multiplication, Horner evaluation. Dyadic-first dispatch with inv/log fallback.</li>\n<li>interval_decide Nat.ceil support: handles goals involving <code>⌈e⌉₊</code> (used in <a href=\"https://github.com/AlexKontorovich/PrimeNumberTheoremAnd/pull/980\">PNT#980</a>).</li>\n<li>Expression reification: added abs, max, min, rational-exponent rpow.</li>\n<li>Warning fixes contributed by @ajirving.</li>\n</ul>\n<p>The general pattern for enumeration-based bounds: define a computable Bool checker, prove a bridge theorem (\"if checker returns true, the math holds\"), then native_decide runs it at native speed.</p>\n<p>The same approach could apply to other numerical verification tasks in the project, if the check is expressible as a decidable Bool computation, LeanCert can likely handle it</p>",
        "id": 574386251,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1771362928
    },
    {
        "content": "<p>There is a certain amount of python code in the LeanCert repository.  What precisely is the interaction between Lean and Python in LeanCert?  Is there any lean code that externally runs a Python script, for instance?</p>",
        "id": 574389008,
        "sender_full_name": "Terence Tao",
        "timestamp": 1771364020
    },
    {
        "content": "<p>No Lean code calls Python. The Python SDK is a discovery frontend: explore functions, find bounds, locate extrema interactively (lc.find_bounds(...), lc.verify_bound(...)), then write the actual Lean proof using the constants you found. </p>\n<p>The workflow is \"explore in Python → prove in Lean.\" The SDK calls a compiled Lean binary under the hood, none of it is in the import path or proof chain</p>",
        "id": 574390616,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1771364623
    },
    {
        "content": "<p>I wonder if splitting the repository into a pure lean one, and as downstream one for the python library would help here.</p>",
        "id": 574608000,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1771450425
    },
    {
        "content": "<p>That makes sense, will get it done this week!</p>",
        "id": 574622196,
        "sender_full_name": "Alejandro Radisic",
        "timestamp": 1771456838
    }
]