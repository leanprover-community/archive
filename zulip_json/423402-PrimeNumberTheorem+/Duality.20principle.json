[
    {
        "content": "<p>Do we have the duality principle for Hilbert operators in Mathlib? I may be missing it, but I can‚Äôt find it under an obvious name. Here is what I mean. Here is what I mean.</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> be Hilbert spaces, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>:</mo><mi>V</mi><mo>‚Üí</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">A : V \\to W</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> be a bounded linear operator. Then the operator norms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and its adjoint coincide: </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math display=\"block\" xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à•</mi><mi>A</mi><mi mathvariant=\"normal\">‚à•</mi><mo>=</mo><mi mathvariant=\"normal\">‚à•</mi><msup><mi>A</mi><mo>‚àó</mo></msup><mi mathvariant=\"normal\">‚à•</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\|A\\| = \\|A^*\\|.</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•</span><span class=\"mord mathnormal\">A</span><span class=\"mord\">‚à•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7387em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord\">‚à•.</span></span></span></span></span></p>\n<p>This is extremely useful in analytic number theory -- in particular, it underlies an entire family of proofs for the large sieve in different forms, to the point that some call it \"the principle of the large sieve\". For most applications in number theory, the finite-dimensional case suffices, but one doesn't need any assumption of finite-dimensionality in the proof.</p>\n<p>Has the duality principle been stated and proved in Lean? The basic language necessary for the task does seem to be there - I'm finding something called \"ContinuousLinearMap.norm_def\", for instance.</p>\n<p>For the sake of convenience, I‚Äôm attaching a screenshot from a draft of my book where the lemma is stated and proved, preceded by some definitions, all in a few lines. <br>\n<a href=\"/user_uploads/3121/Cabsnj7C2VGcfq9ID1_7HaaI/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Cabsnj7C2VGcfq9ID1_7HaaI/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"532x952\" src=\"/user_uploads/thumbnail/3121/Cabsnj7C2VGcfq9ID1_7HaaI/image.png/840x560.webp\"></a></div>",
        "id": 568626427,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768697392
    },
    {
        "content": "<p><del>is it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=innerSL_apply_norm#doc\">docs#innerSL_apply_norm</a></del></p>",
        "id": 568626514,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697508
    },
    {
        "content": "<p>is it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.adjoint#doc\">docs#ContinuousLinearMap.adjoint</a></p>",
        "id": 568626594,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697666
    },
    {
        "content": "<p>which is bundled as a star-linear isometry equiv</p>",
        "id": 568626600,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697682
    },
    {
        "content": "<p>That's the adjoint I mean, yes. The point is that the operator norm of the adjoint of an operator equals the operator norm of the operator itself.</p>",
        "id": 568626616,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768697717
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=norm_map#doc\">docs#norm_map</a></p>",
        "id": 568626633,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697743
    },
    {
        "content": "<p>because the <em>type</em> of <code>ContinuousLinearMap.adjoint</code> is star-linear isometry equiv, and all linear isometries preserve the norm</p>",
        "id": 568626707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697855
    },
    {
        "content": "<p>Is norm_map saying that the adjoint operator is an isometry, yes or no?</p>",
        "id": 568626708,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768697856
    },
    {
        "content": "<p>no, <code>norm_map</code> says isometries which preserve zero preserve the norm</p>",
        "id": 568626715,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697873
    },
    {
        "content": "<p><code>ContinuousLinearMap.adjoint</code> is defined as a star-linear isometry equiv</p>",
        "id": 568626732,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697908
    },
    {
        "content": "<p>so in particular it's automatically an isometry which preserves zero</p>",
        "id": 568626742,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697922
    },
    {
        "content": "<p>Right, then norm_map is not the statement we want. But are you saying that the statement is hidden in a type, because the adjoint map is defined as an isometry?</p>",
        "id": 568626751,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768697941
    },
    {
        "content": "<p>yes</p>",
        "id": 568626757,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697950
    },
    {
        "content": "<p>close enough</p>",
        "id": 568626760,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697958
    },
    {
        "content": "<p>if you have some Lean code I can fill in a <code>sorry</code></p>",
        "id": 568626770,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768697975
    },
    {
        "content": "<p>Ah, interesting. Sounds elegant, but I wish there were a way to highlight this. Wait, is this close enough or do we really have this? Or do you mean that we ought to have a  Lean statement saying exactly the same as the Lemma I posted, and that the proof would be a line or so - the Lemma would be a convenient wrapper for something that already exists?</p>",
        "id": 568626835,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768698074
    },
    {
        "content": "<p>this probably doesn't deserve its own lemma</p>",
        "id": 568626863,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698128
    },
    {
        "content": "<p>but it sounds like you were having trouble proving it so I offered to help if you have some code</p>",
        "id": 568626875,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698149
    },
    {
        "content": "<p>we do already have this it's a zero line proof</p>",
        "id": 568626911,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698217
    },
    {
        "content": "<p>I wasn't having trouble proving it (to be sincere: I was about to give a blueprint to Aristotle). I was just surprised that it didn't seem to be there. I do think it deserves to be easily findable by people who know it as \"the duality principle\". So, sure, a lemma with a zero-line proof and a telling name would be nice.</p>",
        "id": 568626932,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768698247
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 568626941,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768698268
    },
    {
        "content": "<p>oh no we're missing instances</p>",
        "id": 568627099,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698526
    },
    {
        "content": "<p>so the proof I have doesn't work</p>",
        "id": 568627106,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698530
    },
    {
        "content": "<p>But you can give a simple proof (even simpler than what I pasted) given what is there, right? Well, I guess that does mean the statement deserves its own Lemma :)</p>",
        "id": 568627245,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768698726
    },
    {
        "content": "<p>well it didn't end up being zero lines I guess</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">Adjoint</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ContinuousLinearMap</span><span class=\"bp\">.</span><span class=\"n\">norm_adjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚Äñ</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">adjoint</span><span class=\"bp\">‚Äñ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚Äñ</span><span class=\"n\">A</span><span class=\"bp\">‚Äñ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- can't use `_root_.norm_map` here because of missing instances</span>\n<span class=\"w\">  </span><span class=\"n\">SemilinearIsometryClass</span><span class=\"bp\">.</span><span class=\"n\">norm_map</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div>",
        "id": 568627327,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698878
    },
    {
        "content": "<p>the mathematical content of the proof is in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.adjointAux_norm#doc\">docs#ContinuousLinearMap.adjointAux_norm</a></p>",
        "id": 568627379,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1768698953
    },
    {
        "content": "<p>OK - thanks. I think it would be a service to everybody if this were included in Mathlib - I know it's just a wrapper, but it's now more transparent and immediately applicable.</p>",
        "id": 568627404,
        "sender_full_name": "Harald Helfgott",
        "timestamp": 1768699003
    },
    {
        "content": "<p>fwiw, <code>ContinuousLinearMap.adjoint.norm_map A</code> works as proof too</p>",
        "id": 568628139,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1768700091
    }
]