[
    {
        "content": "<p>The project has been quiet recently, but there has been some work happening: <span class=\"user-mention silent\" data-user-id=\"638899\">Lorenzo Luccioli</span>, <span class=\"user-mention silent\" data-user-id=\"243312\">Kexing Ying</span> and I have written parts of the blueprint, and in the next few days I will write Lean statements with <code>sorry</code> proofs and create tasks for those. It will be possible to claim those tasks on github, thanks to workflows that <span class=\"user-mention silent\" data-user-id=\"556875\">Pietro Monticone</span> added to the repository.</p>\n<p>Since I am no longer writing the blueprint alone, I think it's a good time to share a few tips on how to effectively do it. This is also useful information when you contribute a Lean proof: it's better to update the blueprint at the same time to indicate that the work is done.</p>\n<h3>General principles</h3>\n<p>The blueprint will be read by people who want to implement a new lemma from the blueprint in Lean, without having read everything that comes before, and who will be able to use only tools in Mathlib and introduced before in the blueprint.</p>\n<ul>\n<li>Extract many small lemmas. A theorem in a book will correspond to many statements in the blueprint.</li>\n<li>In proofs, refer explicitly to all other lemmas you use, with <code>\\ref{}</code>. The reader should not be expected to know well what has been proved so far, nor where to find it. Don't write \"since X has property P, [...]\", but \"since X has property P by Lemma~\\ref{lem:px}`, [...]\".</li>\n<li>Go from Mathlib (+ the current project state) to your goal. The proof you find in a book will use prerequisites that are not in Mathlib yet: you should describe those. Sometimes the book spends time explaining a lemma that is already proved in Mathlib: simply add a node for it with a <code>\\mathlibok</code> tag and don't repeat the proof.</li>\n<li>Write in a \"Mathlib-like\" way: don't write \"there is a set of measure zero <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> such that on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">N^c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span>,...\", instead write \"almost surely, ...\". It corresponds better to the code, and our goal is to produce code. This is particularly important for definitions.</li>\n<li>Make sure the dependency graph is right: use correctly <code>\\uses{}</code>, <code>\\leanok</code> and <code>\\mathlibok</code>. This is very important.</li>\n</ul>\n<h3>How to write definitions and lemmas</h3>\n<p>Here is an example of definition as it is written in the blueprint when not yet implemented in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"TeX\"><pre><span></span><code><span class=\"k\">\\begin</span><span class=\"nb\">{</span>definition<span class=\"nb\">}</span>[Localizing sequence]<span class=\"k\">\\label</span><span class=\"nb\">{</span>def:localizingSequence<span class=\"nb\">}</span>\n  <span class=\"k\">\\uses</span><span class=\"nb\">{</span>def:preLocalizingSequence<span class=\"nb\">}</span>\nA localizing sequence is a sequence of stopping times <span class=\"s\">$</span><span class=\"o\">(</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"o\">)</span><span class=\"nb\">_{n </span><span class=\"nv\">\\in</span><span class=\"nb\"> </span><span class=\"nv\">\\mathbb</span><span class=\"nb\">{N}}</span><span class=\"s\">$</span> such that <span class=\"s\">$</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"s\">$</span> is non-decreasing and <span class=\"s\">$</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n </span><span class=\"nv\">\\to</span><span class=\"nb\"> </span><span class=\"nv\">\\infty</span><span class=\"s\">$</span> as <span class=\"s\">$</span><span class=\"nb\">n </span><span class=\"nv\">\\to</span><span class=\"nb\"> </span><span class=\"nv\">\\infty</span><span class=\"s\">$</span> (a.s.).\nThat is, it is a pre-localizing sequence that is also almost surely non-decreasing.\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>definition<span class=\"nb\">}</span>\n</code></pre></div>\n<p>Important points:</p>\n<ul>\n<li><code>\\label{def:DefNameHere}</code>: the label of the definition, which will be used in <code>\\ref{}</code> and in <code>\\uses{}</code> later.</li>\n<li><code>\\uses{def:AnotherDef, def:AThirdDef}</code>: list here all the definitions (and possibly theorems) used in the new definition.</li>\n</ul>\n<p>Once the definition is implemented in Lean it becomes this:</p>\n<div class=\"codehilite\" data-code-language=\"TeX\"><pre><span></span><code><span class=\"k\">\\begin</span><span class=\"nb\">{</span>definition<span class=\"nb\">}</span>[Localizing sequence]<span class=\"k\">\\label</span><span class=\"nb\">{</span>def:localizingSequence<span class=\"nb\">}</span>\n  <span class=\"k\">\\uses</span><span class=\"nb\">{</span>def:preLocalizingSequence<span class=\"nb\">}</span>\n  <span class=\"k\">\\leanok</span>\n  <span class=\"k\">\\lean</span><span class=\"nb\">{</span>ProbabilityTheory.IsLocalizingSequence<span class=\"nb\">}</span>\nA localizing sequence is a sequence of stopping times <span class=\"s\">$</span><span class=\"o\">(</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"o\">)</span><span class=\"nb\">_{n </span><span class=\"nv\">\\in</span><span class=\"nb\"> </span><span class=\"nv\">\\mathbb</span><span class=\"nb\">{N}}</span><span class=\"s\">$</span> such that <span class=\"s\">$</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"s\">$</span> is non-decreasing and <span class=\"s\">$</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n </span><span class=\"nv\">\\to</span><span class=\"nb\"> </span><span class=\"nv\">\\infty</span><span class=\"s\">$</span> as <span class=\"s\">$</span><span class=\"nb\">n </span><span class=\"nv\">\\to</span><span class=\"nb\"> </span><span class=\"nv\">\\infty</span><span class=\"s\">$</span> (a.s.).\nThat is, it is a pre-localizing sequence that is also almost surely non-decreasing.\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>definition<span class=\"nb\">}</span>\n</code></pre></div>\n<p>We added <code>\\leanok</code> to mark it as done, and <code>\\lean{Full.Declaration.Name}</code> to link to the Lean definition. It's possible to list several Lean declarations in <code>\\lean{...}</code>, but most often there is only one.<br>\nIf the definition (or lemma) is in Mathlib, use <code>\\mathlibok</code> instead of <code>\\leanok</code>.</p>\n<p>An example of lemma which is not yet implemented:</p>\n<div class=\"codehilite\" data-code-language=\"TeX\"><pre><span></span><code><span class=\"k\">\\begin</span><span class=\"nb\">{</span>lemma<span class=\"nb\">}</span><span class=\"k\">\\label</span><span class=\"nb\">{</span>lem:localizingSequence<span class=\"nb\">_</span>min<span class=\"nb\">}</span>\n  <span class=\"k\">\\uses</span><span class=\"nb\">{</span>def:localizingSequence<span class=\"nb\">}</span>\nLet <span class=\"s\">$</span><span class=\"o\">(</span><span class=\"nv\">\\sigma</span><span class=\"nb\">_n</span><span class=\"o\">)</span><span class=\"nb\">, </span><span class=\"o\">(</span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"o\">)</span><span class=\"s\">$</span> be localizing sequences.\nThen <span class=\"s\">$</span><span class=\"o\">(</span><span class=\"nv\">\\sigma</span><span class=\"nb\">_n </span><span class=\"nv\">\\wedge</span><span class=\"nb\"> </span><span class=\"nv\">\\tau</span><span class=\"nb\">_n</span><span class=\"o\">)</span><span class=\"s\">$</span> is a localizing sequence.\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>lemma<span class=\"nb\">}</span>\n\n<span class=\"k\">\\begin</span><span class=\"nb\">{</span>proof<span class=\"nb\">}</span>\n  <span class=\"k\">\\uses</span><span class=\"nb\">{</span>lem:some<span class=\"nb\">_</span>other<span class=\"nb\">_</span>lemma, def:someDef<span class=\"nb\">}</span>\nDescribe the proof here. In this proof we use Lemma~<span class=\"k\">\\ref</span><span class=\"nb\">{</span>lem:some<span class=\"nb\">_</span>other<span class=\"nb\">_</span>lemma<span class=\"nb\">}</span> and introduce an object which is a someDef (Definition~<span class=\"k\">\\ref</span><span class=\"nb\">{</span>def:someDef<span class=\"nb\">}</span>).\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>proof<span class=\"nb\">}</span>\n</code></pre></div>\n<ul>\n<li>In the first <code>\\uses{...}</code>, in the lemma statement, list all the definitions used to <strong>state</strong> the lemma (not those used only in the proof).</li>\n<li>In the secont <code>\\uses{...}</code> in the proof, list all the definitions and theorems used in the proof.</li>\n</ul>\n<p>Once the lemma is stated in Lean, add a <code>\\leanok</code> to the statement and a <code>\\lean{}</code> to indicate the lemma name. Once the lemma is also proved, add a second <code>\\leanok</code> to the proof.<br>\nFor example, a lemma that is stated and proved in Mathlib will look like this:</p>\n<div class=\"codehilite\" data-code-language=\"TeX\"><pre><span></span><code><span class=\"k\">\\begin</span><span class=\"nb\">{</span>lemma<span class=\"nb\">}</span>[Doob's maximal inequality for <span class=\"s\">$</span><span class=\"nv\">\\mathbb</span><span class=\"nb\">{N}</span><span class=\"s\">$</span>]<span class=\"k\">\\label</span><span class=\"nb\">{</span>lem:maximal<span class=\"nb\">_</span>ineq<span class=\"nb\">}</span>\n  <span class=\"k\">\\uses</span><span class=\"nb\">{</span>def:Submartingale<span class=\"nb\">}</span>\n  <span class=\"k\">\\mathlibok</span>\n  <span class=\"k\">\\lean</span><span class=\"nb\">{</span>MeasureTheory.maximal<span class=\"nb\">_</span>ineq<span class=\"nb\">}</span>\nLet <span class=\"s\">$</span><span class=\"nb\">X : </span><span class=\"nv\">\\mathbb</span><span class=\"nb\">{N} </span><span class=\"nv\">\\rightarrow</span><span class=\"nb\"> </span><span class=\"nv\">\\Omega</span><span class=\"nb\"> </span><span class=\"nv\">\\rightarrow</span><span class=\"nb\"> </span><span class=\"nv\">\\mathbb</span><span class=\"nb\">{R}</span><span class=\"s\">$</span> be [...]\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>lemma<span class=\"nb\">}</span>\n\n<span class=\"k\">\\begin</span><span class=\"nb\">{</span>proof<span class=\"nb\">}</span><span class=\"k\">\\leanok</span>\n\n<span class=\"k\">\\end</span><span class=\"nb\">{</span>proof<span class=\"nb\">}</span>\n</code></pre></div>\n<p>We omitted the proof here, and that proof does not have a <code>\\uses{}</code> to refer to previous lemmas, because it's from Mathlib. Note that the proof environment with a <code>\\leanok</code> tag is important (even if the proof is empty) because if we don't have it, the dependency graph will show the lemma as not proved yet.</p>\n<h3>How to check your work</h3>\n<p>Rather that waiting for CI, it's handy to check the blueprint in local. First, you should have <a href=\"https://github.com/PatrickMassot/leanblueprint\">leanblueprint</a> installed. Then:</p>\n<ul>\n<li>Write your modifications to the blueprint</li>\n<li>run <code>leanblueprint all</code> in the project folder. If you get an error when compiling or in the <code>lake build</code> step, fix it. Then, look at the end of the log for an error like this:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">maximal_ineqd</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">missing</span><span class=\"bp\">.</span>\n<span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">lake</span><span class=\"w\"> </span><span class=\"n\">exe</span><span class=\"w\"> </span><span class=\"n\">checkdecls</span><span class=\"w\"> </span><span class=\"n\">blueprint</span><span class=\"bp\">/</span><span class=\"n\">lean_decls'</span><span class=\"w\"> </span><span class=\"n\">returned</span><span class=\"w\"> </span><span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">exit</span><span class=\"w\"> </span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"mf\">1.</span>\n</code></pre></div>\n<p>This means that you have a <code>\\lean{MeasureTheory.maximal_ineqd}</code> somewhere in your latex, but <code>MeasureTheory.maximal_ineqd</code> is not a Lean declaration imported by your project. Fix the lemma name or add an import.</p>\n<ul>\n<li>run <code>leanblueprint serve</code> and follow the link to look at the blueprint in local. Go to the dependency graph. Check that the dependency links between your new definitions and lemmas are right. Check that the colors of the nodes are right (see the graph legend for the color meanings).</li>\n</ul>",
        "id": 553820229,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762339625
    },
    {
        "content": "<p>Just to be sure: if we use a result that is in Mathlib, we should add the statement to the blueprint? I feel like this would require to add a lot of lemmas.</p>",
        "id": 554498250,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762623130
    },
    {
        "content": "<p>I've been adding definitions only.</p>",
        "id": 554498419,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762623260
    },
    {
        "content": "<p>You could add a link to the lemma in the Mathlib docs in the proof if you want.</p>",
        "id": 554498456,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762623289
    },
    {
        "content": "<p>In PR <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/264\">https://github.com/RemyDegenne/brownian-motion/pull/264</a>, I want to introduce a new type of nodes in the blueprint: lemmas that gather immediate properties of definitions.<br>\nThe explanation, copied from the PR:</p>\n<blockquote>\n<p>Some lemmas are about immediate consequences of definitions, and we don't want to have to track their uses in every downstream theorem when connecting the dependency graph. Currently they form a cloud of nodes in the graph that is seemingly not used by anything else (although they are).</p>\n<p>The tentative solution is, for a definition <code>def:definition</code> with many small such lemmas that are immediate consequences of the def, to create a fake lemma called <code>lem:definition_basic</code> which imports all of them. Then whenever we want to use the definition in the blueprint we instead import that lemma.<br>\nThe main benefit is a more legible, less cluttered dependency graph.</p>\n</blockquote>\n<p>This is an approach I used previously on my TestingLowerBounds project to get a clearer graph:<br>\n<a href=\"https://remydegenne.github.io/testing-lower-bounds/blueprint/dep_graph_document.html\">https://remydegenne.github.io/testing-lower-bounds/blueprint/dep_graph_document.html</a></p>",
        "id": 556833986,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1763387219
    },
    {
        "content": "<p>In the PR I do that for the right continuation of a filtration (for which we currently have a several lemmas that are not connected to anything downstream and are immediate from the def) and for right-continuous filtrations.</p>",
        "id": 556834226,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1763387288
    },
    {
        "content": "<p>The downside is of course that we lose the information of which lemma is or is not used exactly in further developments. But for lemmas that are trivial consequences of the definition we currently don't even think about mentioning their use downstream so we don't have that information anyway.</p>",
        "id": 556835556,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1763387640
    }
]