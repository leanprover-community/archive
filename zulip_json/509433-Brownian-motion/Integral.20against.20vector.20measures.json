[
    {
        "content": "<p>Browsing the internet I found <a href=\"/user_uploads/3121/QP15tGR9wEMrNgbhb9aPyxID/vector_integral.pdf\">vector_integral.pdf</a> about Dobrakov integral which seems to be quite general.</p>",
        "id": 532569639,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1754235519
    },
    {
        "content": "<p>yes, the monograph by Dinculeanu cited therein appears standard, although I'm no expert at all</p>",
        "id": 532573332,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754237484
    },
    {
        "content": "<p>I copied some files containing basic facts about integral against a (usual, <code>ENNReal</code>-valued) measure and am adapting them to <code>VectorMeasure</code><br>\n<a href=\"https://github.com/oliver-butterley/SpectralThm/pull/21/files\">https://github.com/oliver-butterley/SpectralThm/pull/21/files</a></p>\n<p>I translated most of APIs about simple functions and integrals of simple functions. The next will be L1 functions.</p>\n<p>Is this a right approach?</p>",
        "id": 533191513,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754522259
    },
    {
        "content": "<p>It seems to go smoothly, I don't know if everything works that well when we turn to integrable functions, but maybe! However I thought that we may want to develop not only an integral of a scalar function against a vector measure, but more generally of a vector-valued function against an operator-valued measure (that would be given for instance by Dinculeanu's work), and then deduce the former from the latter.</p>",
        "id": 533228285,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1754549542
    },
    {
        "content": "<p>Vector valued function and operator valued measure looks symmetry breaking to me: why not also operator valued function and vector measure? If you want to be really general, Id' say you want function taking value in <code>E</code>, vector measure taking value in <code>F</code>, and a bilinear map from <code>E x F</code>  to <code>G</code>? Unless there is something specific to the case you're referring to, where things work better than in the general situation?</p>",
        "id": 533228800,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754549823
    },
    {
        "content": "<p>No you're right it's with a bilinear map! I got confused because the first thing I looked at was only about operator-valued measures but then I looked at Dinculenau's work which indeed takes this more symmetrical approach.</p>",
        "id": 533229098,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1754549976
    },
    {
        "content": "<p>I see, so I guess the most general assumptions and basic definition will be the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">VectorMeasure</span><span class=\"w\"> </span><span class=\"n\">ContinuousLinearMap</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorMeasure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">ρ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorMeasure</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\" →ₛ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">SimpleFunc</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">setToVectorSimpleFunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→ₛ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">weightedVectorSMul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">SL</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map_add₂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map_smulₛₗ₂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→ₛ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">setToVectorSimpleFunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">weightedVectorSMul</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 533249520,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754557447
    },
    {
        "content": "<p>Yes that looks good!</p>",
        "id": 533250567,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1754557809
    },
    {
        "content": "<p>Does it really make sense to have a field <code>K</code> which is not the reals?</p>",
        "id": 533258011,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754560383
    },
    {
        "content": "<p>well, at least I would like also the complex numbers and I had in mind the case where <code>σ</code> is the conjugate. Should we use <code>RCLike</code> instead?</p>\n<p>Of course, when we define L1 funtions and prove that continuous functions are L1 etc., <code>K</code> and <code>G</code> will have to be complete spaces.</p>",
        "id": 533260112,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754561164
    },
    {
        "content": "<p>Complex-linear maps are also real-linear, and in particular the conjugation is also real-linear, so I'm not sure you would lose in generality by considering only real-linear maps.</p>",
        "id": 533260414,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754561270
    },
    {
        "content": "<p>wouldn't it be inconvenient when we want to prove that integral is complex-linear?</p>",
        "id": 533260736,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754561390
    },
    {
        "content": "<p>I don't think so. For instance, we already know that the usual integral for complex-valued functions is complex-linear, although it is first built as a purely real theory (see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=integral_smul_const#doc\">docs#integral_smul_const</a>)</p>",
        "id": 533261500,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754561674
    },
    {
        "content": "<p>ah ok, I was thinking more about multiplication by a scalar to the function but that is just the linearity of the bilinear form.</p>\n<p>I can switch to reals or <code>RCLike K</code> (I haven't even started), but I'm just wondering whether it wasn't the philosophy that we should make things as general as possible. Should I specialize to reals/<code>RCLike K</code> from the beginning or when I need it?</p>",
        "id": 533265790,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754563267
    },
    {
        "content": "<p>sorry, which is the natural way to consider a conjugate linear map as a <code>Real</code>-linear map?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→ₗ⋆</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→ₗ⋆</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"c1\">-- fails #check (f : E →ₗ[ℝ] E)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 533278549,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754568091
    },
    {
        "content": "<p>I don't know if we have a way in the library to do it transparently now, what I'm saying is that, mathematically, it's true that a complex conjugate linear map is a real linear map.</p>",
        "id": 533332938,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754586670
    },
    {
        "content": "<p>For the practical implementation of vector measure integrals using bilinear maps, as sketched above, using current Mathlib, I think you don't need to redo everything: the <code>setToL1</code> mechanism should also apply to this situation (it was designed to be very general). </p>\n<p>Let me be a little bit more precise. Suppose you have a vector-valued measure <code>mu</code> (with values in a space <code>E</code>), and a bilinear map <code>B : E -&gt;L[R] F -&gt;L[R] G</code>. Then you get a function <code>T : Set alpha -&gt; F -&gt;L[R] G</code>, mapping <code>s</code> and <code>x</code> to <code>B (mu s) x</code>. If you check the property <code>hT : DominatedFinMeasAdditive μ.totalVariation T C</code> (where <code>mu.totalVariation</code> is the positive measure given by the total variation of <code>mu</code>), then <code>setToL1 hT</code> associates to an integrable function <code>f</code> for <code>mu.totalVariation</code> an element of <code>G</code>; this is the desired integral of  <code>f</code> with respect to the vector measure <code>mu</code> and the bilinear form <code>B</code>.</p>",
        "id": 533333779,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1754587084
    },
    {
        "content": "<p>Ah that was the intention of <code>setToL1</code>, I see! I will try then.</p>",
        "id": 533336218,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754588059
    },
    {
        "content": "<p>Of course I agree that mathematically a conjugate linear map is real linear. I will see how this can be automated</p>",
        "id": 533336430,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754588135
    },
    {
        "content": "<p>ok <code>vectorIntegral</code> defined.<br>\n<a href=\"https://github.com/oliver-butterley/SpectralThm/pull/21\">https://github.com/oliver-butterley/SpectralThm/pull/21</a></p>",
        "id": 533367262,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1754603032
    },
    {
        "content": "<p><img alt=\":pr-open:\" class=\"emoji\" src=\"https://avatars.zulip.com/3121/emoji/images/6f19606a.png\" title=\"pr-open\"> I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/28499\">#28499</a></p>\n<p>I'm not sure how to proceed from here. There are a huge amount of theorems about Bochner integral. Should we dulicate them all for vector measures? Or is there a better way?</p>",
        "id": 534721473,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1755298349
    },
    {
        "content": "<p>I think we will have to duplicate, because the assumptions have to be different (in one case, it's for functions integrable wrt mu, in the other one wrt the total variation measure associated to mu). However, normally the statement should have been stated cleanly for <code>SetToL1</code>, which means that there shouldn't be much proof duplication, just applying straight away the <code>SetToL1</code> results to the specific situation at hand.</p>\n<p>(And this should be done in another PR, because this one is already large enough :-)</p>",
        "id": 534833768,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1755448956
    },
    {
        "content": "<p>(Note also that your PR is stuck on <a href=\"https://github.com/leanprover-community/mathlib4/pull/26156\">#26156</a>, which is <code>awaiting-author</code>)</p>",
        "id": 534833843,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1755449050
    },
    {
        "content": "<p>Ah, do you mean that 'f' can be integrable with respect to a vector measure 'mu' and a bilinear pairing 'B' even though it is not integrable with respect to 'mu.variation' (e.g. when 'B = 0')?</p>\n<p>Yes, we should first get total variation merged.</p>",
        "id": 534854334,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1755475287
    },
    {
        "content": "<p>I created a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/30230\">#30230</a>  that depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/28499\">#28499</a>. The goal of this PR is to create an analogue file of  <code>Mathlib.MeasureTheory.Integral.Bochner.Basic.lean</code> for integrals against a vector measure with pairing. I mainly proved some results about linearity. That is, the integral is a linear operator on functions, bilinear forms, and vector measures, respectively. I need some help and advices from the community before making this PR open.</p>\n<ol>\n<li>As suggest in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28499\">#28499</a>, given a vector measure <code>μ</code>, a function <code>f</code>, and a pairing <code>B</code>, the notation for the integral of <code>f</code> against <code>μ</code> and <code>B</code> is <code>∫ x, B (f x) ∂μ</code>. I am not sure how I should create this notation because I am not familiar with the notation3 function and I don't know how to determine the correct precedence level in the notation.</li>\n<li>Similarly, if we have<code>Bμ: VectorMeasureWithPairing α E F G</code> (where <code>α</code> is the underlying measure space and <code>E,F,G</code> are normed vector spaces over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, this type is also defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/28499\">#28499</a>), which is the bundled version of <code>(B : E →L[ℝ] F →L[ℝ] → G) (μ : VectorMeasure α F)</code>, I want to create a notation to represent the integral of <code>f</code> against <code>Bμ</code>. Here are some possible candidates:  <code>∫  x, ∂ Bμ f x</code> and <code>∫  x, f x ∂Bμ</code>. Temporarily I am using the second one in my draft PR. This create troubles because it is the same notation for integrals against a scalar measure, which is also why I want a different notation. Also the notation I suggested may not be the most natural/suitable one, so feel free to share your thoughts here. </li>\n<li>I want to prove that for a real number <code>r</code> and an <code>E</code>-valued vector measure<code>μ</code>, <code>(r• μ).variation=|r| • (μ.variation)</code>. However, <code>|r| • (μ.variation)</code> cannot be defined. I think this is because <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/VectorMeasure/Basic.html#MeasureTheory.VectorMeasure.instSMul\">MeasureTheory.VectorMeasure.instSMul</a> requires <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/ConstMulAction.html#ContinuousConstSMul\">ContinuousConstSMul</a>, and we are missing the instance <code>ContinuousConstSMul ℝ≥0 ℝ≥0∞</code>. I want to make a PR to add this instance into Mathlib.</li>\n<li>I also realized that the above lemma should work in a more general case.  That is, if I have an action <code>f : R -&gt; E -&gt; F</code>, an element <code>r : R</code> and an <code>E</code>-valued vector measure <code>μ</code>, I should be able to define an <code>F</code>-valued vector measure <code>(r• μ)</code>. For instance, I can multiply a <code>NNReal</code>-valued measure with a complex number to obtain a complex measure. However, I am not sure what type classes I need in order to define this.</li>\n</ol>",
        "id": 543133747,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1759635438
    }
]