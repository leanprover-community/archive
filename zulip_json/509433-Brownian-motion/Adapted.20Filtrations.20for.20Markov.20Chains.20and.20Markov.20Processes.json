[
    {
        "content": "<p>This is not directly related to the Brownian Motion project but I figured this would be the best channel to post this since, a) this channel probably contains most of the people who have answers, b) it may be relevant to the project down the line, c) this may involve refactoring definitions important to the project. </p>\n<p>I have started thinking a little bit about formalizing Markov Chains and Markov Processes and I realized the definition of an Adapted filter requires a topology on the state space (and strong measurability). This makes sense for Martingales since you need to take expectations on the state space as part of the definition but is not necessary for Markov chains. Should we have <code>Adapted</code> and <code>StronglyAdapted</code>?  Is there a way to do this that avoids duplicating everything?</p>",
        "id": 563702867,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1765734366
    },
    {
        "content": "<p>I think it would make sense to have <code>StronglyAdapted</code> yes. I came across this a while ago: <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Measurable.20functions.2C.20natural.20filtration.20and.20adapted.20process/with/502370033\">#mathlib4 &gt; Measurable functions, natural filtration and adapted process</a></p>",
        "id": 563703169,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1765734726
    },
    {
        "content": "<p>Yes, this question has come up several times, and that's evidence we need both definitions.</p>",
        "id": 563704095,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1765735728
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32882\">#32882</a></p>",
        "id": 563709236,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1765742662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Adapted.20Filtrations.20for.20Markov.20Chains.20and.20Markov.20Processes/near/563702867\">said</a>:</p>\n<blockquote>\n<p>This is not directly related to the Brownian Motion project but I figured this would be the best channel to post this since, a) this channel probably contains most of the people who have answers, b) it may be relevant to the project down the line, c) this may involve refactoring definitions important to the project. </p>\n<p>I have started thinking a little bit about formalizing Markov Chains and Markov Processes and I realized the definition of an Adapted filter requires a topology on the state space (and strong measurability). This makes sense for Martingales since you need to take expectations on the state space as part of the definition but is not necessary for Markov chains. Should we have <code>Adapted</code> and <code>StronglyAdapted</code>?  Is there a way to do this that avoids duplicating everything?</p>\n</blockquote>\n<p>Did you ever get around to formalizing Markov processes? I want to prove the law of reflection for Brownian motion, and would greatly benefit from a theorem which says 'Markov implies strong Markov'. But this theorem holds at a high level of generality and requires appropriate definitions of the weak and strong Markov property.</p>",
        "id": 573986699,
        "sender_full_name": "Joris van Winden",
        "timestamp": 1771171384
    },
    {
        "content": "<p>No, partly because I got stuck on this issue <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Conditional.20Independence.20for.20Not.20Standard.20Borel.20Spaces/with/565861382\">#mathlib4 &gt; Conditional Independence for Not Standard Borel Spaces</a>  and wanted to come back to it once I had the opportunity to see what the consequences of generalising would be. I did work on it a bit and have some rough ideas but then got busy with other things.</p>",
        "id": 573988137,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1771172493
    },
    {
        "content": "<p>Do you mind if I give it a try? As a first attempt, I came up with the following definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">mΩ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n\n<span class=\"c1\">-- `MeasurableSpace` containing all information up to time `i`</span>\n<span class=\"c1\">-- same definition used in `Filtration.natural`, but with less restrictive assumptions</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">past</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- `MeasurableSpace` containing all information after time `i`</span>\n<span class=\"c1\">-- can alternatively be defined using `past` and `OrderDual`</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- past and future and conditionally independent given the present</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsMarkovProcess</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StandardBorelSpace</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsFiniteMeasure</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Measurable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CondIndep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">past</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hX</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap_le</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>",
        "id": 573992418,
        "sender_full_name": "Joris van Winden",
        "timestamp": 1771175889
    },
    {
        "content": "<p>I do not mind. Some comments: </p>\n<p>Firstly, I think one should first define a Markov Process with respect to a filtration (similar to how Martingales are already defined). See the first \"alternative formulation\" here: <a href=\"https://en.wikipedia.org/wiki/Markov_property\">https://en.wikipedia.org/wiki/Markov_property</a>. </p>\n<p>With regards to <code>Filtration.natural</code> and all similar things (like I did for adapted in the PR above) I think annoyingly we will just need to have strongly measurable and measurable versions. </p>\n<p>As I mentioned in the other thread I am not a huge fan of the StandardBorelSpace assumption but its probably fine to use it for now and then fix it later.</p>",
        "id": 573995330,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1771177612
    },
    {
        "content": "<p>Thanks! Could you explain why you prefer the definition w.r.t a filtration? For martingales I get that a filtration cannot be avoided since it is an intrinsic part of the definition, but for Markov processes this is not the case.</p>\n<p>In either case, I think it is important that the definition should be symmetric under time/order reversal, since a time-reversed Markov process is Markov. So any definition featuring a filtration should (annoyingly) probably also include a backwards filtration.</p>",
        "id": 573996734,
        "sender_full_name": "Joris van Winden",
        "timestamp": 1771178733
    },
    {
        "content": "<p>Why is it more intrinsic to martingales? One could only consider the natural filtration for martingales too. The more general definition allows you to say that it remains a Markov process with additional information.</p>",
        "id": 574001428,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1771183809
    },
    {
        "content": "<p>I see your point. I also checked the textbooks I am familiar with, and most of them use a definition of markovianity which includes a filtration. Still, it slightly bugs me that this definition breaks time-reversal symmetry.</p>",
        "id": 574003644,
        "sender_full_name": "Joris van Winden",
        "timestamp": 1771186245
    },
    {
        "content": "<p>Slightly related to this issue: I saw that random times were recently changed from <code>τ : Ω → ι</code> to <code>τ: Ω → WithTop ι</code>. But why shouldn't a random time be able to take the value <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">-\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">∞</span></span></span></span>?</p>\n<p>I could easily see this come up in the theory of random dynamical systems, where it is not uncommon for processes to have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> as the index set.</p>",
        "id": 574326272,
        "sender_full_name": "Joris van Winden",
        "timestamp": 1771343881
    }
]