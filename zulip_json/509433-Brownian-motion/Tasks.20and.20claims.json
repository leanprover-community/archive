[
    {
        "content": "<p>I am very happy that this project is happening! So if I understand correctly I can just claim a lemma from the blueprint here? If so I'll try lemma 1.10.</p>",
        "id": 523986698,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1749835579
    },
    {
        "content": "<p>Yes that's the idea!  Thanks for joining the project! The numbering might change as we add lemmas to the blueprint as needed, so it's better to specify the lemma name as well as the number. That's covInnerBilin_map</p>",
        "id": 523992571,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749838049
    },
    {
        "content": "<p>Feel free to claim larger parts (several lemmas at once) as well if you are experienced and have time to do it.</p>",
        "id": 523993553,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749838492
    },
    {
        "content": "<p>I'd like to claim lemmas 5.12 to 5.15 (<code>edist_chainingSequence</code> lemmas).</p>",
        "id": 523997619,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749840205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Status.20of.20the.20project/near/523997619\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim lemmas 5.12 to 5.15 (<code>edist_chainingSequence</code> lemmas).</p>\n</blockquote>\n<p>FYI I was taking a look at that section and as far as I can tell there is a discrepancy between the blueprint and the lean file where a bunch of the lemmas and definitions in the blueprint assume the covering set is contained in  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> (but the lean statements don't).</p>",
        "id": 524004044,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749843471
    },
    {
        "content": "<p>I'd like to claim Lemma 1.12 <code>covMatrix_map</code>.</p>",
        "id": 524004113,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1749843504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Status.20of.20the.20project/near/524004044\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Status.20of.20the.20project/near/523997619\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim lemmas 5.12 to 5.15 (<code>edist_chainingSequence</code> lemmas).</p>\n</blockquote>\n<p>FYI I was taking a look at that section and as far as I can tell there is a discrepancy between the blueprint and the lean file where a bunch of the lemmas and definitions in the blueprint assume the covering set is contained in  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> (but the lean statements don't).</p>\n</blockquote>\n<p>Add the assumption to the Lean statements wherever it is needed!</p>",
        "id": 524005847,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749844403
    },
    {
        "content": "<p>I'd like to claim Lemma 2.4 (lem:Indistinguishable.Modification). I've already started to play around with this and it seems that to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>ω</mi><mi mathvariant=\"normal\">∣</mi><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>ω</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>ω</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ ω | X _t (ω) = Y_t (ω) \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">)}</span></span></span></span> is measurable one needs that the diagonal is measurable. Which assumptions should we use to formalize this? </p>\n<p>Or am I being stupid overlooking something?</p>",
        "id": 524012317,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1749847748
    },
    {
        "content": "<p>Im going to work on the lemmas in <code>LogSizeBallSequence.lean</code></p>",
        "id": 524014070,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749848763
    },
    {
        "content": "<p>Actually, I'd like to extend the claim to include the other lemmas from chapter 2.</p>",
        "id": 524022411,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1749854489
    },
    {
        "content": "<p>I'll work on the two <code>scale_change</code> lemmas (5.35 and 5.36).</p>",
        "id": 524040913,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749877053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"605003\">Jonas Bayer</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Status.20of.20the.20project/near/524012317\">said</a>:</p>\n<blockquote>\n<p>I'd like to claim Lemma 2.4 (lem:Indistinguishable.Modification). I've already started to play around with this and it seems that to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>ω</mi><mi mathvariant=\"normal\">∣</mi><msub><mi>X</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>ω</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>Y</mi><mi>t</mi></msub><mo stretchy=\"false\">(</mo><mi>ω</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ ω | X _t (ω) = Y_t (ω) \\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">)}</span></span></span></span> is measurable one needs that the diagonal is measurable. Which assumptions should we use to formalize this? </p>\n</blockquote>\n<p>In my mind <code>Indistinguishable.Modification</code> was simply a <code>filter_upwards</code> application. Why do you need measurability of that set?</p>",
        "id": 524042434,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749879559
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">mΩ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀ᵐ</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">∂</span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"n\">filter_upwards</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"n\">hω</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hω</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>",
        "id": 524043161,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749880757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"605003\">@Jonas Bayer</span> there is currently no Lean file (and no formalized definitions or statements) for that chapter 2. Please create a new file.</p>",
        "id": 524043430,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749881036
    },
    {
        "content": "<p>Or I could do that now and formalize a few statements (with <code>sorry</code> proofs) if you prefer</p>",
        "id": 524043586,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749881175
    },
    {
        "content": "<p>I didn't know about <code>filter_upwards</code>, thanks! (I'm fairly new to the Measure theory API)</p>",
        "id": 524043597,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1749881190
    },
    {
        "content": "<p>If that's fine I'd also like to formalise the statements myself and then we can iterate if something is not very idiomatic for his API.</p>",
        "id": 524043700,
        "sender_full_name": "Jonas Bayer",
        "timestamp": 1749881306
    },
    {
        "content": "<p>Hi Everyone,<br>\nI am hoping to contribute but I realized I need to learn a bit about the MeasureTheory API. Is there a document which outlines its architecture or some brief intro to the main concepts around which the API is centered?</p>",
        "id": 524048901,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1749888647
    },
    {
        "content": "<p>Fantastic project! I'll start working on Lemma 3.3 / <code>centralMoment_two_mul_gaussianReal</code>.</p>",
        "id": 524082566,
        "sender_full_name": "Jérémy Scanvic",
        "timestamp": 1749927896
    },
    {
        "content": "<p>I'll have a look at the Kolmogorov condition distance bounds (lemmas 5.33 and 5.34).</p>",
        "id": 524109608,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749969955
    },
    {
        "content": "<p>Thanks everyone for all the work you are already putting into the project! I made the mistake of launching the project just before a week-end and I have little time to keep up with the progress right now, but I'll post an update tomorrow about what was already done and what is currently claimed.</p>",
        "id": 524110651,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749971610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> there is a short chapter in Mathematics in Lean: <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C13_Integration_and_Measure_Theory.html\">https://leanprover-community.github.io/mathematics_in_lean/C13_Integration_and_Measure_Theory.html</a><br>\nNote that this chapter talks about the Bochner integral but we will mostly use the Lebesgue integral.</p>\n<p>Apart from that I guess you can start proving something, and look at the docs (or leansearch, loogle, etc.) whenever you are missing a def?</p>",
        "id": 524110780,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1749971796
    },
    {
        "content": "<p>I'll have a go at lemmas 3.14 to 3.16, about gaussian characteristic function.</p>",
        "id": 524112745,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1749974357
    },
    {
        "content": "<p>I'll work on <code>lintegral_sup_rpow_edist_cover_of_dist_le</code> now (lemma 5.37)<br>\nEdit: next <code>lintegral_sup_rpow_edist_succ</code> (lemma 5.39)</p>",
        "id": 524124825,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1749987257
    },
    {
        "content": "<p>Is it fine to create an auxiliary file containing general API lemmas to be upstreamed to Mathlib later?</p>",
        "id": 524131399,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1749994462
    },
    {
        "content": "<p>Yes, please create one or more files for those. Ideally files with lemmas grouped by topics (like an ENNReal.lean file for generic ENNReal lemmas, etc.).</p>",
        "id": 524138632,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750001589
    },
    {
        "content": "<p>26 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"509433\" href=\"/#narrow/channel/509433-Brownian-motion/topic/Status.20of.20the.20project/with/523890159\">#Brownian motion &gt; Status of the project</a> by <span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span>.</p>",
        "id": 524138728,
        "sender_full_name": "Notification Bot",
        "timestamp": 1750001660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/524112745\">said</a>:</p>\n<blockquote>\n<p>I'll have a go at lemmas 3.14 to 3.16, about gaussian characteristic function.</p>\n</blockquote>\n<p>One unresolved question in my mind about that part of the blueprint is whether working with <code>covInnerBilin</code> would be better than <code>covMatrix</code>. The blueprint uses matrices but it might be easier to use the bilinear map formulation. Feel free to switch to whatever is more convenient.</p>",
        "id": 524141703,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750004435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/524141703\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/524112745\">said</a>:</p>\n<blockquote>\n<p>I'll have a go at lemmas 3.14 to 3.16, about gaussian characteristic function.</p>\n</blockquote>\n<p>One unresolved question in my mind about that part of the blueprint is whether working with <code>covInnerBilin</code> would be better than <code>covMatrix</code>. The blueprint uses matrices but it might be easier to use the bilinear map formulation. Feel free to switch to whatever is more convenient.</p>\n</blockquote>\n<p>I've been wondering about that, because it certainly is easier to manipulate the bilinear form directly as it does not require to use all the decomposition in bases machinery. So if you say it's ok then i'll probably switch to bilinear forms indeed.</p>",
        "id": 524143049,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750005735
    },
    {
        "content": "<p>In fact I just realized that we don't seem to have a definition for positive semi-definite bilinear form. I think I'll write an API for those because bilinear forms do seem nicer to me.</p>",
        "id": 524143748,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750006543
    },
    {
        "content": "<p>Thanks, Rémy for setting all this up, and for all the contributions already! I would like to work on <code>isProjectiveMeasureFamily_gaussianProjectiveFamily</code> (Lemma 4.9). <br>\nI have a realted question: There does not seem to be the notion of a (linear) _projection_ in mathlib, at least I cannot find one, which I find hard to believe. Am I missing something here?</p>",
        "id": 524154621,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750020493
    },
    {
        "content": "<p>In the context of that lemma, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Restrict.html#Set.restrict\">Set.restrict</a> should be the way to expressed the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>π</mi><mrow><mi>I</mi><mi>J</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\pi_{IJ}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.09618em;\">J</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> map described in the blueprint. Is that function what you meant by projection?</p>",
        "id": 524154901,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750020901
    },
    {
        "content": "<p>If you deal with finsets I'd rather recommend <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Pi.html#Finset.restrict\">Finset.restrict</a> because otherwise you can encounter some strange behaviour. If you are looking for idempotent linear maps, there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Projection.html#LinearMap.IsProj\">LinearMap.IsProj</a>.</p>",
        "id": 524155045,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750021145
    },
    {
        "content": "<p>The proof in the blueprint needs that function packaged as a <code>ContinuousLinearMap</code> (because that interacts well with Gaussians). I'm not sure that we have it with that type.</p>",
        "id": 524155151,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750021270
    },
    {
        "content": "<p>Do you mean for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Pi.html#Finset.restrict\">Finset.restrict</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Restrict.html#Set.restrict\">Set.restrict</a>? Or both? For the former I'm pretty sure we don't, for the latter I don't think either but I'm not sure.</p>",
        "id": 524155558,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750021833
    },
    {
        "content": "<p>Ah, thanks! I see there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Constructions.html#Pi.continuous_restrict\">Pi.continuous_restrict</a> showing continuity as well as <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Submodule/LinearMap.html#LinearMap.restrict\">LinearMap.restrict</a> showing linearity. Hope I can combine them to a <code>ContinuousLinearMap</code>.</p>",
        "id": 524156760,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750023149
    },
    {
        "content": "<p>I'll take on lemmas 3.19 (<code>integral_eval_pi</code>) to 3.25 (\"The covariance matrix of the standard Gaussian measure is the identity matrix.\").</p>",
        "id": 524270844,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750084447
    },
    {
        "content": "<p>Here is a sample of open tasks that are not claimed yet. Anyone can pick one!</p>\n<ul>\n<li><a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:integral_sup_dist_le_sum_rpow\">integral_sup_dist_le_sum_rpow</a> An application of Minkowski's inequality</li>\n<li><a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:internalCoveringNumber_eq_one_of_diam_le\">internalCoveringNumber_eq_one_of_diam_le</a> The covering number is 1 if the radius is larger than the diameter of the set</li>\n<li><a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:L_lt_top\">L_lt_top</a> A particular (slightly ugly) sum is finite</li>\n<li><a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-brownian.html#thm:ContinuousMap.borel_eq_iSup_comap_eval\">borel_eq_iSup_comap_eval</a> Two sigma-algebras (product sigma algebra and Borel sigma-algebra for the continuous functions with the compact-open topology) are equal. No detailed proof in the blueprint, but a link to a stackexchange question.</li>\n<li><a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:integral_div_dist_le_sum_integral_dist_le\">integral_div_dist_le_sum_integral_dist_le</a> Upper bound on the expectation of a ratio, obtained by cutting the space into pieces depending on the value of the denominator</li>\n</ul>\n<p>They are many other lemmas that are ready to be formalized below <code>integral_sup_dist_le_sum_rpow</code>, in the Kolmogorov-Chentsov proof.</p>",
        "id": 524274156,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750085413
    },
    {
        "content": "<p>I'll do <code>integral_sup_dist_le_sum_rpow</code>. <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>, is it acceptable to take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p \\ge 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> as a hypothesis to be able to apply Minkowski? It feels a lot stronger than the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">p&gt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> from the previous lemmas, but if I understand correctly, the final application will have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> natural anyway.</p>",
        "id": 524286431,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750089315
    },
    {
        "content": "<p>Thanks for raising the issue with the blueprint proof (and for the PR!). I'd like to keep the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">p &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> hypothesis. I looked at the original paper, and I don't see how they deal with the possibility of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> there.<br>\nFor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> we could apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Integral/MeanInequalities.html#ENNReal.lintegral_Lp_add_le_of_le_one\">ENNReal.lintegral_Lp_add_le_of_le_one</a>, which is similar but loses a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{1/p-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> factor. That turns into a factor 2 in the final inequality, which would need to be propagated everywhere but is probably not important. See the PR <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/57\">https://github.com/RemyDegenne/brownian-motion/pull/57</a></p>",
        "id": 524309260,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750096902
    },
    {
        "content": "<p>Sorry if I'm missing something obvious here, but do we get a suitable version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.lintegral_Lp_add_le_of_le_one#doc\">docs#ENNReal.lintegral_Lp_add_le_of_le_one</a> for an arbitrary finite sum? The simple induction proof I used to derive the <code>Finset.sum</code> version from the <code>add</code> version for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p \\ge 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> no longer works because we would get an additional factor of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{1/p - 1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1/</span><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> in every step of the induction. Looking at the proof, the factor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> seems to come from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.rpow_add_le_mul_rpow_add_rpow#doc\">docs#ENNReal.rpow_add_le_mul_rpow_add_rpow</a>, and if we use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.rpow_arith_mean_le_arith_mean_rpow#doc\">docs#ENNReal.rpow_arith_mean_le_arith_mean_rpow</a>, then the factor in the final result will be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>−</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">k - m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>.</p>",
        "id": 524319187,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750101278
    },
    {
        "content": "<p>Ah sorry you're right, my fix is not right either. I did that too quickly while trying to prepare dinner at the same time. I don't know then. I'll need to look at it more carefully. It corresponds to a step in the proof of lemma 6.2 in <a href=\"https://link.springer.com/article/10.1007/s10959-022-01207-8\">the paper</a></p>",
        "id": 524321201,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750102318
    },
    {
        "content": "<p>The solution might just be an alternative proof in the case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> (not to this lemma only, but to the next few lemmas as well) based on <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/MeanInequalitiesPow.html#Real.rpow_add_le_add_rpow\">Real.rpow_add_le_add_rpow</a>. It's getting late here but I'll investigate that tomorrow.</p>",
        "id": 524329833,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750106106
    },
    {
        "content": "<p>Yes that seems to work. In the end you can assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p \\ge 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> in the lemma you were proving and in the next two (which means that your current PR is already fine), and I am adding versions of these 3 lemmas that take a slightly different route for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p &lt; 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 524373095,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750137233
    },
    {
        "content": "<p>Awesome, thanks for the quick fix!</p>",
        "id": 524373683,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750137683
    },
    {
        "content": "<p>By the way you were right when you wrote that in the current project the only application is for p a natural number with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">p \\ge 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. We don't really need such a general Kolmogorov-Chentsov theorem for building the Brownian motion on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">R</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8972em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>, but we thought it would be nice to use the opportunity of that project to get a more general result.</p>",
        "id": 524373750,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750137739
    },
    {
        "content": "<p>Alessio Rondelli (not yet on zulip) and I claim <code>internalCoveringNumber_eq_one_of_diam_le</code>.</p>",
        "id": 524414336,
        "sender_full_name": "Lorenzo Luccioli",
        "timestamp": 1750154251
    },
    {
        "content": "<p>Claiming <code>lintegral_sup_rpow_edist_le_sum_rpow_of_le_one</code>.</p>",
        "id": 524508353,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750185293
    },
    {
        "content": "<p>I am claiming <code>isGaussian_multivariateGaussian</code>, since I need to get used to the API of <code>IsGaussian</code>.</p>",
        "id": 524603953,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750198014
    },
    {
        "content": "<p>The API of <code>IsGaussian</code> is very young and is missing important results. In particular in Mathlib there is API for the general Banach space case but no specializations to Hilbert spaces. Etienne added lemmas towards that in the project (In Gaussian/Gaussian.lean, notably). Don't hesitate to add supporting lemmas as the need arises.</p>",
        "id": 524640050,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750229579
    },
    {
        "content": "<p>I claim <code>lintegral_sup_rpow_edist_le_sum_of_le_one</code>(5.46)</p>",
        "id": 524653047,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750234828
    },
    {
        "content": "<p>and <code>lintegral_sup_rpow_edist_le_sum</code></p>",
        "id": 524654167,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750235238
    },
    {
        "content": "<p>and <code>lintegral_sup_rpow_edist_le_of_minimal_cover_of_le_one</code></p>",
        "id": 524658652,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750236823
    },
    {
        "content": "<p>and <code>lintegral_sup_rpow_edist_le_of_minimal_cover</code></p>",
        "id": 524659869,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750237250
    },
    {
        "content": "<p>I'm claiming <code>L_lt_top</code></p>",
        "id": 524662028,
        "sender_full_name": "Jérémy Scanvic",
        "timestamp": 1750237942
    },
    {
        "content": "<p>There is a small issue in the blueprint statement of <a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:integral_sup_rpow_dist_cover_rescale\">integral_sup_rpow_dist_cover_rescale</a>. There is a condition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo>≤</mo><mn>4</mn><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\delta \\le 4\\varepsilon_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\">4</span><span class=\"mord\"><span class=\"mord mathnormal\">ε</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> missing, which will require some adaptation at the point where the lemma is used. I am currently fixing the blueprint.</p>",
        "id": 524683313,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750245516
    },
    {
        "content": "<p>Is <code>variance_dual_stdGaussian</code> in the file <code>MultivariateGaussian</code> supposed to be used somewhere? I proved it because it was in the file but it does not appear in the blueprint nor anywhere else in the code. Should I add it to the blueprint?</p>",
        "id": 524691851,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750248640
    },
    {
        "content": "<p>I thought it would be useful for <code>isGaussian_stdGaussian</code>. That variance appears in the goal where I left a <code>sorry</code> in <code>isGaussian_stdGaussian</code>. But perhaps you already proved that one by another mean?</p>",
        "id": 524694375,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750249481
    },
    {
        "content": "<p>As for the blueprint, I'd add it if you use it for something.</p>",
        "id": 524694892,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750249652
    },
    {
        "content": "<p>Ok I see, in the blueprint there was the lemma giving the <code>charFun</code> of <code>stdGaussian</code> before (but it wasn't in the lean file), so I proved it too and then for <code>isGaussian_stdGaussian</code> I simply used <code>isGaussian_iff_gaussian_charFun</code> (I introduced a <code>ContinuousBilinForm</code> version of the inner product). I didn't realize that your comment before the <code>sorry</code> referred to <code>variance_dual_stdGaussian</code>.<br>\nIn the end I still proved <code>variance_dual_stdGaussian</code>, and to do so I wrote a few lemmas to prove that random variables defined on different probability spaces were independent once they were seen as random variables on the product space, which could be interesting for Mathlib. But I think the route using <code>charFun</code> instead of <code>charFunDual</code> is easier.</p>",
        "id": 524696735,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750250268
    },
    {
        "content": "<p>Well it sounds like you proved many interesting lemmas, and that's great! Sorry for the confusion.</p>",
        "id": 524697868,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750250610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/524683313\">said</a>:</p>\n<blockquote>\n<p>There is a small issue in the blueprint statement of <a href=\"https://remydegenne.github.io/brownian-motion/blueprint/chap-kolmogorov_chentsov.html#lem:integral_sup_rpow_dist_cover_rescale\">integral_sup_rpow_dist_cover_rescale</a>. There is a condition <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi><mo>≤</mo><mn>4</mn><msub><mi>ε</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\delta \\le 4\\varepsilon_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03785em;\">δ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\">4</span><span class=\"mord\"><span class=\"mord mathnormal\">ε</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> missing, which will require some adaptation at the point where the lemma is used. I am currently fixing the blueprint.</p>\n</blockquote>\n<p>I pushed the blueprint changes.</p>",
        "id": 524710995,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750254252
    },
    {
        "content": "<p>I claim lemma 5.7 about the covering of the unit interval.</p>",
        "id": 524768659,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750274000
    },
    {
        "content": "<p>I claim <code>integral_div_dist_le_sum_integral_dist_le</code></p>",
        "id": 524794361,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750287858
    },
    {
        "content": "<p>Claiming <code>integral_sup_rpow_dist_cover_rescale</code></p>",
        "id": 524815084,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750308589
    },
    {
        "content": "<p>17 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"509433\" href=\"/#narrow/channel/509433-Brownian-motion/topic/Suprema.20and.20subtypes/with/524816922\">#Brownian motion &gt; Suprema and subtypes</a> by <span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span>.</p>",
        "id": 524830021,
        "sender_full_name": "Notification Bot",
        "timestamp": 1750318207
    },
    {
        "content": "<p>Claiming <code>integral_sup_rpow_edist_le_of_minimal_cover_two</code>.</p>",
        "id": 524867557,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750333557
    },
    {
        "content": "<p>I claim <code>isGaussian_gaussianProjectiveFamily</code>, which is apparently a lemma in the code but does not correspond to anything in the blueprint. Well I prove that.</p>",
        "id": 524874434,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750335892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"572064\">@Peter Pfaffelhuber</span> in the PR <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/71\">https://github.com/RemyDegenne/brownian-motion/pull/71</a> I changed the definition of <code>gaussianProjectiveFamily</code> to use a map by a continuous linear equivalence instead of merely a measurable equivalence, since that interacts better with Gaussians.<br>\nThat's relevant for the task <code>isProjectiveMeasureFamily_gaussianProjectiveFamily</code> that you claimed.</p>",
        "id": 524882185,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750338420
    },
    {
        "content": "<p>I claim <code>finite_set_bound_of_edist_le</code></p>",
        "id": 525047954,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750428009
    },
    {
        "content": "<p>and <code>finite_set_bound_of_edist_le_of_le_diam'</code></p>",
        "id": 525050172,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750428727
    },
    {
        "content": "<p>I claim <code>lintegral_sup_rpow_edist_le_of_minimal_cover_two</code></p>",
        "id": 525184307,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750550292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525184307\">said</a>:</p>\n<blockquote>\n<p>I claim <code>lintegral_sup_rpow_edist_le_of_minimal_cover_two</code></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"223948\">@David Ledvinka</span> I have already claimed this! See my message from a few days ago.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/524867557\">said</a>:</p>\n<blockquote>\n<p>Claiming <code>integral_sup_rpow_edist_le_of_minimal_cover_two</code>.</p>\n</blockquote>",
        "id": 525193900,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750567817
    },
    {
        "content": "<p>Oops my apologies somehow I saw your claim before that and totally missed your recent one. No worries!</p>",
        "id": 525193938,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750567879
    },
    {
        "content": "<p>I think the current unfinished claims are those:</p>\n<ul>\n<li>Jérémy Scanvic: <code>L_lt_top</code></li>\n<li>Markus Himmel: <code>integral_sup_rpow_dist_cover_rescale</code>, <code>integral_sup_rpow_edist_le_of_minimal_cover_two</code></li>\n<li>Peter Pfaffelhuber: <code>isProjectiveMeasureFamily_gaussianProjectiveFamily</code></li>\n</ul>",
        "id": 525196997,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750572839
    },
    {
        "content": "<p>I claim <code>integral_id_multivariateGaussian</code></p>",
        "id": 525197347,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750573570
    },
    {
        "content": "<p>Question, given that all the characteristic functions are now available. Don't you think it would be beneficial to show how moments can be computed from the chatacteristic function using derivatives?</p>",
        "id": 525197663,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750574171
    },
    {
        "content": "<p>Yes, that would be generally useful.</p>",
        "id": 525198267,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750575231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525197347\">said</a>:</p>\n<blockquote>\n<p>I claim <code>integral_id_multivariateGaussian</code></p>\n</blockquote>\n<p>I'm also claiming the covariance and characteristic function of the multivariate Gaussian.</p>",
        "id": 525201008,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750580408
    },
    {
        "content": "<p>Would there be any harm to define <code>multvariateGaussian</code> on a general <code>Fintype</code> rather than on <code>Fin d</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">multivariateGaussian'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">PosSemidef</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">stdGaussian</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">toEuclideanCLM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝕜</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That way we would not need <code>gaussianProjectiveFamilyAux</code>, because the <code>gaussianProjectiveFamily</code> can be defined as a <code>multivariateGaussian</code>, I think.</p>",
        "id": 525203972,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750584963
    },
    {
        "content": "<p>I personally think it should be defined for an arbitrary fintype.</p>",
        "id": 525204638,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750586175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"572064\">Peter Pfaffelhuber</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525203972\">said</a>:</p>\n<blockquote>\n<p>Would there be any harm to define <code>multvariateGaussian</code> on a general <code>Fintype</code> rather than on <code>Fin d</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">multivariateGaussian'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">PosSemidef</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">stdGaussian</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">toEuclideanCLM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝕜</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That way we would not need <code>gaussianProjectiveFamilyAux</code>, because the <code>gaussianProjectiveFamily</code> can be defined as a <code>multivariateGaussian</code>, I think.</p>\n</blockquote>\n<p>That would still be a measure on a <code>EuclideanSpace</code>, and <code>gaussianProjectiveFamily</code> is a family of measures on product types: <code>Measure (I → ℝ)</code></p>",
        "id": 525204720,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750586333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525204638\">said</a>:</p>\n<blockquote>\n<p>I personally think it should be defined for an arbitrary fintype.</p>\n</blockquote>\n<p>I agree. We will need the squared root of a bilinear form to write a good def. I only found the squared root of a matrix.</p>",
        "id": 525204749,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750586378
    },
    {
        "content": "<p>Oh sorry I misread what Etienne wrote. I was reacting to what I imagined to be \"it should be defined for an arbitrary finite dimensional inner product space\".</p>",
        "id": 525204874,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750586568
    },
    {
        "content": "<p>I made the change from <code>Fin d</code> to <code>ι</code> in <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/87\">https://github.com/RemyDegenne/brownian-motion/pull/87</a></p>",
        "id": 525205062,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750586932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525204874\">schrieb</a>:</p>\n<blockquote>\n<p>Oh sorry I misread what Etienne wrote. I was reacting to what I imagined to be \"it should be defined for an arbitrary finite dimensional inner product space\".</p>\n</blockquote>\n<p>Not sure this is feasible. You have to worry about existence of such an object. I think you have to use show existence on some Euclidean Space, and map the measure from there.</p>",
        "id": 525205135,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1750587094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525204874\">said</a>:</p>\n<blockquote>\n<p>Oh sorry I misread what Etienne wrote. I was reacting to what I imagined to be \"it should be defined for an arbitrary finite dimensional inner product space\".</p>\n</blockquote>\n<p>This should not be too complicated either, we already have the links between matrices and continuous bilinear forms related to <code>PosSemidef</code> so defining the square root is straight forward.</p>",
        "id": 525206452,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750589293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> perhaps you want to claim <code>integral_sup_rpow_edist_le_of_minimal_cover_two_of_le_one</code> as well? It has a lot in common with <code>integral_sup_rpow_edist_le_of_minimal_cover_two</code> that you just proved.</p>",
        "id": 525307748,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750677314
    },
    {
        "content": "<p>Thanks, but I won't have much time in the next two weeks, so I won't claim any additional tasks right now.</p>",
        "id": 525310916,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1750678450
    },
    {
        "content": "<p>Ok, no problem. You proved a lot of lemmas from chapter 5 already! Thanks!</p>\n<p>Your work on the other lemma will simplify the task for the person who claims this one.</p>",
        "id": 525311508,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750678660
    },
    {
        "content": "<p>I added more details to the end of the blueprint, and wrote enough Lean statements to have an actual <a href=\"https://github.com/RemyDegenne/brownian-motion/blob/ecf487104bd29a5ab8e02c5d14a0877bb8886db1/BrownianMotion/Gaussian/BrownianMotion.lean#L41\">definition for the Brownian motion</a>, instead of the <code>sorry</code> that was there previously. So more tasks are available over there.<br>\nThe blueprint on the website will reflect the changes in around 1 hour.</p>",
        "id": 525311924,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750678805
    },
    {
        "content": "<p>I claim <code>integral_sup_rpow_edist_le_of_minimal_cover_two_of_le_one</code></p>",
        "id": 525320906,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750681894
    },
    {
        "content": "<p>I claim <code>lintegral_sup_cover_eq_of_lt_iInf_dist</code></p>",
        "id": 525341297,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750687709
    },
    {
        "content": "<p>If nobody has claimed it I'll try lemma 3.32 <code>IsGaussianProcess.modification</code>.</p>",
        "id": 525372697,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750697590
    },
    {
        "content": "<p>I will claim <code>finite_kolmogorov_chentsov</code></p>",
        "id": 525415379,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750717609
    },
    {
        "content": "<p>This theorem assumes that the entire set has bounded internal covering number whereas the theorem it relies on assumes the finite subset has bounded internal covering number. I took a look at the reference paper and as far as I can tell they seem to omit this technicality. At the top of page 1479 they \"assume\" the covering number bound assumption (1) also applies to the subset. Of course I think you can easily prove that with that assumption you can choose a C uniform over subsets (2 times the previous C passing through the external covering number). However I think the current formal statements need to be reworked a bit. (Unless I am missing something)</p>",
        "id": 525443167,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750742244
    },
    {
        "content": "<p>To be specific I think <code>HasBoundedInternalCoveringNumber (.univ : Set T) c d</code> implies <code>HasBoundedInternalCoveringNumber J  (2 * c) d</code> for <code>J : Set T</code></p>",
        "id": 525443294,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750742345
    },
    {
        "content": "<p>Yes good catch. Internal covering numbers are not monotone with respect to the set, but if we accept to pay a factor two it's fine (exercise 4.2.10 in the first edition of <a href=\"https://www.math.uci.edu/~rvershyn/papers/HDP-book/HDP-book.html\">https://www.math.uci.edu/~rvershyn/papers/HDP-book/HDP-book.html</a>; can't find it in the second edition). That might give a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> rather than a 2 though? It's still fine.</p>",
        "id": 525444954,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750743814
    },
    {
        "content": "<p>Oh yes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">2 ^ d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> sorry (forgot to distribute the power in the proof in my head). This is not a problem overall but I think it is possibly a little more of a pain for refactoring.</p>",
        "id": 525445657,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750744425
    },
    {
        "content": "<p>I'm making a blueprint PR to add the missing covering number lemmas.</p>",
        "id": 525449993,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750747014
    },
    {
        "content": "<p><a href=\"https://github.com/RemyDegenne/brownian-motion/pull/97\">https://github.com/RemyDegenne/brownian-motion/pull/97</a><br>\nIt has the new covering number lemmas, but it's still a draft because I want to also fix the constants everywhere. That means also changing the definition of L. <span class=\"user-mention\" data-user-id=\"761212\">@Jérémy Scanvic</span> that will impact the lemma <code>L_lt_top</code> for which you have a draft (it will change some constants, but not the structure of L, so that should not be too bad).</p>",
        "id": 525452131,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750748108
    },
    {
        "content": "<p>Changing the definition of L was not a big refactor, since we use its value in two lemmas only, and use it as a black box after that. I'm merging the PR in a few minutes, when CI is done.</p>",
        "id": 525454215,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750749079
    },
    {
        "content": "<p>I claim 6.3 (<code>map_sub_preBrownian</code>) and 6.4 (<code>isKolmogorovProcess_preBrownian</code>).</p>",
        "id": 525490168,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750762265
    },
    {
        "content": "<p>Current claims:</p>\n<ul>\n<li>Jérémy Scanvic: <code>L_lt_top</code></li>\n<li>Peter Pfaffelhuber: <code>isProjectiveMeasureFamily_gaussianProjectiveFamily</code></li>\n<li>David Ledvinka: <code>finite_kolmogorov_chentsov</code></li>\n<li>Etienne Marion: <code>map_sub_preBrownian</code> and <code>isKolmogorovProcess_preBrownian</code></li>\n</ul>",
        "id": 525490916,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750762536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525490168\">said</a>:</p>\n<blockquote>\n<p>I claim 6.3 (<code>map_sub_preBrownian</code>) and 6.4 (<code>isKolmogorovProcess_preBrownian</code>).</p>\n</blockquote>\n<p>For <code>map_sub_preBrownian</code>, you'll probably need describe the sum of two jointly gaussian random variables, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.covariance#doc\">docs#ProbabilityTheory.covariance</a></p>",
        "id": 525491509,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750762779
    },
    {
        "content": "<p>I claim 5.70, <code>finite_set_bound_of_dist_le_of_diam_le</code></p>",
        "id": 525520259,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750772002
    },
    {
        "content": "<p>and <code>finite_set_bound_of_dist_le_of_le_diam</code></p>",
        "id": 525584833,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750794562
    },
    {
        "content": "<p>I claim <code>internalCoveringNumber_subset_le</code> and <code>hasBoundedInternalCoveringNumber_subset</code></p>",
        "id": 525678274,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750846116
    },
    {
        "content": "<p>On the Kolmogorov-Chentsov side, several of our dark green nodes in the graph still depend on <code>sorry</code>, because of two lemmas that are not reflected by the blueprint: <code>exists_finset_card_eq_internalCoveringNumber</code> and <code>exists_finset_card_eq_packingNumber</code>, in the Continuity/CoveringNumber file.</p>\n<p>The quantity <code>internalCoveringNumber</code> is defined as an infimum of values in ENat, and <code>exists_finset_card_eq_internalCoveringNumber</code> states that the infimum is attained. <code>exists_finset_card_eq_packingNumber</code> is similar, for paking numbers and a supremum.</p>\n<p>So that's one more task someone could claim.</p>",
        "id": 525708162,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750856629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525490168\">said</a>:</p>\n<blockquote>\n<p>I claim 6.3 (<code>map_sub_preBrownian</code>) and 6.4 (<code>isKolmogorovProcess_preBrownian</code>).</p>\n</blockquote>\n<p>I claim 6.7 to 6.9 as well (<code>isHolderWith_brownian</code> -&gt; law of B_t).</p>",
        "id": 525710632,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750857322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/525708162\">said</a>:</p>\n<blockquote>\n<p>On the Kolmogorov-Chentsov side, several of our dark green nodes in the graph still depend on <code>sorry</code>, because of two lemmas that are not reflected by the blueprint: <code>exists_finset_card_eq_internalCoveringNumber</code> and <code>exists_finset_card_eq_packingNumber</code>, in the Continuity/CoveringNumber file.</p>\n<p>The quantity <code>internalCoveringNumber</code> is defined as an infimum of values in ENat, and <code>exists_finset_card_eq_internalCoveringNumber</code> states that the infimum is attained. <code>exists_finset_card_eq_packingNumber</code> is similar, for paking numbers and a supremum.</p>\n<p>So that's one more task someone could claim.</p>\n</blockquote>\n<p>I did those. I really wanted the other results to be sorry-free :)</p>",
        "id": 525775530,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750879488
    },
    {
        "content": "<p>With PR <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/103\">https://github.com/RemyDegenne/brownian-motion/pull/103</a>, <code>finite_kolmogorov_chentsov</code> is sorry-free. We are getting close to the end of the project!</p>",
        "id": 525775773,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750879616
    },
    {
        "content": "<p>On the Gaussian side, many lemmas that are green in the blueprint still depend on <code>sorry</code> but that's due to placeholder <code>sorry</code> that refer to things that are fully proved in Mathlib PRs.</p>",
        "id": 525776607,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750880018
    },
    {
        "content": "<p>Regarding <code>aemeasurable_brownian_apply</code>, I know that a continuous process can be written as a pointwise limit of measurable processes and is therefore measurable. But in the lean file it comes before <code>continuous_brownian</code>. Is there another (maybe easier to formalize) proof?</p>",
        "id": 525787440,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750884351
    },
    {
        "content": "<p>The order in the file does not mean anything. I listed some properties there without thinking about the proofs (and as you can see the blueprint for that part is lacking).</p>",
        "id": 525788130,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750884641
    },
    {
        "content": "<p>Actually the (a.e.-)measurability should be added to the conclusion of the four <code>exists_modification...</code> theorems: they are supposed to state that there exists a process (with a measurability condition) that is a modification and has additional properties.</p>",
        "id": 525837405,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750922117
    },
    {
        "content": "<p>Do you know if it’s possible to ensure true measurability? If not, my feeling is that it’s better to have BM to be measurable rather than a-e measurable, even if we only get almost sure continuity.</p>",
        "id": 525845298,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750924784
    },
    {
        "content": "<p>Yes, since we start from a measurable process (<code>preBrownian</code>) we will be able to get a measurable and continuous process (not just a.e).</p>",
        "id": 525848828,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750925935
    },
    {
        "content": "<p>I claim 5.80, the first theorem in the chain of results about existence of Hölder modifications.</p>",
        "id": 525849136,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1750926045
    },
    {
        "content": "<p>Nice! Indeed I see how you can get it from the construction. So instead of proving <code>aemeasurable_brownian</code> I can prove that <code>brownian.uncurry</code> is measurable with respect to the product sigma-algebra.</p>",
        "id": 525854253,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1750927736
    },
    {
        "content": "<p>I claim <code>countable_kolmogorov_chentsov</code></p>",
        "id": 525968788,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1750966210
    },
    {
        "content": "<p>We will need a lemma like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/UniformSpace/UniformEmbedding.html#Dense.uniformContinuous_extend\">Dense.uniformContinuous_extend</a>, but with <code>uniformContinuous</code> replaced with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/Holder.html#HolderWith\">HolderWith</a></p>",
        "id": 526066742,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751024863
    },
    {
        "content": "<p>I'll have a look</p>",
        "id": 526074593,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751027744
    },
    {
        "content": "<p>I think that the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/MetricSpace/HolderNorm.html#MemHolder\">MemHolder</a> for exponent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> implies MemHolder for exponent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">0 &lt; a &lt; b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6835em;vertical-align:-0.0391em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> is also missing from Mathlib (and will be needed).</p>",
        "id": 526090454,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751032830
    },
    {
        "content": "<p>Isn’t this rather that if you are a and b Hölder and a &lt;= c &lt;= b then you are also c Hölder?</p>",
        "id": 526116966,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751041266
    },
    {
        "content": "<p>I forgot to mention an important assumption without which I think the result I want is false: the domain of the function is bounded.</p>",
        "id": 526124270,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751044154
    },
    {
        "content": "<p>I claim 6.12 (<a href=\"https://remydegenne.github.io/brownian-motion/docs/find/#doc/ProbabilityTheory.ContinuousMap.borel_eq_iSup_comap_eval\">ContinuousMap.borel_eq_iSup_comap_eval</a>)</p>",
        "id": 526187459,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751097806
    },
    {
        "content": "<p>Probably won't be able to work on this again until Monday but I am wondering what the status of whats left is. <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code> is partially done, are the sorrys unclaimed? Is there any sorrys in the lean not reflected in the blueprint or gaps in the blueprint that haven't fully been worked out? (and if you guys have it all worked out I can work on the \"bonus\" lemmas instead)</p>",
        "id": 526217483,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1751131593
    },
    {
        "content": "<p>I claim 5.13 (<code>volume_le_of_isCover</code>) and 5.14 (<code>exists_finset_card_eq_internalCoveringNumber</code>).</p>",
        "id": 526218755,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751132769
    },
    {
        "content": "<p>I also did 5.15 (<code>le_volume_of_isSeparated</code>). I claim 5.16 to 5.20.</p>",
        "id": 526228666,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751145133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223948\">@David Ledvinka</span> <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code> is unclaimed, and together with <code>internalCoveringNumber_smul</code> and <code>internalCoveringNumber_Ico_zero_one_le_one_div</code> that I introduced when doing a partial proof is as far as I can tell the only unclaimed lemma remaining on the path to the definition of the Brownian motion.<br>\nThe proof of <code>internalCoveringNumber_Ico_zero_one_le_one_div</code> should be very similar to the lemma <code>internalCoveringNumber_Icc_zero_one_le_one_div</code> proved by Etienne: the differences are Ico vs Icc and NNReal vs Real. Or it could be proved with the volume tools that Etienne is adding.</p>\n<p>The claims are:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>: the two remaining Hölder modification lemmas. One of them is partially done in <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/114\">https://github.com/RemyDegenne/brownian-motion/pull/114</a>.</li>\n<li><span class=\"user-mention\" data-user-id=\"572064\">@Peter Pfaffelhuber</span>: <code>isProjectiveMeasureFamily_gaussianProjectiveFamily</code></li>\n<li><span class=\"user-mention\" data-user-id=\"761212\">@Jérémy Scanvic</span>: <code>L_lt_top</code>. In progress at <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/66\">https://github.com/RemyDegenne/brownian-motion/pull/66</a></li>\n<li><span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span>: the lemmas relating volume and covering numbers. In progress at <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/116\">https://github.com/RemyDegenne/brownian-motion/pull/116</a></li>\n</ul>",
        "id": 526246615,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751173363
    },
    {
        "content": "<p>Update: the only two remaining lemmas on the path to the Brownian motion definition are <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code> (unclaimed) and <code>L_lt_top</code> (claimed by Jérémy).</p>",
        "id": 526586837,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751369496
    },
    {
        "content": "<p>I will claim <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code></p>",
        "id": 526665073,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1751395540
    },
    {
        "content": "<p>I'm not sure I'm going to be able to finish proving <code>L_lt_top</code>. I couldn't quite find my way through the existing mathlib lemma and I won't have much time to dig into it deeper in the next few weeks. If anyone wants to have a go at it feel free to do so!</p>",
        "id": 526672130,
        "sender_full_name": "Jérémy Scanvic",
        "timestamp": 1751398719
    },
    {
        "content": "<p>I will unclaim <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code> then and claim <code>L_lt_top</code></p>",
        "id": 526672628,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1751398943
    },
    {
        "content": "<p>I claim <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code></p>",
        "id": 526742047,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751443385
    },
    {
        "content": "<p>Done and merged.</p>",
        "id": 526769883,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751452400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/526672628\">said</a>:</p>\n<blockquote>\n<p>I will unclaim <code>isCoverWithBoundedCoveringNumber_Ico_nnreal</code> then and claim <code>L_lt_top</code></p>\n</blockquote>\n<p>As in Jérémy's draft PR, you'll need to add a hypothesis <code>EMetric.diam (Set.univ : Set T) ≠ ∞</code> that is currently missing from the statement. That hypothesis can be proved with <code>HasBoundedInternalCoveringNumber.diam_lt_top</code> at the point where we use the lemma.</p>",
        "id": 526770242,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751452537
    },
    {
        "content": "<p>I claim 6.12, independence of Brownian increments.</p>",
        "id": 526790837,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751459569
    },
    {
        "content": "<p>The main goal of the project is attained, but there are still a couple of things that could be done about the current code. Of course we could also think about extensions (prove more properties of the Brownian, define other related objects...) but for now I'll list a few things about the code we already have:</p>\n<ul>\n<li><del>the whole point of the measurability condition on pairs in the Kolmogorov process definition is to avoid a separability assumption on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>. We managed to do that for most of the proof, but for the 4 final results about the existence of Hölder continuous modifications I gave up and added a <code>SecondCountableTopology E</code> assumption. It would be nice to remove it and deal with the measurability proofs that will break in <code>exists_modification_holder_aux'</code> (in the KolmogorovChentsov file). The blueprint does not contain any details about that, and the paper we are following states that the measurability \"can be shown by standard arguments\".</del> Done.</li>\n<li><del>In the proof of that same lemma, I use convergence in measure, but I can't use the Mathlib definition because in Mathlib it uses <code>dist</code>, while we work in a <code>EMetricSpace</code> with <code>edist</code>. Perhaps we should refactor the Mathlib def?</del> Done.</li>\n<li>In Mathlib there is <code>HolderWith</code> and <code>HolderOnWith</code>, but there is only <code>MemHolder</code> and no <code>MemHolderOn</code>. The conclusion of our <code>exists_modification_holder_iSup</code> would be naturally written with the missing <code>MemHolderOn</code></li>\n<li>We have a lemma that gives the moment of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span> of a Gaussian on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>. For completeness it would be nice to have the moment of order <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> (which is zero).</li>\n<li><del>Etienne used <code>MeasurePreserving</code> to state that some random variable has a specified law, because it was easier to use than a condition about <code>Measure.map</code> (because of measurability?). The downside is that it is very obscure: when I read \"measure preserving\" I don't see easily that it's just giving a law. What do we do about that? How do we best talk about the laws of random variables?</del> Done.</li>\n<li>Our multivariate Gaussian is defined with a covariance matrix, which requires a basis. Do we want a definition that uses a continuous bilinear form?</li>\n<li>Can we prove that our Wiener measure is Gaussian? (when restricted to an interval, perhaps?)</li>\n<li>We are missing docstrings on several definitions, and many lemmas have weird names.</li>\n</ul>\n<p>If you think of something else, please mention it below!</p>\n<p>And there is also the most important task: PR to Mathlib.</p>",
        "id": 527276717,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1751718694
    },
    {
        "content": "<p>About measurePreserving, I introduced a predicate HasLaw in my PR about increments (not yet pushed though) which is the same but only requires aemeasurable instead of measurable, which I think is more suited to probability. The idea is to have a framework that is closer to what we do in paper maths, in particular avoid proving measurability all the time. I won’t have much time to work on it this week-end but it should be up next week.</p>",
        "id": 527277228,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1751719253
    },
    {
        "content": "<p>I like the idea of moving towards something like <code>HasLaw</code> and using type classes for properties of the law. I suggested something like this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25602\">#25602</a> (but didn't end up implementing it). Notice that with the current approach I had to add the more general <code>IndepFun.map_mul_eq_map_mconv_map₀'</code> as well as <code>IndepFun.map_mul_eq_map_mconv_map₀</code> because it would be annoying to pass a proof of the pushforward of the law being finite each time you use it. The reason you have to use finite measure here is because Sigma Finite is not preserved by push-forward (but sigma finiteness of the push-forward is all you need). Thus for example we could have a typeclass <code>SigmaFiniteLaw (X P)</code> and then prove in particular if <code>P</code> is a finite measure then its always an instance (hopefully all the type class inference works here). Then <code>IndepFun.hasLaw_mul</code> and <code>IndepFun.hasLaw_fun_mul</code> could be generalized to <code>SigmaFiniteLaw</code></p>",
        "id": 527780832,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1752014092
    },
    {
        "content": "<p>If we adopt an approach like this more widely its probably also worth thinking about how to integrate it with Kernels and conditional probability. Should we also have HasConditionaLaw (similar to <code>HasLaw</code> but with a kernel instead of a measure) or is there a way to have one definition for both that isnt too messy when you just want to use measures?</p>",
        "id": 527781253,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1752014361
    },
    {
        "content": "<p>We will probably need two definitions, but we can link the definition for measures to the one for kernels so that results proved for kernels can be used to easily get the analog for measures.</p>",
        "id": 527875535,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1752063448
    },
    {
        "content": "<p>I realized that with your <code>HasLaw</code> predicate you don't actually need separate type classes for properties of the law like I suggested above since you can just use the typeclasses for the law <code>μ</code> (which I think is evidence that this predicate is a good idea). I submitted a suggestion to your <code>HasLaw</code> PR that implements the above suggested generalization but without the need for a separate type class.</p>",
        "id": 531967823,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1753929769
    },
    {
        "content": "<p>I have a question on <code>preBrownian</code> in the <code>BrownianMotion.lean</code>. Isn't this usually called the _canonical process_? (See e.g. Definition 14.6 in the Klenke book). In particular, I do not see anything particular _Brownian_ about this definition.</p>",
        "id": 538203608,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1757332360
    },
    {
        "content": "<p>It's indeed the canonical process. It's called pre-Brownian here because on the particular probability space that we consider it has all the properties of the Brownian except for the continuity.</p>",
        "id": 538204634,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1757332610
    },
    {
        "content": "<p>Ok, true. As you say this is only true on the probability space <code>gaussianLimit</code>. Shouldn't we call is <code>canonicalProcess</code> (with more general index set and state space)? For example, this is an obvious generalization:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">hasLaw_canonicalProcess</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preBrownian</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">aemeasurable</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">measurable_pi_lambda</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">measurable_preBrownian</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">aemeasurable</span>\n<span class=\"w\">  </span><span class=\"n\">map_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">map_id</span>\n</code></pre></div>",
        "id": 538210880,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1757334247
    },
    {
        "content": "<p>Maybe related: in <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/134\">#134</a> (which is still draft, I didn't have time to clean it yet) I define an <code>IsPreBrownian</code> predicate as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsPreBrownian</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">volume_tac</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hasLaw</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gaussianProjectiveFamily</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>",
        "id": 538211994,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1757334551
    },
    {
        "content": "<p>Note also </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">preBrownian</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 538212173,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1757334595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/538211994\">schrieb</a>:</p>\n<blockquote>\n<p>Maybe related: in <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/134\">#134</a> (which is still draft, I didn't have time to clean it yet) I define an <code>IsPreBrownian</code> predicate as follows:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsPreBrownian</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">Ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">volume_tac</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hasLaw</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HasLaw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">restrict</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">ω</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">gaussianProjectiveFamily</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It can be proved that this is the same as <code>IsGaussianProcess</code> with a special expectation and covariance, right?</p>",
        "id": 538212878,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1757334775
    },
    {
        "content": "<p>Well <code>IsGaussianProcess</code> does not mention expectation and covariance, but yes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">IsPreBrownian</span><span class=\"bp\">.</span><span class=\"n\">isGaussianProcess</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsPreBrownian</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsGaussianProcess</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hasGaussianLaw</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsPreBrownian</span><span class=\"bp\">.</span><span class=\"n\">hasLaw</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hasGaussianLaw</span>\n</code></pre></div>",
        "id": 538215599,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1757335452
    },
    {
        "content": "<p>My claim would be that some statements in <code>BrownianMotion.lean</code> are still true when replacing <code>gaussianLimit</code> with any <code>projectiveLimit</code> (except those which rely on continuity, or on Gaussian distributions, of course).</p>",
        "id": 538217560,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1757335978
    },
    {
        "content": "<p>I created a few issues on the github repository: <a href=\"https://github.com/RemyDegenne/brownian-motion/issues\">https://github.com/RemyDegenne/brownian-motion/issues</a><br>\nThey are also visible on the project view: <a href=\"https://github.com/users/RemyDegenne/projects/1/views/1\">https://github.com/users/RemyDegenne/projects/1/views/1</a><br>\nEach issue contains a link to a lemma in the blueprint, and each of those blueprint lemmas have links to Lean statements with <code>sorry</code> proofs. The task for each issue is to prove that statement.</p>\n<p>Read the contributing guide to learn how to interact with those issues, in particular how to claim them: <a href=\"https://github.com/RemyDegenne/brownian-motion/blob/master/CONTRIBUTING.md\">https://github.com/RemyDegenne/brownian-motion/blob/master/CONTRIBUTING.md</a></p>\n<p>Please report anything unexpected with the issue claiming workflows. It's the first time we try them on this project.<br>\nI'll add more issues in the next days.</p>",
        "id": 554056871,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762426114
    },
    {
        "content": "<p>Can we solve several issues in one PR or is it better to open a PR for each issue?</p>",
        "id": 554171660,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762456786
    },
    {
        "content": "<p>I'm fine with one PR for both. Let's try it and see if the automated workflow allows it</p>",
        "id": 554173315,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762457316
    },
    {
        "content": "<p>Sure, you can claim multiple task issues and then <code>propose</code> the same <code>#PR_NUMBER</code> that should add the keywords “close #ISSUE1 … close #ISSUEn” linking all of them.</p>",
        "id": 554177564,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1762458629
    },
    {
        "content": "<p>In case it doesn’t currently work as expected you can write it manually or use the UI by just selecting all of them by clicking. Pretty quick either way.</p>",
        "id": 554177772,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1762458698
    },
    {
        "content": "<p>So I commented <code>propose #202</code> on <code>#198</code> and it moved in progress, but when I commented <code>awaiting-review</code> in <code>#202</code> it did not put <code>#198</code> in review.</p>",
        "id": 554190627,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762463578
    },
    {
        "content": "<p>New task: <a href=\"https://github.com/RemyDegenne/brownian-motion/issues/203\">https://github.com/RemyDegenne/brownian-motion/issues/203</a></p>",
        "id": 554272576,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762507091
    },
    {
        "content": "<p>Just wanted to indicate that I am working on defining the right continuation of a filtration and adding API lemmas to the blueprint and statements to prove in the code.</p>",
        "id": 554427436,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762555923
    },
    {
        "content": "<p>I thought a bit about the definition of the right continuation, and I'd like to have a definition that makes discrete filtrations right continuous, so that our theorems apply to both discrete and continuous settings. A way to do that would be to do something similar to <code>Function.rightLim</code>: if the point <code>i</code> is not isolated on the right, take the infimum <code>⨅ j &gt; i, 𝓕 j</code> as you are doing in <a href=\"https://github.com/RemyDegenne/brownian-motion/pull/207\">https://github.com/RemyDegenne/brownian-motion/pull/207</a>, but if it is isolated, then take <code>𝓕 i</code>. The right continuation of a filtration indexed by Nat is then the filtration itself. Also it we have a filtration indexed by [0, T], then the right continuation at T is <code>𝓕 T</code>.</p>",
        "id": 554462557,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762588349
    },
    {
        "content": "<p>With your current definition of right continuation (which is also implied by our previous definition of right continuous filtration), a Nat indexed filtration is right continuous only if it is constant.</p>",
        "id": 554462636,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762588431
    },
    {
        "content": "<p>You are right I didn’t think of that.</p>",
        "id": 554462692,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762588480
    },
    {
        "content": "<p>I’ll work on the part about class D/DL processes.</p>",
        "id": 554851390,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1762846589
    },
    {
        "content": "<p>I'm finishing the Doob Lp inequality blueprint and creating tasks.</p>",
        "id": 554876447,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1762855464
    },
    {
        "content": "<p>I added tasks about (auxiliary lemmas for) the Komlos lemma.</p>",
        "id": 556631189,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1763237214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> just added a new batch of tasks: <a href=\"https://github.com/RemyDegenne/brownian-motion/issues\">https://github.com/RemyDegenne/brownian-motion/issues</a>.</p>\n<p>We are having a hard time creating tasks fast enough to keep up with the speed of formalization! Thanks to everyone contributing proofs, it's going great.</p>\n<p>This reinforces the impression I had for the first part of the project that the bottleneck for this project is translating the maths into Lean statements (so mainly blueprint writing, and then a bit of translation work, or a lot of work when it comes to finding the right definition and generality). I also know that sometimes restraining oneself to write only statements and let others do the proofs is a bit frustrating, so I want to thank <span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> and <span class=\"user-mention\" data-user-id=\"243312\">@Kexing Ying</span> who have been working recently on the blueprint to produce tasks for others to work on, as well as <span class=\"user-mention\" data-user-id=\"638899\">@Lorenzo Luccioli</span> and <span class=\"user-mention\" data-user-id=\"930183\">@Alessio Rondelli</span> who wrote parts of the blueprint on Doob-Meyer and Doob's Lp inequality.</p>",
        "id": 556823993,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1763384441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/556823993\">said</a>:</p>\n<blockquote>\n<p>I also know that sometimes restraining oneself to write only statements and let others do the proofs is a bit frustrating</p>\n</blockquote>\n<p>I agree with this <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But it is also quite interesting to write the blueprint and somewhat satisfying to watch the structure of the project being constructed out of it.</p>",
        "id": 556825359,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1763384825
    },
    {
        "content": "<p>Some more tasks appeared!</p>",
        "id": 557896696,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1763463052
    },
    {
        "content": "<p>I am working on formalizing the entire section on simple processes: <a href=\"https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html\">https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html</a>. I decided to go with a bundled definition of <code>SimpleProcess</code> and <code>ElementaryPredictableSet</code>, and to change a general bilinear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> back to scalar multiplication in the definition of elementary stochastic integral.</p>",
        "id": 558906286,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1763915558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/558906286\">said</a>:</p>\n<blockquote>\n<p>I am working on formalizing the entire section on simple processes: <a href=\"https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html\">https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html</a>. I decided to go with a bundled definition of <code>SimpleProcess</code> and <code>ElementaryPredictableSet</code>, and to change a general bilinear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> back to scalar multiplication in the definition of elementary stochastic integral.</p>\n</blockquote>\n<p>Why did you remove the general bilinear map?</p>",
        "id": 558906741,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1763916020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/558906741\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/channel/509433-Brownian-motion/topic/Tasks.20and.20claims/near/558906286\">said</a>:</p>\n<blockquote>\n<p>I am working on formalizing the entire section on simple processes: <a href=\"https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html\">https://remydegenne.github.io/brownian-motion/blueprint/sect0005.html</a>. I decided to go with a bundled definition of <code>SimpleProcess</code> and <code>ElementaryPredictableSet</code>, and to change a general bilinear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> back to scalar multiplication in the definition of elementary stochastic integral.</p>\n</blockquote>\n<p>Why did you remove the general bilinear map?</p>\n</blockquote>\n<p>See <a class=\"stream-topic\" data-stream-id=\"509433\" href=\"/#narrow/channel/509433-Brownian-motion/topic/Definition.20of.20elementary.20stochastic.20integral/with/558907167\">#Brownian motion &gt; Definition of elementary stochastic integral</a></p>",
        "id": 558907189,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1763916494
    },
    {
        "content": "<p>If someone feels like figuring out how to add an upstreaming dashboard like <a href=\"https://alexkontorovich.github.io/PrimeNumberTheoremAnd/upstreaming\">this one</a> to our repository, that would be cool!</p>",
        "id": 570043353,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1769419604
    }
]