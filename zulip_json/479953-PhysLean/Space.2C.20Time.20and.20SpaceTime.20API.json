[
    {
        "content": "<p>Following on from the thread: </p>\n<p><a class=\"stream-topic\" data-stream-id=\"479953\" href=\"/#narrow/channel/479953-PhysLean/topic/Fourier.20Transform/with/528337978\">#PhysLean &gt; Fourier Transform</a> </p>\n<p>I thought it was worth having a dedicated thread for the API around Space, Time and SpaceTime, given their importance. (And also not to distract away from the original purpose of that thread). </p>\n<p>I now know of three things which it would be great to do with these APIs.</p>\n<ol>\n<li>Improve the documentation in the <code>PhysLean.SpaceAndTime.Space.Basic</code> module, to make it an entry point into the project. </li>\n<li>The definition of the type <code>Space d</code> is currently using an <code>abbrev</code>, but I think it might be better to have it as a <code>def</code>. This will require improving the API around <code>Space</code>, which can only be a good thing. </li>\n<li>Create a physics-orientated API around distributions (ideally so that people don't even know they are working with distributions).</li>\n</ol>\n<p>As a start to 1, I've made this small <a href=\"https://github.com/HEPLean/PhysLean/pull/641\">PR641</a>. Any help with any of these would be great.</p>",
        "id": 528338158,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1752239718
    },
    {
        "content": "<p>Curious what's the current status with this initiative? Looking at potentially contributing here</p>",
        "id": 529544038,
        "sender_full_name": "David Feng",
        "timestamp": 1752890547
    },
    {
        "content": "<p>Hey, so 1 &amp; 2 are still very much open, and would be great things to try and tackle! 3 is being discussed at <a class=\"stream-topic\" data-stream-id=\"479953\" href=\"/#narrow/channel/479953-PhysLean/topic/Normed.20dual.20of.20Schwarz.20space/with/529507042\">#PhysLean &gt; Normed dual of Schwarz space</a></p>",
        "id": 529556316,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1752906691
    },
    {
        "content": "<p>Following on somewhat, from the thread on units, but something which is more on topic for this thread: </p>\n<p>I've been thinking about what the type <code>Time</code> is in PhysLean, and how one should think about it.  As a result of this 'thinking' I think should modify the docstring to the <code>Time.Basic</code> file to be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Time</span>\n\n<span class=\"cm\">In this module we define the type `Time`, corresponding to time in a given</span>\n<span class=\"cm\">(but arbitary) set of units, with a given (but arbitary) choice of origin (time zero).</span>\n<span class=\"cm\">We note that this is the version of time most often used in undergraduate and</span>\n<span class=\"cm\">non-mathematical physics.</span>\n\n<span class=\"cm\">The choice of units or origin can be made on a case-by-case basis, as</span>\n<span class=\"cm\">long as they are done consistently. However, since the choice of units and origin is</span>\n<span class=\"cm\">left implicit, Lean will not catch inconsistencies in the choice of units or origin when</span>\n<span class=\"cm\">working with `Time`.</span>\n\n<span class=\"cm\">For example, for the classical mechanics system corresponding to the harmonic oscillator,</span>\n<span class=\"cm\">one can take the origin of time to be the time at which the initial conditions are specified,</span>\n<span class=\"cm\">and the units can be taken as anything as long as the units chosen for time `t` and</span>\n<span class=\"cm\">the angular frequency `ω` are consistent.</span>\n\n<span class=\"cm\">With this notion of `Time`, it becomes equivalent to the type `ℝ`, and inherits all the</span>\n<span class=\"cm\">instances of `ℝ`.</span>\n\n<span class=\"cm\">Within other modules e.g. `TopTime.Basic`, we define versions of time with less choices made.</span>\n\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 530549315,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1753359726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> I'd like to understand the high level goals of the Space API. Is the intention to abstract away from <code>EuclideanSpace ℝ (Fin d)</code> ? </p>\n<p>What would you see as an \"improvement\" to the Space API wrt item number 2 here?</p>",
        "id": 531020335,
        "sender_full_name": "David Feng",
        "timestamp": 1753572087
    },
    {
        "content": "<p>Ok, great question. </p>\n<p>The problem currently is that <code>Space d</code> is definitionally the same type as <code>EuclideanSpace ℝ (Fin d)</code>. The advantage of this, is that you get all the API that has been defined on  <code>EuclideanSpace ℝ (Fin d)</code> for free on <code>Space d</code>. But the (major) downside to this is that Lean is more than happy to treat an element of <code>EuclideanSpace ℝ (Fin d)</code> as an element of <code>Space d</code> and vice versa. </p>\n<p>This means if you define multiple things as equivalent to <code>EuclideanSpace ℝ (Fin d)</code>, like <code>ElectricField d</code> and <code>Space d</code>, you can treat terms of these types as terms of the other type (an electric field as a point in space etc). Mathematically this is fine, but physically it makes no sense. The idea of abstracting away from <code>EuclideanSpace ℝ (Fin d)</code> is to prevent such casting. </p>\n<p>There are other advantages too, if you abstract away from <code>EuclideanSpace ℝ (Fin d)</code> there is more freedom to give <code>Space d</code> the additional instances that makes physical sense , not just inherit everything from <code>EuclideanSpace ℝ (Fin d)</code>. </p>\n<p>This <a href=\"https://github.com/HEPLean/PhysLean/pull/658\">PR</a> did the analogous to (2) for <code>Time</code>. </p>\n<p>I should say, that I made a mistake in the statement of (2) really I think we want <code>Space d</code> to be defined like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Space</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But even turning it from a <code>abbrev</code> to a <code>def</code> gets half-way to doing this.</p>",
        "id": 531115251,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1753613277
    },
    {
        "content": "<p>That makes sense! I'm curious though what about the constructs from <code>EuclideanSpace ℝ (Fin d)</code> which the Space API makes use of currently?</p>\n<p>Perhaps I just need to get more familiar with encapsulation in Lean, but would we be able to choose to <em>only</em> expose the inner product from <code>EuclideanSpace</code>, for example?</p>\n<p>I imagine we wouldn't want to be completely redefining everything need from the underlying EuclideanSpace instance ,correct?</p>",
        "id": 531955194,
        "sender_full_name": "David Feng",
        "timestamp": 1753921413
    },
    {
        "content": "<p>I think we basically only use that it is an inner product space and the instances needed to define that inner-product space e.g. <code>Module</code>.. You can sometimes use <code>deriving</code> to expose certain instances on something defined through a <code>def</code>, but I'm not sure this works with <code>InnerProduct</code> or even <code>Module</code>. However, doing so does not prevent the casting issue I mentioned. </p>\n<blockquote>\n<p>I imagine we wouldn't want to be completely redefining everything need from the underlying EuclideanSpace instance ,correct?</p>\n</blockquote>\n<p>I think this can be solved by 1. defining an inner product structure on <code>Space d</code> using it's underlying <code>val</code>, and then defining an isometry equivalence between <code>Space d</code> and <code>EuclideanSpace ℝ (Fin d)</code>. Then everything on <code>EuclideanSpace ℝ (Fin d)</code> can be carried over to <code>Space d</code>  with use of this isometry.</p>",
        "id": 531982754,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1753938984
    },
    {
        "content": "<p>I should caveat this with: I understand that this is a design choice. And because it is a choice there isn't one correct answer for how things should be done. But I do think that the design choice using <code>structure</code> does have several advantages over using <code>abbrev</code> or <code>def</code> - but I'm always happy to hear counterarguments.</p>",
        "id": 531990794,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1753943265
    },
    {
        "content": "<p>This probably can wait, but I think it would be good to define type instance: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Space</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>To allow us to add elements of <code>EuclideanSpace (Fin d) ℝ</code> to <code>Space d</code> without weirdly casting things as Space.</p>",
        "id": 532253715,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754036307
    },
    {
        "content": "<p>I started work on rewriting <code>SpaceTime</code> as a structure with a <code>Time</code> component and a <code>Space</code> component (currently <code>SpaceStruct</code> while rewriting is happening), currently <code>SpaceTimeStruct</code> to not break everything.</p>\n<p>What I have so far is <a href=\"https://github.com/morrison-daniel/PhysLean/blob/spacetime_api/PhysLean/SpaceAndTime/SpaceTime/SpaceTimeStruct.lean\">here</a>. It has a few sorrys related to <code>SpaceStruct</code> not having a <code>Module</code> or <code>InnerProductSpace</code> instance. I pulled in some stuff from other files since they were relatively small.</p>\n<p>I wasn't sure what operations to put on it so I just implemented everything  I could by doing it on <code>Time</code> and <code>Space</code> separately. I'm not sure if we actually want all of them but I did it anyway. In particular I decided to add a regular inner product to <code>SpaceTime</code> which is the sum of the inner products on the <code>Time</code> and <code>Space</code> components, and then the Minkowski product is a bilinear form. I was kind of thinking ahead to wanting to define distributions on <code>SpaceTime</code> which currently requires a <code>NormedAddCommGroup</code> instance which in part needs <code>dist x y = 0</code> implies <code>x = y</code> which wouldn't be true of the Minkowski product so we need a separate inner product.</p>",
        "id": 533395604,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1754627687
    },
    {
        "content": "<p>Nice! Thank you for doing this. I think we will need the normal inner-product for the reasons you state. </p>\n<p>For the Minkowski product, I think it is best to define it in the same way it is done for <code>Lorentz.vector</code>, which is to </p>\n<ol>\n<li>define a <code>Tensorial</code> instance see <a href=\"https://github.com/HEPLean/PhysLean/blob/3c35be22030160ea0294254468cc49535c5d4cbc/PhysLean/Relativity/Tensors/RealTensor/Vector/Basic.lean#L101C1-L101C85\">here</a>. </li>\n<li>define it through index notation (see <a href=\"https://github.com/HEPLean/PhysLean/blob/master/PhysLean/Relativity/Tensors/RealTensor/Vector/MinkowskiProduct.lean\">here</a>). </li>\n</ol>\n<p>The <code>Tensorial</code> instance, will then give you, for free, an action of the Lorentz group on <code>SpaceTime</code>.</p>",
        "id": 533396319,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754628392
    },
    {
        "content": "<p>Also, for the causality stuff - thanks starting to reproduce that for <code>SpaceTime</code> - which I guess is the natural place for it to be defined, rather than <code>Lorentz.Vector</code>! :)</p>",
        "id": 533397042,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754629038
    },
    {
        "content": "<p>My other thought was that I would presume that we want to separate time derivatives from space derivatives, e.g. if we have coords t, x, y, z I wouldn't think we want a derivative in the t + x direction. Rather we want to relate  time derivatives and space derivatives so we don't actually want distributions on <code>SpaceTime</code>. Then again, I don't really know much about distributions so I could very well be way off.</p>",
        "id": 533398733,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1754630260
    },
    {
        "content": "<p>How much of the index notation do I need to understand in order to make a <code>Tensorial</code> instance? And where's the best place to start?</p>",
        "id": 533398862,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1754630376
    },
    {
        "content": "<p>My thought with the causality type stuff was it makes sense to condense it into a single file, at least for now so it's easier to see the state of things at a glace and then if it gets too big we can separate it out later.</p>",
        "id": 533398993,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1754630474
    },
    {
        "content": "<blockquote>\n<p>if we have coords t, x, y, z I wouldn't think we want a derivative in the t + x direction. Rather we want to relate time derivatives and space derivatives so we don't actually want distributions on <code>SpaceTime</code>.</p>\n</blockquote>\n<p>I think ideally one would want both. I think the way to think about it, is that things related to special relativity and the Lorentz group should be done via <code>SpaceTime</code> whilst non-relativistic things should be done via <code>Space</code> and <code>Time</code> kept separate. </p>\n<blockquote>\n<p>How much of the index notation do I need to understand in order to make a <code>Tensorial</code> instance? And where's the best place to start?</p>\n</blockquote>\n<p>You shouldn't need to know much -  if anything - all you need is to define a linear equivalence to the relevant Tensor space. But you could do this via defining a linear equivalence to <code>Lorentz.Vector</code> first and then composing that with the one defined in this <a href=\"https://github.com/HEPLean/PhysLean/blob/3c35be22030160ea0294254468cc49535c5d4cbc/PhysLean/Relativity/Tensors/RealTensor/Vector/Basic.lean#L101\">instance</a>.</p>",
        "id": 533408466,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754636755
    },
    {
        "content": "<p>Actually somewhat related, to what <span class=\"user-mention\" data-user-id=\"752663\">@David Feng</span>  is doing with <code>Space</code>, I think eventually we will want an instance of a <code>MulAction</code> of <code>SO(d)</code> on <code>Space</code>, like we should have an instance of the Lorentz group acting on <code>SpaceTime</code> (which will be inherited from the <code>tensorial</code> instance).</p>",
        "id": 533408605,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754636835
    },
    {
        "content": "<p>One question:</p>\n<p>What Is the long term plan with respect to  SpaceTime API  depending on Space d and Time ?</p>\n<p>I’m just wondering if we’d expect to run into any issues adding structure to SpaceTime  as more structure is adddd to the underlying  Space d</p>",
        "id": 533531865,
        "sender_full_name": "David Feng",
        "timestamp": 1754688976
    },
    {
        "content": "<p>Good point - so in practice I don't think it should cause any issues, but it  might make <span class=\"user-mention\" data-user-id=\"622397\">@Daniel Morrison</span> 's life a bit easier if <code>SpaceTime</code> isn't defined directly though <code>Space</code> and <code>Time</code>.  </p>\n<p>One thing about defining things through <code>Structure</code> is that the API around the definition becomes more important than the actual definition itself. Which should hopefully mean that small changes to the definition, shouldn't change it's usability if the API is kept up-to-date.</p>",
        "id": 533552038,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754712631
    },
    {
        "content": "<p>Honestly I feel the opposite, it's maybe more complicated to work on something in tandem with other people but the actual API is way easier to write. Most of what I wrote was unfold <code>SpaceTime</code> into the <code>Space</code> and <code>Time</code> components and apply the properties there. It also means that if we want to change how <code>Space</code> works  we can do that and not have to worry about changing all of <code>SpaceTime</code> to match.</p>",
        "id": 533555603,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1754717221
    },
    {
        "content": "<p>Ok, this makes sense, and you likely have a better understanding of what will work here than I do. I personally am happy either way :).</p>",
        "id": 533565131,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1754729280
    },
    {
        "content": "<p>Asking about the space refactor <a href=\"https://github.com/HEPLean/PhysLean/pull/819\">PhysLean#819</a> here:</p>\n<p>Obviously I'll have to look through it a bit more to understand what has actually changed, but would it be possible to outline the main conceptual changes?</p>\n<p>from what I understand this is a consequence of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27270\">#27270</a> (I don't really know how that works either), but what I'm really interested in is the <code>Space 1</code> in HarmonicOscillator has been replaced by <code>EuclideanSpace ℝ (Fin 1)</code>. I liked how the former implementation actually links to spatial coordinates, so is this a compromise that's necessary and do you mind explaining what works and what doesn't anymore?</p>",
        "id": 560375682,
        "sender_full_name": "ZhiKai Pong",
        "timestamp": 1764159392
    },
    {
        "content": "<p>The main reason for having <code>Space</code> as a structure is that it prevents casting from<code>EuclideanSpace ℝ (Fin 1)</code>, and allows us to be more flexible with how we work with it.  This change is a consequence of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27270\">#27270</a>, in as much as that this PR makes <code>EuclideanSpace ℝ (Fin 1)</code> more difficult to work with, and the advantages of having <code>Space</code> as just an abbreviation of <code>EuclideanSpace ℝ (Fin d)</code> (to me) no longer made sense. In most places within the project, making <code>Space</code> a structure actually shortens proofs. </p>\n<p>Concerning the change to the HarmonicOscillator. I changed from <code>Space 1</code> to <code>EuclideanSpace ℝ (Fin 1)</code>,  because this was the easiest thing to do to get something which would build. The main problem was that the derivative (i.e. velocity) of a function <code>Time -&gt; Space 1</code> is another function <code>Time -&gt; Space 1</code> not <code>Time -&gt; EuclideanSpace ℝ (Fin 1)</code>, as one would hope. This ended up breaking a lot of things, which could be fixed but would require careful refactoring. </p>\n<p>From the physics point of view, one <em>can</em> justify this change as follows (although I'm not advocating for this strongly): In PhysLean <code>Space d</code> is designed to be (what I would call) a worldvolume, that is it is the space on which fields, or trajectories, etc are defined. For example, in classical mechanics the worldvolume is <code>Time</code>, whilst in quantum field theory it is <code>SpaceTime d</code>. In physics examples called \"non-linear sigma models\" the worldvolume is any manifold M.</p>\n<p>In <code>Space 1</code>'s old use within the  HarmonicOscillator file it was not acting as a worldvolume but as a target space (or phase space) for the the trajectory (it appeared on the right side of the map <code>Time -&gt; Space 1</code>, not on the left side).  Treating <code>Space 1</code> as a worldvolume is a physically different quantity to it acting as a target space. Thus it's use in HarmonicOscillator is/was slightly erroneous in the first place. (To make this point further, if we had more then one particle, or the particle was restricted to a circle, the target space would not be <code>Space 1</code>, but something else).</p>",
        "id": 560387480,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1764162942
    },
    {
        "content": "<p>so for the vector fields with <code>Space -&gt; EuclideanSpace ℝ (Fin 3)</code> those are still correct, but it should never be the codomain of functions? (should I internalize it as the target space is a representation of the \"real\" <code>Space</code> but not actually the <code>Space</code>?) I have never thought about it this way before but I think it makes sense, thanks!</p>",
        "id": 560389135,
        "sender_full_name": "ZhiKai Pong",
        "timestamp": 1764163430
    },
    {
        "content": "<p>Yep, vector fields should be <code>Space -&gt; EuclideanSpace ℝ (Fin 3)</code>. </p>\n<blockquote>\n<p>(should I internalize it as the target space is a representation of the \"real\" <code>Space</code> but not actually the <code>Space</code>?)</p>\n</blockquote>\n<p>I think so - although I agree this is a bit tricky to get ones head around. The <code>Space 1</code> in the HarmonicOscillator is really the configuration space (I said phase space above, but think configuration space is more correct), a given configuration then physically corresponds to the particle been at a specific point in real space. (or something along those lines).</p>",
        "id": 560389990,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1764163671
    }
]