[
    {
        "content": "<p>IRight now, it is quite difficult computing <code>gradient f</code> as the API in mathlib is not well developed. I think <code>gradient</code> is not even the good primitive to work with. I made a <a href=\"https://github.com/HEPLean/PhysLean/pull/622\">PR622</a> that defines</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">   </span><span class=\"n\">adjFDeriv</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fderiv</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adjoint</span>\n</code></pre></div>\n<p>then we have <code>gradient f x = adjFDeriv ğ•œ f x 1</code> and working with <code>adjFDeriv</code> is easier as we can formulate composition theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">adjFDeriv_comp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DifferentiableAt</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DifferentiableAt</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">adjFDeriv</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">dy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">adjFDeriv</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adjFDeriv</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">dy</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>One difficulty when working with <code>gradient</code>/<code>adjFDeriv</code> is thatÂ <code>XÃ—Y</code>Â is not an inner product space so we have to work withÂ <code>WithLp 2 (XÃ—Y)</code>Â which does not have as well developed API. Part of the PR is to defineÂ <code>ProdL2 X Y := WithLp 2 (XÃ—Y)</code>Â and corresponding API to make our life easier.</p>\n<p>The PR is just a draft and there a bunch of <code>sorry</code>, any help would be appreciated. <br>\n<span class=\"user-mention\" data-user-id=\"890057\">@ZhiKai Pong</span> I think this PR would help you to do bunch of calculations you have been doing.</p>",
        "id": 525215109,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750601134
    },
    {
        "content": "<p>This PR is also necessary to derive Euler-Lagrange equations by using variational calculus.</p>",
        "id": 525215307,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750601383
    },
    {
        "content": "<p>I have been quite busy recently and haven't been following very closely on what you and Joseph are working on, but many thanks for those and I'll definitely go through them when I have time :)</p>",
        "id": 525216997,
        "sender_full_name": "ZhiKai Pong",
        "timestamp": 1750603711
    },
    {
        "content": "<p>Great! Somewhat related, I made <a href=\"https://github.com/HEPLean/PhysLean/pull/620\">PR620</a> a couple of days ago which relates <code>Space.grad</code> to <code>gradient</code>.</p>",
        "id": 525229170,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1750619875
    },
    {
        "content": "<p>I have significantly reworked how <code>adjoint</code> works. I really hate the situation with <code>XÃ—Y</code> vs <code>WithLp 2 (XÃ—Y)</code> so instead I have introduced the class</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">InnerProductSpace'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Normâ‚‚</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">Core</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Norm induced by inner is topologicaly equivalent to the given norm -/</span>\n<span class=\"w\">  </span><span class=\"n\">inner_top_equiv_norm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span>\n<span class=\"w\">    </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">â€¢</span><span class=\"w\"> </span><span class=\"bp\">â€–</span><span class=\"n\">x</span><span class=\"bp\">â€–^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">re</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">re</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">core</span><span class=\"bp\">.</span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">â€¢</span><span class=\"w\"> </span><span class=\"bp\">â€–</span><span class=\"n\">x</span><span class=\"bp\">â€–^</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which attaches inner product to normed space and requires that the norm induced by the inner product is topologically equivalent to the existing norm on the space. This way we can have inner product on <code>XÃ—Y</code> and not faff around with <code>WithLp</code>. For example, for <code>f : â„ â†’ â„ â†’ â„</code> we can write <code>adjFDeriv â„ â†¿f</code> and Lean will not complain that the is no instance <code>InnerProductSpace ğ•œ (â„Ã—â„)</code> as it does when we write <code>gradient â†¿f</code>.</p>\n<p>The only sorries are related to the topological equivalence between <code>X</code> equipped with its norm topology and the topology induced by the inner product.</p>",
        "id": 525237199,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750631704
    },
    {
        "content": "<p>How should I think of the difference between <code>InnerProductSpace'</code> and <code>InnerProductSpace</code>?<br>\nIs one more general than the other, or are they secretly equivalent?</p>",
        "id": 525257228,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1750656774
    },
    {
        "content": "<p>I added doc string to <code>InnerProductSpace'</code></p>\n<hr>\n<p>Effectively as <code>InnerProductSpace ğ•œ E</code> but it does not requires that <code>â€–xâ€–^2 = âŸªx,xâŸ«</code>. It is<br>\nonly required that they are equivalent <code>âˆƒ (c &gt; 0) (d &gt; 0), c â€¢ â€–xâ€–^2 â‰¤ âŸªx,xâŸ« â‰¤ d â€¢ â€–xâ€–^2</code>. The main<br>\npurpose of this class is to provide inner product space structure on product types <code>ExF</code> and<br>\npi types <code>Î¹ â†’ E</code> without using <code>WithLp</code> gadget.</p>\n<p>If you want to access Lâ‚‚ norm use <code>â€–xâ€–â‚‚ := âˆšâŸªx,xâŸ«</code>.</p>\n<p>This class induces <code>InnerProductSpace ğ•œ (WithLp 2 E)</code> which equips <code>â€–Â·â€–</code> on <code>X</code> with Lâ‚‚ norm.<br>\nThis is very useful when translating results from <code>InnerProductSpace</code> to <code>InnerProductSpace'</code><br>\ntogether with <code>toL2 : E â†’L[ğ•œ] (WithLp 2 E)</code> and <code>fromL2 : (WithL2 2 E) â†’L[ğ•œ] E</code>.</p>\n<p>In short we have these implications:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">InnerProductSpace'</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">E</span>\n<span class=\"w\">  </span><span class=\"n\">InnerProductSpace'</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The reason behind this type class is that with current mathlib design the requirement<br>\n<code>â€–xâ€–^2 = âŸªx,xâŸ«</code> prevents us to give inner product space structure on product type <code>EÃ—F</code> and pi<br>\ntype <code>Î¹ â†’ E</code> as they are equipped with max norm. One has to work with <code>WithLp 2 (EÃ—F)</code> and<br>\n<code>WithLp 2 (Î¹ â†’ E)</code>. This places quite a bit inconvenience on users in certain scenarios,<br>\nin particular the main motivation behind this class is to make computations of <code>adjFDeriv</code> and<br>\n<code>gradient</code> easy.</p>",
        "id": 525262568,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750660331
    },
    {
        "content": "<p>This makes sense! Thanks for the explanation.</p>",
        "id": 525264714,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1750661411
    },
    {
        "content": "<p>I really tried making <code>adjFDeriv</code> working with <code>WithLp</code> but it was really painful and I was constantly accidentally causing defeq abuse between <code>Xâ¨¯Y</code> and <code>WithLp 2 (XÃ—Y)</code>. If I can't get it right then there is no hope for beginners to get it right.</p>",
        "id": 525265528,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750661804
    },
    {
        "content": "<p>I would like to have <code>InnerProductSpace'</code> in mathlib and ideally <code>InnerProductSpace</code> just extends it and most of the results are formulated in terms of <code>InnerProductSpace'</code>. However, when I talked <a href=\"#narrow/channel/287929-mathlib4/topic/inner.20product.20on.20.60.E2.84.9D.C3.97.E2.84.9D.60.20and.20definition.20of.20.60InnerProductSpace.60/with/446144372\">about it</a> I did not get any meaningful response to the proposed change.</p>",
        "id": 525265814,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750661941
    },
    {
        "content": "<p>Yeah, I agree with the philosophy here. Anything that avoids defeq abuse or having to  worry about things being the correct type, I think is a massive benefits to usability - and is a massive turn-off using Lean when it's not done right.</p>",
        "id": 525267871,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1750662821
    },
    {
        "content": "<p>I think this is especially true for physicists where the tolerance for dealing with this type of thing is much lower than it is for mathematicians.</p>",
        "id": 525268102,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1750662931
    },
    {
        "content": "<p>Yeah, I feel that sometimes complains like that falls on deaf ears as people actually deciding on changing mathlib got used to lots of the idiosyncrasies.</p>",
        "id": 525268883,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750663291
    },
    {
        "content": "<p>My reading of the conversation about inner products was that Tomas said \"for what I'm doing the following set up would be good\" and the implicit response was \"for other projects doing different things this wouldn't be good\". But I might be misreading. Tomas never wants this max distance on a product but other people do</p>",
        "id": 525271430,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750664282
    },
    {
        "content": "<p>Maybe it's similar to how Tomas doesn't want to bundle things like group homomorphisms because they're inconvenient for FunProp but people doing other things think they're great. </p>\n<p>I think it's basically impossible to make one system which is perfect for everyone</p>",
        "id": 525271706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750664388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Computing.20.60gradient.60/near/525271706\">said</a>:</p>\n<blockquote>\n<p>I think it's basically impossible to make one system which is perfect for everyone</p>\n</blockquote>\n<p>Yeah I understand that and I use mathlib/Lean in a quite different way than most people so it makes sense I don't get my way and I try my best to find workarounds.</p>",
        "id": 525273900,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750665261
    },
    {
        "content": "<p>I agree that the inner product conversation just petered out though rather than people having a sensible discussion. Is there a way of taking it further e.g. making a PR or would this be very time-consuming?</p>",
        "id": 525274583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750665509
    },
    {
        "content": "<p>I will draft a PR to mathlib if I find the time. The core of it will be this PR to PhysLean but I'm not sure about the downstream effects/generalizations in mathlib.</p>",
        "id": 525275978,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750665998
    },
    {
        "content": "<p>In my head, gradients are the differential 1-form of a 0-form. I thought someone was working on differential forms but maybe both my premises are wrong.</p>",
        "id": 525331579,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1750685120
    },
    {
        "content": "<p>This you get already with <code>fderiv</code>,  for <code>f : X â†’ â„</code> you have <code>(fderiv â„ f x) : X â†’L[â„] â„</code> which is effectively 1-form.</p>",
        "id": 525332040,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750685227
    },
    {
        "content": "<p>The goal of gradient is also include the identification <code>(X â†’L[â„] â„) â‰ƒ X</code> given by inner product.</p>",
        "id": 525332238,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750685273
    },
    {
        "content": "<p>For example this expression often encountered in optimization <code>x + s â€¢ âˆ‡ f x</code> type checks only if <code>âˆ‡ f x</code> has the same type as <code>x</code> thus it can't be 1-form.</p>\n<p>Same for ODE <code>áº‹ = âˆ‡ f x</code>. It makes sense only if <code>x</code> has the same type as <code>âˆ‡ f x</code></p>",
        "id": 525332760,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750685405
    },
    {
        "content": "<p>Do we not normally do this via a Riemannian metric? But I know they don't quite exist in Mathlib yet.</p>",
        "id": 525334980,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1750685990
    },
    {
        "content": "<p>Well I'm doing everything only on vector spaces, so it needs inner product structure. But yes, on manifolds you need Riemannian metric.</p>",
        "id": 525335569,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1750686127
    }
]