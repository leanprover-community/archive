[
    {
        "content": "<p>I'm wondering what Euclidean/Minkowski spaces should look like in Lean and I gave a look to your repo. I noticed that you redefine <code>Space</code>, instead of using <code>EuclideanSpace</code>. Is there a particular reason to do this way?<br>\nPerhaps it would make sense to duplicate some code for Minkowski space, as one would not want the Euclidean inner product.</p>",
        "id": 575170846,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771775417
    },
    {
        "content": "<p>this is implemented in <a href=\"https://github.com/HEPLean/PhysLean/pull/819\">PhysLean#819</a></p>\n<p>Quoting <span class=\"user-mention\" data-user-id=\"653351\">@Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.2C.20Time.20and.20SpaceTime.20API/near/560387480\">here</a>:</p>\n<blockquote>\n<p>The main reason for having <code>Space</code> as a structure is that it prevents casting from<code>EuclideanSpace ℝ (Fin 1)</code>, and allows us to be more flexible with how we work with it. This change is a consequence of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27270\">#27270</a>, in as much as that this PR makes <code>EuclideanSpace ℝ (Fin 1)</code> more difficult to work with, and the advantages of having <code>Space</code> as just an abbreviation of <code>EuclideanSpace ℝ (Fin d)</code> (to me) no longer made sense. In most places within the project, making <code>Space</code> a structure actually shortens proofs.</p>\n</blockquote>\n<p>He can probably go through the implementation considerations and implications in more detail.</p>",
        "id": 575174331,
        "sender_full_name": "ZhiKai Pong",
        "timestamp": 1771778347
    },
    {
        "content": "<p>Will give a more detailed response tomorrow, but just to add for now that SpaceTime is Minkowski space. It carries a instance of the type class Tensorial which allows one to use index notation</p>",
        "id": 575177569,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771781308
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"890057\">@ZhiKai Pong</span> for the pointer. I see, you want to avoid <code>abbrev</code>.</p>\n<p>If that is the point, perhaps one can use type synonym? In this way you only need re-declare instances and not reprove theorems.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MyES</span><span class=\"bp\">.</span><span class=\"n\">toMyES</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">MyES</span><span class=\"bp\">.</span><span class=\"n\">toMyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"bp\">.</span><span class=\"n\">ofLp_injective</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyES</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">j</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 575179624,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771783456
    },
    {
        "content": "<p>(apparently you are doing something similar with <code>Lorentz.Vector</code>)</p>",
        "id": 575180363,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771784150
    },
    {
        "content": "<p>Basically to reiterate some of my points about, one could do:</p>\n<blockquote>\n<p>def MyES (d : ℕ) := EuclideanSpace ℝ (Fin d)`</p>\n</blockquote>\n<p>And this is initially how we had it in PhysLean. There were a number of reasons for the change to a structure: </p>\n<ol>\n<li>Changing to a structure prevents casting from <code> EuclideanSpace ℝ (Fin d)</code> to <code>Space</code> and vice-versa. Practically this prevents you from treating e.g. an electric field as a point in space, which would physically make no sense. So it acts as a type-check guard against incorrect statements. This is an argument against <code>def</code> as well as <code>abbrev</code>.</li>\n<li>Defining a structure lets you define exactly what you want for <code>Space</code> in terms of instances. I believe<code>def</code> does this as well. </li>\n<li>For  <code> EuclideanSpace ℝ (Fin d)</code> in particular, the need to use <code>WithLp.ofLp</code> and <code>WithLp.toLp</code> ended up getting too much, and actually making proofs longer then just defining a <code>structure</code>. </li>\n</ol>\n<p>More generally, I personally have found that defining a new <code>structure</code> is the way to go, and a lot of the times I haven't I have regretted it. In particular, I personally think we should be making <code>SpaceTime</code> a structure.</p>",
        "id": 575226434,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771823588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575226434\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Defining a structure lets you define exactly what you want for <code>Space</code> in terms of instances. I believe<code>def</code> does this as well.</li>\n</ol>\n</blockquote>\n<p>Are there any instances you want that don't coincide with the ones on EuclideanSpace?</p>",
        "id": 575227744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771824743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575226434\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>For <code>EuclideanSpace ℝ (Fin d)</code> in particular, the need to use <code>WithLp.ofLp</code> and <code>WithLp.toLp</code> ended up getting too much, and actually making proofs longer then just defining a <code>structure</code>.</li>\n</ol>\n</blockquote>\n<p>All you've done here is replace <code>ofLp</code> with <code>Space.val</code> and <code>toLp</code> with <code>Space.mk</code> though, right?</p>",
        "id": 575227778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771824776
    },
    {
        "content": "<blockquote>\n<p>Practically this prevents you from treating e.g. an electric field as a point in space</p>\n</blockquote>\n<p>Could you elaborate on this? Wouldn't an electric field have type <code>EuclideanSpace ℝ (Fin d) -&gt; ℝ</code>?</p>",
        "id": 575227886,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771824865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575227744\">said</a>:</p>\n<blockquote>\n<p>Are there any instances you want that don't coincide with the ones on EuclideanSpace?</p>\n</blockquote>\n<p>Indeed not, although one could imagine <code>Space</code> as an <code>AddTorsor</code> not a <code>Module</code>, although we haven't gone down this route yet. However, there is also the physical context that you want to apply to those instances through documentation, for example that the choice of a metric is akin to the choice of units. This (to me) is equally important as the actual definitions themselves.</p>\n<blockquote>\n<p>All you've done here is replace <code>ofLp</code> with <code>Space.val</code> and <code>toLp</code> with <code>Space.mk</code>though, right?</p>\n</blockquote>\n<p>There were some cases where the <code>simp only [...]</code> got reduced as well I think.</p>\n<blockquote>\n<p>Could you elaborate on this? Wouldn't an electric field have type <code>EuclideanSpace ℝ (Fin d) -&gt; ℝ</code>?</p>\n</blockquote>\n<p>An electric field should be <code>Space d -&gt; EuclideanSpace ℝ (Fin d)</code> (or in maths words, a section of the trivial vector-bundle  with base <code>Space d</code> and fiber <code>EuclideanSpace ℝ (Fin d)</code>). But in any, case there are many things in physics which take the form of <code>EuclideanSpace ℝ (Fin d)</code>, and from the point of view of physics you should not be able to cast between them.</p>",
        "id": 575228469,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771825347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575228469\">said</a>:</p>\n<blockquote>\n<p>for example that the choice of a metric is akin to the choice of units.</p>\n</blockquote>\n<p>But <code>Space</code> is explicitly endowed with the Euclidean metric, isn't it?</p>",
        "id": 575232988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771828727
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575228469\">said</a>:</p>\n<blockquote>\n<p>An electric field should be <code>Space d -&gt; EuclideanSpace ℝ (Fin d)</code></p>\n</blockquote>\n<p>Whoops, I of course was thinking of the potential</p>",
        "id": 575233064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771828810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575228469\">said</a>:</p>\n<blockquote>\n<p>although one could imagine <code>Space</code> as an <code>AddTorsor</code> not a <code>Module</code>, although we haven't gone down this route yet</p>\n</blockquote>\n<p>This seems like the most compelling argument to me; you could imagine a <code>WithoutOrigin M</code> type alias that just forgets the <code>0</code> of a module. I think I've discussed this with others in the past but it always seemed there was no compelling application. Probably if you go further down this route you should work with an abstract affine space in the first place.</p>",
        "id": 575233175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771828916
    },
    {
        "content": "<p>(having your spaces be distinct abstract types also ensures that there is no chance that you accidentally use one where the other should be)</p>",
        "id": 575233226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771828959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575228469\">said</a>:</p>\n<blockquote>\n<p>But in any, case there are many things in physics which take the form of <code>EuclideanSpace ℝ (Fin d)</code>, and from the point of view of physics you should not be able to cast between them.</p>\n</blockquote>\n<p>This doesn't seem to help much: there are infinitely many classes of vector in physics between which casting is nonsense, and having only two distinct buckets to assign them to does not seem materially better than having one.</p>",
        "id": 575233433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771829124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575232988\">said</a>:</p>\n<blockquote>\n<p>But <code>Space</code> is explicitly endowed with the Euclidean metric, isn't it?</p>\n</blockquote>\n<p><code>Space</code> is explicitly endowed with the Euclidean metric, that is something which takes two points in Space and returns a real number. To choose a specific metric from an equivalence class corresponds to a choice in units. </p>\n<p>But more generally, one of the aims of PhysLean is to include the physics context of a result as well as the mathematics context. The physics context is done through documentation strings and names and organization etc. In some cases it is necessary to repeat results in Mathlib so the correct physics context can be applied to it. I see the restating of the instances on <code>Space</code> here rather than <code>EuclideanSpace</code> as an instance of this. </p>\n<blockquote>\n<p>(having your spaces be distinct abstract types also ensures that there is no chance that you accidentally use one where the other should be)</p>\n</blockquote>\n<p>Indeed. </p>\n<blockquote>\n<p>This doesn't seem to help much: there are infinitely many classes of vector in physics between which casting is nonsense, and having only two distinct buckets to assign them to does not seem materially better than having one.</p>\n</blockquote>\n<p>I'm not sure where you got the 'two distinct buckets' from here. In theory (IMO - happy to be told otherwise), in PhysLean each distinct physical quantity should have a distinct definition so that the appropriate physics and mathematics context can be applied to the results.</p>",
        "id": 575241074,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771833313
    },
    {
        "content": "<p>Am I right in thinking that <code>Space</code> is morally <code>WithDimension length (EuclideanSpace _ _)</code>? I guess my point is that if your field vectors don't also get a dimension-specific type and continue to use EuclideanSpace, then you've only gone from \"everything is just a vector\" to \"everything is either a spacial vector or a non-spacial vector\".</p>",
        "id": 575244786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771834902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575241074\">said</a>:</p>\n<blockquote>\n<p>The physics context is done through documentation strings and names and organization etc. In some cases it is necessary to repeat results in Mathlib so the correct physics context can be applied to it.</p>\n</blockquote>\n<p>The docstring currently says:</p>\n<blockquote>\n<p>The type <code>Space d</code> represents <code>d</code> dimensional Euclidean space.</p>\n</blockquote>\n<p>which doesn't seem to apply any guidance as to the intended semantic difference between Space and EuclideanSpace.</p>",
        "id": 575245368,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1771835099
    },
    {
        "content": "<blockquote>\n<p>Am I right in thinking that <code>Space</code> is morally <code>WithDimension length (EuclideanSpace _ _)</code>? </p>\n</blockquote>\n<p>Strictly speaking <code>Space</code> is the type corresponding to a point in Space, with a given choice of origin, and a given choice of unit of length. Giving you the structure of a module on <code>Space</code>. (The <code>Time</code> module is probably has better documentation around this). Morally one could think of this as <code>WithDimension length (EuclideanSpace _ _)</code>, or as the type <code>EuclideanSpace _ _</code> carrying an instance of the dimension <code>length</code>.</p>\n<blockquote>\n<p>I guess my point is that if your field vectors don't also get a dimension-specific type and continue to use EuclideanSpace, then you've only gone from \"everything is just a vector\" to \"everything is either a spacial vector or a non-spacial vector\".</p>\n</blockquote>\n<p>Agreed, and I think this requires a refactor of the field vectors to give them dimension-specific types.</p>\n<blockquote>\n<p>which doesn't seem to apply any guidance as to the intended semantic difference between Space and EuclideanSpace.</p>\n</blockquote>\n<p>I agree, and this should be enhanced in the documentation.</p>",
        "id": 575248347,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771836217
    },
    {
        "content": "<p>Maybe we could improve the documentation on <code>Space d</code> too: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The type `Space d` is the world-volume which corresponds to</span>\n<span class=\"sd\"> `d` dimensional Euclidean space with a given (but arbitrary)</span>\n<span class=\"sd\">choice of length unit, and a given (but arbitrary) choice of zero.</span>\n\n<span class=\"sd\">The default value of `d` is `3`. Thus `Space = Space 3`-/</span>\n</code></pre></div>",
        "id": 575249190,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771836513
    },
    {
        "content": "<p>I also think it is important that we include the reasonings behind the design choice of <code>structure</code> in the repo. If anyone thinks they can articulate that in a better than I have, I would love to hear it.</p>",
        "id": 575249487,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771836616
    },
    {
        "content": "<p>I see, if you want to avoid casting, <code>def</code> is not good.</p>\n<p>If you really want to consider <code>Space</code> as the type of space points, <code>AddTorsor</code> (affine space) seems the right class. And I would say there should not be the <code>AddCommGroup</code> instance for <code>Space</code>, because (as you just wrote) the choice of <code>0</code> is arbitrary. Instead there should be the action of the metric-preserving subgroup of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineEquiv#doc\">docs#AffineEquiv</a> and <code>EuclideanSpace ℝ (Fin d)</code> should be isomorphic to a subgroup of it.</p>",
        "id": 575315407,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771858147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575315407\">ha scritto</a>:</p>\n<blockquote>\n<p>I see, if you want to avoid casting, <code>def</code> is not good.</p>\n<p>If you really want to consider <code>Space</code> as the type of space points, <code>AddTorsor</code> (affine space) seems the right class. </p>\n</blockquote>\n<p>I agree, but switching to AddTorsor without losing the ability to do calculus would require the upgrades to fderiv suggested in this <a href=\"#narrow/channel/287929-mathlib4/topic/Upgrade.20.60fderiv.60.20to.20.60AddTorsor.60/with/520208852\">discussion</a></p>",
        "id": 575319287,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1771859116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"382902\">Yoh Tanimoto</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575315407\">said</a>:</p>\n<blockquote>\n<p>I see, if you want to avoid casting, <code>def</code> is not good.</p>\n<p>If you really want to consider <code>Space</code> as the type of space points, <code>AddTorsor</code> (affine space) seems the right class. And I would say there should not be the <code>AddCommGroup</code> instance for <code>Space</code>, because (as you just wrote) the choice of <code>0</code> is arbitrary. Instead there should be the action of the metric-preserving subgroup of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineEquiv#doc\">docs#AffineEquiv</a> and <code>EuclideanSpace ℝ (Fin d)</code> should be isomorphic to a subgroup of it.</p>\n</blockquote>\n<p>Yeah, agreed. The next question is, given Matteo's comment, what is the best way to proceed? At the very least, I think the conversation here, should be linked to in the <code>Space</code> file and maybe add a <code>TODO</code> item related to eventually changing to <code>AddTorsor</code>.</p>",
        "id": 575329082,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771861412
    },
    {
        "content": "<p>I think one of the conditions that we had on changing to an <code>AddTorsor</code> is that it should be understandable to the average (non-mathematical) physicist, this will require careful documentation and potentially notation.</p>",
        "id": 575329601,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771861490
    },
    {
        "content": "<p>Indeed it would be good to expand the documentation to explain that the point <code>0</code> shouldn't play a special role, addition of space points does not make sense but only differences, and affine space is exactly the structure that forgets them.</p>",
        "id": 575332888,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771862300
    },
    {
        "content": "<p>Hopefully <a href=\"https://github.com/HEPLean/PhysLean/pull/959\">PhysLean#959</a> sufficiently conveys the idea - reviews welcome.</p>",
        "id": 575511843,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1771930677
    },
    {
        "content": "<p>I added suggestions.</p>\n<p>Next question. How should the Euclidean/Poincaré group be defined? In mathlib, there are <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/GeneralLinearGroup/Basic.html#LinearMap.GeneralLinearGroup\">LinearMap.GeneralLinearGroup</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup/Defs.html#Matrix.GeneralLinearGroup\">Matrix.GeneralLinearGroup</a>. The former is easy to implement the action on linear spaces, while the latter is useful for calculations. Maybe there should be similar two definitions for the Euclidean/Poincaré group?</p>",
        "id": 575608930,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1771955868
    },
    {
        "content": "<p>Many thanks <span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> . </p>\n<p>Do you think it would be an option to define them abstractly, and rely on a <code>MulAction</code> instance to do the heavy-lifting? This is (kind of) the approach taken with the Lorentz group.  I think this avoids the need for two definitions.</p>",
        "id": 575701057,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772001885
    },
    {
        "content": "<p>I think there is a good reason to define both, at least for mathlib: it is one thing to define the group of isometries of a given metric space (Euclidean/Minkowski), it is another to prove that it is isomorphic to the semidirect product of the Lorentz and translation groups (and time/parity inversion). Not sure which or both should be in PhysLean</p>",
        "id": 575732137,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772013278
    },
    {
        "content": "<p>I agree with this, and I think it is likely the way we should end up going.</p>",
        "id": 575733469,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772013635
    },
    {
        "content": "<p>I think this is something we should add to the requirements for the Euclidean group, which are detailed in this GitHub issue <a href=\"https://github.com/HEPLean/PhysLean/pull/940\">PhysLean#940</a></p>",
        "id": 575739194,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772015249
    },
    {
        "content": "<p>yes, and it is also important to define subgroups of the Lorentz/Poincaré/Euclidean groups, in particular the connected component of the unit element. <a href=\"https://physlean.com/docs/PhysLean/Relativity/LorentzGroup/Basic.html#LorentzGroup\">https://physlean.com/docs/PhysLean/Relativity/LorentzGroup/Basic.html#LorentzGroup</a> is the full Lorentz group, while often for representations we only consider the connected component.</p>",
        "id": 575759819,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772021780
    },
    {
        "content": "<p>I wonder if we could make these changes to <code>Space</code> now by replacing the <code>fderiv</code> with some other form of derivative in PhysLean - I am aware that this would be a large amount of work, but I think it would be nice at least make concrete plans to do this.</p>",
        "id": 575770521,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772025303
    },
    {
        "content": "<blockquote>\n<p>How should the Euclidean/Poincaré group be defined? In mathlib, there are <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/GeneralLinearGroup/Basic.html#LinearMap.GeneralLinearGroup\">LinearMap.GeneralLinearGroup</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup/Defs.html#Matrix.GeneralLinearGroup\">Matrix.GeneralLinearGroup</a>.</p>\n</blockquote>\n<p>Isn't the group already in mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIsometryEquiv.instGroup#doc\">docs#LinearIsometryEquiv.instGroup</a> ?</p>",
        "id": 575812122,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772035798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575812122\">said</a>:</p>\n<blockquote>\n<p>Isn't the group already in mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIsometryEquiv.instGroup#doc\">docs#LinearIsometryEquiv.instGroup</a> ?</p>\n</blockquote>\n<p>This is something I would call the \"full\" Euclidean group, when <code>E</code> is <code>EuclideanSpace ℝ (Fin d)</code>, which consists of rotations, translations but also reflections. The representation theory of the part containing rotations and translations can be studied using its Lie algebra, while reflections behave differently.</p>",
        "id": 575823024,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772038407
    },
    {
        "content": "<p>Now I am confused a bit though, since if we did want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIsometryEquiv.instGroup#doc\">docs#LinearIsometryEquiv.instGroup</a>, then this relies on our Euclidean space <code>Space d</code> having an instance of a <code>Module</code>, however above we argued that it shouldn't have a structure of a <code>Module</code>.</p>",
        "id": 575934151,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772083153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> I think an option here would be to define <code>FullEuclideanGroup</code> via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearIsometryEquiv.instGroup#doc\">docs#LinearIsometryEquiv.instGroup</a>, and then <code>EuclideanGroup</code> via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.connectedComponentOfOne#doc\">docs#Subgroup.connectedComponentOfOne</a></p>",
        "id": 575934540,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772083361
    },
    {
        "content": "<p>I assume then you'd instead want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineIsometryEquiv.instGroup#doc\">docs#AffineIsometryEquiv.instGroup</a></p>",
        "id": 575935341,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772083802
    },
    {
        "content": "<p>Great, thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> ! In fact I don't think there is anything stopping us defining a <code>NormedAddTorsor (EuclideanSpace ℝ (Fin d)) (Space d)</code> instance now, and then defining the Euclidean group now through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineIsometryEquiv.instGroup#doc\">docs#AffineIsometryEquiv.instGroup</a>.</p>",
        "id": 575936362,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772084393
    },
    {
        "content": "<p>(I think it would be bad to rely on the existing <code>NormedAddTorsor (Space d) (Space d)</code>instance, because I think this only makes sense because <code>Space d</code> is a <code>Module</code>).</p>",
        "id": 575936453,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772084447
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NormedAddTorsor#doc\">docs#NormedAddTorsor</a> carries no additional data anyway, so you should always define it if you already have the metric and normed space  and AddTorsor structure.</p>",
        "id": 575936949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772084733
    },
    {
        "content": "<p>Agreed - we don't have <code>AddTorsor (EuclideanSpace ℝ (Fin d)) (Space d)</code> yet so this will need to be defined.</p>",
        "id": 575937536,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772085038
    },
    {
        "content": "<p>Oh, you stopped at VAdd?</p>",
        "id": 575937594,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772085066
    },
    {
        "content": "<p>Yeah - fixing it now :)</p>",
        "id": 575937669,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772085111
    },
    {
        "content": "<p>I'd recommend writing (and contributing to mathlib) a Function.Injective.addTorsor to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.addAction#doc\">docs#Function.Injective.addAction</a></p>",
        "id": 575937757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772085166
    },
    {
        "content": "<p>I expect you can do something similar for Function.Injective.normedAddTorsor</p>",
        "id": 575937831,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772085213
    },
    {
        "content": "<p>In other words, you want to pull-back the self <code>NormedAddTorsor</code> instance on <code>EuclideanSpace ℝ (Fin d)</code> to <code>Space d</code>. This makes sense.</p>",
        "id": 575938243,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772085491
    },
    {
        "content": "<p>Yes; the pattern for those defs is that you define the data manually, then pull back the proofs</p>",
        "id": 575938877,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772085782
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/35794\">#35794</a> containing these, and added some more 'requirements' to the <code>Space</code> issue on <a href=\"https://github.com/HEPLean/PhysLean/pull/854\">PhysLean#854</a> related to <code>NormedAddTorsor</code></p>",
        "id": 575943140,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772088148
    },
    {
        "content": "<p>Those look good, I've left some comments about how to make them shorter</p>",
        "id": 575943404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772088309
    },
    {
        "content": "<p>On a related topic is how we should deal with Euclidean space-time. The current plan is to define a type <code>TimeAndSpace</code> which is an abbreviation of <code>Time x Space d</code>. This is needed in a number of places, and in particular is needed for the Galilean group. The current plan is at <a href=\"https://github.com/HEPLean/PhysLean/pull/939\">PhysLean#939</a></p>",
        "id": 575958150,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772093997
    },
    {
        "content": "<p>I don't think it's easy to tell the difference between <code>SpaceTime</code> vs <code>TimeAndSpace</code> from the name, I'd prefer something like <code>ClassicalSpaceTime</code> or maybe there's something better</p>",
        "id": 575960155,
        "sender_full_name": "ZhiKai Pong",
        "timestamp": 1772094603
    },
    {
        "content": "<p>I don't think <code>classical</code> is the right adjective here. Maybe <code>EuclidSpaceTime</code>, or <code>GalileanSpaceTime</code> (though a bit long).</p>",
        "id": 575960755,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772094769
    },
    {
        "content": "<p>sorry that I was sloppy, yes I intended to use the affine group. As for the Poincaré group, I don't find the relevant definitions, as the Lorentz \"metric\" is indefinite. The closest thing seems <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.IsOrthogonal#doc\">docs#LinearMap.IsOrthogonal</a> which applies to any bilinear form</p>",
        "id": 575980049,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772099940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575958150\">said</a>:</p>\n<blockquote>\n<p>The current plan is to define a type <code>TimeAndSpace</code> which is an abbreviation of <code>Time x Space d</code></p>\n</blockquote>\n<p>This will come with the wrong norm</p>",
        "id": 576098440,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772131525
    },
    {
        "content": "<p>Here is a totally insane suggestion: define a type that is under the hood <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>×</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R} \\times E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> for any inner product space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> and bundle it with the inner product (aka bilinear form) <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mi>d</mi><msup><mi>t</mi><mn>2</mn></msup><mo>+</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">-dt^2 + ds</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\">d</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">ds</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span></span></span></span> is the inner product on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>. Then you can do all of the things SR and you might be even be able to get it into mathlib. Another thing to do is just consider a type with an inner product that is non-degenerate and you can still define space-, time-, and lightlike vectors, etc (without assuming the signature is (n,1)).</p>",
        "id": 576132570,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772143890
    },
    {
        "content": "<p>Why not <code>inner p q = inner p.1 q.1 - inner p.2 q.2</code> so that you can generalize it to two spaces?</p>",
        "id": 576132782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772143992
    },
    {
        "content": "<p>(I have no strong opinion on which way the <code>-</code> should go)</p>",
        "id": 576132862,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772144030
    },
    {
        "content": "<p>in that case it doesn't matter, right <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 576132967,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772144083
    },
    {
        "content": "<p>You can probably get away for a long time with being agnostic to the sign convention: just define positive, negative and null vectors depending on the sign of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">g(v,v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span> (aka don't call them space- or timelike)</p>",
        "id": 576133670,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772144406
    },
    {
        "content": "<p>Oh, a nice thing about using two inner product spaces: you get the wave operator for free, just take the difference of the laplacians.</p>",
        "id": 576134106,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772144650
    },
    {
        "content": "<p>Isn't the wave operator just the laplacian anyway?</p>",
        "id": 576139004,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772146272
    },
    {
        "content": "<p>yes, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Laplacian.laplacian#doc\">docs#Laplacian.laplacian</a> is only defined for an inner product space</p>",
        "id": 576140872,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772147257
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InnerProductSpace.instLaplacian#doc\">docs#InnerProductSpace.instLaplacian</a> for the definition of the Laplacian on functions</p>",
        "id": 576141067,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772147356
    },
    {
        "content": "<p>Is a minkowski space not a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InnerProductSpace#doc\">docs#InnerProductSpace</a> ? As far as I can tell all the axioms hold.</p>",
        "id": 576144421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772149441
    },
    {
        "content": "<p>(I realize it's not an inner product space in the mathematical sense)</p>",
        "id": 576144444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772149452
    },
    {
        "content": "<p>My claim is that changing <code>InnerProductSpace.instLaplacian</code> to be for SeminormedAddCommGroup would suffice</p>",
        "id": 576144532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772149501
    },
    {
        "content": "<p><code>Norm</code> is nonneg but Minkowski space metric (Lorentz metric) is indefinite</p>",
        "id": 576144649,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1772149572
    },
    {
        "content": "<p>Oh of course, so I guess \"Is minkowski space an <code>InnerProductSpace</code>\" is as a question a type error.</p>",
        "id": 576145684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772150326
    },
    {
        "content": "<p>Yeah, because the definition of the Laplacian depends on choosing an orthonormal basis, it is not possible to use that definition for indefinite bilinear forms</p>",
        "id": 576165253,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1772159611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/channel/479953-PhysLean/topic/Space.20vs.20EuclideanSpace/near/575943140\">said</a>:</p>\n<blockquote>\n<p>I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/35794\">#35794</a> containing these, and added some more 'requirements' to the <code>Space</code> issue on <a href=\"https://github.com/HEPLean/PhysLean/pull/854\">PhysLean#854</a> related to <code>NormedAddTorsor</code></p>\n</blockquote>\n<p>Many thanks for your fast review of this <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>.</p>",
        "id": 576191169,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1772175607
    }
]