[
    {
        "content": "<p>Following a discussion on AITP, I was curious -- how far are Lean libraries from proving completeness of superposition (basically ordered resolution &amp; rewriting &amp; unification)? Some basic aspects such as a first order term, or a variable should be in ModelTheory (perhaps also some compactness results could come handy). Is there anywhere something regarding clauses (say in propositional setup)? Perhaps some term rewriting theory? And in case someone would look at it, it would rather belong to CSLib than Mathlib, what do you think?</p>\n<p>By the way, the original motivation was that if we could convince Lean <code>satisfiable</code> by a superposition-based solver is correct (in experiments with Terry Tao's equational theories). Of course the problems there were a bit specific, only used unit clauses, so the theory should be easier. Although having superposition completeness would be a nice theoretical accomplishment... just perhaps too hard?</p>",
        "id": 540040727,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758121707
    },
    {
        "content": "<p>Ok, I was pointed to an Isabelle formalization<br>\n<a href=\"https://drops.dagstuhl.de/storage/00lipics/lipics-vol309-itp2024/LIPIcs.ITP.2024.12/LIPIcs.ITP.2024.12.pdf\">https://drops.dagstuhl.de/storage/00lipics/lipics-vol309-itp2024/LIPIcs.ITP.2024.12/LIPIcs.ITP.2024.12.pdf</a></p>",
        "id": 540099298,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758141611
    },
    {
        "content": "<p>If vampire gives us the superposition proof trace there shouldn't really be a need for any proof theory on our side I think? Recovering the proof given the trace should be a pretty doable Lean meta programming task, even in the non unit case (of course as simplifications come in things might get a bit more difficult though)</p>",
        "id": 540167822,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758181798
    },
    {
        "content": "<p>I meant the \"satisfiable case\", that is when Vampire concludes there are no more clauses that can be derived. This requires proving completeness which is much harder than soundness.</p>",
        "id": 540176916,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758184535
    },
    {
        "content": "<p>If vampire concludes there are no more clauses that can be derived and it hasn't reached a contradiction yet the active set / processed set (depending on which literature you read) contains a model.</p>",
        "id": 540177382,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758184662
    },
    {
        "content": "<p>We discussed this on AITP, and \"contains a model\" is quite a bold statement. The model could be infinite. I need to check if Vampire at least decides all the unit equalities but even then you need some rewriting theory (termination, confluence) to be sure there equalities define a model.</p>",
        "id": 540179283,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758185122
    },
    {
        "content": "<p>Indeed, it simplifies to the unit equalities, so for this particular task, term-rewriting theory (KBO) should be enough. Does Lean have it?</p>",
        "id": 540182365,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758186071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/516743-computer-science/topic/Superposition/near/540099298\">said</a>:</p>\n<blockquote>\n<p>Ok, I was pointed to an Isabelle formalization<br>\n<a href=\"https://drops.dagstuhl.de/storage/00lipics/lipics-vol309-itp2024/LIPIcs.ITP.2024.12/LIPIcs.ITP.2024.12.pdf\">https://drops.dagstuhl.de/storage/00lipics/lipics-vol309-itp2024/LIPIcs.ITP.2024.12/LIPIcs.ITP.2024.12.pdf</a></p>\n</blockquote>\n<p>I can only tell you that the people that wrote this paper taught me it contains a model, you can check here to see how it is recovered in theory: <a href=\"https://www.tcs.ifi.lmu.de/lehre/ws-2024-25/atp/slides13-more-superposition.pdf\">https://www.tcs.ifi.lmu.de/lehre/ws-2024-25/atp/slides13-more-superposition.pdf</a></p>\n<p>While there are indeed infinite models superposition is a semi-decision procedure, it is only guaranteed to terminate if a proof (in this case a contradiction) exists, otherwise it can end up running forever. If it terminates the saturated clause set can be used to recover a model. It might be that Vampire implements additional strategies on top of superposition (I've only read E papers and code before, don't know about Vampire) that are able to identify certain situations where an infinite model exists and give up but the basic superposition calculus has this property.</p>",
        "id": 540182817,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758186195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Olšák</span> <a href=\"#narrow/channel/516743-computer-science/topic/Superposition/near/540182365\">said</a>:</p>\n<blockquote>\n<p>Indeed, it simplifies to the unit equalities, so for this particular task, term-rewriting theory (KBO) should be enough. Does Lean have it?</p>\n</blockquote>\n<p>While you might need some theory to prove that something is a counter example to your statement there is no need to actually do that proof when presenting a counter example to your user (one of the nice properties of counter example finding tools as opposed to proving ones). I guess one could do this for fun still but for an interactive tool there is no need to produce proofs.</p>",
        "id": 540184089,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758186546
    },
    {
        "content": "<p>Let's take natural numbers with a successor and predecessor for example. If I am not mistaken, this only has an infinite model:</p>\n<div class=\"codehilite\" data-code-language=\"Prolog\"><pre><span></span><code><span class=\"nf\">fof</span><span class=\"p\">(</span><span class=\"s s-Atom\">'succ_nz'</span><span class=\"p\">,</span> <span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span> <span class=\"p\">![</span><span class=\"nv\">X</span><span class=\"p\">]</span> <span class=\"s s-Atom\">:</span> <span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X</span><span class=\"p\">)</span> <span class=\"p\">!</span><span class=\"o\">=</span> <span class=\"s s-Atom\">z</span><span class=\"p\">)).</span>\n<span class=\"nf\">fof</span><span class=\"p\">(</span><span class=\"s s-Atom\">'pred_succ'</span><span class=\"p\">,</span> <span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span> <span class=\"p\">![</span><span class=\"nv\">X</span><span class=\"p\">]</span> <span class=\"s s-Atom\">:</span> <span class=\"p\">(</span><span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X</span><span class=\"p\">))</span> <span class=\"o\">=</span> <span class=\"nv\">X</span><span class=\"p\">)).</span>\n<span class=\"nf\">fof</span><span class=\"p\">(</span><span class=\"s s-Atom\">'succ_pred'</span><span class=\"p\">,</span> <span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span> <span class=\"p\">![</span><span class=\"nv\">X</span><span class=\"p\">]</span> <span class=\"s s-Atom\">:</span> <span class=\"p\">((</span><span class=\"nv\">X</span> <span class=\"p\">!</span><span class=\"o\">=</span> <span class=\"s s-Atom\">z</span><span class=\"p\">)</span> <span class=\"s s-Atom\">=&gt;</span> <span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nv\">X</span><span class=\"p\">))</span> <span class=\"o\">=</span> <span class=\"nv\">X</span><span class=\"p\">))).</span>\n</code></pre></div>\n<p>Vampire answers</p>\n<div class=\"codehilite\" data-code-language=\"Prolog\"><pre><span></span><code><span class=\"c1\">% # SZS output start Saturation.</span>\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">u7</span><span class=\"p\">,</span><span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span>\n    <span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nv\">X0</span><span class=\"p\">))</span> <span class=\"o\">=</span> <span class=\"nv\">X0</span> <span class=\"p\">|</span> <span class=\"s s-Atom\">z</span> <span class=\"o\">=</span> <span class=\"nv\">X0</span><span class=\"p\">).</span>\n\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">u6</span><span class=\"p\">,</span><span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span>\n    <span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X0</span><span class=\"p\">))</span> <span class=\"o\">=</span> <span class=\"nv\">X0</span><span class=\"p\">).</span>\n\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">u5</span><span class=\"p\">,</span><span class=\"s s-Atom\">axiom</span><span class=\"p\">,</span>\n    <span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X0</span><span class=\"p\">)</span> <span class=\"p\">!</span><span class=\"o\">=</span> <span class=\"s s-Atom\">z</span><span class=\"p\">).</span>\n\n<span class=\"c1\">% # SZS output end Saturation.</span>\n</code></pre></div>\n<p>E answers</p>\n<div class=\"codehilite\" data-code-language=\"Prolog\"><pre><span></span><code><span class=\"s s-Atom\">#</span> <span class=\"nv\">SZS</span> <span class=\"s s-Atom\">status</span> <span class=\"nv\">Satisfiable</span>\n<span class=\"s s-Atom\">#</span> <span class=\"nv\">Processed</span> <span class=\"s s-Atom\">positive</span> <span class=\"s s-Atom\">unit</span> <span class=\"nn\">clauses</span><span class=\"p\">:</span>\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">i_0_2</span><span class=\"p\">,</span> <span class=\"s s-Atom\">plain</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X1</span><span class=\"p\">))</span><span class=\"o\">=</span><span class=\"nv\">X1</span><span class=\"p\">)).</span>\n\n<span class=\"s s-Atom\">#</span> <span class=\"nv\">Processed</span> <span class=\"s s-Atom\">negative</span> <span class=\"s s-Atom\">unit</span> <span class=\"nn\">clauses</span><span class=\"p\">:</span>\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">i_0_1</span><span class=\"p\">,</span> <span class=\"s s-Atom\">plain</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nv\">X1</span><span class=\"p\">)!</span><span class=\"o\">=</span><span class=\"s s-Atom\">z</span><span class=\"p\">)).</span>\n\n<span class=\"s s-Atom\">#</span> <span class=\"nv\">Processed</span> <span class=\"s s-Atom\">non</span><span class=\"o\">-</span><span class=\"s s-Atom\">unit</span> <span class=\"nn\">clauses</span><span class=\"p\">:</span>\n<span class=\"nf\">cnf</span><span class=\"p\">(</span><span class=\"s s-Atom\">i_0_3</span><span class=\"p\">,</span> <span class=\"s s-Atom\">plain</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nf\">s</span><span class=\"p\">(</span><span class=\"nf\">p</span><span class=\"p\">(</span><span class=\"nv\">X1</span><span class=\"p\">))</span><span class=\"o\">=</span><span class=\"nv\">X1</span><span class=\"p\">|</span><span class=\"nv\">X1</span><span class=\"o\">=</span><span class=\"s s-Atom\">z</span><span class=\"p\">)).</span>\n</code></pre></div>\n<p>If I tried, I could get the provers to also show the term ordering they are using.<br>\nHow would you use any of this to convince Lean of satisfiability?</p>",
        "id": 540187239,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758187397
    },
    {
        "content": "<p>I'm again not sure why you are interested in convincing Lean of satisfiability here, if you have a use case for extracting SAT into Lean apart from counter example generation please do tell because I am not aware of one.</p>\n<p>Anyway, this is likely one of the situations mentioned above where the practical superposition systems implement additional mechanisms to detect they are in a hopeless situation. If you just hand this to a completely plain superposition prover it will indeed end up looping (e.g. the one I wrote with the people from LMU does end up looping). Unfortunately I'm not deep enough into practical ATPs to say exactly how this works out but I can ask around.</p>",
        "id": 540193179,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758189239
    },
    {
        "content": "<p>I am not sure if I agree with the \"practical / theoretical\" distinction. I admit I haven't implemented superposition on my own but just manually I don't see any meaningful rewrite I could do in the example problem (assuming <code>z</code> is the smallest in the term ordering). The only rewrites I can see is combining the two inverses, but that results in a trivially true clause. Am I missing something? How does your solver loop?</p>\n<p>Also yes, it is more of a curiosity than a critical need. As I mentioned above, the question arose from the equational theories project (which already finished, but someone could want something similar in the future). In equational theories, people wanted to have both proofs and disproofs.</p>",
        "id": 540198227,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758191036
    },
    {
        "content": "<blockquote>\n<p>How does your solver loop?</p>\n</blockquote>\n<p>It does end up in a situation where it repeatedly superposes clause 3 and descendants with itself, most of these are detected as useless but there are enough to keep the loop going. I would assume that E and Vampire have a smarter idea of what inferences might be redundant.</p>\n<blockquote>\n<p>In equational theories, people wanted to have both proofs and disproofs.</p>\n</blockquote>\n<p>If you are interested in a disproof a superposition prover can do that for you by just asking it to prove the negation of your theorem instead of the theorem it found a counter example for. Then you can just run the normal proof recovery procedure from the trace.</p>",
        "id": 540205284,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758193572
    },
    {
        "content": "<p>And regarding the practical theoretical distinction, here is e.g. the eprover manual: <a href=\"https://wwwlehre.dhbw-stuttgart.de/~sschulz/WORK/E_DOWNLOAD/V_3.1/eprover.pdf\">https://wwwlehre.dhbw-stuttgart.de/~sschulz/WORK/E_DOWNLOAD/V_3.1/eprover.pdf</a> on page 8 and following they describe the specific inference system they are using, theoretical first order superposition has 4 rules, they have multiple pages of rules alone. A real world superposition implementation takes a lot of shortcuts through additional tricks that are not described in formalisations like the Isabelle paper above. As a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">fof</span><span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">conjecture</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span>\n<span class=\"w\">   </span><span class=\"o\">((</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"bp\">&lt;=&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span>\n<span class=\"w\">   </span><span class=\"o\">((</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&lt;=&gt;</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"o\">)</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>solving this query in any kind of reasonable time is basically completely hopeless if you don't implement the CLC simplification rule.</p>",
        "id": 540205976,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758193847
    },
    {
        "content": "<p>The trick seems to be that the theoretical algorithm for extracting the model that's e.g. described in here:<br>\n<a href=\"https://www.tcs.ifi.lmu.de/lehre/ws-2024-25/atp/slides13-more-superposition.pdf\">https://www.tcs.ifi.lmu.de/lehre/ws-2024-25/atp/slides13-more-superposition.pdf</a></p>\n<p>can also end up looping, so if you were to let it run on what vampire outputs it would just start printing the infinite description of the model that you are looking for.</p>",
        "id": 540211800,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1758195855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/516743-computer-science/topic/Superposition/near/540205284\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>How does your solver loop?</p>\n</blockquote>\n<p>It does end up in a situation where it repeatedly superposes clause 3 and descendants with itself, most of these are detected as useless but there are enough to keep the loop going. I would assume that E and Vampire have a smarter idea of what inferences might be redundant.</p>\n</blockquote>\n<p>I would be curious for example what is the first clause it derives, and how it doesn't realize it is trivial (if you can easily display it).</p>\n<blockquote>\n<blockquote>\n<p>In equational theories, people wanted to have both proofs and disproofs.</p>\n</blockquote>\n<p>If you are interested in a disproof a superposition prover can do that for you by just asking it to prove the negation of your theorem instead of the theorem it found a counter example for. Then you can just run the normal proof recovery procedure from the trace.</p>\n</blockquote>\n<p>Not really. The claim \"every model of T satisfies X\" cannot be negated within first order theory. You would need to provide to the solver external theory which is on its own capable of constructing the model, and I am afraid FOL solvers are not great when dealing with such problems.</p>",
        "id": 540325201,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1758231927
    }
]