[
    {
        "content": "<p>Hello,<br>\nDoes anyone know of a formalization of the lambda calculus in Lean?<br>\nIn particular termination of beta/eta reduction?</p>",
        "id": 152020148,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545045874
    },
    {
        "content": "<p>I would have a look at <a href=\"https://github.com/leanprover/mathlib/tree/master/computability\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/tree/master/computability\">https://github.com/leanprover/mathlib/tree/master/computability</a> (but maybe this is something else)</p>",
        "id": 152020719,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1545046488
    },
    {
        "content": "<p>And, if it doesn't exist, maybe having a look at <a href=\"https://github.com/leanprover/mathlib/blob/5613d2ecc92ce8fae9555745bd94756dec61a323/group_theory/free_group.lean#L127\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/5613d2ecc92ce8fae9555745bd94756dec61a323/group_theory/free_group.lean#L127\">https://github.com/leanprover/mathlib/blob/5613d2ecc92ce8fae9555745bd94756dec61a323/group_theory/free_group.lean#L127</a> and <a href=\"https://github.com/leanprover/mathlib/blob/57194fa57e76721a517d6969ee88a6007f0722b3/logic/relation.lean#L288\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/57194fa57e76721a517d6969ee88a6007f0722b3/logic/relation.lean#L288\">https://github.com/leanprover/mathlib/blob/57194fa57e76721a517d6969ee88a6007f0722b3/logic/relation.lean#L288</a> could be a good idea</p>",
        "id": 152020807,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1545046571
    },
    {
        "content": "<p>I don't think lambda calculus has been done, although there are several projects in the same space</p>",
        "id": 152021502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047377
    },
    {
        "content": "<p>I assume you are talking about simply typed lambda calculus, since of course the regular kind doesn't terminate</p>",
        "id": 152021571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047417
    },
    {
        "content": "<p>I believe Jeremy has a formalization of lambda calculus, although he intended it for different purposes and I don't think he proved this property</p>",
        "id": 152021611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047476
    },
    {
        "content": "<p>aha, here it is: <a href=\"https://github.com/avigad/embed/blob/master/src/exp.lean\" target=\"_blank\" title=\"https://github.com/avigad/embed/blob/master/src/exp.lean\">https://github.com/avigad/embed/blob/master/src/exp.lean</a></p>",
        "id": 152021724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047605
    },
    {
        "content": "<p>it's not much more than the definition</p>",
        "id": 152021734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047616
    },
    {
        "content": "<p>I guess he never defined typechecking for lambda terms, since he was going for FOL</p>",
        "id": 152021811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545047687
    },
    {
        "content": "<p>Ok, thanks for the pointers. I will think about whether I'd like to work on this then. Actually, I'd like to formalize a unification procedure for lambda-terms, but I will need a formalization of the lambda-calculus for that first :-)</p>",
        "id": 152023395,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545049684
    },
    {
        "content": "<p>I might be missing something obvious here</p>",
        "id": 152023686,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545050052
    },
    {
        "content": "<p>but what happened to the Y-combinator?</p>",
        "id": 152023688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545050058
    },
    {
        "content": "<p>oh, that's what \"simply typed\" rules out isn't it</p>",
        "id": 152023697,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545050073
    },
    {
        "content": "<p>Yes, I wasn't very precise. I meant simply typed lambda calculus.</p>",
        "id": 152023793,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545050268
    },
    {
        "content": "<p>Hey, I'm actually working on this right now! Is there any particular formulation that you want to use? I'm trying to figure out inherently typed terms at the moment, but I have a formulation in raw terms with a typechecking procedure and a proof of progress, basically following \"Software Foundations\".</p>",
        "id": 152218893,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1545259385
    },
    {
        "content": "<p>Oh, that's great! As I said, I actually would like to formalize a unification procedure for lambda-terms. So if I could build on your library once it's finished, that would be perfect. I find it hard to predict which formulation would be more suitable for this, but I guess it doesn't matter too much.</p>",
        "id": 152262213,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545318573
    },
    {
        "content": "<p>It's not pretty code and definitely not suitable for a library, but I can upload it somewhere like git when I have a bit more time if that helps your project :)</p>",
        "id": 152263621,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1545319794
    },
    {
        "content": "<p>By the way, you mean unification of the entire term assuming some holes on one (or both?) sides, not just types, right?</p>",
        "id": 152263723,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1545319842
    },
    {
        "content": "<p>Yes, with holes on both sides, but the holes are realized as free variables. In addition to that, there are also constant symbols. So for example, one could ask for unifiers of <code>f (X a) b</code> and <code>f c (Y d)</code>, where uppercase letters are variables and lowercase letters are constants. A unifier would be <code>{X â†¦ Î»Z. c; Y â†¦ Î»Z. b}</code>. The procedure is described here: <a href=\"https://www.sciencedirect.com/science/article/pii/0304397576900219\" target=\"_blank\" title=\"https://www.sciencedirect.com/science/article/pii/0304397576900219\">https://www.sciencedirect.com/science/article/pii/0304397576900219</a></p>",
        "id": 152271412,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545326027
    },
    {
        "content": "<p>So it sounds like you don't plan / don't have time to improve your code such that it would be usable as a library?  If I decide to formalize lambda calculus myself, I will ask you again for what you've done. But currently, I tend to using Isabelle/HOL instead for this project (Oh, oh, high treason in this chat I suppose).</p>",
        "id": 152272457,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545326923
    },
    {
        "content": "<p>Oh, I do hope to make it fairly readable, just not the very partial raw-term formulation, which is what I have currently, but rather the inherently-typed one which I only started on. That said, I'm using quantified type theory to support linear typing, which is more general than simply-typed lambda, but can be instantiated (I think..) to simply-typed lambda.</p>",
        "id": 152275053,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1545329256
    },
    {
        "content": "<p>We actually did some stlc in lean in the University of Washington's graduate PL class last fall: <a href=\"https://courses.cs.washington.edu/courses/cse505/17au/lec11/lean/stlc.lean\" target=\"_blank\" title=\"https://courses.cs.washington.edu/courses/cse505/17au/lec11/lean/stlc.lean\">https://courses.cs.washington.edu/courses/cse505/17au/lec11/lean/stlc.lean</a></p>",
        "id": 152293681,
        "sender_full_name": "Josh Pollock",
        "timestamp": 1545346495
    },
    {
        "content": "<p>Thanks! I'll have a closer look next year. Happy holidays :-)</p>",
        "id": 152324240,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1545391637
    },
    {
        "content": "<p>I just started learning lambda calculus. If you don't mind explaining, I was wondering why the condition <code>x2 \\notin FV (e1) \\/ x1 \\notin FV (e)</code> is not a part of the definition for <code>lam_diff</code> in <code>is_subst</code>?</p>",
        "id": 154197485,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546459490
    },
    {
        "content": "<p>are you referring to a particular formalization?</p>",
        "id": 154197511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546459532
    },
    {
        "content": "<p>Sorry, yes. The one that Josh Pollock posted a link to earlier in the thread.</p>",
        "id": 154197586,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546459599
    },
    {
        "content": "<p>I think you are right. There are variable capturing substitutions that are admitted by <code>is_subst</code></p>",
        "id": 154197839,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1546459914
    },
    {
        "content": "<p>If that is the case, would adding that condition be the simplest fix?</p>",
        "id": 154198088,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546460144
    },
    {
        "content": "<p>If I try to add connectives like <code>âˆ§</code> and <code>âˆ¨</code> to the inductive definition, I seem to get an error of \"...contains variables that are not parameters\". Are these permitted in inductive definitions?</p>",
        "id": 154201289,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546463205
    },
    {
        "content": "<p>Would this work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">is_subst</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"n\">string</span> <span class=\"bp\">â†’</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"kt\">Prop</span>\n<span class=\"c1\">-- (Î» y . P)[ x := N ] = (Î» y . P [ x := N ]) if x â‰  y and y âˆ‰ FV (N) or x âˆ‰ FV (P)</span>\n<span class=\"bp\">|</span> <span class=\"n\">lam_diff</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span>\n    <span class=\"n\">x</span> <span class=\"bp\">â‰ </span> <span class=\"n\">y</span>\n    <span class=\"bp\">â†’</span> <span class=\"o\">((</span><span class=\"bp\">Â¬</span> <span class=\"n\">is_free</span> <span class=\"n\">N</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">âˆ¨</span> <span class=\"o\">(</span><span class=\"bp\">Â¬</span> <span class=\"n\">is_free</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"bp\">â†’</span> <span class=\"n\">is_subst</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">N</span> <span class=\"n\">e</span>\n    <span class=\"bp\">â†’</span> <span class=\"n\">is_subst</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">y</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">y</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 154202553,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546464493
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"kn\">constant</span> <span class=\"n\">is_free</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"n\">string</span> <span class=\"bp\">â†’</span> <span class=\"kt\">Prop</span>\n\n<span class=\"n\">meta</span> <span class=\"kn\">inductive</span> <span class=\"n\">is_subst</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"n\">string</span> <span class=\"bp\">â†’</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"n\">expr</span> <span class=\"bp\">â†’</span> <span class=\"kt\">Prop</span>\n<span class=\"c1\">-- (Î» y . P)[ x := N ] = (Î» y . P [ x := N ]) if x â‰  y and y âˆ‰ FV (N) or x âˆ‰ FV (P)</span>\n<span class=\"bp\">|</span> <span class=\"n\">lam_diff</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">),</span>\n    <span class=\"n\">x</span> <span class=\"bp\">â‰ </span> <span class=\"n\">y</span>\n    <span class=\"bp\">â†’</span> <span class=\"o\">((</span><span class=\"bp\">Â¬</span> <span class=\"n\">is_free</span> <span class=\"n\">N</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">âˆ¨</span> <span class=\"o\">(</span><span class=\"bp\">Â¬</span> <span class=\"n\">is_free</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n    <span class=\"bp\">â†’</span> <span class=\"n\">is_subst</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">N</span> <span class=\"n\">e</span>\n    <span class=\"bp\">â†’</span> <span class=\"n\">is_subst</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">y</span> <span class=\"n\">sorry</span> <span class=\"n\">P</span> <span class=\"n\">sorry</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">lam</span> <span class=\"n\">y</span> <span class=\"n\">sorry</span> <span class=\"n\">e</span> <span class=\"n\">sorry</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 154203012,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546464943
    },
    {
        "content": "<p>this works for me verbatim</p>",
        "id": 154203014,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546464946
    },
    {
        "content": "<p>Thank you. Do you think this would be a good fix for the definition?</p>",
        "id": 154203290,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546465256
    },
    {
        "content": "<p>no because it has <code>sorry</code></p>",
        "id": 154203316,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546465281
    },
    {
        "content": "<p>I'm sorry, I didn't mean verbatim, but if the definition was amended in this manner.</p>",
        "id": 154203407,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546465372
    },
    {
        "content": "<p>my point is that I didn't change the part you complained about</p>",
        "id": 154203425,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546465393
    },
    {
        "content": "<p>i.e. your diagnosis is not very accurate</p>",
        "id": 154203436,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546465407
    },
    {
        "content": "<p>The diagnosis about the error message or about the definition in the link that Josh posted? My post may have been confusing. I don't get error messages for the code I posted, it was changed to avoid them. I was asking if it worked to fix the definition that Josh posted.</p>",
        "id": 154203689,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546465644
    },
    {
        "content": "<p>oh... context...</p>",
        "id": 154203786,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1546465721
    },
    {
        "content": "<p>Sorry about that.</p>",
        "id": 154203800,
        "sender_full_name": "Paige Thomas",
        "timestamp": 1546465737
    },
    {
        "content": "<p>Moving the discussion with <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> on an 'upstream' Lambda calculus from  <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/cslib/with/527717285\">#general &gt; cslib</a> to here, hope it's ok.</p>\n<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> To make the discussion more concrete, I've kickstarted a 'Computability' directory with a plain old definition for the syntax of lambda-calculus and free/bound variables: <a href=\"https://github.com/cs-lean/cslib/blob/main/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean\">https://github.com/cs-lean/cslib/blob/main/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean</a></p>\n<p>The strategy I'm proposing is that we define in there the presentation that most people are used to, even if it will of course give the expected complications with capture-avoiding substitution. I would then like to have alternative syntaxes (De Brujin indeces, nameless, etc.) living in separate files as well. This will enable formally proving that these alternative presentations are 'correct'.<br>\nIt doesn't need to be done all at once, I'd be perfectly ok with having the alternatives proceed at different speeds (also because there's potentially a lot of stuff to do, which will likely require multiple people: on top of syntax, there are several established evaluation strategies, which we should allow for side-by-side as well). So if you have some particular definition, we can go ahead with it while the 'plain old' definition still cooks.<br>\nI think it's valuable to discuss the outlook though.</p>\n<p>What do you think?</p>",
        "id": 527863841,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752059405
    },
    {
        "content": "<p>(you'll find in there a substitution relation, that should become a function to an Option, I guess.. will hack it later)</p>",
        "id": 527928410,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752079535
    },
    {
        "content": "<p>I have a formalization of untyped lambda calculus and a proof of the substitution lemma written a while ago: <a href=\"https://github.com/PratherConid/LeanLambda\">https://github.com/PratherConid/LeanLambda</a>. It uses the \"plain old definition\" where free/bound variables are strings instead of de-brujin indices. <code>readme.md</code> gives an extensive sketch of the proof. The proof can definitely be simplified.</p>",
        "id": 527939816,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1752084033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"524339\">Yicheng Qian</span> <a href=\"#narrow/channel/113488-general/topic/Lambda.20calculus/near/527939816\">said</a>:</p>\n<blockquote>\n<p>I have a formalization of untyped lambda calculus and a proof of the substitution lemma written a while ago: <a href=\"https://github.com/PratherConid/LeanLambda\">https://github.com/PratherConid/LeanLambda</a>. It uses the \"plain old definition\" where free/bound variables are strings instead of de-brujin indices. <code>readme.md</code> gives an extensive sketch of the proof. The proof can definitely be simplified.</p>\n</blockquote>\n<p>very nice! it's pretty near to the direction i'm following (modulo some minor differences, like I'm abstracting from what the type of variables is, but that's likely easily fixable).</p>\n<p>What are you doing in <code>subst</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find_string_not_in</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">avar</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">avar</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rename</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>in particular, could you explain how you're making <code>subst</code> a total function? What happens when there's capturing?</p>",
        "id": 527943195,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752085433
    },
    {
        "content": "<p><code>List.find_string_not_in xs</code> returns a string that's not in <code>xs</code>, so using this here prevents capturing.</p>",
        "id": 527946236,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1752086517
    },
    {
        "content": "<p>It's not efficient though, but we could define a version which uses cache and prove that they are equivalence.</p>",
        "id": 527946405,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1752086581
    },
    {
        "content": "<p>Ah, I see! This means assuming that the type of variables is not finite, and that there is a way of getting one such 'fresh' name. (This is often done in pen-and-paper presentations as well.) I don't have these assumptions but we could add them for sure.</p>",
        "id": 527948668,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752087621
    },
    {
        "content": "<p>I have done deBrujin indices and locally nameless, both currently with proofs of confluence for a beta reduction. (It has pairs and a unit type because I need that for my research, but this could be removed for upstreaming). I think it would be nice to have a normalization proof too. <a href=\"https://github.com/chenson2018/LeanScratch/tree/main/LeanScratch\">https://github.com/chenson2018/LeanScratch/tree/main/LeanScratch</a></p>\n<p>It sounds like the desire is to have multiple formulations for representing syntax, so  a subdirectory for each? Maybe proofs that they preserve certain proofs? I will also be working on System F in the near future.</p>",
        "id": 527951100,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752088650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/113488-general/topic/Lambda.20calculus/near/527951100\">said</a>:</p>\n<blockquote>\n<p>I have done deBrujin indices and locally nameless, both currently with proofs of confluence for a beta reduction. (It has pairs and a unit type because I need that for my research, but this could be removed for upstreaming). I think it would be nice to have a normalization proof too. <a href=\"https://github.com/chenson2018/LeanScratch/tree/main/LeanScratch\">https://github.com/chenson2018/LeanScratch/tree/main/LeanScratch</a></p>\n<p>It sounds like the desire is to have multiple formulations for representing syntax, so  a subdirectory for each? Maybe proofs that they preserve certain proofs? I will also be working on System F in the near future.</p>\n</blockquote>\n<p>Agree on the multiple subdirs ('HOAS'? 'nameless'?).<br>\nI think we're gonna encounter this situation again and again (e.g., pi-calculus), so it's good to use this as a testbed.<br>\nSay that the formalisation that aims to be near to the plain pen and paper presentation is called 'Plain'. What I'm currently doing is that the plain presentation is in the main directory (currently <code>Computability/LambdaCalculus/Untyped</code>, which contains only a Basic file for now). We could also make a 'Plain' subdirectory, I guess. I wonder if Plain is a good name though, hence why I'm simply putting the plain presentation in the main directory for now.</p>",
        "id": 527951736,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752088967
    },
    {
        "content": "<p>And I've been looking at your repo, nice stuff.</p>",
        "id": 527951761,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752088979
    },
    {
        "content": "<p>I've tried to draft the 'subst that gets a fresh name' here, akin to what <span class=\"user-mention\" data-user-id=\"524339\">@Yicheng Qian</span>'s subst: <a href=\"https://github.com/cs-lean/cslib/blob/1dc4c6fefe6715d3f0e11a84d9bf99ee09b6bfa3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L57\">https://github.com/cs-lean/cslib/blob/1dc4c6fefe6715d3f0e11a84d9bf99ee09b6bfa3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L57</a></p>\n<p>Any idea on how to elegantly define that Term.freshVar function that I'm invoking there, without fixing type <code>Var</code>? Maybe there's something useful in mathlib about infinite types for that? (I've asked here as well: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Get.20a.20.27fresh.27.20element.20not.20in.20a.20Finset/with/527953971\">#Is there code for X? &gt; Get a 'fresh' element not in a Finset</a>.)</p>",
        "id": 527952928,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752089558
    },
    {
        "content": "<p>We could of course make our own class, but I'd rather reuse something if it exists.</p>",
        "id": 527953457,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752089835
    },
    {
        "content": "<p>I'd also like to point out that the fact that variables might be captured made the proof much more complicated than I expected. There are several theorems that are supposed to be proven by induction, where I had to apply variable renaming to some lambda terms in the middle of the proof to avoid variable capturing, and that had the inadvertent effect of making the induction hypothesis unapplicable, which forced me to change the statement of the theorem to strengthen the induction hypothesis.<br>\nBut I think most of this could be avoided if I had't decided to stick to the named approach throughout the entire proof. I imagine the proof would be much shorter if we define a translation between named terms and nameless terms and transfer the properties.</p>",
        "id": 527961229,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1752093167
    },
    {
        "content": "<p>Right!<br>\nI think I've reached something reasonable to define substitution and the assumption that we need a fresh variable generator. See <a href=\"https://github.com/cs-lean/cslib/blob/2439f43103a78c5dc02f8530b7923248cf8795d3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L86\">https://github.com/cs-lean/cslib/blob/2439f43103a78c5dc02f8530b7923248cf8795d3/Cslib/Computability/LambdaCalculus/Untyped/Basic.lean#L86</a></p>\n<p>Next steps would probably be to define one of the thousand semantics in a subdir (I guess cbv for starters) and a more convenient formulation (HOASLambdaCalculus?) in another subdir.  Then establish an encoding from LambdaCalculus.Term to HOASLambdaCalculus.Term, and we could even try to prove that the encoding is a <code>Bisimulation</code> (e.g., on the lts obtained by lifting the reduction relation to a transition relation where all labels are tau; I could make this more convenient from the LTS files).</p>\n<p>Let me know if anybody is up for working a bit on that.</p>\n<p>Some of these names are getting long... :-)</p>",
        "id": 528046177,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752142423
    },
    {
        "content": "<p>Hi all â€” would there be any interest in a formalisation of combinator logic? Coincidentally I have been working on one for the past few days as an exercise (I'm quite fresh to lean) â€” <a href=\"https://github.com/thomaskwaring/learning/blob/master/Learning/SKI.lean\">see here</a> â€” &amp; modulo a LOT of tidying up I might have something that is useful.</p>\n<p>So far I've formalised:</p>\n<ul>\n<li>Definitions, using the \"SKI\" basis, of single-step and large reduction.</li>\n<li>The Church-Rosser theorem: that the relation of having a common reduct is an equivalence (using Tait &amp; Martin-LÃ¶f's parallel reduction).</li>\n<li>\"Bracket abstraction\" (as it is termed <a href=\"https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis\">here</a>): for a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>â€¦</mo><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(x_1, \\dots, x_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">â€¦</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> with some number of \"holes\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">x_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (I've called such an object a \"context\"), a combinatory term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">[x]T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>â‹…</mo><msub><mi>t</mi><mn>1</mn></msub><mo>â‹…</mo><mo>â‹¯</mo><mo>â‹…</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">T \\cdot t_1 \\cdot \\dots \\cdot t_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"minner\">â‹¯</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> reduces to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>â€¦</mo><mo separator=\"true\">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">T(t_1,\\dots,t_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">â€¦</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> for any terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</li>\n<li>Definitions of all the usual auxiliary combinators, pairs and (a start on) booleans â€” I did this before bracket abstraction, so I could make those proofs a lot shorter now.</li>\n<li>Church numerals: I defined a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> to represent a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> iff for any terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f,x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>â‹…</mo><mi>f</mi><mo>â‹…</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">t \\cdot f \\cdot x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> reduces to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>â‹…</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo>â‹…</mo><mo>â€¦</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo>â‹…</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>â€¦</mo><mtext>â€‰</mtext><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f \\cdot (f \\cdot \\dots (f \\cdot x) \\dots ))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"minner\">â€¦</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">â€¦</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mclose\">))</span></span></span></span>, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> in the middle. With this I have addition, multiplication, predecessor (urgh), ordering and primitive recursion â€” again this could be cleaned up with bracket abstraction.</li>\n<li>Unbounded root finding: a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">RFind</mtext></mrow><annotation encoding=\"application/x-tex\">\\texttt{RFind}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">RFind</span></span></span></span></span> such that, given a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi mathvariant=\"double-struck\">N</mi></msub><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>â†’</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\"> f_\\mathbb{N} : \\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and a term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> representing it (in the obvious Church-numeral sense), if there exists <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi mathvariant=\"double-struck\">N</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f_\\mathbb{N} (n) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext mathvariant=\"monospace\">RFind</mtext><mo>â‹…</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">\\texttt{RFind} \\cdot f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6111em;\"></span><span class=\"mord text\"><span class=\"mord texttt\">RFind</span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">â‹…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> reduces to a term representing the minimum such <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</li>\n</ul>\n<p>I'm not sure exactly the right way to formalise this idea, but all of those together more-or-less express that combinators have the same power as general recursive functions <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/Partrec.html\">as formalised in Mathlib</a>.</p>\n<p>Obviously combinators are a pretty arcane way to program, but it does avoid the many problems &amp; choices related to syntax conventions, free / bound variables / etc that has been discussed above. Let me know if there's any interest!</p>",
        "id": 528325969,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1752235870
    },
    {
        "content": "<p>Definitely intersting! SKI is used, among other things, in a lot of recent and very interesting research on higher-order mathematical semantics.</p>",
        "id": 528329402,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752236988
    },
    {
        "content": "<p>I'm near enough for reviewing it, but I'm gonna try to get an expert on board for discussing this. We have at least one in our same section at the workplace.</p>",
        "id": 528329623,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752237066
    },
    {
        "content": "<p>Wonderful news â€” keep me updated on what my next steps should be, in the meantime I'll start tidying up my code in a way that seems reasonable to me. I'd also be very interested in seeing that research! It sounds close to the area of my PhD</p>",
        "id": 528331272,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1752237615
    },
    {
        "content": "<p>You can just create a fork when you like and start adding definitions.</p>\n<p>We're trying to be careful with notation, using type classes when possible to reuse them across different models. But don't think too much about it for now. Just try to be economical with new notations.</p>",
        "id": 528334367,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752238563
    },
    {
        "content": "<p>It'd be very good if you could add a reference to a pen-and-paper presentation (or other useful refs) at the beginning, so that one can compare to the formalisation.</p>",
        "id": 528334534,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752238627
    },
    {
        "content": "<p>Great, will do. I havenâ€™t been working from a particular pen-and-paper presentation, but I will have a look for one or else write up something rough of my own.</p>",
        "id": 528335701,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1752238957
    },
    {
        "content": "<p>It's SKI, hopefully Google will be able to help. :â -â )</p>",
        "id": 528339588,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752240124
    },
    {
        "content": "<p>One thing that could be shared between all the lambda calculi and SKI are a few notations and theorems about reflexive transitive relations. As an example, in my own repo I have this file separated out: <a href=\"https://github.com/chenson2018/LeanScratch/blob/main/LeanScratch/Confluence/Basic.lean\">https://github.com/chenson2018/LeanScratch/blob/main/LeanScratch/Confluence/Basic.lean</a></p>\n<p>I see similar patterns in your SKI formalization (which I think looks pretty good btw!), so maybe we can extract some pieces that are general.</p>",
        "id": 528374641,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752251990
    },
    {
        "content": "<p>Absolutely.<br>\nSome of those things are also very similar to what I have for LTSs (see <code>mtr</code> and <code>str</code>): <a href=\"https://github.com/cs-lean/cslib/blob/main/Cslib/Semantics/LTS/Basic.lean\">https://github.com/cs-lean/cslib/blob/main/Cslib/Semantics/LTS/Basic.lean</a></p>\n<p>Further, a reduction relation can be seen as an LTS with only tau-labels.</p>\n<p>We'll need Diamond and Confluence also for LTSs, and then also definitions for non-interference, serialisable... we should try to keep these concepts as general as possible.</p>",
        "id": 528377549,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752253335
    },
    {
        "content": "<p>The opposite is also true: if one restricts the transition relation of an LTS to a single label (e.g., tau), then one gets a relation.</p>\n<p>I just wonder if it can be made to work nicely. That is, I wouldn't want to force people interested only in simple reduction relations to see the LTS API. Maybe we can at least have 'to' and 'from' defs between Rel and LTS and then use the LTS API internally to prove<br>\ntheorems about reductions</p>",
        "id": 528378391,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752253692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/113488-general/topic/Lambda.20calculus/near/528374641\">said</a>:</p>\n<blockquote>\n<p>One thing that could be shared between all the lambda calculi and SKI are a few notations and theorems about reflexive transitive relations.</p>\n</blockquote>\n<p>I agree â€” there were even a couple of things that felt like they should be in (or at least semi-trivially derivable from) Mathlib, I'm thinking specifically of the <code>Transitive</code> instances between single step and multi reduction.</p>\n<p>For the moment I think I'll try to split off the relevant lemmas into their own file, and prove them in a reasonably general form â€” with the understanding that later they might become corollaries of LTS results etc</p>",
        "id": 528379614,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1752254242
    },
    {
        "content": "<p>formalised my mesg a bit (toRel and toLTS): <a href=\"https://github.com/cs-lean/cslib/blob/f07cd5d92bee90aa09fabf3d8112d1c87e867477/Cslib/Semantics/LTS/Basic.lean#L71\">https://github.com/cs-lean/cslib/blob/f07cd5d92bee90aa09fabf3d8112d1c87e867477/Cslib/Semantics/LTS/Basic.lean#L71</a></p>\n<p>At the very least we should be able to prove that rel.toLTS.Diamond &lt;-&gt; rel.Diamond.</p>",
        "id": 528388998,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752258649
    },
    {
        "content": "<p>(I still have to define Diamond for lts but it's as for Rel, just add transition labels)</p>",
        "id": 528389073,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752258678
    },
    {
        "content": "<p>I just <a href=\"https://github.com/cs-lean/cslib/pull/5\">opened a PR</a> adding some definitions for a locally nameless lambda calculus. My intent would be to follow up with definitions for reduction and proofs of confluence and strong normalization.</p>",
        "id": 528555553,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752438667
    },
    {
        "content": "<p>I'll have a (rather large) PR up tomorrow I think, formalising the things I mentioned <a href=\"#narrow/channel/113488-general/topic/Lambda.20calculus/near/528325969\">in my first message</a> (plus documentation, some major tidying, etc)</p>",
        "id": 528556464,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1752439680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/113488-general/topic/Lambda.20calculus/near/528555553\">said</a>:</p>\n<blockquote>\n<p>I just <a href=\"https://github.com/cs-lean/cslib/pull/5\">opened a PR</a> adding some definitions for a locally nameless lambda calculus. My intent would be to follow up with definitions for reduction and proofs of confluence and strong normalization.</p>\n</blockquote>\n<p>Great, thank you! I'm in the process of trying to figure out how to manage notation across all these languages, I'll open a topic about that so that we can discuss it together.</p>\n<p>RE your use of simp attributes: I've tried to avoid annotating stuff for aesop and simp so far because (1) sometimes simping too much makes using theorems harder, and (2) <code>grind</code> has arrived. I wonder if it's a good opportunity to learn grind, but we don't need to do that now ofc. But if you're adding simp-annotations for aesop, I'd suggest to create a ruleset with the simps you need instead of annotating the lemmas. This has been very useful in one of our internal projects.</p>\n<p>RE the notation for substitution: you can instantiate the class HasSubstitution to get the notation.</p>",
        "id": 528557656,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752440923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I have addressed each of your comments on the PR.  I've not very advanced in my aesop usage, could you clarify a bit about using a ruleset here? Is what you're suggesting to remove all of the simp attributes I currently have on definitions in <code>LocallyNameless/Basic.lean</code> and place them in a ruleset? Besides these, the only lemma I annotated was <code>HasFresh.fresh_notMem</code>.</p>",
        "id": 528565859,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752450028
    },
    {
        "content": "<p>I'm not sure if golfing is welcome, but there's some opportunity for automation just within this untyped lambda calculus file itself in CSLib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Renaming preserves size. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">rename</span><span class=\"bp\">.</span><span class=\"n\">eq_sizeOf</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sizeOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">rename</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sizeOf</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">rename</span><span class=\"o\">])</span>\n\n<span class=\"c1\">-- or, the decreasing_by proof for Term.subst - should grind be attached to eq_sizeOf calls?</span>\n<span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rename</span><span class=\"bp\">.</span><span class=\"n\">eq_sizeOf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"bp\">.</span><span class=\"n\">sizeOf_spec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"bp\">.</span><span class=\"n\">sizeOf_spec</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 528585563,
        "sender_full_name": "Tristan Figueroa-Reid",
        "timestamp": 1752469880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> <span class=\"user-mention\" data-user-id=\"767695\">@Tristan Figueroa-Reid</span> In an internal project over-annotating with simp made our codebase brittle, so I might've become over-conservative. Admittedly, that might've been because we used simp in the middle of proofs, which I read somewhere is discouraged in mathlib. Is there a guide somewhere on how to manage simp-annotations and golfing wrt maintainability?</p>",
        "id": 528593072,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752474716
    },
    {
        "content": "<p>Are you meaning <a href=\"https://leanprover-community.github.io/extras/simp.html\">this page</a> that includes a section on non-terminal simp? Happy to update to adhere to this, I just wasn't really thinking about it when I originally wrote this in a repo only I used.</p>",
        "id": 528595290,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752475796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/113488-general/topic/Lambda.20calculus/near/528595290\">said</a>:</p>\n<blockquote>\n<p>Are you meaning <a href=\"https://leanprover-community.github.io/extras/simp.html\">this page</a> that includes a section on non-terminal simp? Happy to update to adhere to this, I just wasn't really thinking about it when I originally wrote this in a repo only I used.</p>\n</blockquote>\n<p>Yes, that's the one, thanks.<br>\nI think it makes very good sense, so I'd follow it (not sure I've been following it 100% myself, I'll have a look at my own code later).</p>",
        "id": 528595727,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752476015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"767695\">@Tristan Figueroa-Reid</span> that means golfing is welcome, as long as proofs remain understandable and fast. In fact, I'd be very interested in leveraging <code>grind</code> in the codebase.</p>",
        "id": 528618041,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752484553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Your simp annotations also seem to make sense, now that I'm a bit wiser from reading the docs. As long as we don't use simp mid-proof, so that's good to avoid. Let me know when you've done a pass at your pr.</p>",
        "id": 528618269,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752484632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> I have pushed a commit that makes all simps either terminal or limited to <code>simp only</code>.</p>",
        "id": 528700806,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752510848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/113488-general/topic/Lambda.20calculus/near/528700806\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> I have pushed a commit that makes all simps either terminal or limited to <code>simp only</code>.</p>\n</blockquote>\n<p>I put a couple of minor comments, please feel free to correct me if I understood the mathlib styling wrong. They're very simple stuff, and after those I think it's ready to be merged.</p>",
        "id": 528728582,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752522259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span> Thanks for merging! I see I broke a test by changing the directory structure, I'll make a quick PR to fix. I see there is a workflow that might have caught this, but I think you have to approve it to run on our PRs?</p>",
        "id": 528788005,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752561274
    },
    {
        "content": "<p>Oh, it should just run for all PRs.. I'll double check, thanks for spotting this.</p>",
        "id": 528788128,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1752561354
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Lambda.20calculus\">#general &gt; Lambda calculus</a> by <span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span>.</p>",
        "id": 529708434,
        "sender_full_name": "Notification Bot",
        "timestamp": 1753039677
    },
    {
        "content": "<p>It would be great if we can have one for fresh string, particularly in locally nameless setting.</p>",
        "id": 529748843,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1753070982
    },
    {
        "content": "<p>One what? Do you mean an instance of HasFresh?</p>",
        "id": 529753549,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753075013
    },
    {
        "content": "<p>Yes</p>",
        "id": 529758840,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1753077456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>  Such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasFresh</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 529758973,
        "sender_full_name": "Ka Wing Li",
        "timestamp": 1753077515
    },
    {
        "content": "<p>It'd definitely be nice to have it. For something legible, one could go by alphabetical ordering on ascii characters and get the 'next one' (resetting and suffixing with an additional character whenever the end is reached). But we could also just take the longest string in the set and add a suffix character.</p>",
        "id": 529780614,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753083067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Do I understand correctly that locally closed nameless lambda terms should correspond to named lambda terms?</p>",
        "id": 532870612,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754384647
    },
    {
        "content": "<p>They should both represent the \"same\" STLC, yes. We could prove this at some point! We have named and locally nameless, I think the other common representation we're missing would be regular de Bruijn indices. All three should be able to soundly be transformed into each other.</p>",
        "id": 532872205,
        "sender_full_name": "Chris Henson",
        "timestamp": 1754385045
    },
    {
        "content": "<p>That's one of the things I was hoping we could do at some point. Let me sketch a thing...</p>",
        "id": 532872349,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754385080
    },
    {
        "content": "<p>There was recently an <a href=\"https://comono.id/dissertation.pdf\">interesting thesis</a> that touches on this, deriving each of these three approaches from a common monadic framework formalized in Rocq. (Not saying I want to replicate this per se, just mentioning since it's relevant)</p>",
        "id": 532872878,
        "sender_full_name": "Chris Henson",
        "timestamp": 1754385236
    },
    {
        "content": "<p>Something like this: <a href=\"https://github.com/cs-lean/cslib/blob/lambda-nameless-adequacy/Cslib/Computability/LambdaCalculus/LocallyNameless/Untyped/Adequacy.lean\">https://github.com/cs-lean/cslib/blob/lambda-nameless-adequacy/Cslib/Computability/LambdaCalculus/LocallyNameless/Untyped/Adequacy.lean</a></p>",
        "id": 532873989,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754385540
    },
    {
        "content": "<p>Yes, something like that. Maybe more idiomatic to say something with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Defs.html#Equiv\">docs#Mathlib.Logic.Equiv.Defs.Equiv</a>? Going both directions is potentially annoying though. Would be nice to state equivalent reductions as well.</p>",
        "id": 532875332,
        "sender_full_name": "Chris Henson",
        "timestamp": 1754385887
    },
    {
        "content": "<p>the other direction is trickier, we could either refer to the image of <code>toNameless</code> or try to make a (requires nonobvious design choices) deterministic <code>toNamed</code> function.</p>",
        "id": 532880464,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754387666
    },
    {
        "content": "<p>I'll sketch what the first looks like.</p>",
        "id": 532880484,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754387674
    },
    {
        "content": "<p>For the semantics, we could state a bisimulation or even an isomorphism result.</p>",
        "id": 532880729,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754387748
    },
    {
        "content": "<p>Something like (for alpha-equiv):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Two named terms are Î±-equivalent iff their locally nameless variants are equal. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">named_locallyNameless_alphaEquiv_iff_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Named</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†”</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toLocallyNameless</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toLocallyNameless</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- Two locally-closed nameless terms are equal iff they are the nameless translation of</span>\n<span class=\"sd\">Î±-equivalent named terms. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">locallyNameless_lc_named_eq_iff_alphaEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocallyNameless</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmlc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">LC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnlc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">LC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â†”</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">âˆƒ</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Named</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"bp\">.</span><span class=\"n\">toLocallyNameless</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"bp\">.</span><span class=\"n\">toLocallyNameless</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span>\n<span class=\"w\">    </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(Updated <a href=\"https://github.com/cs-lean/cslib/blob/lambda-nameless-adequacy/Cslib/Computability/LambdaCalculus/LocallyNameless/Untyped/Adequacy.lean\">https://github.com/cs-lean/cslib/blob/lambda-nameless-adequacy/Cslib/Computability/LambdaCalculus/LocallyNameless/Untyped/Adequacy.lean</a>)</p>",
        "id": 532881251,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1754387930
    }
]