[
    {
        "content": "<p>I'm playing around with using <code>grind</code> for bisimulation/bisimilarity results, and it's going pretty well. I've encountered a weird problem with unfolding definitions though. <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> perhaps it's similar to your problem with forward reasoning? I feel like this should be pretty simple though...</p>\n<p>Check out the unfolding I'm doing here: <a href=\"https://github.com/leanprover/cslib/blob/01dd639de4b55c944958d27ff2b6bebf89226ee9/Cslib/Languages/CCS/BehaviouralTheory.lean#L162\">https://github.com/leanprover/cslib/blob/01dd639de4b55c944958d27ff2b6bebf89226ee9/Cslib/Languages/CCS/BehaviouralTheory.lean#L162</a></p>\n<p>Basically, I have to manually unfold a structure (<code>Lts</code>) for <code>grind</code> to be able to proceed. I've tried using <code>grind ext</code> on <code>Lts</code>, the <code>etaStruct</code> config, and even making an explicit theorem like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Process</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"bp\">@</span><span class=\"n\">CCS</span><span class=\"bp\">.</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But nothing seems to work. What I want is to get rid of those <code>unfold</code> instructions. Ideally, we'd golf the entire proof to a single <code>grind</code> use.</p>",
        "id": 536766441,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756466011
    },
    {
        "content": "<p>It may be related, though I am not sure about <code>ext</code>. I think the problem is the automatic selection of <code>defs</code>.</p>",
        "id": 536813007,
        "sender_full_name": "Chris Henson",
        "timestamp": 1756481262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> maybe you have some insight?</p>",
        "id": 536845028,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756493375
    },
    {
        "content": "<p>I had a brief look, but I'm not sure.</p>\n<p>It's suspicious, I guess, that the step we're having difficulty with is <code>unfold lts</code>, where <code>lts</code> is an <code>abbrev</code> (mildly further suspicious that it is generated by meta code in <code>elab \"create_lts\"</code>, but that's probably okay).</p>",
        "id": 537394707,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756870627
    },
    {
        "content": "<p>How important is this <code>lts</code> function? If you replace the theorem statement with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bisimilarity_choice_idem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"o\">[{</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}]</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>then everything goes through. (arguably this is more readable: I really don't like this \"all implicit arguments\" <code>lts</code>...)</p>\n<p>But I agree it should still work!</p>",
        "id": 537395102,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756870969
    },
    {
        "content": "<p>(As general advice, I would suggest never set up any notation until <em>after</em> you have things working, but I accept that I am an extremist about notation. :-)</p>",
        "id": 537395580,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756871497
    },
    {
        "content": "<p>Hmm... I tried making it not an <code>abbrev</code>, or making the <code>defs</code> argument explicit, to no avail.</p>",
        "id": 537395916,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756871794
    },
    {
        "content": "<p>Could it be this definition is missing equational theorems etc. usually generated by the def elaborator and relied on by grind?</p>",
        "id": 537407004,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1756879937
    },
    {
        "content": "<p>I'm starting to suspect that too after Kim's reply.</p>",
        "id": 537407140,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756880046
    },
    {
        "content": "<p>But I hadn't thought of <code>def</code>fing that explicitly, let's see..</p>",
        "id": 537407230,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756880113
    },
    {
        "content": "<p>Making it an explicit <code>reducible</code> def works!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Process</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Act</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨@</span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 537407671,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756880429
    },
    {
        "content": "<p>To make sure I understand, this is because of the way it was defined using <code>addAndCompile</code>?</p>",
        "id": 537407949,
        "sender_full_name": "Chris Henson",
        "timestamp": 1756880628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/537395102\">said</a>:</p>\n<blockquote>\n<p>How important is this <code>lts</code> function? If you replace the theorem statement with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bisimilarity_choice_idem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"o\">[{</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}]</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>then everything goes through. (arguably this is more readable: I really don't like this \"all implicit arguments\" <code>lts</code>...)</p>\n<p>But I agree it should still work!</p>\n</blockquote>\n<p>Pretty important, we use the Lts type that it returns for various convenient dot notations and other notations.</p>\n<p>But I can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bisimilarity_choice_idem</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"o\">[</span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">defs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">defs</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>which reads much, much better, thanks. :-)</p>",
        "id": 537411913,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756882694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/537395580\">said</a>:</p>\n<blockquote>\n<p>(As general advice, I would suggest never set up any notation until <em>after</em> you have things working, but I accept that I am an extremist about notation. :-)</p>\n</blockquote>\n<p>This code predates <code>grind</code>, so we were unaware. We have a design puzzle with multiple moving parts (transition and program equivalence notation, dot-notation, supporting automation/grind, ...), and the theorems in that file are a good test to figure things out. Otherwise, in general I agree.</p>",
        "id": 537412118,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756882798
    },
    {
        "content": "<p>I made a PR <a href=\"https://github.com/leanprover/cslib/pull/54\">cslib#54</a> with some minor grind-golfing. Once you fix the lts equational lemmas issue much more will be possible!</p>",
        "id": 537413469,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1756883387
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 537426475,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756888406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/537413469\">said</a>:</p>\n<blockquote>\n<p>I made a PR <a href=\"https://github.com/leanprover/cslib/pull/54\">cslib#54</a> with some minor grind-golfing. Once you fix the lts equational lemmas issue much more will be possible!</p>\n</blockquote>\n<p>The docs say that <code>grind cases</code> is always scoped, correct? What about your line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">grind</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ParNil</span><span class=\"bp\">.</span><span class=\"n\">parNil</span>\n</code></pre></div>\n<p>Should I be concerned about polluting the search space for grind in any way?</p>",
        "id": 537429332,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756889427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>: I've created a <code>grind-ccs</code> branch to play with these issues.<br>\nTherein, I have manually defined <code>lts</code> so that we can exclude problems introduced by our elaborators (but we should fix that once we know what we wanna do, ofc).</p>\n<p>Please have a look at my two 'grind hacks' given in <a href=\"https://github.com/leanprover/cslib/blob/c74dd26bd7cea93c96d96ab542aa18bdfac6ac21/Cslib/Languages/CCS/BehaviouralTheory.lean#L38\">https://github.com/leanprover/cslib/blob/c74dd26bd7cea93c96d96ab542aa18bdfac6ac21/Cslib/Languages/CCS/BehaviouralTheory.lean#L38</a>. Specifically, I have to (a) require that the definition of <code>lts</code> is reducible (otherwise, we need manual unfoldings) and (b) introduce some equations manually to get through instances like Zero if people don't use those uniformly.</p>\n<p>Re (a): I'm unsure whether requiring reducibility is intended with grind. Is it? It's weird to me, at least, since grind seems to get the right equalities out, but somehow doesn't use them when needed.</p>\n<p>Re (b): An easy solution here is probably to tell people to use the notations given by classes uniformly all over the place, instead of just some places. ;-) That sounds ok?</p>",
        "id": 537435506,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756891587
    },
    {
        "content": "<p>I have created the issue <a href=\"https://github.com/leanprover/cslib/pull/55\">cslib#55</a> for the elab issues, I'll take a look soon.</p>\n<p>I'm reminded that despite being the author of that meta code, I still don't  quite understood the usefulness of <code>Lts</code> (and <code>ReductionSystem</code>). I've had the thought that it would be nicer if the notations directly were the relation and closure versus this bundling. Do you think you could comment on the issue with an explanation <span class=\"user-mention\" data-user-id=\"929508\">@Fabrizio Montesi</span>? </p>\n<p>Re (b) I do like the paramaterized notations and they should be the encouraged interface. However even if you only use the notation, and despite the <code>notation3</code>-generated delaborators, you can still occasionally be exposed to the underlying <code>Lts</code> or <code>ReductionSystem</code>. In some places I have <code>grind</code> annotations <a href=\"https://github.com/leanprover/cslib/blob/ac3d1d18bdfaf21de8c23b400e1b28912bd44340/Cslib/Languages/LambdaCalculus/LocallyNameless/Untyped/FullBetaConfluence.lean#L43-L47\">like this</a> that are helpful, with a TODO comment that I should generate these along with <code>Lts</code> and <code>ReductionSystem</code>.</p>",
        "id": 537460347,
        "sender_full_name": "Chris Henson",
        "timestamp": 1756901008
    },
    {
        "content": "<p>There are two motivations behind them. One, which we can forget about, is historical: I was in doubt as to whether we should bundle more stuff (like the types of states and actions), but that turned out not to be necessary. The other reason is that I wanted good support for automatically deriving the <code>MTr</code> and <code>STr</code> relations for any Lts and offering them to users, and the dot-notation achieves that. I'm unsure how to do without a structure, but if there's a better way I'm all for it. :-)</p>",
        "id": 537461690,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756901471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Btw, this reveals that sometimes it's convenient to control attributes on the lts/rs definition. Maybe we should allow for it being defined separately and still benefit from the notation?..</p>",
        "id": 538004320,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757166720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/537460347\">said</a>:</p>\n<blockquote>\n<p>Re (b) I do like the paramaterized notations and they should be the encouraged interface. However even if you only use the notation, and despite the <code>notation3</code>-generated delaborators, you can still occasionally be exposed to the underlying <code>Lts</code> or <code>ReductionSystem</code>. In some places I have <code>grind</code> annotations <a href=\"https://github.com/leanprover/cslib/blob/ac3d1d18bdfaf21de8c23b400e1b28912bd44340/Cslib/Languages/LambdaCalculus/LocallyNameless/Untyped/FullBetaConfluence.lean#L43-L47\">like this</a> that are helpful, with a TODO comment that I should generate these along with <code>Lts</code> and <code>ReductionSystem</code>.</p>\n</blockquote>\n<p>Not sure I get what you mean, as I was talking about the notation generated by <code>Zero</code> and similar. (See the link to my 'hacks'.)</p>",
        "id": 538004435,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757166794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/538004320\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> Btw, this reveals that sometimes it's convenient to control attributes on the lts/rs definition. Maybe we should allow for it being defined separately and still benefit from the notation?..</p>\n</blockquote>\n<p>You mean being able to add attributes to the derived definition? We could probably pass those along in the attribute if you wanted.</p>\n<p>Note however, you can already use the command that adds these notations on existing definitions. See <a href=\"https://github.com/leanprover/cslib/blob/5b2ba412c4e8e5867ddec142b2005a46fd9e6eb3/Cslib/Foundations/Semantics/ReductionSystem/Basic.lean#L85-L95\"><code>reduction_notation</code></a> and <a href=\"https://github.com/leanprover/cslib/blob/5b2ba412c4e8e5867ddec142b2005a46fd9e6eb3/Cslib/Foundations/Semantics/Lts/Basic.lean#L592-L602\"><code>lts_transition_notation</code></a>.</p>",
        "id": 538027942,
        "sender_full_name": "Chris Henson",
        "timestamp": 1757188978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Grind.20and.20unfolding/near/538004435\">said</a>:</p>\n<blockquote>\n<p>Not sure I get what you mean, as I was talking about the notation generated by <code>Zero</code> and similar. (See the link to my 'hacks'.)</p>\n</blockquote>\n<p>I think we are describing the same problem form different perspectives. The issue is when grind cannot see through a notation. So when instantiating a notation typeclass, it can be helpful to follow up with a <code>grind _=_</code> lemma to treat them interchangeably.</p>",
        "id": 538028455,
        "sender_full_name": "Chris Henson",
        "timestamp": 1757189474
    },
    {
        "content": "<p>Not sure if that's considered a \"hack\", but I don't know of another way to do this. As an example, in working with contexts, I have found it helpful to add grind annotations to existing lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.append_eq#doc\">docs#List.append_eq</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.mem_def#doc\">docs#Option.mem_def</a></p>",
        "id": 538028714,
        "sender_full_name": "Chris Henson",
        "timestamp": 1757189726
    }
]