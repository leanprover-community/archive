[
    {
        "content": "<p>(Triggered by the discussion in <a href=\"https://github.com/cs-lean/cslib/pull/17#discussion_r2228569513\">https://github.com/cs-lean/cslib/pull/17#discussion_r2228569513</a> with <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> )<br>\nIn logic, semantics, and type systems (at least!), we encounter often the situation where we'd like to use important Lean symbols for notation. Examples: <code>T → T</code> for arrow types (functions) in an embedded type system, <code>A → B</code> for implication in an embedded logic, <code>M → N</code> for a reduction, <code>x : T</code> for x has type T, etc.</p>\n<p>I can see that:</p>\n<ol>\n<li>Some formalisation projects, especially in Rocq, <em>do</em> overload the core notation for their embedded systems.</li>\n<li>Some projects figure out alternative notation.</li>\n</ol>\n<p>Is option 1 even feasible in Lean in the long run?<br>\nIf we instead follow option 2, we should probably agree on some standard 'translation' of the normal pen-and-paper symbol and document it, so that we use it coherently. (Ideally even in code, with type classes.)</p>",
        "id": 531132729,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753619983
    },
    {
        "content": "<p>Here you could consider some <code>t(_ → _)</code> elaborator where within the <code>()</code> you're not using regular lean syntax at all</p>",
        "id": 531133408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753620250
    },
    {
        "content": "<p>Is there a convention for how these elaborators should be called? I see a lot of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Name</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in docs.</p>",
        "id": 531133733,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753620368
    },
    {
        "content": "<p>That's not really the same thing; I'm thinking of things in the style of <code>q(_)</code> and <code>congr(_)</code> and <code>ofNat(_)</code> that are currently in mathlib (though these don't really invent new notation inside the <code>()</code>s)</p>",
        "id": 531133888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753620432
    },
    {
        "content": "<p>the</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is a syntax quotation</p>",
        "id": 531133895,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753620434
    },
    {
        "content": "<p>Whoops, yes, sorry for the conflation.</p>",
        "id": 531134534,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753620665
    },
    {
        "content": "<p>Mmh, so perhaps we could make an appropriately-namespaced term elaborator whenever we wanted this kind of syntax, and then people who wanted to use it easily could just <code>open</code> to get it. Term elaborators might actually also solve some problems we had with taking parameters when we use notation.</p>",
        "id": 531135592,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753621076
    },
    {
        "content": "<p>Trying to imagine how this will look in nontrivial places. Here's the reduction of a typing judgement (a concept used in plenty of works):</p>\n<p><code>red(ty(Γ ⊢ M : T) → ty(Γ ⊢ M' : T))</code></p>",
        "id": 531139836,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753622705
    },
    {
        "content": "<p>Here's an example in <a href=\"https://github.com/UCSCFormalMethods/LeanLTL/blob/ef8d4c9dd94d3ae85e76328549b70e35551891f2/LeanLTL/TraceSet/Notation.lean#L369-L370\">LeanLTL</a> (<a href=\"https://arxiv.org/abs/2507.01780\">short paper</a>). The <code>LLTL[t]</code> macro expands the Lean term <code>t</code> to an LTL interpretation.</p>\n<p><code>LLTL[p → q]</code> expands to <code>p ⇨ q</code>, where <code>⇨</code> is the Heyting algebra arrow. There's also a pretty printer that turns Heyting algebra arrows back into LLTL syntax if it's for LTL types.</p>",
        "id": 531140404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753622921
    },
    {
        "content": "<p>This uses macros, but a future version probably will use more hands-on elaboration to control expansion better.</p>",
        "id": 531140559,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753622980
    },
    {
        "content": "<p>A sequents in classical linear logic instantiated with the type MyAtom of atomic propositions: <code>cll MyAtom(?a &amp; !b)</code></p>",
        "id": 531140569,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753622985
    },
    {
        "content": "<p>Check the notation file of Iris : <a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/BI/Notation.lean\">https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/BI/Notation.lean</a></p>",
        "id": 531141197,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753623231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Overloading.20Lean's.20notation/near/531141197\">said</a>:</p>\n<blockquote>\n<p>Check the notation file of Iris</p>\n</blockquote>\n<p>Like this one?</p>\n<p><a href=\"https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/BI/Notation.lean\">https://github.com/leanprover-community/iris-lean/blob/master/src/Iris/BI/Notation.lean</a></p>\n<p>(Crossed over, thx for the link.)</p>",
        "id": 531141410,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753623312
    },
    {
        "content": "<p>Iris sells it pretty well, looks nice.<br>\nThanks for the input, everyone. :)</p>\n<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> What do you think of the approach?</p>",
        "id": 531141669,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753623423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/stream/516743-computer-science/topic/Overloading.20Lean's.20notation/near/531139836\">said</a>:</p>\n<blockquote>\n<p>Trying to imagine how this will look in nontrivial places. Here's the reduction of a typing judgement (a concept used in plenty of works):</p>\n<p><code>red(ty(Γ ⊢ M : T) → ty(Γ ⊢ M' : T))</code></p>\n</blockquote>\n<p>There is no need to nest <code>red(...)</code> and <code>ty(...)</code>, this can be done as part of the elab. </p>\n<p>In general yes, this was on my radar and seems correct. I have written some simple term elaborators. As I mentioned in a previous PR I'd also like a pretty printer, the examples posted above are helpful for learning how to write one.</p>\n<p>I will reply to your comment on the PR regarding some details I believe would need to be worked out.</p>",
        "id": 531157713,
        "sender_full_name": "Chris Henson",
        "timestamp": 1753629249
    },
    {
        "content": "<p>I don't have much to contribute, but I am curious about such overloaded notation too for other model logics. And <span class=\"user-mention\" data-user-id=\"315434\">@Andrés Goens</span> a while ago wrote these examples, including pretty printing, in the pdl project: <a href=\"https://github.com/m4lvin/lean4-pdl/compare/main...pretty\">https://github.com/m4lvin/lean4-pdl/compare/main...pretty</a></p>",
        "id": 531203559,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1753646658
    },
    {
        "content": "<p>Created a related issue: <a href=\"https://github.com/cs-lean/cslib/issues/23\">https://github.com/cs-lean/cslib/issues/23</a></p>",
        "id": 531284972,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753684050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422703\">Malvin Gattinger</span> <a href=\"#narrow/channel/516743-computer-science/topic/Overloading.20Lean's.20notation/near/531203559\">said</a>:</p>\n<blockquote>\n<p>I don't have much to contribute, but I am curious about such overloaded notation too for other model logics. And <span class=\"user-mention silent\" data-user-id=\"315434\">Andrés Goens</span> a while ago wrote these examples, including pretty printing, in the pdl project: <a href=\"https://github.com/m4lvin/lean4-pdl/compare/main...pretty\">https://github.com/m4lvin/lean4-pdl/compare/main...pretty</a></p>\n</blockquote>\n<p>right, that approach is essentially the same as above, just using a different syntactic convention <code>[f|...]</code> instead of <code>f(...)</code></p>",
        "id": 531530433,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1753773132
    },
    {
        "content": "<p>the cool think I think is when building these unexpanders that it also shows up on the proof goals</p>",
        "id": 531530515,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1753773161
    },
    {
        "content": "<p>Term conversion is η-conversion's cool grandchild.</p>",
        "id": 531561751,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753782120
    }
]