[
    {
        "content": "<p>Let <code>L : Set (List A)</code> be a \"language\" in the automata theory sense, where <code>A : Type*</code>.  We can define <code>L^ω : Set (ℕ → A)</code> to be the set of infinite sequences each of which is an infinite concatenation of words from <code>L</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">L</span><span class=\"bp\">^</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">⇊</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>where <code>as ⇊ i j</code> is the finite word consisting of <code>as i, as (i + 1), ..., as (j - 1)</code>.  (That is, ⇊ is the analogue of List.extract for infinite sequences.). The above definition works and I've proved quite a few results involving it in my automata theory development (see <a href=\"https://github.com/ctchou/AutomataTheory\">https://github.com/ctchou/AutomataTheory</a>).  But I've found that it is very, very painful to work with the above definition.  For example, I'm now trying to prove the intuitively obvious result:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">∗</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">ω</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">^</span><span class=\"n\">ω</span>\n</code></pre></div>\n<p>where <code>L∗</code> is the Kleene-star of <code>L</code>.  I'm finding the going very tough and unpleasant.  Hence my question: Is there a better and more usable definition of <code>L^ω</code>?  I have not been able to think of any.</p>",
        "id": 539912686,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758070409
    },
    {
        "content": "<p>ah, so φ basically lists the indices of the \"stitches\" (so to speak) in the concatenation for each sequence</p>",
        "id": 539925259,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758082072
    },
    {
        "content": "<p>or even simpler, it just lists the starting indices for each concatenated word</p>",
        "id": 539925340,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758082138
    },
    {
        "content": "<p>yeah, it does seem a bit difficult to express \"<code>as</code> is an infinite concatenation of finite lists\"</p>",
        "id": 539925573,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758082337
    },
    {
        "content": "<p>Yes, that's right.   The <code>L^ω ⊆ (L∗)^ω</code> direction is easy to prove.  But the other direction <code>(L∗)^ω ⊆ L^ω</code> is nasty and I can't think of an alternative definition or an intermediate lemma to make it easier.</p>",
        "id": 539925855,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758082577
    },
    {
        "content": "<p>Toward the end of this file:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/work-1/AutomataTheory/Languages/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/work-1/AutomataTheory/Languages/Basic.lean</a><br>\nyou can find my current incomplete proof.  It is not pretty and I had to use notions and results from this file:<br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/work-1/AutomataTheory/Sequences/Segments.lean\">https://github.com/ctchou/AutomataTheory/blob/work-1/AutomataTheory/Sequences/Segments.lean</a><br>\nwhich are rather unwieldy, although the intuitive idea is very simple.</p>",
        "id": 539926071,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758082791
    },
    {
        "content": "<p>btw, not sure if you're aware but a lot of the sequence API you've written is also covered by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a></p>",
        "id": 539926161,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758082874
    },
    {
        "content": "<p>(if you wanted to create your own API that's fine too, just thought I would mention it)</p>",
        "id": 539926198,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758082919
    },
    {
        "content": "<p>Yes, I've looked at Stream' and may change my code to use it later.  But as far as I can tell, Stream' does not have the sort of results that I use.  In particular, Stream' seems to try hard to avoid talking about explicit  indices, while I need to  directly reason about indices all the time (which is why the omega tactic is used all over the place in my code).</p>",
        "id": 539926351,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758083061
    },
    {
        "content": "<p>BTW, why is it called <code>Stream'</code>?  Wouldn't <code>Sequence</code> be a better name?  This is especially confusing when there is also <code>Stream</code> which is different from <code>Stream'</code>.</p>",
        "id": 539926518,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758083208
    },
    {
        "content": "<p>yeah I have no idea, it was called <code>stream</code> in mathlib3</p>",
        "id": 539926617,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758083284
    },
    {
        "content": "<p>and then of course there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.Seq#doc\">docs#Stream'.Seq</a> which is referred to as a \"sequence\"</p>",
        "id": 539926712,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758083355
    },
    {
        "content": "<p>to be fair, getting terminology right can be hard</p>",
        "id": 539926726,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758083368
    },
    {
        "content": "<p>one thought would be to have φ be a list of word lengths rather than indices, from which you could then derive the indices by summing up previous lengths... however, I have no idea if that would make things harder or easier</p>",
        "id": 539927478,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758083830
    },
    {
        "content": "<p>I only know that it would remove the need for the <code>StrictMono</code> and <code>φ 0 = 0</code> requirements</p>",
        "id": 539927533,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758083893
    },
    {
        "content": "<p>but the lists would contain the same information, so it probably wouldn't buy you anything</p>",
        "id": 539927656,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758084012
    },
    {
        "content": "<p>I doubt it.  The difficulty in the proof of <code>(L∗)^ω ⊆ L^ω</code> is that the LHS has two levels of indices (or lengths) and it is a pain in the *** to somehow \"flatten\" them into a single level when one can't use a recursive formulation of the flattening operation.  (At least I don't know how to do that.)</p>",
        "id": 539927858,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758084185
    },
    {
        "content": "<p>Imagine that we want to prove <code>(L∗)∗ = L∗</code>.  One could define the Kleene-star <code>L∗</code> using a definition like that for <code>L^ω</code>.  (Indeed, there is a theorem <code>IterStar_seg_exists</code> in <code>Languages/Basic.lean</code> showing you how that can be done.). But we probably won't use that approach.  Instead, we will try to exploit the recursive definition of <code>L ^ n</code> and do an inductive proof.  It would be nice if I know how to do that with <code>L^ω</code>.</p>",
        "id": 539928428,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758084676
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/516743-computer-science/topic/Is.20there.20a.20better.20definition.20of.20L.5E.CF.89.20.3F/near/539928428\">said</a>:</p>\n<blockquote>\n<p>It would be nice if I know how to do that with <code>L^ω</code>.</p>\n</blockquote>\n<p>I <em>think</em> the equivalent version for <code>L^ω</code> would be a coinductive definition, but that's a guess based on <a href=\"https://en.wikipedia.org/wiki/Coinduction#Stream_as_a_final_coalgebra\">the fact that</a> infinite streams over <code>A</code> are a final coalgebra for the functor </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>X</mi><mo>↦</mo><mi>A</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X \\mapsto A \\times X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span></p>\n<p><a href=\"#narrow/channel/113488-general/topic/Coinduction.20in.20mathlib4.3F/with/539487564\">Lean support for coinduction</a> is I think fairly nascent so this might not help even if it is true.</p>",
        "id": 539984544,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758106716
    },
    {
        "content": "<p>The <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a> API should have some coinductive things</p>",
        "id": 539986311,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758107336
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.head#doc\">docs#Stream'.head</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.tail#doc\">docs#Stream'.tail</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.corec#doc\">docs#Stream'.corec</a></p>",
        "id": 539986670,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758107481
    },
    {
        "content": "<p>I guess it will be nicer if we create APIs and lemmas on <code>(ℕ → List α) → ℕ → α</code></p>",
        "id": 539999645,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1758111427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/516743-computer-science/topic/Is.20there.20a.20better.20definition.20of.20L.5E.CF.89.20.3F/near/539986311\">said</a>:</p>\n<blockquote>\n<p>The <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a> API should have some coinductive things</p>\n</blockquote>\n<p>It would be great if someone can show me how to define <code>L^ω</code> using the <code>Stream'</code> API.  I looked at the API and it is not clear to me how to do so.  In fact, we can start with something even simpler: the concatenation of a language of finite words and an ω-language of infinite words:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ConcatInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">al0</span><span class=\"w\"> </span><span class=\"n\">as1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">al0</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">as1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">al0</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">as1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>where <code>++</code> is a notation for appending a finite word and an infinite word:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AppendListInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">xl</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">xl</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">xl</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If <code>ℕ → A</code> is replaced by <code>Stream' A</code>,  can the <code>Stream'</code> API be used to define the above?</p>",
        "id": 540070098,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758130677
    },
    {
        "content": "<p>I can see how to define <code>AppendListInf</code> using the <code>Stream'</code> API by recursing on the first argument, but I don't see how to do <code>ConcatInf</code>.  How do you get the existential quantifiers?</p>",
        "id": 540070605,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758130863
    },
    {
        "content": "<p>What's wrong with <code>ConcatInf</code>?</p>",
        "id": 540072750,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758131714
    },
    {
        "content": "<p>Nothing wrong with it.  But if the <code>Stream'</code> API is limited to defining <code>AppendListInf</code> and everything else is kept the same, then I don't see how the <code>Stream'</code> API is going to improve the definition of <code>L^ω</code>.</p>",
        "id": 540073528,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758131984
    },
    {
        "content": "<p>I didn't say it was going to improve anything I just mentioned about the coinductive things</p>",
        "id": 540075516,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758132619
    },
    {
        "content": "<p>I believe <code>AppendListInf</code> already exists as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.appendStream%27#doc\">docs#Stream'.appendStream'</a></p>",
        "id": 540075786,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758132731
    },
    {
        "content": "<p>(and it comes with the <code>++ₛ</code> notation which is nice)</p>",
        "id": 540075968,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1758132811
    },
    {
        "content": "<p>Thanks for pointing it out.  I'll use it if I ever switch to using <code>Stream'</code>.</p>",
        "id": 540076156,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758132878
    },
    {
        "content": "<p>I finished the proof of <code>(L∗)^ω = L^ω</code>.  It's not pretty, but it works:</p>\n<p><a href=\"https://github.com/ctchou/AutomataTheory/blob/f209ad388f87c737598cb59376a17157c077e34d/AutomataTheory/Languages/Basic.lean#L259\">https://github.com/ctchou/AutomataTheory/blob/f209ad388f87c737598cb59376a17157c077e34d/AutomataTheory/Languages/Basic.lean#L259</a></p>",
        "id": 540115849,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1758150657
    }
]