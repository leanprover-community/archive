[
    {
        "content": "<p>I was porting a variant of <a href=\"https://plfa.github.io/DeBruijn/#terms-and-the-typing-judgment\">this definition from PLFA</a> and was a bit torn on if this should be in <code>Prop</code> or <code>Type</code>. Any thoughts either way? I've written both and am curious what people find more idiomatic.</p>",
        "id": 533965377,
        "sender_full_name": "Chris Henson",
        "timestamp": 1754999964
    },
    {
        "content": "<p>I was writing some lambda calculus code and made my typing judgement a <code>Type (max u v)</code>, and then immediately proved unique typing and unique typing judgements, so that I wouldn't have trouble with disequal typing judgements.</p>",
        "id": 533966479,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755000310
    },
    {
        "content": "<p>In this case it looks like judgements <em>are</em> your terms, and you want to distinguish between different judgements for the same type, so do make it a <code>Type</code>.</p>",
        "id": 533966724,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755000393
    },
    {
        "content": "<p>if you make it a <code>Prop</code> you get that all terms of the same type are equal (you probably don't want that).</p>",
        "id": 533966772,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755000412
    },
    {
        "content": "<p>Ah yeah, that's a pretty good argument. It becomes something like beta eta equivalence classes if you work in <code>Prop</code>. (Which could be desirable for some situations, but wasn't what I wanted here)</p>",
        "id": 533970222,
        "sender_full_name": "Chris Henson",
        "timestamp": 1755001744
    },
    {
        "content": "<p>I don't see how you could possibly get beta-eta equivalence classes just from making it a <code>Prop</code></p>",
        "id": 533970717,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755001893
    },
    {
        "content": "<p>My thought was that In <code>Prop</code>, every typing derivation with the same context and type would be equal. So any type preserving transformation on derivations is equal, e.g. beta or eta reduction.</p>",
        "id": 533971979,
        "sender_full_name": "Chris Henson",
        "timestamp": 1755002325
    },
    {
        "content": "<p>You also get additional equalities, like <code>1 = 0</code></p>",
        "id": 533978473,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755004436
    },
    {
        "content": "<p>This depends on how you frame it. You can get around the limit by adding more parameters to your Prop</p>",
        "id": 534002748,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1755011572
    },
    {
        "content": "<p>If you set \"Is (Judgement) by (derivation)\" as your Prop, then you won't run into the proof irrelevance headache, because your props will be distinguished for different derivations. It's just way more inconvenient</p>",
        "id": 534002901,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1755011633
    },
    {
        "content": "<p>Fwiw, Mario already did this : <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/Prettyprinting.20the.20result.20of.20an.20.23eval/near/403046669\">#lean4 &gt; Prettyprinting the result of an #eval @ üí¨</a></p>",
        "id": 534003280,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1755011772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/516743-computer-science/topic/Prop.20or.20Type.20for.20Intrinsically.20Typed.20Derivations.3F/near/534002901\">said</a>:</p>\n<blockquote>\n<p>If you set \"Is (Judgement) by (derivation)\" as your Prop, then you won't run into the proof irrelevance headache, because your props will be distinguished for different derivations. It's just way more inconvenient</p>\n</blockquote>\n<p>I understand the idea here, but is this different from having untyped terms paramaterizing our derivations?</p>",
        "id": 534005648,
        "sender_full_name": "Chris Henson",
        "timestamp": 1755012532
    },
    {
        "content": "<p>This is a recurring question when formalising inference systems in Lean.</p>",
        "id": 534027832,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755020497
    },
    {
        "content": "<p>For example, you can ask yourself the same question when formalising the inference systems for an operational semantics, derivations in logic, etc.</p>\n<p>In classical linear logic right now, we have that a Proof ends in <code>Prop</code>: <a href=\"https://github.com/cs-lean/cslib/blob/cacc4910658d1599560b0e81b035d3e1fde16cfe/Cslib/Logic/LinearLogic/CLL/Basic.lean#L153\">https://github.com/cs-lean/cslib/blob/cacc4910658d1599560b0e81b035d3e1fde16cfe/Cslib/Logic/LinearLogic/CLL/Basic.lean#L153</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Sequent</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>This means that I cannot really say whether a <code>Proof</code> is cut-free with a simple function. People usually work around with similar devices to what <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> said or weaker variations, like making another inductive with extra parameters (like a counter of the number of cuts within) and prove a characterisation theorem.</p>",
        "id": 534028304,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755020742
    },
    {
        "content": "<p>Essentially, the general question is what to do when making a deep embedding of an inference system.<br>\nThis is gonna be relevant for Phil's PLFL as well, I guess, will trigger.</p>",
        "id": 534028579,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755020873
    },
    {
        "content": "<p>Basically you have to ask yourself how much impredicativity is useful for your inductive type definition.  If it is important then you might be willing to take on the painful task of parametrising  your props with the derivation tree.</p>",
        "id": 534034155,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1755023261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/stream/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/534005648\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/516743-computer-science/topic/Prop.20or.20Type.20for.20Intrinsically.20Typed.20Derivations.3F/near/534002901\">said</a>:</p>\n<blockquote>\n<p>If you set \"Is (Judgement) by (derivation)\" as your Prop, then you won't run into the proof irrelevance headache, because your props will be distinguished for different derivations. It's just way more inconvenient</p>\n</blockquote>\n<p>I understand the idea here, but is this different from having untyped terms paramaterizing our derivations?</p>\n</blockquote>\n<p>A derivation tree is distinct from the last sequent in it. So technically yes</p>",
        "id": 534034278,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1755023331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/534034155\">said</a>:</p>\n<blockquote>\n<p>Basically you have to ask yourself how much impredicativity is useful for your inductive type definition.  If it is important then you might be willing to take on the painful task of parametrising  your props with the derivation tree.</p>\n</blockquote>\n<p>Another thing I was playing with was to define <code>Proof : Sequent ‚Üí Type</code>, and then have a <code>Provable : Sequent ‚Üí Prop</code> defined as 'there exists a <code>Proof</code>of the sequent'. (<code>Provable</code> is called <code>Valid</code> or <code>Derivable</code> in some texts.)</p>\n<p>I still have to explore the ergonomics of this though.</p>",
        "id": 534193192,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755077920
    },
    {
        "content": "<p>Something like this: <a href=\"https://github.com/cs-lean/cslib/blob/1784e7fa311c7596867844bd4bb90d8ead49b2a1/Cslib/Logic/LinearLogic/CLL/Basic.lean#L171\">https://github.com/cs-lean/cslib/blob/1784e7fa311c7596867844bd4bb90d8ead49b2a1/Cslib/Logic/LinearLogic/CLL/Basic.lean#L171</a></p>\n<p>Logical equivalences are stated in terms of <code>Provable</code>, whereas <code>cutFree</code> is stated on <code>Proof</code> (here: <a href=\"https://github.com/cs-lean/cslib/blob/provable/Cslib/Logic/LinearLogic/CLL/CutElimination.lean\">https://github.com/cs-lean/cslib/blob/provable/Cslib/Logic/LinearLogic/CLL/CutElimination.lean</a>).</p>",
        "id": 534221628,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755088775
    },
    {
        "content": "<p>Had an exchange with Phil Wadler and we agreed the approach using <code>Type</code> for inference systems seems sensible. That's what he's using in PLFA/PLFL as well.</p>\n<p>I'd like to hear more about where we should care for proof irrelevance though, to see if <code>Provable</code> is useful and adequate.</p>",
        "id": 534351401,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1755153937
    },
    {
        "content": "<p>Think I've managed to define cut-free proofs, cut admissibility, and cut elimination in a decent way, without having to resort to <code>Type</code>.<br>\nYou can check it out at: <a href=\"https://github.com/leanprover/cslib/blob/main/Cslib/Logics/LinearLogic/CLL/CutElimination.lean\">https://github.com/leanprover/cslib/blob/main/Cslib/Logics/LinearLogic/CLL/CutElimination.lean</a></p>",
        "id": 536577994,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1756377787
    },
    {
        "content": "<p>on this, i‚Äôve started having a look at formalising ‚Äúnon idempotent intersection types‚Äù as a way of getting a feel for <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>‚Äôs lambda calculus work ‚Äî it seemed necessary to have a <code>Type</code> of derivations there because you start to be interested in eg the size of the derivation, which i think you would lose with proof irrelevance</p>",
        "id": 538456971,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1757429424
    },
    {
        "content": "<p>(see slides <a href=\"https://pageperso.lis-lab.fr/~giulio.guerrieri/ECI2024/day4.pdf\">https://pageperso.lis-lab.fr/~giulio.guerrieri/ECI2024/day4.pdf</a>)</p>",
        "id": 538457147,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1757429468
    },
    {
        "content": "<p>I've recently added an example of how to do that for CLL: <a href=\"https://cs-lean.github.io/Cslib/Logics/LinearLogic/CLL/CutElimination.html#CLL.Proof.HasSize\">https://cs-lean.github.io/Cslib/Logics/LinearLogic/CLL/CutElimination.html#CLL.Proof.HasSize</a><br>\nBasically you define something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"bp\">.</span><span class=\"n\">HasSize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sequent</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 538588930,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757491228
    },
    {
        "content": "<p>right i follow ‚Äî how would this work for induction measures (say, height or complexity of cuts) since it's not a function on proofs, would it go through using some lemma like \"every proof has a unique size\"?</p>",
        "id": 538599477,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1757494672
    },
    {
        "content": "<p>I still have to explore this fully, but I guess that either you go by induction/cases on the inductive that defines the measure (like Proof.HasSize) or you incorporate the measure explicitly in the theorem statement. An example of the first is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">HasSize</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">hsize</span>\n</code></pre></div>",
        "id": 538612602,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757499098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/538599477\">said</a>:</p>\n<blockquote>\n<p>right i follow ‚Äî how would this work for induction measures (say, height or complexity of cuts) since it's not a function on proofs, would it go through using some lemma like \"every proof has a unique size\"?</p>\n</blockquote>\n<p>You can't do that for proofs</p>",
        "id": 538614361,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757499766
    },
    {
        "content": "<p>I think they are talking about deduction trees. Not lean prop proofs</p>",
        "id": 538615629,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757500230
    },
    {
        "content": "<p>oh, should have said so, then it's just recursive pattern matching like everything else</p>",
        "id": 538615882,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757500314
    },
    {
        "content": "<p><code>Prop</code>s are defeq, and saying a <code>Prop</code> is cut-free/height-bounded sounds weird since there could be both a cut-free proof and a proof with cut on the same sequent.</p>",
        "id": 539101649,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757691912
    },
    {
        "content": "<p>They are not talking about Lean <code>Prop</code>s. See my previous message</p>",
        "id": 539101875,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757691966
    },
    {
        "content": "<p>Conceptually not, but the Lean definition <a href=\"https://cs-lean.github.io/Cslib/Logics/LinearLogic/CLL/CutElimination.html#CLL.Proof.CutFree\">CLL.Proof.CutFree</a> is.</p>",
        "id": 539102050,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757692002
    },
    {
        "content": "<p>No it‚Äôs a predicate on <code>Proof</code></p>",
        "id": 539102287,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757692046
    },
    {
        "content": "<p>And a <code>Proof</code> is a <code>Prop</code></p>",
        "id": 539102351,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757692058
    },
    {
        "content": "<p>No it is a predicate on sequents</p>",
        "id": 539102610,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757692101
    },
    {
        "content": "<p>If you have a derivation tree, you have <code>h : Proof Œì</code> as a <code>Prop</code>. And then you have <code>h.CutFree</code> which is a predicate on a <code>Prop</code>.</p>",
        "id": 539102900,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757692152
    },
    {
        "content": "<p>What I mean is, you can legally construct two derivations <code>h1 : Proof Œì</code> and <code>h2 : Proof Œì</code>, one using cut and one is cut-free. However Lean's type system gives <code>h1 = h2</code>, and <code>h1.CutFree</code> <code>h2.CutFree</code> both hold.</p>",
        "id": 539103265,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757692214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539102610\">said</a>:</p>\n<blockquote>\n<p>No it is a predicate on sequents</p>\n</blockquote>\n<p>The predicate seems to say \"this sequent has a proof\" without recording anywhere which proof it is</p>",
        "id": 539106637,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757692737
    },
    {
        "content": "<p>So if you say a <code>Proof</code> is cut-free what this actually says is that there exists some cut-free proof of that sequent</p>",
        "id": 539107200,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757692827
    },
    {
        "content": "<p>which is fine if that's what you intended but usually that's not what I would think it's supposed to mean</p>",
        "id": 539107986,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757692955
    },
    {
        "content": "<p>That <code>Proof</code> was once called <code>Provable</code>, which matches what you're saying. I was trying the <code>Prop</code> thing but I agree it has its quirks... also, if we just used <code>Type</code>, we'd get actual algorithms for manipulating proofs.</p>",
        "id": 539110949,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757693465
    },
    {
        "content": "<p>However I'm not fully convinced that requiring a precise <code>Proof</code> is what we want for the definition of logical equivalence. That's why I proposed to have the current Proof as a Type, and then a Prop called Provable defined as 'there exists a Proof of Gamma'. Thoughts?</p>",
        "id": 539111615,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757693577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539110949\">said</a>:</p>\n<blockquote>\n<p>if we just used <code>Type</code>, we'd get actual algorithms for manipulating proofs.</p>\n</blockquote>\n<p>I‚Äôm inclined to agree with this ‚Äî it doesn‚Äôt seem to me that things would be especially more difficult with <code>Type</code> valued derivations, &amp; that also opens up semantics / realisability flavoured applications (ie translations on derivation trees)</p>",
        "id": 539112226,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1757693682
    },
    {
        "content": "<p>I'd be happy to switch <code>Proof</code> to <code>Type</code>, but it'd be nice to discuss how to define <code>Proposition.equiv</code> under that change.</p>",
        "id": 539145183,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757702715
    },
    {
        "content": "<p>My idea was to define it by replacing <code>Proof</code> with <code>Provable</code>. But then lots of proofs about equivalences have to extract the underlying proof from the existential (which I guess would be fine?).</p>",
        "id": 539145251,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757702760
    },
    {
        "content": "<p>One thing to watch out for. You will run headlong into the predicativity of type, especially if you have higher order predicates</p>",
        "id": 539145816,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703039
    },
    {
        "content": "<p>Can you flesh that out a bit?</p>",
        "id": 539145995,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757703122
    },
    {
        "content": "<p>An alternative is to define <code>CutFreeProof : Sequent Œì ‚Üí Prop</code> that merely says \"there exists a cut-free proof for this sequent\"</p>",
        "id": 539146035,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1757703136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539145995\">said</a>:</p>\n<blockquote>\n<p>Can you flesh that out a bit?</p>\n</blockquote>\n<p>If you want to write <code>exists predicate(something) , &lt;some property of predicate&gt;</code>, I believe there are some universe bumps along the way.</p>",
        "id": 539146203,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539146035\">said</a>:</p>\n<blockquote>\n<p>An alternative is to define <code>CutFreeProof : Sequent Œì ‚Üí Prop</code> that merely says \"there exists a cut-free proof for this sequent\"</p>\n</blockquote>\n<p>That doesn't sound too bad actually. It'd basically be <code>Proof</code> but without the cut rule.</p>",
        "id": 539146208,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757703213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539146203\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539145995\">said</a>:</p>\n<blockquote>\n<p>Can you flesh that out a bit?</p>\n</blockquote>\n<p>If you want to write <code>exists predicate(something) , &lt;some property of predicate&gt;</code>, I believe there are some universe bumps along the way.</p>\n</blockquote>\n<p>Mmh, right, that could very well be -- although I don't have a specific example in mind.</p>",
        "id": 539146321,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1757703261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539146208\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539146035\">said</a>:</p>\n<blockquote>\n<p>An alternative is to define <code>CutFreeProof : Sequent Œì ‚Üí Prop</code> that merely says \"there exists a cut-free proof for this sequent\"</p>\n</blockquote>\n<p>That doesn't sound too bad actually. It'd basically be <code>Proof</code> but without the cut rule.</p>\n</blockquote>\n<p>You might want to specifically define a proof that says <code>IsProofOf Proposition proof-tree</code></p>",
        "id": 539146390,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703295
    },
    {
        "content": "<p>This can be a prop</p>",
        "id": 539146418,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703305
    },
    {
        "content": "<p>Then for each proof and proof tree, you have a different proposition</p>",
        "id": 539146453,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/534034155\">said</a>:</p>\n<blockquote>\n<p>Basically you have to ask yourself how much impredicativity is useful for your inductive type definition.  If it is important then you might be willing to take on the painful task of parametrising  your props with the derivation tree.</p>\n</blockquote>\n<p>Which is what I suggested a while back</p>",
        "id": 539146505,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1757703345
    },
    {
        "content": "<p>I've put together a formalisation of the basics of natural deduction for intuitionistic propositional logic (Gentzen's system NJ) using <code>Type</code> valued derivations ‚Äî <a href=\"https://github.com/thomaskwaring/cslib_SKI/blob/scratch/Cslib/Logics/NaturalDeduction/NJ.lean\">see here</a>. I'll pr it if it seems of interest to cslib (maybe as it relates to STLC <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>?), but in the meantime it can serve as an example of how such a development might look.</p>\n<p>In particular, I have a type <code>Derivation : Sequent Atom ‚Üí Type _</code>, and a predicate <code>Derivable : Sequent Atom ‚Üí Prop</code> expressing that there exists some derivation, so each result is duplicated, though the <code>Prop</code> version is always a one-liner.</p>",
        "id": 539986346,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758107349
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539145183\">said</a>:</p>\n<blockquote>\n<p>I'd be happy to switch <code>Proof</code> to <code>Type</code>, but it'd be nice to discuss how to define <code>Proposition.equiv</code> under that change.</p>\n</blockquote>\n<p>I dealt with this by defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Equivalent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"o\">},</span><span class=\"n\">A</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>\n<p>(ie an iff), and from there it was easy to show that it's an equivalence relation and has relevant substitution properties eg </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">equivalent_derivability</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IPL</span><span class=\"bp\">.</span><span class=\"n\">NJ</span><span class=\"bp\">.</span><span class=\"n\">Equivalent</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">Œì</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">‚Üî</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">Œì</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>",
        "id": 539986760,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758107507
    },
    {
        "content": "<p>That's great, Thomas!</p>\n<p>I'll have a look asap. I'm almost done battling CCS, too, and I'd like to coordinate for your pr there (will write in the other thread).</p>",
        "id": 539988005,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758107903
    },
    {
        "content": "<p>That </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Contexts are finsets of propositions. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Atom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is fishy, shouldn't it be a <code>Multiset</code>? See <code>CLL.MProof</code>.</p>",
        "id": 539996675,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758110638
    },
    {
        "content": "<p>i went for <code>Finset</code> to avoid explicit contraction, same as multisets avoid explicit exchange</p>",
        "id": 539997652,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758110919
    },
    {
        "content": "<p>Oh, fishy but useful. :)</p>",
        "id": 539997821,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758110965
    },
    {
        "content": "<p>Q: Why did you go for a custom inductive in Derivable instead of just using an existential? Simpler definition, I guess?</p>",
        "id": 539997986,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758111014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539997821\">said</a>:</p>\n<blockquote>\n<p>Oh, fishy but useful. :)</p>\n</blockquote>\n<p>yah, see also having weakening as a derived rule</p>",
        "id": 539998398,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758111085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/539997986\">said</a>:</p>\n<blockquote>\n<p>Q: Why did you go for a custom inductive in Derivable instead of just using an existential? Simpler definition, I guess?</p>\n</blockquote>\n<p>simpler definition, it seemed vaguely ugly to define it as <code>Exists D, True</code>, also this way i get to give a name to the constructor</p>",
        "id": 539998817,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758111206
    },
    {
        "content": "<p>Played a bit with this in the context of linear logic, following my original <code>Provable</code> proposal, to see how it'd look. I'd like to discuss the general pattern since then we can just agree to do the same across logics (and, possibly, inference systems..!).</p>\n<p>First of all, I'd like notation to distinguish proof/derivation trees from the proposition that something is provable. I'm using <code>‚áì</code> for the former and <code>‚ä¢</code> for the latter for now.</p>\n<p>Second, I think we can just use <code>Nonempty</code> for <code>Provable</code> (or <code>Derivable</code>). It's equivalent to what you're doing, <span class=\"user-mention\" data-user-id=\"931332\">@Thomas Waring</span>.</p>\n<p>I've adapted the linear logic development to these conventions, you can see it here: <a href=\"https://github.com/leanprover/cslib/blob/logic-provable/Cslib/Logics/LinearLogic/CLL/Basic.lean\">https://github.com/leanprover/cslib/blob/logic-provable/Cslib/Logics/LinearLogic/CLL/Basic.lean</a></p>\n<p>This gives us actual algorithms to manipulate CLL proofs, which I think is good.</p>\n<p>The downside is that now in all theorems about equivalences we gotta go through Provable.fromProof/toProof (the latter being noncomputable), but that looks ok to me.</p>\n<p>This got me wondering, however: don't we just want the same for equivalences? That is, algorithms that rewrite proofs into proofs with equivalent propositions. These algorithms are basically what's already in there for the proofs of equivalences, since they're all constructive. Getting the <code>Prop</code> equivalence is then trivial.</p>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚áì</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"bp\">‚´†</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"bp\">‚áì</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"bp\">‚´†</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"bp\">‚´†</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"bp\">‚´†</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"bp\">.</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Provable</span><span class=\"bp\">.</span><span class=\"n\">fromProof</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Provable</span><span class=\"bp\">.</span><span class=\"n\">fromProof</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 540179378,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758185153
    },
    {
        "content": "<p>Note that I'm leaving the symbol <code>‚ä®</code> out of this, since we'll probably wanna use it for semantics.</p>",
        "id": 540179899,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758185311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540179378\">said</a>:</p>\n<blockquote>\n<p>This got me wondering, however: don't we just want the same for equivalences?</p>\n</blockquote>\n<p>yes I agree</p>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540179378\">said</a>:</p>\n<blockquote>\n<p>Second, I think we can just use <code>Nonempty</code> for <code>Provable</code></p>\n</blockquote>\n<p>okay great ‚Äî I got scared off by the difference (if any) between a <code>Prop</code> and an <code>instance</code> but if it works then absolutely that's better.</p>",
        "id": 540182793,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758186185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540179378\">said</a>:</p>\n<blockquote>\n<p>First of all, I'd like notation to distinguish proof/derivation trees from the proposition that something is provable. I'm using <code>‚áì</code> for the former and <code>‚ä¢</code> for the latter for now.</p>\n</blockquote>\n<p>One small query here ‚Äî to me <code>‚ä¢</code> reads as notation for the sequent itself, though you're right that it's often used to mean \"is provable\" (maybe in future we can annotate the notation with the system in question, eg <code>CLL ‚ä¢ ...</code>). Would we run into issues once sequents are no longer one-sided (say for ILL)? Something like <code>‚ä¢ Œì‚ä¢A</code> seems confusing to me.</p>",
        "id": 540184200,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758186578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540184200\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540179378\">said</a>:</p>\n<blockquote>\n<p>First of all, I'd like notation to distinguish proof/derivation trees from the proposition that something is provable. I'm using <code>‚áì</code> for the former and <code>‚ä¢</code> for the latter for now.</p>\n</blockquote>\n<p>One small query here ‚Äî to me <code>‚ä¢</code> reads as notation for the sequent itself, though you're right that it's often used to mean \"is provable\" (maybe in future we can annotate the notation with the system in question, eg <code>CLL ‚ä¢ ...</code>). Would we run into issues once sequents are no longer one-sided (say for ILL)? Something like <code>‚ä¢ Œì‚ä¢A</code> seems confusing to me.</p>\n</blockquote>\n<p>I started thinking about the same issue, I agree it'll get confusing. Consider also type systems, etc. :\\</p>",
        "id": 540204141,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758193211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"929508\">Fabrizio Montesi</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540179899\">said</a>:</p>\n<blockquote>\n<p>Note that I'm leaving the symbol <code>‚ä®</code> out of this, since we'll probably wanna use it for semantics.</p>\n</blockquote>\n<p>on this, i have soundness &amp; completeness (for tautologies) for Heyting-algebra semantics of IPL</p>",
        "id": 540230451,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758201228
    },
    {
        "content": "<p>Re notation:<br>\nI should add that it's not <em>that</em> bad, just that it might be a bit confusing and annoying.</p>\n<p>If one has two sided sequents, one can define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span>\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"s2\">\"‚áì\"</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Or something like that (similar for the turnstile).</p>\n<p>Also, I think turnstile is supposed to mean 'provable', since it's the symbol used to assert/validate a context/sequent (the Gammas).</p>",
        "id": 540296519,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758219772
    },
    {
        "content": "<p>I should give another read to Martin Lof's lectures one of these days... :o)<br>\n<a href=\"https://ncatlab.org/nlab/files/MartinLofOnTheMeaning96.pdf\">https://ncatlab.org/nlab/files/MartinLofOnTheMeaning96.pdf</a></p>",
        "id": 540297680,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758220119
    },
    {
        "content": "<p>Alright, I've pushed what I have to CLL for now. :)</p>\n<p>I'm not sure that this is easy to generalise as typeclasses to share across logics though yet... mmmh... what do you think?</p>",
        "id": 540445201,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758285461
    },
    {
        "content": "<p>great, i‚Äôll take a proper look today</p>\n<p>given we don‚Äôt yet have results that apply to all logics i don‚Äôt think there‚Äôs much use in setting up typeclasses ‚Äî probably easier to stick an informal convention to match terminology &amp; notation as much as is appropriate</p>",
        "id": 540758206,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758535356
    },
    {
        "content": "<p>if it seems in-scope i can assemble my natural deduction &amp; heyting semantics into a pr? maybe the latter less-so than the former, let me know</p>",
        "id": 540758447,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758535422
    },
    {
        "content": "<p>One small difference in our idioms ‚Äî I've been putting in two results for your one, one <code>def</code> explicitly giving a <code>Proof</code>, then a one-line <code>theorem</code> deriving the <code>Provable</code> version. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Double negation introduction -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Derivation</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivation</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">implI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">implE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ax'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">Derivation</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>\n<p>Not sure if we would ever need the added constructivity, but it probably can't hurt?</p>",
        "id": 540821565,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758551771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540821565\">said</a>:</p>\n<blockquote>\n<p>One small difference in our idioms ‚Äî I've been putting in two results for your one, one <code>def</code> explicitly giving a <code>Proof</code>, then a one-line <code>theorem</code> deriving the <code>Provable</code> version. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Double negation introduction -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Derivation</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivation</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">implI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">implE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ax'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Proposition</span><span class=\"w\"> </span><span class=\"n\">Atom</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Derivable</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">},</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"n\">Derivation</span><span class=\"bp\">.</span><span class=\"n\">dni</span><span class=\"bp\">‚ü©</span>\n</code></pre></div>\n<p>Not sure if we would ever need the added constructivity, but it probably can't hurt?</p>\n</blockquote>\n<p>I agree this is the way to go, I haven't done it like that only because of lack of time.</p>\n<p>I really need to start having a system for handling TODO and issues... will come back to that in another thread.</p>",
        "id": 540984847,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758625694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"931332\">Thomas Waring</span> <a href=\"#narrow/channel/516743-computer-science/topic/Prop.20or.20Type.20for.20Derivations.3F/near/540758447\">said</a>:</p>\n<blockquote>\n<p>if it seems in-scope i can assemble my natural deduction &amp; heyting semantics into a pr? maybe the latter less-so than the former, let me know</p>\n</blockquote>\n<p>Very much in scope, yes! Let's start with the first, I imagine there's a bit of code to review.</p>\n<p>Re typeclasses: we could at least have some classes to manage notation, maybe? Like, HasLogicalEquiv, which gives the \\equiv notation?</p>",
        "id": 540985154,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1758625794
    },
    {
        "content": "<p>Great, I'll open a PR sometime today :-) I agree about notation typeclasses, so far I haven't defined any so I'll probably put the PR it as is &amp; add that when appropriate</p>",
        "id": 541004864,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758631609
    }
]