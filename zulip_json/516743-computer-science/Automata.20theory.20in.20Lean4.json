[
    {
        "content": "<p>This is the discussion thread for <a class=\"stream-topic\" data-stream-id=\"113486\" href=\"/#narrow/channel/113486-announce/topic/Automata.20theory.20in.20Lean4/with/531915294\">#announce &gt; Automata theory in Lean4</a> .</p>",
        "id": 531915391,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1753904090
    },
    {
        "content": "<p>Do you think it would be possible to find an implementation of NFA and DFAs that is suitable both for your work and what currently exists in Mathlib? It would be great to unify these again, perhaps with a view to learning from these two experiences and putting the synthesis in the new CSLib?</p>",
        "id": 531956972,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753922546
    },
    {
        "content": "<p>For my purpose, the main inconvenience of the current definitions of NFA and DFA in mathlib is that the set of accepting states are bundled in as a part of the NFA or DFA structure.  This makes sense if one only has to deal with finite executions.  But for automata on infinite words, the meaning of the accepting states is very different and in fact there are several different notion of acceptance with differently structured accepting states (see the definitions <code>BuchiAccept</code>, <code>MullerAccept</code>, etc in <a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Basic.lean</a>).  By moving the accepting states out of the structure of an <code>Automaton</code>, I was able to use the same automata constructions to prove the same or similar closure properties for both regular and ω-regular languages.</p>\n<p>On the other hand, I found it convenient to include the type of the states as a field of the <code>Automaton</code> structure, while Mathlib's NFA and DFA have that type as an input parameter.  By bundling the state type, I can very easily define various constructions on automata without having to separately define the corresponding constructions on the state types (for example, see practically every file in <a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/</a>).  I do have to make separate definitions about accepting states, but that is necessitated by the math because the same construction tends not to work for both finite and infinite words.</p>\n<p>Another minor difference is that I don't have ε-transitions in my theory.  In textbooks the ε-transitions are typically used to smooth the presentation of the proofs of various closure properties of regular languages.  But one can do the same proofs without them, at the expense of a slightly less transparent proof in the case of concatenation.</p>",
        "id": 531994990,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1753944971
    },
    {
        "content": "<p>I don't think these differences are insurmountable, but some work needs to be done, I agree.</p>",
        "id": 532004630,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753948324
    },
    {
        "content": "<p>Also, your notions of acceptance can probably be easily defined on top of the Lts type we already have. There we have already come up with some strategies. (And vice versa we might benefit from some of your definitions.)</p>",
        "id": 532004943,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753948422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/516743-computer-science/topic/Automata.20theory.20in.20Lean4/near/531994990\">said</a>:</p>\n<blockquote>\n<p>Another minor difference is that I don't have ε-transitions in my theory.  In textbooks the ε-transitions are typically used to smooth the presentation of the proofs of various closure properties of regular languages.  But one can do the same proofs without them, at the expense of a slightly less transparent proof in the case of concatenation.</p>\n</blockquote>\n<p>Epsilon NFAs are actually superfluous and can be accomplished by raising the alphabet type to an Option type</p>",
        "id": 532013712,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753951143
    },
    {
        "content": "<p>Have you used Mathlib's Stream API? Last I checked, it already had some API that would make infinite words convenient to handle</p>",
        "id": 532013936,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753951212
    },
    {
        "content": "<p>Infinite trees for tree automaton will be much harder</p>",
        "id": 532014012,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753951235
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> is the repository open for pull requests?</p>",
        "id": 532016515,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753951955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/516743-computer-science/topic/Automata.20theory.20in.20Lean4/near/532013936\">said</a>:</p>\n<blockquote>\n<p>Have you used Mathlib's Stream API? Last I checked, it already had some API that would make infinite words convenient to handle</p>\n</blockquote>\n<p>+1 for the Stream API, I'm already using it for the definition of divergence in LTS. (Well, <code>Stream'</code>, to be precise.)</p>",
        "id": 532064219,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753965733
    },
    {
        "content": "<p>Btw, here's how a definition based on <code>Lts</code> would look like, since a DFA is a transition system.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Cslib</span><span class=\"bp\">.</span><span class=\"n\">Semantics</span><span class=\"bp\">.</span><span class=\"n\">Lts</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Dfa</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The transition system of the automaton</span>\n<span class=\"w\">  </span><span class=\"n\">lts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lts</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"n\">Label</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Start state</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Accept states</span>\n<span class=\"w\">  </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The automaton is finite-state</span>\n<span class=\"w\">  </span><span class=\"n\">finite_state</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">FiniteState</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The automaton is deterministic</span>\n<span class=\"w\">  </span><span class=\"n\">deterministic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">lts</span><span class=\"bp\">.</span><span class=\"n\">Deterministic</span>\n</code></pre></div>\n<p>Then one can reuse the theorems for <code>Lts</code>. Alternatively, one can make custom definitions for the transition relation, finite_state, and deterministic, make a <code>toLts</code> function and then prove that the custom properties are the same as defined in the <code>Lts</code> library. Then one could go back and forth between the results for <code>Lts</code> and automata, I think.</p>\n<p>(This is just a sketch, one can move a few other things around.)</p>",
        "id": 532069204,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753967059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> The rationale in <code>Lts</code> is to keep things as unbundled in the general lib, then one can bundle things as they please for their proofs more down the line. I think some of your defs (like for executions and accepting runs) might apply (almost?) directly to all transition systems.</p>",
        "id": 532069692,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753967175
    },
    {
        "content": "<p>I've made a playground here <a href=\"https://github.com/cs-lean/cslib/tree/automata\">https://github.com/cs-lean/cslib/tree/automata</a> in case anybody wants to play with this.</p>",
        "id": 532070103,
        "sender_full_name": "Fabrizio Montesi",
        "timestamp": 1753967288
    },
    {
        "content": "<p>Another tidbit. For non determinism I would use the RTC construction to construct the transition relation of a run</p>",
        "id": 532078004,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753969266
    },
    {
        "content": "<p>Even if the definitions are fundamentally incompatible, there could be some <code>Equiv</code>s and theorems proving some correspondences (perhaps in restricted cases).</p>",
        "id": 532089471,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1753971993
    },
    {
        "content": "<p>In this case I think Ching-Tsun's API is more general than the current Mathlib API.</p>",
        "id": 532090580,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1753972255
    },
    {
        "content": "<p>Thanks for the comments!  I have introduced some infix and postfix notations for operations on languages and ω-languages yesterday (see <a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Languages/Basic.lean</a>).  I plan to find some better notations for operations on sequences as well.  BTW, if anyone has a better idea for the issue I raised in <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Unicode.20notation.20question/with/532161163\">#new members &gt; Unicode notation question</a> , please let me know.</p>\n<p><del>About the Stream API: I'm not sure it will help, because then you need to talk about whether an infinite stream actually contains infinitely many non-<code>none</code> letters to make up an infinite word.  My experience suggests that that would be a messy business.    In any case, I think the ε-transitions are just a technical device for making certain proofs look better on paper.  We don't really need them once those proofs have been done without them.</del> </p>\n<p>In my formalization the deterministic automaton is not a special case of a nondeterministic automaton (<code>Automaton</code>), but a separate class (<code>DetAutomaton</code>) with a unique initial state and a next-state function and a <code>.toNA</code> function to convert it to a nondeterministic automaton (<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Det.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Det.lean</a>).  I actually started with DA being a special case of NA, but found later that having two separate classes is more convenient.  For one thing, I can easily define a function (<code>DetAutomaton.DetRun</code>) that maps an input word to a run and can  easily prove properties about it.  The power-set construction (<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/PSet.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/PSet.lean</a>) and the congruence construction (<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Congr.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Automata/Congr.lean</a>) very naturally produce <code>DetAutomaton</code>.</p>\n<p>Also, the finite-state assumption is almost never needed in proving properties about various automata constructions.  Basically I start to introduce the finite-state assumption only as part of the definitions of regular and ω-regular languages, which do require the automata accepting them to be finite-state.   You can search for the string \"Finite \" to find out where the finite-state assumption enters into the theory.  (BTW, the automata theory in mathlib also doesn't assume NFA and DFA are finite-state, despite the \"F\" in their names.). Incidentally, I never have to assume that the alphabet type <code>A</code> is finite anywhere.  (Of course, this generality is illusory, because a finite-state machine can only make finitely many distinctions on an infinite alphabet.)</p>\n<p>Finally, I'd like to note that the stuff in: <br>\n<a href=\"https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Sequences/Segments.lean\">https://github.com/ctchou/AutomataTheory/blob/main/AutomataTheory/Sequences/Segments.lean</a><br>\nmay be of interest independently of automata theory.</p>",
        "id": 532153860,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1753990653
    },
    {
        "content": "<p>Sorry, I misunderstood what <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> wrote about Stream' above.  Please ignore what I've crossed out above.  I will look into Stream' to see how to use it.</p>",
        "id": 532238136,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1754031141
    },
    {
        "content": "<p>I think I confused Stream' with Stream, which does contain optional values.  They really should have chosen a different name.</p>",
        "id": 532241010,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1754032244
    },
    {
        "content": "<p>I looked into <code>Stream'</code>.  I don't think I'll use it.  The API of <code>Stream'</code> seems designed to support working with infinite sequences without ever using explicit indices to access the sequence's elements.  This is exactly the opposite of what most proofs in my theory do, where direct indexing (and hence the <code>omega</code> tactic) are used everywhere.  There are two functions in <code>Stream'</code> which I ended up duplicating in my theory (AppendListInf and SuffixFrom, which correspond to appendStream' and drop in <code>Stream'</code>).  But in order to use the <code>Stream'</code> versions, I would have to change all the type declarations from <code>ℕ → *</code> to <code>Stream' *</code>, which is more trouble than it is worth.</p>",
        "id": 532251644,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1754035661
    }
]