[
    {
        "content": "<p>OK <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, following up on <a href=\"https://github.com/leanprover-community/batteries/pull/1029#issuecomment-2477024376\">https://github.com/leanprover-community/batteries/pull/1029#issuecomment-2477024376</a> I very much get the proof irrelevance of Prop, and the non-dependent nature of <code>NonEmpty.elim</code>, but not sure what is wrong with my <code>let</code> versions.</p>",
        "id": 482468481,
        "sender_full_name": "John Ericson",
        "timestamp": 1731613131
    },
    {
        "content": "<p>The last <code>let</code> is suffering the same issue again: <code>let &lt;x, h&gt; := proof_of_existential; foo = bar</code> never works because existential elimination only works when followed by a <em>proof</em> of a proposition, not a proposition itself</p>",
        "id": 482468753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613223
    },
    {
        "content": "<p>Try it in lean and you will see</p>",
        "id": 482468791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613244
    },
    {
        "content": "<p>(in general it might help to typecheck your suggestions first so I don't have to play typechecker)</p>",
        "id": 482468879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/.60MonadSatisfying.60.20class.20design/near/482468879\">said</a>:</p>\n<blockquote>\n<p>(in general it might help to typecheck your suggestions first so I don't have to play typechecker)</p>\n</blockquote>\n<p>Yes fair, sorry about that. I haven't pull the latest version yet.</p>",
        "id": 482469063,
        "sender_full_name": "John Ericson",
        "timestamp": 1731613335
    },
    {
        "content": "<p>Regarding</p>\n<blockquote>\n<p>There's no way to get a proof-irrelevant universal quantification for this? That seems like an odd deficiency. I would think <code>NonEmpty</code> ought to work, since class vs inductive is more or less sugar, right? One should be able to dependently eliminate it into <code>_ : Prop</code>, no?</p>\n</blockquote>\n<p>Exists is not the left adjoint of implication, Sigma is</p>",
        "id": 482469148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613374
    },
    {
        "content": "<p>which is to say, currying is only a thing between Sigma and implication not exists and implication</p>",
        "id": 482469250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613411
    },
    {
        "content": "<blockquote>\n<p>because existential elimination only works when followed by a <em>proof</em> of a proposition, not a proposition itself</p>\n</blockquote>\n<p>hmm this sounds like <code>Prop n : Type n+1</code> not <code>Prop n : Prop n+1</code> biting?</p>",
        "id": 482469283,
        "sender_full_name": "John Ericson",
        "timestamp": 1731613429
    },
    {
        "content": "<p>more like <code>h : p : Prop</code> vs <code>p : Prop : Type</code></p>",
        "id": 482469375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613452
    },
    {
        "content": "<p><code>let &lt;x, h&gt; := _; h</code> is okay, <code>let &lt;x, h&gt; := _; p</code> is not</p>",
        "id": 482469445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613481
    },
    {
        "content": "<p>Regarding the question of whether <code>satisfying</code> is uniquely defined, it seems plausible but I'm not sure if it's provable.</p>",
        "id": 482469717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/.60MonadSatisfying.60.20class.20design/near/482469250\">said</a>:</p>\n<blockquote>\n<p>which is to say, currying is only a thing between Sigma and implication not exists and implication</p>\n</blockquote>\n<p>(I was hoping in lieu of having two implications, <code>NonEmpty</code> or similar would act as a modality, and(<code>NonEmpty _ -&gt; _</code> would be the thing, but I guess that doesn't work for similar reasons.)</p>",
        "id": 482469766,
        "sender_full_name": "John Ericson",
        "timestamp": 1731613614
    },
    {
        "content": "<p>The equivalence involving nonempty is <code>(∃ x, p x) ↔ Nonempty {x // p x}</code></p>",
        "id": 482469870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613650
    },
    {
        "content": "<p>so you could say that <code>satisfying</code> is a very specific instance of a choice function on that subtype</p>",
        "id": 482470093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731613722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/.60MonadSatisfying.60.20class.20design/near/482469870\">said</a>:</p>\n<blockquote>\n<p>The equivalence involving nonempty is <code>(∃ x, p x) ↔ Nonempty {x // p x}</code></p>\n</blockquote>\n<p>(yes right, but that one doesn't help get right adjoint irrelevant function type)</p>",
        "id": 482470232,
        "sender_full_name": "John Ericson",
        "timestamp": 1731613777
    },
    {
        "content": "<p>On a slightly different note, have you thought about:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"n\">p0</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>?</p>\n<p>I gather the basic idea of <code>SatisfiesM</code> is \"I might have to rewrite this one step in order to prove the missing lema\", but the use of the lemma can proceed compositionally. The above gadget is neat because that means two people can independently rewrite the monadic step and we can use both simultaneously: we're not just linearly rewriting our monadic actions with refinement types, and different choices aren't irrevocable decisions but confluent decisions.</p>",
        "id": 482474680,
        "sender_full_name": "John Ericson",
        "timestamp": 1731615142
    },
    {
        "content": "<p>that's provable if the subtype in <code>satisfying</code> is unique</p>",
        "id": 482475038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731615275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the <code>Subtype.val &lt;$&gt; satisifying _ x'</code> ?</p>",
        "id": 482481254,
        "sender_full_name": "John Ericson",
        "timestamp": 1731617678
    },
    {
        "content": "<p><code>{ y : m {a // p a} // Subtype.val &lt;$&gt; y = x }</code></p>",
        "id": 482481424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731617744
    },
    {
        "content": "<p>whether that thing has one inhabitant?</p>",
        "id": 482481558,
        "sender_full_name": "John Ericson",
        "timestamp": 1731617790
    },
    {
        "content": "<p>if we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Subtype.val</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Subtype.val</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Then we can have a</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p0</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">y0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(thinking aloud here...)</p>",
        "id": 482481827,
        "sender_full_name": "John Ericson",
        "timestamp": 1731617906
    }
]