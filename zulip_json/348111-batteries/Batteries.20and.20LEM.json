[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Apologises for the orthogonal question but I am wondering how is it going to different from Mathlib? Is it going to be a self contained library that comes with Lean without excluded middle?</p>",
        "id": 472756638,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727290355
    },
    {
        "content": "<p>Highly doubt that. Lean's core tactics liberally use LEM.</p>",
        "id": 472760177,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727291967
    },
    {
        "content": "<p>And lean core has discouraged PRs which make tactic changes to cater to constructive logic.</p>",
        "id": 472760299,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727292014
    },
    {
        "content": "<p>Batteries is still built on top of this core. This library is meant to be an extended version of the standard library, with useful programming utilities</p>",
        "id": 472760395,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1727292077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/348111-batteries/topic/Welcome.20New.20Batteries.20Maintainers!/near/472760177\">said</a>:</p>\n<blockquote>\n<p>Highly doubt that. Lean's core tactics liberally use LEM.</p>\n</blockquote>\n<p>Interesting; I was not aware of this.  Can you point me towards the theorem in Lean’s core library that uses LEM? I was under the impression that it’s just Mathlib.</p>",
        "id": 472767542,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727295324
    },
    {
        "content": "<p>Core takes stuff from mathlib all the time</p>",
        "id": 472767666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727295364
    },
    {
        "content": "<p>I'm personally still committed to supporting constructive logic in lean but there's only so much I can do if upstream doesn't play ball</p>",
        "id": 472767761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727295414
    },
    {
        "content": "<p>One more thing: imagine I am formalising something in Lean but want to avoid the proofs and constructions that used LEM because in the end I want to compute. How can I keep track that I am not using LEM? (In Coq, it’s Print Assumptions so something similar to this Lean)</p>",
        "id": 472769651,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727296243
    },
    {
        "content": "<p>There is #print axioms. But you can still do computation with code that merely used LEM for a proof. It only gets difficult if you want to reduce proofs or run code that actually uses LEM as a decision procedure.</p>",
        "id": 472769990,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727296408
    },
    {
        "content": "<p>9 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"348111\" href=\"/#narrow/stream/348111-batteries/topic/Welcome.20New.20Batteries.20Maintainers.21\">#batteries &gt; Welcome New Batteries Maintainers!</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 472770020,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727296425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472769990\">said</a>:</p>\n<blockquote>\n<p>There is #print axioms. But you can still do computation with code that merely used LEM for a proof. It only gets difficult if you want to reduce proofs or run code that actually uses LEM as a decision procedure.</p>\n</blockquote>\n<p>Now I am slightly confused. Imagine I wrote a program in tactic mode and somewhere I sneaked LEM then you cannot turn it into a runtime code; can you?</p>",
        "id": 472770642,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727296713
    },
    {
        "content": "<blockquote>\n<p>in the end I want to compute</p>\n</blockquote>\n<p>In Lean there are a couple notations of computing (reduction or <code>#eval</code>). It's possible to use LEM/choice and still get executable programs (via <code>#eval</code> or compilation), so long as it's not being used to make decisions when constructing concrete data. Definitions that can't be <code>#eval</code>'d need to be marked <code>noncomputable</code>, and if it's not <code>noncomputable</code> you can <code>#eval</code> it.</p>",
        "id": 472770656,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727296722
    },
    {
        "content": "<p>If you make a definition using tactics, and one of the tactics sneaks in choice, then that can make the definition fail to be computable in this <code>#eval</code> sense, and Lean would require you to mark the definition <code>noncomputable</code>.</p>",
        "id": 472770831,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727296803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472770831\">said</a>:</p>\n<blockquote>\n<p>If you make a definition using tactics, and one of the tactics sneaks in choice, then that can make the definition fail to be computable in this <code>#eval</code> sense, and Lean would require you to mark the definition <code>noncomputable</code>.</p>\n</blockquote>\n<p>Awesome; this is what I was looking for :) Now how to avoid those tactics? After each tactic, I should use print axiom or is there a better way than this?</p>",
        "id": 472771288,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727297024
    },
    {
        "content": "<p>Usually people don't use tactics to create definitions. Instead, they write the definition using \"normal\" functional programming, and embed tactic proofs where they are needed.</p>",
        "id": 472771475,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727297106
    },
    {
        "content": "<p>There's no problem for computability to have one of these embedded tactic proofs depend on choice/LEM, so <code>#print axioms</code> would be too conservative.</p>",
        "id": 472771514,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727297125
    },
    {
        "content": "<p>I don't mean to say that you definitely shouldn't use tactics to create definitions, but you can run into accidental noncomputability this way for example.</p>\n<p>It's also easy to make non-reducing terms using tactics (if you use <code>rw</code> or <code>simp</code> for example), which can matter if you're trying to make reducible <code>Decidable</code> instances.</p>",
        "id": 472771774,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727297229
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> !  Basically the idea is write the definition without tactics and then prove things using tactics, which possibly involve LEM.</p>",
        "id": 472772876,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727297713
    },
    {
        "content": "<p>Actually LEM basically never blocks computation, because it is computationally irrelevant</p>",
        "id": 472772927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727297741
    },
    {
        "content": "<p>By the way, it's definitely possible to make evaluatable functions using tactics. The tactic <code>by_cases</code> can introduce choice, but it doesn't always. For example, the following turns out to be fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's possible to use <code>if</code> directly to prevent choice from ever being possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here's an example where <code>by_cases</code> introduces choice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to compile definition, consider marking it as 'noncomputable' because it depends on</span>\n<span class=\"cm\">'Classical.propDecidable', and it does not have executable code</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Using <code>refine if ...</code> directly gives the immediate error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  failed to synthesize</span>\n<span class=\"cm\">    Decidable (∀ (n : Nat), p n = true)</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 472773052,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727297795
    },
    {
        "content": "<p>you need some of the stronger forms of LEM based on the axiom of choice to get something <code>noncomputable</code> in the generating-code sense</p>",
        "id": 472773053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727297795
    },
    {
        "content": "<p>(I was using LEM as shorthand for \"classical instances\", but yes)</p>",
        "id": 472773149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727297838
    },
    {
        "content": "<p>And ‘by_cases’ lives in Lean core or some outside library? (I don’t see a way to encode allTrue in Coq ; I mean it is not possible constructively so Lean rejects it rightly so)</p>",
        "id": 472774195,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727298339
    },
    {
        "content": "<p><code>by_cases</code> is part of core, but usually if you are building data you would use <code>if h : P then _ else _</code> anyway</p>",
        "id": 472774291,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727298376
    },
    {
        "content": "<p>This isn't the cleanest example, but I think it is kind of neat, since it demonstrates that you can use choice to construct a definition that you can compute with. It's using the fact that every iteration of the loop makes <code>H.choose - n</code> smaller. I imagine it can be simplified. (And also, it doesn't <em>need</em> choice; mathlib has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a>, which doesn't depend on any axioms.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">hn'</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">hn'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_or_eq_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt_succ</span><span class=\"w\"> </span><span class=\"n\">hn'</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">H'</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"n\">hn'</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">decreasing_by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_wf</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hH</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hH</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">hH</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lt_or_eq_of_le</span><span class=\"w\"> </span><span class=\"n\">hH</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hH</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 472775985,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727299285
    },
    {
        "content": "<p>Yep; you may also want to have a look at Constructive Epsilon library (<a href=\"https://coq.inria.fr/doc/v8.20/stdlib/Coq.Logic.ConstructiveEpsilon.html\">https://coq.inria.fr/doc/v8.20/stdlib/Coq.Logic.ConstructiveEpsilon.html</a>). From programming perspective, all it is a linear search and it is bound to succeed because of H.</p>",
        "id": 472777567,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727300144
    },
    {
        "content": "<p>Kyle is on the right track. The most general case of this is Markov's Principle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">MP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>This axiom is not valid in intuitionistic constructive logic. This axiom basically says that classical logic is sound to prove termination of programs. The so-called Russian school of constructivism accepts MP as true, hence the name. Merely assuming LEM for <code>Prop</code> in Lean, allows one to prove MP as a theorem. Lean allows LEM arguments to be tucked into termination proofs without much fuss, so it is quite plausible that one could prove MP in Lean without any obvious red flags.</p>",
        "id": 472804943,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727319918
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Am I missing something? <span aria-label=\"woman shrugging\" class=\"emoji emoji-1f937-200d-2640\" role=\"img\" title=\"woman shrugging\">:woman_shrugging:</span></p>",
        "id": 472806094,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727320800
    },
    {
        "content": "<p>I think what Francois is saying is that while that has constructed an expression that looks like a closed term, there are no guarantees that/when MP p will terminate for arbitrary p when actually executed</p>",
        "id": 472815020,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1727327061
    },
    {
        "content": "<p>Sure it will. :-) That's what <code>h</code> says.</p>",
        "id": 472817690,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727329186
    },
    {
        "content": "<p><code>#print axioms MP</code></p>",
        "id": 472819290,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727330220
    },
    {
        "content": "<p><code>simp</code> counts as a red flag.</p>",
        "id": 472819422,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727330322
    },
    {
        "content": "<p>Using Kyle's idea, I think it's perhaps possible to hide all the uses of LEM in the termination arguments.</p>",
        "id": 472819901,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727330542
    },
    {
        "content": "<p>I remain mystified by the idea that this is an interesting distinction. :-)</p>\n<p>I don't really see how you would do it, in any case. <code>WellFounded.fix</code> can see the quantity you're saying is decreasing, and surely the choice has to happen then.</p>",
        "id": 472821414,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727331447
    },
    {
        "content": "<p>I'm not saying that Lean can prove MP without using any axioms! I'm saying that it can conceal them so that it looks like it's not using any axioms even after reasonable inspection. The following is a bit more concealed but the <code>simp_all</code> does raise my eyebrow.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">MP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">Nat.find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"n\">decreasing_by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- it's too late here to finish...</span>\n</code></pre></div>",
        "id": 472823976,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727332850
    },
    {
        "content": "<p>Ideally, the <code>decreasing_by</code> argument would be automatically generated and would hide the actual use of classical reasoning.</p>",
        "id": 472825407,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727333532
    },
    {
        "content": "<p>Surely <code>#print axioms</code> is the only meaningful sense of \"reasonable inspection\"?</p>",
        "id": 472829385,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727335157
    },
    {
        "content": "<p>Not really. Lean has a habit of using <code>Classical.choice</code> even when it's not needed, so <code>#print axioms</code> is not a reliable tool. In the case of MP, I know that no proof can get by with no axioms (or even just <code>propext</code> and <code>Quot.sound</code>). For a general theorem where I don't know that, the fact that <code>#print axioms</code> shows <code>Classical.choice</code> wouldn't tell me much and I would rely on old fashioned visual inspection.</p>",
        "id": 472830865,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727335742
    },
    {
        "content": "<p>I would say <code>#print axioms</code> is perfectly reliable, it's Lean you have a problem with. :-)</p>",
        "id": 472830984,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1727335788
    },
    {
        "content": "<p>Well, <em>I</em> don't have a problem with Lean. But yes, anyone using Lean for constructive reasoning is misguided. This is to illustrate that the issues run really deep and \"fixing\" Lean for constructive reasoning is not possible in an add-on library.</p>",
        "id": 472831356,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727335908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472831356\">said</a>:</p>\n<blockquote>\n<p>But yes, anyone using Lean for constructive reasoning is misguided. This is to illustrate that the issues run really deep and \"fixing\" Lean for constructive reasoning is not possible in an add-on library.</p>\n</blockquote>\n<p>I am not a type theorist but I believe the underlying logic of Lean is CIC, same as Coq but with some caveats such as proof irrelevance. So I don’t understand why you need to <em>fix</em> Lean for constructive reasoning.</p>",
        "id": 472833404,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727336538
    },
    {
        "content": "<p>You don't need to fix Lean the type theory but lots of things that ordinary Lean users use for every day tasks make use of LEM/choice/etc. under the hood and you'd have to change that. It was determined in previous discussions that the Lean core developers don't want such a change.</p>",
        "id": 472834360,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1727336846
    },
    {
        "content": "<p>Or at least want to see some strong arguments to put in the work</p>",
        "id": 472834548,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727336896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472834360\">said</a>:</p>\n<blockquote>\n<p>You don't need to fix Lean the type theory but lots of things that ordinary Lean users use for every day tasks make use of LEM/choice/etc. under the hood and you'd have to change that. It was determined in previous discussions that the Lean core developers don't want such a change.</p>\n</blockquote>\n<p>This is fine but it is completely different from fixing Lean. I may choose not to use any of those libraries or just use the constructive ones. The only surprise to me is ‘by_cases’ living in core but I get the idea: write the computable part in functional programming style and do the proofs using tactics.</p>",
        "id": 472836606,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727337532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472834548\">said</a>:</p>\n<blockquote>\n<p>Or at least want to see some strong arguments to put in the work</p>\n</blockquote>\n<p>There is already an excellent library Mathlib that provides reasoning support for mathematics, it would be nice to have one such constructive library for programming as well :)</p>",
        "id": 472841937,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727339315
    },
    {
        "content": "<p>The practical problem is that \"any of those libraries\" includes the core library shipped with lean, including (AIUI) tactics like <code>split</code> and <code>simp</code></p>",
        "id": 472845203,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727340388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239476\">Mukesh Tiwari</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472836606\">said</a>:</p>\n<blockquote>\n<p>write the computable part in functional programming style and do the proofs using tactics.</p>\n</blockquote>\n<p>It's a bit more complicated than that. Warning: I'm about to put my proof-theorist hat on and explain things in excessive detail!</p>\n<p>There are several flavors of constructive reasoning. What you're proposing is often called recursive constructive reasoning (which follows Markov). Other flavors are intuitionistic constructive reasoning (which follows Brouwer) and Bishop's constructive reasoning (which is closest to CIC). The key difference between recursive constructive reasoning and the others is that it uses a classical <em>meta</em>-theory. This means that in recursive constructivism, Markov's principle from above is simply true because there is no logical distinction between <code>∃ n : Nat, p n</code> and <code>¬ ∀ n : Nat, ¬ p n</code> when <code>p</code> is a decidable predicate. In Bishop constructivism, hence in CIC, there is a distinction and Markov's principle is not a theorem, only <code>Nat.find</code> is.</p>\n<p>The difference is subtle but it is consequential. In Bishop constructivism, a proof of <code>∃ n : Nat, p n</code> must actually construct <code>n</code>, we can extract an actual algorithm from the proof. This is called proof mining. This means that when we prove that a definition is total in CIC, we can extract a run time bound from the proof.</p>\n<p>This is not so in recursive constructivism. Proof mining doesn't work directly for classical logic. A classical proof of <code>∃ n : Nat, p n</code> only gives a constructive proof of <code>¬ ∀ n : Nat, ¬ p n</code>: if you search through <code>Nat</code> it's impossible you won't find an <code>n</code> such that <code>p n</code>. This is enough to convince me that <code>n</code> exists but it doesn't give much information at all about <code>n</code>. When you prove that a function is total this way, the only run time bound you get is the trivial bound: run it and see how long it takes.</p>\n<p>Lean, with all its current bells and whistles, is perfectly sound for recursive constructive reasoning. Any function that is not marked <code>noncomputable</code> is total and the proof term given by Lean will convince any recursive constructivist. If <code>#print axioms</code> shows nothing for that proof term, then this is a plain CIC proof and you can mine a useful run time bound for the function. Otherwise, you can try to coax Lean into giving a better proof term but that's probably a lot of extra work and there is no guarantee you will succeed.</p>",
        "id": 472847458,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727341125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472815020\">said</a>:</p>\n<blockquote>\n<p>there are no guarantees that/when MP p will terminate for arbitrary p when actually executed</p>\n</blockquote>\n<p>Is there a good resource somewhere about what it means to say \"an algorithm only terminates if you assume LEM\"?</p>",
        "id": 472849779,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727341900
    },
    {
        "content": "<p>\"actually executed\" also raises questions like the non-verified status of Lean's compiler and interpreter, or pragmatic limitations on runtime making eventual termination irrelevant.</p>",
        "id": 472850255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472845203\">said</a>:</p>\n<blockquote>\n<p>The practical problem is that \"any of those libraries\" includes the core library shipped with lean, including (AIUI) tactics like <code>split</code> and <code>simp</code></p>\n</blockquote>\n<p>Such a library could ship with <code>elab \"simp\" =&gt; an_exact_copy_of_the_simp_code_without_choice</code></p>",
        "id": 472850388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342091
    },
    {
        "content": "<p>At once point there was discussion about Batteries doing this around <a href=\"https://github.com/leanprover/lean4/pull/2414\">lean4#2414</a>, but it was deemed to cause too much fragmentation</p>",
        "id": 472850538,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342140
    },
    {
        "content": "<p>(hey, that issue is now fixed!)</p>",
        "id": 472850974,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472845203\">said</a>:</p>\n<blockquote>\n<p>The practical problem is that \"any of those libraries\" includes the core library shipped with lean, including (AIUI) tactics like <code>split</code> and <code>simp</code></p>\n</blockquote>\n<p>So actually I think this no longer holds</p>",
        "id": 472851370,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472845203\">said</a>:</p>\n<blockquote>\n<p>The practical problem is that \"any of those libraries\" includes the core library shipped with lean, including (AIUI) tactics like <code>split</code> and <code>simp</code></p>\n</blockquote>\n<p>So actually I think this no longer holds</p>",
        "id": 472851389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727342429
    },
    {
        "content": "<p>the issue with <code>split</code> is fixed, but the issue with core's posture toward similar PRs is seemingly not, so I'm not sure whether I want to try looking again for eliminable uses of choice just to start another fight</p>",
        "id": 472874257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727350223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472847458\">said</a>:</p>\n<blockquote>\n<p>Otherwise, you can try to coax Lean into giving a better proof term but that's probably a lot of extra work and there is no guarantee you will succeed.</p>\n</blockquote>\n<p>By this, you mean figuring out all the machinery and tactics that does not use classical stuff and then use them to write the proof?  </p>\n<p>Thanks for the elaborate answer. One of my colleagues Ulrich Berger at Swansea also has slightly different view on constructivism. His argument is to not use any classical stuff in a construction if we care about it and want to run on a computer, but happy to use LEM and all sort of classical stuff in proof if it is computationally irrelevant.   And I should say I am not against it as long as I get the code that I care about :)</p>",
        "id": 472878753,
        "sender_full_name": "Mukesh Tiwari",
        "timestamp": 1727351807
    },
    {
        "content": "<p>Yes, that's what I mean.</p>",
        "id": 472880805,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727352386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472849779\">said</a>:</p>\n<blockquote>\n<p>Is there a good resource somewhere about what it means to say \"an algorithm only terminates if you assume LEM\"?</p>\n</blockquote>\n<p>There are several semantics for intuitionistic logic. The most accessible is probably Kripke Semantics.</p>\n<p>The basic idea is that you have several \"worlds\" that are partially ordered by the \"later\" relation. Later worlds always have more knowledge: once you know something you can never forget it. Given this there is a standard way to interpret False, ∧, ∨, →, ∀, ∃, etc. This interpretation always satisfies intuitionistic logic but not always LEM. </p>\n<p>For example, the Kripke interpretation of <code>∃ n : Nat, p n</code> is: in the current world (and hence all future world) there exists a natural number <code>n</code> such that <code>p n</code> is true. The Kripke interpretation of <code>¬ ∀ n : Nat, ¬ p n</code>is: in every future world there is a later world in which there exists a natural number <code>n</code> such that <code>p n</code> is true. These are clearly different: in the second case you don't necessarily have much information about <code>n</code> but in the first you definitely know what <code>n</code> is.</p>\n<p>Using Kripke semantics, a statement \"foo is true assuming LEM\" means that in every Kripke model, if the model satisfies LEM then it also satisfies foo. </p>\n<p>PS: The Kripke models for LEM are up to a specific notion of equivalence those with only one world. These one-world models are identical to the usual Tarski semantics for classical logic.</p>",
        "id": 472884896,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727353817
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472847458\">said</a>:</p>\n<blockquote>\n<p>The difference is subtle but it is consequential. In Bishop constructivism, a proof of <code>∃ n : Nat, p n</code> must actually construct <code>n</code>, we can extract an actual algorithm from the proof. This is called proof mining. This means that when we prove that a definition is total in CIC, we can extract a run time bound from the proof.</p>\n</blockquote>\n<p>Something I've wondered is why worry too much about whether the proofs themselves have extractable data if instead, when you know you have a good algorithm, you can construct a term of <code>{n : Nat // p n}</code>? This is like how pure mathematicians operate (at least in my milieu of 3-manifold topology). Step 1: prove mere existence. Step 2: create an algorithm. Step 3: create an <em>efficient</em> algorithm.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472847458\">said</a>:</p>\n<blockquote>\n<p>Any function that is not marked <code>noncomputable</code> is total</p>\n</blockquote>\n<p>Just for a point of information, <code>noncomputable</code> is independent of being total as far as Lean is concerned. Non-total functions are marked <code>partial</code>. Given the rest of the sentence maybe you mean that recursive constructivists need no <code>noncomputable</code> to be happy, but it's a bit ambiguous so I figured I'd mention it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472850974\">said</a>:</p>\n<blockquote>\n<p>(hey, that issue is now fixed!)</p>\n</blockquote>\n<p>Yes, core likes to see concrete applications. The <a href=\"https://github.com/leanprover/lean4/pull/4313\">lean4#4313</a> showed that tactics couldn't be used to construct some data, but <a href=\"https://github.com/leanprover/lean4/pull/2414\">lean4#2414</a> doesn't have a concrete application (or at least core doesn't see avoiding axioms in propositions to be an application). I'm not saying we should expect much progress in this direction, but something like Mario's example of <code>def foo : Nat := by by_cases 2 + 2 = 4 &lt;;&gt; exact 1</code> in the issue discussion could be an issue on its own (something less artificial though; I think it's more likely to see <code>split</code> in definition automation, so that's now satisfied, and for those who care about creating definitions, there's always <code>refine if h : 2 + 2 = 4 then ?_ else ?_</code> as an easy workaround).</p>",
        "id": 472946661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727372855
    },
    {
        "content": "<p>I'm particularly pleased because I was sure precisely that circumstance would justify the non-classical <code>split</code>, but I wasn't able to work out the test case to demo it myself!</p>",
        "id": 472977741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727387036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472946661\">said</a>:</p>\n<blockquote>\n<p>François G. Dorais <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472847458\">said</a>:</p>\n<blockquote>\n<p>Any function that is not marked <code>noncomputable</code> is total</p>\n</blockquote>\n<p>Just for a point of information, <code>noncomputable</code> is independent of being total as far as Lean is concerned. Non-total functions are marked <code>partial</code>. Given the rest of the sentence maybe you mean that recursive constructivists need no <code>noncomputable</code> to be happy, but it's a bit ambiguous so I figured I'd mention it.</p>\n</blockquote>\n<p>Yes, thanks for clarifying! I did mean <code>noncomputable</code> though. What the kernel sees is what matters in this context: proofs are only relevant to the kernel, they're ignored by the compiler. As far as the kernel, <code>partial</code> functions are actually total, they're essentially constant functions with value <code>default</code> with a bit of extra sauce to prevent the kernel from using the specific value of <code>default</code>.</p>\n<p>Not <code>noncomputable</code> is required to ensure that the function term doesn't use <code>Classical.choice</code> or other noncomputable axioms. Some constructivists, namely Bishop, may oppose <code>Quot.sound</code> and <code>propext</code> as well but that's another story.</p>",
        "id": 472991057,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727395457
    },
    {
        "content": "<p>I'm not sure I understand what you mean regarding <code>noncomputable</code> and partiality then. </p>\n<p>Both <code>noncomputable</code> and <code>partial</code>/<code>opaque</code> declarations suffer the same problem from the perspective of the kernel — neither will fully reduce on all inputs, so you could say that these are both partial functions. However, even functions not marked with either can fail to reduce. So, if you're talking about reduction, it's not the case that no <code>noncomputable</code> means total in the reduction sense.</p>\n<p>If we're talking about totality in the mathematical sense of whether the supplied equations for a declaration determine a total function, then <code>noncomputable</code> definitions are total, but <code>partial</code> functions are not. The implementation detail that <code>partial</code> functions are added to the environment as <code>opaque</code> declarations doesn't matter for this.</p>\n<hr>\n<p>In early Lean, the noncomputability checker did try to determine whether a declaration would reduce for evaluation purposes, but my understanding is that this was abandoned because of how reduction can get stuck on <code>Eq.rec</code>. The solution was creating a separate compilation step where all computationally irrelevant material would be erased. (The reduction check was completely abandoned in Lean 4, and now the <code>noncomputable</code> checker is to try running the compiler.)</p>\n<p>Nowadays we also have the <code>simp (config := {ground := true})</code> evaluator. That evaluates terms and produces an equal (rather than defeq) term, with proof. I haven't had much experience with it to know what it can't do, but it should be at least as capable as reduction. There are probably still non-<code>noncomputable</code> definitions that are not total in this sense. There are also <code>noncomputable</code> definitions that <em>are</em> total in this sense, at least when allowing type parameters to be specialized to certain types. Think for example <code>simp</code> being able to replace an <code>Inf</code> term with <code>Nat.find</code>.</p>",
        "id": 472994041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727397803
    },
    {
        "content": "<p>In the original post you were quoting, this was stated from the perspective of a recursive constructivist. That functions are computable (formerly known as recursive functions, hence the name \"recursive constructivist\") is essential to a recursive constructivist.</p>\n<p>In CIC, all functions are total, so to say that something is total or not is basically meaningless: if you can define it then its total. The role of the kernel in Lean is to check that. To the kernel,  <code>axioms</code> like <code>Classical.choice</code> are total and so is every <code>opaque</code> and <code>partial</code> definition. The kernel doesn't care at all about computability.</p>\n<p>The compiler is the component of Lean that cares about computability. There is no reasonable code for <code>Classical.choice</code> so any term that involves that axiom is deemed <code>noncomputable</code>. The Lean compiler requires computable functions to rely on no axioms other than <code>propext</code> and <code>Quot.sound</code> (which have a computable interpretation that the compiler knows).</p>\n<p>Lean combines both the kernel and the compiler. The codewords <code>opaque</code> and <code>partial</code> are just bridges that allow the two parts to work together where the kernel needs a total function but the compiler wants to run code with no termination proof. </p>\n<p>The intersection, definitions that are not marked <code>noncomputable</code> is what a recursive constructivist cares about.</p>",
        "id": 472995642,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727399037
    },
    {
        "content": "<p>This slightly humorous table briefly summarizes many of the various sterotypical constructive stances out there that I can think of at the moment.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Is it total?</th>\n<th>Is it computable?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Lean Kernel</td>\n<td>It better be!</td>\n<td>I don't care</td>\n</tr>\n<tr>\n<td>Lean Compiler</td>\n<td>I don't care</td>\n<td>It better be!</td>\n</tr>\n<tr>\n<td>Lean Enthusiast</td>\n<td>Obviously</td>\n<td>That would be great!</td>\n</tr>\n<tr>\n<td>Classical Mathematician</td>\n<td>Yeah, why?</td>\n<td>Maybe, why?</td>\n</tr>\n<tr>\n<td>Recursive Constructivist</td>\n<td>Is there a proof?</td>\n<td>It better be!</td>\n</tr>\n<tr>\n<td>Intuitionistic Constructivist</td>\n<td>Here is a counterexample</td>\n<td>What do you mean?</td>\n</tr>\n<tr>\n<td>Bishop Constructivist</td>\n<td>I have a proof!</td>\n<td>Here's the code!</td>\n</tr>\n<tr>\n<td>Computer Scientist</td>\n<td>A proof would be great</td>\n<td>What else is there?</td>\n</tr>\n<tr>\n<td>Type Theorist</td>\n<td>It better be!</td>\n<td>In theory</td>\n</tr>\n<tr>\n<td>Assembly Programmer</td>\n<td>What?</td>\n<td>What?</td>\n</tr>\n</tbody>\n</table>",
        "id": 473000872,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727403173
    },
    {
        "content": "<p>Ok, I see, I misunderstood your last message, thinking you were implying that <code>noncomputable</code> might still have anything to do with totality, sorry. You're saying \"Every function is total, and if it is not <code>noncomputable</code> then it satisfies a recursive constructivist,\" which makes sense, but you would want to add \"not <code>partial</code>\" as well, right?</p>\n<p>I would say that it's meaningful to ask whether a function declaration is total or not. This is something that the so-called \"equation compiler\" is responsible for. This is the component between the elaborator and the kernel that consumes the elaborated definition, which consists of some number of equations the function must satisfy, and tries to find a way construct a function term that implements the equations. If the equations determine only a partial function, then this process fails. The other compiler is independent of this, and it consumes the same elaborated definition. The <code>partial</code> modifier disables the equation compiler, and the <code>noncomputable</code> modifier disables the compiler. No matter what the details may be for how <code>partial</code> is represented in the kernel, wouldn't you agree that to satisfy a recursive constructivist you would want neither modifier on a definition?</p>\n<p>I personally wouldn't try telling a recursive constructivist that the following is a total function <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">allTrue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">while</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<blockquote>\n<p>The compiler is the component of Lean that cares about computability.</p>\n</blockquote>\n<p>We do care sometimes about computability in other components. For example with the <code>decide</code> tactic we care about kernel reducibility of the <code>Decidable</code> instances. There's <code>native_decide</code> for this if you trust the compiler.</p>",
        "id": 473001337,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727403491
    },
    {
        "content": "<p>Agreed. I'm assuming the recursive constructivist is given the same input as the kernel, which excludes the code for the compiler in the case of <code>partial</code> functions.</p>\n<p>I think the base issue is: what is trusted? The Lean kernel is implicitly trusted by any user. It would be great to have a trusted Lean compiler but that's not the case right now. Lean programmers are, of course, never to be trusted :-)</p>\n<p>For a <code>partial</code> function, the kernel assumes that it is total as an unspecified \"axiom\". When a programmer writes <code>partial def foo ...</code> the promise to the kernel is that <code>foo</code>'s code will always return on any valid input, thereby fulfilling the kernel's assumption. This is not exactly true since <code>panic!</code>, for example, is regularly used in Lean code, but <code>panic!</code> is intended as a bug signal not as an expected outcome. So, a \"moral\" Lean programmer fully intends to meet that kernel promise and the Lean language is designed to encourage this kind of \"moral behavior\".</p>",
        "id": 473003224,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727404817
    },
    {
        "content": "<p>This discussion is diverging into philosophy. This is not the right place for that but I am happy to keep discussing this topic elsewhere.</p>\n<p>Just to be clear: I know a lot about constructivism but I am not a constructivist. I have always been a classical mathematician and moonlighting computer scientist. My goal here was to explain the constructive point of view and its legitimacy, but I am in no way supporting nor defending any kind of militant constructivism. I really hate fights and I will jump out never looking back as soon as I see one forming.</p>",
        "id": 473005628,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727406570
    },
    {
        "content": "<p>The thread I've been tugging on here is that <code>noncomputable</code> is not a kernel notion — it's for the definitions just before they're equation compiled and passed to the kernel, so it makes sense talking about functions at that level, and at that level functions can still be partial. There's no existing mechanism for saying that a kernel declaration would be <code>noncomputable</code> or not, and this is a reason why we've been talking past each other somewhat, since I've been working with my understanding of <code>noncomputable</code>-as-it-is.</p>\n<p>I think this bit of precision is important. It's possible to write a not-<code>noncomputable</code> function that's <code>partial</code>, yet it's something a constructivist would never accept based on the type alone. The trick here is that it's easy to write a non-total definition that is a \"computable\" witness for the type.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">dec</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>The kernel sees that the opaque definition for <code>f</code> is something involving <code>Classical.choice</code>, but this is not prevented by the lack of <code>noncomputable</code>.</p>\n<p>I think my point here is that it doesn't matter that the kernel sees <code>f</code> as being total. What I get from this is that we need to accept not every function is total for the purpose of satisfying recursive constructivists.</p>",
        "id": 473010531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727410098
    },
    {
        "content": "<p>I agree with everything you wrote. Our perspectives are a bit different but we don't really disagree as far as I can tell. </p>\n<p>I see a <code>partial def</code> to mean: this is a total function, I promise! You see the actual definition as being somehow important. I don't think it is because, from my perspective, the kernel's response is: Okay, I trust you. But I won't make any assumptions about what the function returns. I will make sure that if the return value has the right type then everything else will check out.</p>",
        "id": 473011501,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727410848
    },
    {
        "content": "<p>To home in on our perceived disagreement: the key is where I wrote \"I trust you\" above. I classify the issue you point out as a trust issue but you don't see it like that. I like your perspective but I have to remove my proof-theorist hat to appreciate it.</p>",
        "id": 473012790,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727411664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472847458\">said</a>:</p>\n<blockquote>\n<p>Lean, with all its current bells and whistles, is perfectly sound for recursive constructive reasoning. Any function that is not marked <code>noncomputable</code> is total and the proof term given by Lean will convince any recursive constructivist.</p>\n</blockquote>\n<p>I've just been trying to make sense of this quote given what you're saying. If we have a function marked <code>partial</code> and not marked <code>noncomputable</code>, will a recursive constructivist be happy with your informal claim that \"this is a total function, I promise!\"? (Is this what you had in mind when you wrote this earlier?)</p>\n<p>I'll grant you that if there were a version of Lean where kernel definitions could be <code>noncomputable</code>, and where this noncomputability check sees through <code>opaque</code> definitions, and where the compiler can successfully compile the output of the equation compiler, then sure, why not, it's all implementable, and the <code>noncomputable</code> marker would be enough. But I hope you understand that I feel like this is a lot to assume without comment!</p>",
        "id": 473012979,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727411831
    },
    {
        "content": "<p>I do understand how opaque definitions work in the kernel, and the theoretical relationship between the original definition and the opaque definition. I have no problem with the idea that the definition is dropped once it reaches the kernel or the concept that in the type theory every function is total.</p>",
        "id": 473013108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727411924
    },
    {
        "content": "<p>What the kernel verifies is that this is a valid oracle computation where the <code>opaque</code> and <code>partial</code> functions are considered as oracles. So if you substitute any suitable computable function for the oracles, the compiler will know what to do and result will be a computable function.</p>",
        "id": 473013269,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727412043
    },
    {
        "content": "<p>Substituting the computable function is what the compiler and programmer are responsible for. Axioms are different and the compiler/programmer are not expected nor allowed to substitute for them. They remain <code>noncomputable</code>.</p>",
        "id": 473013409,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727412140
    },
    {
        "content": "<p>Interestingly, there are oracle programs P[*] where P[f] is total computable whenever the oracle f is total computable but it is not true that P[f] is total whenever f is total. What the Lean kernel checks is the latter. In other words, there can be a real benefit to substituting partial defs with total ones when possible.</p>",
        "id": 473018019,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727415678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/473010531\">said</a>:</p>\n<blockquote>\n<p>The kernel sees that the opaque definition for <code>f</code> is something involving <code>Classical.choice</code>, but this is not prevented by the lack of <code>noncomputable</code>.</p>\n</blockquote>\n<p>Once again, you've blown my mind! This basically makes <code>noncomputable</code> meaningless!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- or any `noncomputable` function</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">f_eq_F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>This would be fixed if <code>partial</code> required <code>Inhabited</code> instead of <code>Nonempty</code> like in the old days...</p>\n<p>When did that change? I remember there was a discussion about that long long ago but I didn't think people were seriously considering this.</p>",
        "id": 473052277,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727427208
    },
    {
        "content": "<p>I must have skipped a beat or two...</p>",
        "id": 473052667,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727427287
    },
    {
        "content": "<p>(I agree it's surprising.) It's not meaningless, it differentiates between functions that have no implementation and functions that do have an implementation. Lean could auto-implement all noncomputable functions with looping behavior, but that would be undesirable since it would cause accidental use of them to cause busy looping instead of a useful error message.</p>",
        "id": 473066918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727431073
    },
    {
        "content": "<p>I guess we really do need something like a <code>total</code> keyword. Otherwise it's questionable why we do termination proofs at all.</p>",
        "id": 473083716,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436057
    },
    {
        "content": "<p>the termination proofs are for the kernel</p>",
        "id": 473083828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436079
    },
    {
        "content": "<p>because <code>partial</code> definitions don't satisfy their specification</p>",
        "id": 473083910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436096
    },
    {
        "content": "<p>Yes, but that puts a lot of pressure on trusting users. We at least need a convenient way to list the partial defs we're trusting in a def (excluding the termination proof).</p>",
        "id": 473084490,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436197
    },
    {
        "content": "<p>what do you mean by trusting?</p>",
        "id": 473084605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436217
    },
    {
        "content": "<p>You can certainly have a <code>#print opaques</code> command, I think I <a href=\"#narrow/stream/113488-general/topic/linter.20for.20partial.20functions/near/388259582\">wrote one</a> a while back</p>",
        "id": 473084706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436239
    },
    {
        "content": "<p>In the sense above. I want my defs to be total computable functions.</p>",
        "id": 473084867,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436289
    },
    {
        "content": "<p>you gave very many definitions of what that means</p>",
        "id": 473085039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436346
    },
    {
        "content": "<p>Most likely the answer will be either that it involves banning some axiom or lean feature being used in the closure of a given statement, in which case it is easy to implement a check for it as in <code>#print axioms</code>, or it's more complicated than that and it's not possible in lean without rewriting the kernel or elaborator</p>",
        "id": 473085631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436483
    },
    {
        "content": "<p>True, I did! It's funny to think that a def with a termination proof is actually not total.</p>",
        "id": 473086096,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436615
    },
    {
        "content": "<p>Do you mind if I add <code>#print opaques</code> to Batteries?</p>",
        "id": 473086198,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436654
    },
    {
        "content": "<p>(Unless you want to do it yourself, of course!)</p>",
        "id": 473086286,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727436691
    },
    {
        "content": "<p>there is also a <code>@[terminating]</code> attribute later in the same thread, although I'm not sure how to approach the <code>@[terminates]</code> attribute from a library maintenance perspective</p>",
        "id": 473086998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436932
    },
    {
        "content": "<p>feel free to PR it</p>",
        "id": 473087082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727436959
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/966\">batteries#966</a></p>",
        "id": 473092672,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1727438932
    }
]