[
    {
        "content": "<p>There is a recurrent need for <code>List1</code>, the nonempty list type. It still doesn't exist. The main issue is that there are several alternatives.</p>\n<p>0: <em>Status Quo</em>. Nonempty lists can be modeled (a) as a subtype <code>{ l : List α // l ≠ [] }</code> or (b) as a product <code>α × List α</code>. In practice, these are often handled (a) as <code>(l : List α ) (h : l ≠ [])</code> or  (b) as <code>(head : α) (tail : List α)</code> in function definitions and theorems.</p>\n<p>1: <em>Weak Type</em>. The <code>List1 α</code> type could an abbreviation. <br>\nAs (a) </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Or (b) </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>2: <em>Strong Type</em>. The <code>List1 α</code> type could be a structure.<br>\nAs (a) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n</code></pre></div>\n<p>Or (b)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I've experimented with all these options with no clear winner. If you have experimented with these or otherwise have an opinion then please share your thoughts.</p>",
        "id": 566659256,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767759324
    },
    {
        "content": "<p>Could you elaborate on where the need arises?</p>",
        "id": 566683671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767774989
    },
    {
        "content": "<p>My vote is for 2b for the simple reason that it matches what Haskell does</p>",
        "id": 566763955,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1767800888
    },
    {
        "content": "<p>Experimental PR for 2b at <a href=\"https://github.com/leanprover-community/batteries/pull/1607\">batteries#1607</a>. Comments and suggestions welcome!</p>",
        "id": 566810675,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767815073
    },
    {
        "content": "<p>Are there concrete cases where the need for this has come up? That might better inform which is most ergonomic.</p>",
        "id": 566811637,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767815462
    },
    {
        "content": "<p>Option 2b results in code duplication, since you can't just reuse functions defined for <code>List</code>.</p>",
        "id": 566812754,
        "sender_full_name": "suhr",
        "timestamp": 1767815907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> how about when you want to take the product of some elements in a semigroup.</p>",
        "id": 566813357,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1767816103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566763955\">said</a>:</p>\n<blockquote>\n<p>My vote is for 2b for the simple reason that it matches what Haskell does</p>\n</blockquote>\n<p>And Haskell uses it because it can't express <code>list ≠ []</code>.</p>",
        "id": 566813535,
        "sender_full_name": "suhr",
        "timestamp": 1767816173
    },
    {
        "content": "<p>My reason for bringing this up is this PR <a href=\"https://github.com/leanprover-community/batteries/pull/1595\">batteries#1595</a>. (<em>This is from a new contributor, please be nice!</em>) The author used the type <code>Σ n, Vector α (1 + n)</code> where <code>List1 α</code> would be better, in whatever form.</p>",
        "id": 566814404,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767816512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566812754\">said</a>:</p>\n<blockquote>\n<p>Option 2b results in code duplication, since you can't just reuse functions defined for <code>List</code>.</p>\n</blockquote>\n<p>Please see the experimental PR <a href=\"https://github.com/leanprover-community/batteries/pull/1607\">batteries#1607</a> and let me know what list functions aren't reusable.</p>",
        "id": 566815641,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767816933
    },
    {
        "content": "<p>For a comparison of both approaches:<br>\nHere is 2a in its most basic form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nofun</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">toList_ne_nil</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">head_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">tail_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">cons_head_tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">head_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">tail_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">mk_toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 566816797,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767817389
    },
    {
        "content": "<p>and (2b)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">toList_ne_nil</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nofun</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">head_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">tail_cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">cons_head_tail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">toList_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">head_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">tail_mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List1</span><span class=\"bp\">.</span><span class=\"n\">mk_toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">toList_ne_nil</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 566816826,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767817397
    },
    {
        "content": "<p>The main difference is that 2a preserves the defeq <code>List1.toList_mk</code> while 2b preserves the defeq <code>List1.cons_head_tail</code>.</p>",
        "id": 566816980,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767817459
    },
    {
        "content": "<p>My first thought is that it'd be more important to preserve the projection defeq <code>List1.toList_mk</code> than it is to preserve the eta defeq <code>List1.cons_head_tail</code>.</p>",
        "id": 566817487,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767817624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> Please submit an alternative experimental PR on Batteries.</p>",
        "id": 566817589,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767817654
    },
    {
        "content": "<p>Alright</p>",
        "id": 566817738,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767817709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566813357\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> how about when you want to take the product of some elements in a semigroup.</p>\n</blockquote>\n<p>We already solve this in a lattice context with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup%27#doc\">docs#Finset.sup'</a></p>",
        "id": 566820521,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767818802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566814404\">said</a>:</p>\n<blockquote>\n<p>My reason for bringing this up is this PR <a href=\"https://github.com/leanprover-community/batteries/pull/1595\">batteries#1595</a>. (<em>This is from a new contributor, please be nice!</em>) The author used the type <code>Σ n, Vector α (1 + n)</code> where <code>List1 α</code> would be better, in whatever form.</p>\n</blockquote>\n<p>In that PR I think it should either return <code>{ l : List α // l ≠ [] }</code> or just <code>List α</code>, perhaps with some <code>SatisfiesM</code> result indicating it is non-nil</p>",
        "id": 566820749,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767818886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> This is option 0a (compatible with 1a). Do you have a rationale why there is no need for a <code>List1</code> API?</p>",
        "id": 566821873,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767819416
    },
    {
        "content": "<p>My claim is merely that <a href=\"https://github.com/leanprover-community/batteries/pull/1595\">batteries#1595</a> seems a long way from an application for it</p>",
        "id": 566822614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767819723
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/1609\">batteries#1609</a></p>",
        "id": 566823962,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1767820266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566822614\">said</a>:</p>\n<blockquote>\n<p>My claim is merely that <a href=\"https://github.com/leanprover-community/batteries/pull/1595\">batteries#1595</a> seems a long way from an application for it</p>\n</blockquote>\n<p>I disagree. Had <code>List1</code> been available, the author would have used it. Who knows how many users out there are using inefficient <code>List1</code> implementations?!</p>",
        "id": 566825342,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767820796
    },
    {
        "content": "<p>Could we please rename whatever is implemented here to <code>NonEmptyList</code>? I wouldn't know what <code>List1</code> is meant to mean.</p>",
        "id": 566829000,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1767822352
    },
    {
        "content": "<p>I agree but the <code>many</code>/<code>many1</code> paradigm is pretty deeply enshrined.</p>",
        "id": 566830239,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767822885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566825342\">said</a>:</p>\n<blockquote>\n<p>I disagree. Had <code>List1</code> been available, the author would have used it. Who knows how many users out there are using inefficient <code>List1</code> implementations?!</p>\n</blockquote>\n<p>But the author isn't using any API other than the definition itself!</p>",
        "id": 566830455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767822998
    },
    {
        "content": "<p>There is some precedent for the 'List1' name, this is what Idris calls it at least, but I agree a more evocative name would probably be better</p>",
        "id": 566831564,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767823476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566830455\">said</a>:</p>\n<blockquote>\n<p>But the author isn't using any API other than the definition itself!</p>\n</blockquote>\n<p>I don't understand. The point is that having a named type indicates the preferred implementation. (IMHO: if you have a type name then you have an API, possibly a trivial one.)</p>",
        "id": 566831855,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767823610
    },
    {
        "content": "<p>FWIW I think you're arguing for either 0a or 1a.</p>",
        "id": 566833054,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767824188
    },
    {
        "content": "<p>Yes, I think for the purpose of that PR alone, 0a is the right choice, and 1a is harmless enough if perhaps overkill. I would argue that we should compile a list of more compelling use-cases before deciding to write any API functions that consume <code>List1</code></p>",
        "id": 566833322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767824302
    },
    {
        "content": "<p>I think it would be very hard to compile current uses of 0a and 0b.</p>",
        "id": 566833701,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767824483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/566816980\">said</a>:</p>\n<blockquote>\n<p>The main difference is that 2a preserves the defeq <code>List1.toList_mk</code> while 2b preserves the defeq</p>\n</blockquote>\n<p>And I think if you implement <code>Coe</code>, then you basically get some properties for free. Like, <code>(List1.cons x xs) ++ ys</code>  becomes <code>(cons x xs).toList ++ ys</code>, which is definitionally equal to <code>x :: (xs ++ ys)</code>.</p>",
        "id": 566834519,
        "sender_full_name": "suhr",
        "timestamp": 1767824871
    },
    {
        "content": "<p>Though, this particular example works for both versions. But also <code>List1.mk xs h ++ ys</code> could coerce to <code>(List1.mk xs h).toList ++ ys</code>, which is definitionally equal to <code>xs ++ ys</code>.</p>",
        "id": 566835678,
        "sender_full_name": "suhr",
        "timestamp": 1767825429
    },
    {
        "content": "<p>I'm confused, aren't you talking about two things with different types being defeq? Or is there an implicit coercion there?</p>",
        "id": 566836066,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767825616
    },
    {
        "content": "<p>I'm talking about having an implicit coercion from List1 to List.</p>",
        "id": 566836213,
        "sender_full_name": "suhr",
        "timestamp": 1767825700
    },
    {
        "content": "<p>For the sake of clarity, can you edit your message to make the coercion placement explicit?</p>",
        "id": 566836462,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767825856
    },
    {
        "content": "<p>For anyone just joining, there are two experimental implementations of 2a and 2b available on Batteries:</p>\n<ul>\n<li>2a is at <a href=\"https://github.com/leanprover-community/batteries/pull/1609\">batteries#1609</a> (author Robin Arnez)</li>\n<li>2b is at <a href=\"https://github.com/leanprover-community/batteries/pull/1607\">batteries#1607</a> (author François G. Dorais)</li>\n</ul>\n<p>These are intended for anyone interested to experiment. Contributions are welcome for both!</p>",
        "id": 566836768,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767826029
    },
    {
        "content": "<p>Obviously, at most one will be merged. But actual implementations are helpful to make a sound decision.</p>",
        "id": 566837513,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767826295
    },
    {
        "content": "<p>Note that implementations for 1a and 1b are not necessary since the above can easily be adapted. The main point is to compare the a and b approaches.</p>",
        "id": 566838733,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1767826732
    },
    {
        "content": "<p>By the way, Mathlib has <code>List1</code>-like design already: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.Seq#doc\">docs#Stream'.Seq</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27.Seq1#doc\">docs#Stream'.Seq1</a></p>",
        "id": 566861598,
        "sender_full_name": "Miyahara Kō",
        "timestamp": 1767843642
    },
    {
        "content": "<blockquote>\n<p><em>This is from a new contributor, please be nice!</em></p>\n</blockquote>\n<p>Hello! That new contributor is me :)<br>\nI come from Haskell, and I love <code>NonEmptyList</code>, but I'm actually wondering why there's a need for a non-empty list, over a more general length-indexed list type.</p>\n<p>The reason returning a vector isn't ideal, in my case, was because I don't know the size of the vector ahead of time, so I had to create one from a list.</p>\n<p>But if I had a length-indexed list, I wouldn't have this problem.<br>\nI would think that a length-indexed list would be strictly more powerful than a nonempty list?<br>\nYou'd be able to express that your list has at least two elements, for example...</p>\n<p>Maybe this is a stupid question, I don't know.</p>",
        "id": 567397720,
        "sender_full_name": "Owen Shepherd",
        "timestamp": 1768146181
    },
    {
        "content": "<p>BTW, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeSemigroup#doc\">docs#FreeSemigroup</a> in Mathlib.</p>",
        "id": 567397989,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768146378
    },
    {
        "content": "<p>Isn't <code>List1</code> kinda anti-pattern? IIRC we prefer unbundled version (i.e. two separate arguments/fields <code>l : List α</code> and <code>l ≠ []</code> when possible, and in case of function return type we return <code>List α</code> and prove non-emptiness in a separate theorem). Is there a need for bundled version? <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> suggests we don't need bundled version for <a href=\"https://github.com/leanprover-community/batteries/pull/1607\">batteries#1607</a>, as we can prove non-emptiness in a separate theorem using <code>SatisfiesM</code>.<br>\nPS: Alternatively <code>α</code> and <code>List α</code> is also being used as a unbundled version of non-empty list.</p>",
        "id": 567403048,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1768150883
    },
    {
        "content": "<p>I think it's worth remembering that the context of this discussion is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">many</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">many1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"sd\">/-- something complex -/</span>\n</code></pre></div>\n<p>where the suggested alternatives are:</p>\n<ol>\n<li>\n<p><code>def many1 (p : f α) : f (List α) := List.cons &lt;$&gt; p &lt;*&gt; many p </code>, which matches <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.many1#doc\">docs#Lean.Parser.many1</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Internal.Parsec.many1#doc\">docs#Std.Internal.Parsec.many1</a><br>\n  a. optionally with a <code>SatisfiesM</code> theorem</p>\n</li>\n<li>\n<p><code>def many1 (p : f α) : f {l : List α // l ≠ []} := /- the above with some proof -/</code></p>\n</li>\n<li><code>def many1 (p : f α) : f (α × List α) := Prod.mk &lt;$&gt; p &lt;*&gt; many p</code></li>\n</ol>\n<p>Given that <code>many</code> is partial anyway, I don't think it makes much sense to spend a lot of time designing an API for the return type of <code>many1</code>. Do we have a case where option 1 (without 1a) is not sufficient?</p>",
        "id": 567404604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768152472
    },
    {
        "content": "<p>The main use of having the length seems to be to make a termination argument, but it seems highly likely you'd just mark the caller as <code>partial</code> anyway given that <code>many</code> is</p>",
        "id": 567404809,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768152597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/567404809\">said</a>:</p>\n<blockquote>\n<p>The main use of having the length seems to be to make a termination argument</p>\n</blockquote>\n<p>Maybe also to be able to get the head of the result without introducing an error codepath?<br>\nThat's generally the reason to use <code>Data.List.NonEmpty</code> in Haskell.<br>\nI guess the sensible thing to do would be to PR <code>many</code>, and leave <code>many1</code> as a follow-up...</p>\n<p>Is there something I can read somewhere on why <code>{l : List α // l ≠ []}</code> is preferred over <code>(Σ n, IList α (1 + n))</code> (apart from the latter not existing, obviously)?</p>",
        "id": 567405958,
        "sender_full_name": "Owen Shepherd",
        "timestamp": 1768153800
    },
    {
        "content": "<p>By <code>IList α (1 + n)</code> I assume you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Vector#doc\">docs#List.Vector</a>  <code>α (1 + n)</code>?</p>",
        "id": 567406011,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768153865
    },
    {
        "content": "<p><code>(Σ n, List.Vector α (1 + n))</code> reads somewhat as \"there exists an n such that there is a list whose length is <code>n + 1</code>\", which seems like very long winded way of saying \"a list whose length is not zero\", which is is also more long winded than \"a list which is not nil\".</p>",
        "id": 567406120,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768153988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/567406011\">said</a>:</p>\n<blockquote>\n<p>By <code>IList α (1 + n)</code> I assume you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Vector#doc\">docs#List.Vector</a>  <code>α (1 + n)</code>?</p>\n</blockquote>\n<p>This is exactly what I meant. I didn't know this existed, though it looks like it's in mathlib, not batteries, so I couldn't use it anyway?<br>\nTo me it looks like <code>List.Vector</code> is strictly more expressive than <code>NonEmpty</code>, so introducing the latter seems unnecessary. The more list-like types there are, the more code there is, and there's an n*n problem for conversions between them, no?</p>",
        "id": 567406624,
        "sender_full_name": "Owen Shepherd",
        "timestamp": 1768154480
    },
    {
        "content": "<p>I think moving List.Vector to batteries would be very reasonable, but that's a discussion for another thread.</p>\n<p>(Generally things are moved only when someone needs them)</p>",
        "id": 567406954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768154710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/567404604\">said</a>:</p>\n<blockquote>\n<p>I think it's worth remembering that the context of this discussion is:</p>\n</blockquote>\n<p>First, this is <em>not</em> the context of this discussion and I tried to make that clear. It is, however, the most recent time I've seen ad-hoc nonempty list types.</p>\n<p>(FWIW, I wouldn't recommend using <code>List1</code> even if it did exist in any form, your option 1 is the better one in this case. That is what I will suggest once I get around to reviewing that PR.)</p>",
        "id": 567417772,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1768168156
    },
    {
        "content": "<p>Apologies, I misinterpreted what you said above.</p>",
        "id": 567417883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768168272
    },
    {
        "content": "<p>To be clear, in your most recent message you mean \"I wouldn't recommend <code>List1</code> ... <em>for that specific PR</em>\"? Presumably you have other cases in mind where you would use it?</p>",
        "id": 567417896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768168285
    },
    {
        "content": "<p>I'm pretty sure you've also seen ad hoc nonempty list types as well, most are 0a and 0b. The primary question is whether 1a/b or 2a/b may be better than the status quo.</p>\n<p>I do have <code>List1</code> in my personal stuff (which I basically copied into <a href=\"https://github.com/leanprover-community/batteries/pull/1607\">batteries#1607</a>). My main use case was to implement free categories.</p>",
        "id": 567418511,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1768169024
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FreeSemigroup#doc\">docs#FreeSemigroup</a> morally a good tool for free categories?</p>",
        "id": 567418679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768169214
    },
    {
        "content": "<p>(of course List is isomorphic to FreeMonoid, but that doesn't make List the wrong choice everywhere!)</p>",
        "id": 567418728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768169255
    },
    {
        "content": "<p>Actually, I eventually found that a path type was what I needed but we're getting sidetracked. This is Batteries, free constructions are very common in programming (though most don't care much about the mathematical theory).</p>",
        "id": 567419061,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1768169570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1013372\">Owen Shepherd</span> <a href=\"#narrow/channel/348111-batteries/topic/Nonempty.20List.20Type/near/567405958\">said</a>:</p>\n<blockquote>\n<p>Maybe also to be able to get the head of the result without introducing an error codepath?<br>\nThat's generally the reason to use <code>Data.List.NonEmpty</code> in Haskell.</p>\n</blockquote>\n<p>That doesn't work in Lean since it uses eager evaluation instead of lazy evaluation, like Haskell.</p>",
        "id": 567421525,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1768172064
    },
    {
        "content": "<p>It's not about laziness.<br>\nData.List.head is non-total, whereas Data.List.NonEmpty.head is total, for obvious reasons.</p>\n<p>I'm still not advocating for a non-empty list type in lean though, my preference would be to have <code>List.Vector</code> moved to <code>batteries</code>, so I could return  <code>Σ n, List.Vector a (succ n)</code> or something like that.</p>\n<p>This seems more... constructive, than returning a list and a proof that it's non-empty... But I'm new to this :)</p>",
        "id": 567434832,
        "sender_full_name": "Owen Shepherd",
        "timestamp": 1768187506
    },
    {
        "content": "<p><code>Σ n, List.Vector a (succ n)</code> is a bit like <code>∃x, n = k + x</code>. It works, but can we something like <code>≤</code> for lists?</p>",
        "id": 567435465,
        "sender_full_name": "suhr",
        "timestamp": 1768188412
    },
    {
        "content": "<p>In addition to<code>List.Vector α n = { l : List α // l.length = n }</code> you could have <code>List.Something α n = { l : List α // n ≤ l.length }</code></p>",
        "id": 567435526,
        "sender_full_name": "suhr",
        "timestamp": 1768188497
    },
    {
        "content": "<p>I'll note that <code>Σ n, List.Vector a (succ n)</code> is also somewhat significantly different in terms of runtime representation to <code>List</code>: It stores a <em>pair</em> of a natural number and a <code>List</code> of that length. That means if you use <code>Σ n, List.Vector a (succ n)</code> you have to compute the length in addition to knowing that the list is nonempty. For just representing the fact that a list is nonempty I'd prefer if a nonempty list type was at least as efficient to store and manipulate as <code>List</code>.</p>",
        "id": 567509042,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1768218261
    }
]