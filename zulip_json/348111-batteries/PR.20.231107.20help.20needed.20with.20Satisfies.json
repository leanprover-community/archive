[
    {
        "content": "<p>Hello all, I need some help with working around this <code>SatisfiesM</code> predicate in <a href=\"https://github.com/leanprover-community/batteries/pull/1107\">batteries#1107</a></p>\n<p>This PR is about adding some missing monadic defs for vectors (see the discussion in <a href=\"https://github.com/leanprover-community/batteries/pull/925\">batteries#925</a>). I am trying to extract the size guarantee of <code>Array.size_modifyM</code> (which uses Satisfies) to give me a proof that the size of the modified vector remains unchanged (around line 31). Conceptually I understand where my \"proof\" is going wrong. But I am not sure I know how to work around it.</p>",
        "id": 497028024,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738336214
    },
    {
        "content": "<h3>Update</h3>\n<p>On discord, we discussed using an <code>[implemented_by]</code> unsafe def ...<code> with an unsafe cast on </code>Array.modifyM<code> to get a vector, and writing the safe version without using </code>Array` defs. User Rob_23oba (who is not on Zulip) suggested something as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">modifyMUnsafe</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Array and Vector have the same internal representation, so this cast is valid</span>\n<span class=\"w\">  </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">modifyM</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`modifyM v i f` applies a monadic transformation `f` to `v[i]`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">modifyMUnsafe</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">modifyM</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">   </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>",
        "id": 497043668,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738340879
    },
    {
        "content": "<p>The disadvantage is that of course one is always using the unsafe version for computations in practice.</p>",
        "id": 497043764,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738340902
    },
    {
        "content": "<p>The advantage is that one doesn't need extra typeclass instances like <code>LawfulMonad</code>, <code>LawfulFunctor</code> and <code>MonadSatisfying</code> to use <code>satisfying</code></p>",
        "id": 497043881,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738340943
    },
    {
        "content": "<p>What is the community's opinion on this? CC : <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span></p>",
        "id": 497044238,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738341052
    },
    {
        "content": "<p>No unsafe definitions here please, unless there are significant performance gains which are otherwise in inaccessible. In particular, not for the sake of proofs.</p>",
        "id": 497084535,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738355959
    },
    {
        "content": "<p>Why do you want the implemented_by here in the first place?</p>",
        "id": 497085056,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738356184
    },
    {
        "content": "<p>Note that for Array/Vector I'll soon be changing the signature, so <code>modify</code> takes an in-bounds proof and <code>modifyIfInBounds</code> preserves the current behaviour parallel to List.</p>",
        "id": 497085305,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738356284
    },
    {
        "content": "<p>It was an idea to get around the challenge I described above. I need to show that the size of the vector after <code>modifyM</code> is <code>n</code> and I have very little experience with <code>SatisfiesM</code></p>",
        "id": 497085432,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738356341
    },
    {
        "content": "<p>So to use the <code>satisfying</code> function to extract the proof from <code>Array.size_modifyM</code>, I had to add a bunch of instances and the proof is still wrong. I can see why it is wrong, but not the fix.</p>",
        "id": 497085672,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738356430
    },
    {
        "content": "<p>What's wrong with the safe definition above? Just remove the implemented by.</p>",
        "id": 497085694,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738356440
    },
    {
        "content": "<p>It might not be efficient. Last time I wrote my own defs for Vector I was told that it must use the array functions.</p>",
        "id": 497085754,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738356480
    },
    {
        "content": "<p>To make sure the functions use FBIP</p>",
        "id": 497086084,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1738356623
    }
]