[
    {
        "content": "<p>We have a variety of <code>modify</code> functions on collections, which take the form <code>modify (c : Coll X) (f : X -&gt; X) (i : Idx)</code>, except that there is inconsistency in the order of arguments: does the function come first (<code>List.modify</code>), or does the index come first (<code>Batteries.HashMap.modify</code>, <code>Array.modify</code>)?</p>\n<p>Arguments either way?</p>\n<p>I feel like it is slightly more likely the the partially applied <code>modify f</code> is useful rather than <code>modify i</code>. On the other hand it is probably more churn/harder to reach consistency to move the function first everywhere.</p>",
        "id": 478836471,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729828214
    },
    {
        "content": "<p>My gut tells me function first but I just realized I have no good argument for that.</p>",
        "id": 478836986,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1729828679
    },
    {
        "content": "<p>I guess there is no good answer. Partial application prefers function first, but lean's syntax encourages function arguments last (for parentheses-less <code>fun</code> that possibly spans multiple lines). So either is probably fine.</p>\n<p>One could make the argument that function first is more versatile: works well partially applied, but in can get the other form with <code>c.modify (i := …) fun x =&gt; …</code>.</p>\n<p>In any case I think it's important that the collection comes last, so that you can nicely nest calls to <code>modify</code> in each other.</p>",
        "id": 478859229,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729842178
    },
    {
        "content": "<p>collection comes first is a fairly strong convention at this point</p>",
        "id": 478864820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729844212
    },
    {
        "content": "<p>I agree that having the index before function makes things easier in the large function case (which is a pretty common situation)</p>",
        "id": 478864915,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729844251
    },
    {
        "content": "<p>We generally don't optimize for partial applications at all, because we have a section syntax and dot notation. Plus I would argue that overuse of partial application and especially higher order combinators is what leads to the classic (and unreadable) pointfree haskell style</p>",
        "id": 478865343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729844395
    },
    {
        "content": "<p>Fair points. I'm certainly prone to lean towards classic Haskell :-)</p>",
        "id": 478867681,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729845153
    },
    {
        "content": "<p>My approach (inconsistently applied in Aesop) is:</p>\n<ul>\n<li>Collection last because the partially applied form <code>modify f i</code> or <code>modify i f</code> can be useful while <code>modify c f</code> or <code>modify c i</code> is never useful (could be written as <code>c.modify</code> instead).</li>\n<li>Function argument second to last because in the fully applied form it's usually nicer to write <code>c.modify i λ &lt;long expression&gt;</code> than <code>c.modify (λ &lt;long expression&gt;) i</code>, especially if the function spans over multiple lines. <code>c.modify (i := i) f</code> is an okay workaround, but the common case is the fully applied form, so we should optimise for that.</li>\n</ul>",
        "id": 478876687,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1729848072
    },
    {
        "content": "<p>Jannis's case is pretty good! However, as Mario says above, collection first is pretty well established at this point (although with <em>many</em> exceptions). We can start changing that, but I'd want everyone who's spoken so far to be in favour. :-)</p>",
        "id": 478892871,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1729853638
    },
    {
        "content": "<p>Is it generally useful (even though a bit counter-intuitive) to put the namespace-relevant parameter near the end, on the grounds that if by using dot notation, you can effectively pull it to the front when explicitly applying it, and thus dot notation vs plain function application now gives you two useful partial applications of a single function.</p>",
        "id": 478899112,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1729856002
    },
    {
        "content": "<p>Yes, I have been using Joachim's argument above to justify a lot of my function argument order choices</p>",
        "id": 478905796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729858261
    },
    {
        "content": "<p>For my two cents, I fully agree with Jannis's analysis.</p>\n<p>Also, I supsect the promienence of \"collection first\" in core is a result of Joachim's insight that putting the namespace-relevant parameter last is naturally counter-intuitive. It is natural when writing a definition for e.g. <code>List</code> to start with the thought that the first thing one needs is the <code>List</code> in question.</p>",
        "id": 479740927,
        "sender_full_name": "Mac Malone",
        "timestamp": 1730312684
    }
]