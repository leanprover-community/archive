[
    {
        "content": "<p>Does lean have Haskell style <code>Arrow</code>s? I am aware that Mathlib has the mathematical version of Arrows, but I wonder if that is the right thing to use for computational purposes, because I don't understand the underlying comma categories very well.</p>",
        "id": 465762016,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724850581
    },
    {
        "content": "<p>I am aware that with Monads, there is a <code>LawfulMonad</code> and a <code>Monad</code>, and the latter is used for programming stuff.</p>",
        "id": 465767821,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1724851540
    },
    {
        "content": "<p>I'll let others speak to what's currently in batteries/what might be soon, but in the meantime — what are you looking for and what do you want to accomplish when you say \"Haskell Style Arrows\"? (It's also perfectly OK to only have a partial answer or to not know! I started really learning about <code>Arrow</code>s by trying (failing) to port them into Lean 4 <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>)</p>\n<p>There are lots of things in more or less vaguely categorical Haskell that supervene on the same construction (e.g. <code>Applicative</code> vs. the typeclass sometimes called <code>Monoidal</code> — see the end of McBride &amp; Paterson's article introducing <code>Applicative</code>), plus there are simplifications made by feature/library authors for a mix of reasons ranging from \"doing something more general than this would incur more friction for all the other use cases that we the feature authors currently are guessing people would plausibly use this for\" to \"expressing something at a certain level of generality is not possible [in Haskell]\". In the case of <code>Arrow</code> specifically, while I'm not privy to the exact thought process that went into John Hughes making the <code>Arrow</code> typeclass as he did, a present or future Lean programmer has the benefit of 2+ decades of hindsight (downstream of <code>Arrow</code>, among other things) and the ambient setting of a much more expressive programming language.</p>\n<ol>\n<li>\n<p>Do you just want \"closed Cartesian category\" combinators (<code>dup</code>, <code>swap</code>, <code>***</code>, <code>&amp;&amp;&amp;</code>, <code>|||</code>, <code>+++</code>, <code>first</code>, <code>second</code>, <code>fst</code>, <code>snd</code>, <code>curry</code>, <code>uncurry</code>...) you can use with garden-variety functions for point-free style? </p>\n</li>\n<li>\n<p>Do you want machinery to express categorical EDSLs? If so, you probably <em>don't</em> want a direct port of <code>Arrow</code> <em>per se</em>, chiefly because of the <code>arr</code> method. Either way, if you're after categorical EDSLs, how fine-grained of a typeclass hierarchy do you want?  Do you want the \"substructural\" typeclasses that might let you write e.g. an elegant logic programming or probabilistic programming library interface? Is the way that <code>Control.Arrow</code> carves things up really what you're after? </p>\n</li>\n<li>\n<p>Overlapping with other questions: are there particular (categorical ± ergonomic) properties you have in mind that you want an <code>Arrow</code>-like abstraction to capture?</p>\n</li>\n<li>\n<p>Are you sure you don't want a library that takes profunctors (and, again, does that mean more like the Haskell <code>profunctors</code> library simplification, or something more expansive?) as primitive and categories (and hence Hughes's <code>Arrow</code> typeclass) as derived?</p>\n</li>\n</ol>",
        "id": 466412137,
        "sender_full_name": "Eric Meinhardt",
        "timestamp": 1725064916
    },
    {
        "content": "<p>So the correct answer is \"I am exploring\". The original Hughes paper had a parser example. But Ross Patterson's chapter in the fun of programming book gave some nice examples. One problem I am trying to solve in more than one way is composing multi input and multi output functions into pipelines. Ofc there are some simpler ways to accomplish the task. Arrow-like structures were used in certain hardware papers dealing with synchronous circuits, but these aren't enough for asynchronous circuits with combinatorial delays. What I am really looking for in the end are arrows with some state. I already have a case study on verifying these circuits that is to be ready for submission soon.</p>",
        "id": 466511418,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725101479
    },
    {
        "content": "<p>Profunctors don't have a straightforward way to loop anything.</p>",
        "id": 466511690,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725101663
    },
    {
        "content": "<p>My interest in categorical anything is limited to pragmatism.</p>",
        "id": 466511745,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1725101738
    }
]