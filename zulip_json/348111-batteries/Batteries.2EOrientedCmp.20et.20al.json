[
    {
        "content": "<p>There are a number of typeclasses in Batteries about comparators which are now duplicates of the same typeclasses in <code>Std</code>, e.g. <code>OrientedCmp</code>.</p>\n<p>Is anyone available to deprecate these, and identify what if any functionality Batteries is still adding here?</p>",
        "id": 526514185,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1751337093
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a></p>",
        "id": 526613047,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1751377659
    },
    {
        "content": "<p>That was a big job <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> ! Fortunately, I was looking for something to get me back to speed after a long months of overwhelming daytime jobs...</p>\n<p>I'm on the final stretch and I think I need additional direction as to where Std is going. In <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a>, I moved all the old Batteries classes stuff to <code>Batteries.Classes.Deprecated</code> and I only kept stuff that is missing from Std in <code>Batteries.Classes.Order</code>. Since there is a lot more than I expected, I tried to be comprehensive rather than editorial. I did leave a few notes and I gave absurdly long name for things that I don't think should be in Std. (I still need to do the Mathlib adaptation but that doesn't look like a difficult one so far.)</p>\n<p>Anyway, I would appreciate your input before moving further. No rush!</p>",
        "id": 526895489,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1751500298
    },
    {
        "content": "<p>Thanks for your effort! Sorry, I hadn't seen this thread until now. I am working exactly on overhauling the order-related typeclasses in Std this quarter, so there will be changes and improvements. I am still figuring out the details, though.</p>\n<p>Do you mean by \"additional direction as to where Std is going\" whether Std is going to support the missing lemmas in the foreseeable future, or were you thinking of something different?</p>",
        "id": 527457616,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1751887680
    },
    {
        "content": "<p>My question was vague (which reflected my ambivalence) so let me clarify.</p>\n<p>Kim's request suggested that there wasn't much, if anything, in Batteries that wasn't already in Std. There was in fact quite a few things in the difference: the classes <code>LawfulLECmp</code>, <code>LawfulLTCmp</code>, <code>LawfulBCmp</code>, <code>LawfulCmp</code>, their <code>Ord</code> aliases, and some associated lemmas. I think these could go in Std but it's fine for them to stay in Batteries.</p>",
        "id": 528181550,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1752196544
    },
    {
        "content": "<p>I see! I agree that it makes sense to have them in Std now that similar classes are also living there. I'll keep this in mind and try upstreaming the remaining classes/lemmas at a later point in the coming weeks, okay?</p>",
        "id": 528605323,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1752480213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span> let me mention a lingering issue that can only be solved by fixing in core.</p>\n<p>For historical reasons, the default way for constructing an <code>Ordering</code>-valued comparison from <code>LE</code> or <code>LT</code> instances is <code>compareOfLessAndEq</code>. This choice has some defects: </p>\n<ol>\n<li>It requires both <code>DecidableLT</code> and <code>DecidableEq</code>.</li>\n<li>The definition <code>if x &lt; y then .lt else if x = y then .eq else .gt</code> doesn't work unless <code>.eq</code> really means equality.</li>\n<li>Proving anything about this comparison requires a priori knowing a bunch of facts about the relation between <code>&lt;</code> and <code>=</code>.</li>\n</ol>\n<p>This was partly fixed by adding <code>compareOfLessAndBEq</code>which requires <code>BEq</code> instead of <code>DecidableEq</code>. This is a bit better for 1 and 2 but it actually makes 3 worse in many ways.</p>\n<p>There are better alternatives! For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">compareOfLT</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableLT</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">gt</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">compareOfLE</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableLE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">gt</span>\n</code></pre></div>\n<p>Both of these are optimal for 1 and 2 and are much better for 3 as well.</p>\n<p>We may be too far down the rabbit hole to fix this but we can't lose hope!</p>",
        "id": 531259753,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753669967
    },
    {
        "content": "<p>Is <a href=\"https://github.com/leanprover-community/batteries/pull/1306/files#diff-cfcf4566e36c67b744dd9cebdba658b29d7127cc8fab620a5e4fa6a598e051efR188\"><code>TransCmp.compareOfLessAndEq</code></a> (and its usages) a good example where these problems play out?</p>",
        "id": 531303278,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753690319
    },
    {
        "content": "<p>Yes, exactly.</p>",
        "id": 531414225,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753721166
    },
    {
        "content": "<p>I find your arguments for <code>compareOfLT/compareOfLE</code> quite plausible, but assuming that the standard library is comprehensive enough (which may not always be the case), I think the definition of <code>Ord</code> instances of stdlib shouldn't even be relevant downstream, at least at some point in the future.</p>\n<p>For example, let's consider <code>LawfulOrd Nat</code>. This instance is currently defined using <code>LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm</code>.</p>\n<p>If the standard library provided convenient lemmas to derive <code>TransOrd</code>, <code>LawfulEqOrd</code> and other instances in the presence of  (say) <code>LE</code> or <code>LT</code> satisfying certain axioms, or perhaps proved that its <code>Ord</code> instances are propositionally equal to <code>compareOfLE</code>, a <code>LawfulOrd Nat</code> instance could be defined without reliance on the definitional nature of the <code>Ord</code> instances . I'm open to adding the lemmas to the standard library that make it convenient to do so.</p>\n<p>Is my reasoning sound or do you think projects downstream of the standard library really need to rely on the definition of stdlib's <code>Ord</code> instances?</p>",
        "id": 531699692,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753823374
    },
    {
        "content": "<p>The whole point of those theorems like <code>TransCmp.compareOfLessAndEq</code> is to establish that a given Ord instance is in fact a LawfulOrd</p>",
        "id": 531702177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753824451
    },
    {
        "content": "<p>if the definition was different, you would prove LawfulOrd in a different way</p>",
        "id": 531702312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753824509
    },
    {
        "content": "<p>holy shit the new names are terrible</p>",
        "id": 531702436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753824565
    },
    {
        "content": "<p>I thought that was an instance name</p>",
        "id": 531702460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753824574
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The awful names are my fault, to some extent, \"I gave absurdly long name for things that I don't think should be in Std\" to quote myself from earlier.</p>",
        "id": 531727541,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753838805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531699692\">said</a>:</p>\n<blockquote>\n<p>Is my reasoning sound or do you think projects downstream of the standard library really need to rely on the definition of stdlib's <code>Ord</code> instances?</p>\n</blockquote>\n<p>They already do! This is the \"rabbit hole\" I mentioned earlier. It's a weed that needs to be uprooted.</p>",
        "id": 531727876,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753839022
    },
    {
        "content": "<p>FWIW when <code>compareOfLessAndEq</code> was introduced about four years ago, my thought was that this was a bad choice, but I thought just as you that this choice is irrelevant downstream and core would eventually fix it. I have since regretted many times not doing anything to change it back then...</p>",
        "id": 531730044,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753840452
    },
    {
        "content": "<p>Also remember that <code>Ord</code> instances are data and therefore subject to diamond issues, regardless of propositional equality.</p>",
        "id": 531730756,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753840891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531702177\">said</a>:</p>\n<blockquote>\n<p>The whole point of those theorems like <code>TransCmp.compareOfLessAndEq</code> is to establish that a given Ord instance is in fact a LawfulOrd</p>\n</blockquote>\n<p>I understand, but my point is that <code>TransOrd</code>/<code>LawfulOrd</code> instances can be proved without the underlying definition by relying on theorems such as (in the <code>Nat</code> case) <code>Nat.le_trans</code>, <code>Nat.le_total</code>, <code>Nat.le_antisymm</code>, <code>Nat.compare_eq_lt</code> and <code>Nat.compare_eq_gt</code>. These theorems are provided by the standard library and they are independent of the intensional definition of the <code>Ord</code> instance.</p>\n<p>So if these theorems were used, the proof of <code>LawfulOrd</code> wouldn't change if the definition was different (but still propositionally equal). Of course, the standard library's lemmas would need different proofs when the definition is changed, but my point is that this would not affect downstream users.</p>",
        "id": 531758304,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753856581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531727876\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531699692\">said</a>:</p>\n<blockquote>\n<p>Is my reasoning sound or do you think projects downstream of the standard library really need to rely on the definition of stdlib's <code>Ord</code> instances?</p>\n</blockquote>\n<p>They already do! This is the \"rabbit hole\" I mentioned earlier. It's a weed that needs to be uprooted.</p>\n</blockquote>\n<p>With \"they already do\", do you mean that they rely on the intensional definition or that they <em>need</em> to? I think that for most standard library types and their <code>Ord</code> instances, the standard library provides enough lemmas to fully characterize the instances propositionally.</p>\n<p>(As I said, I'm happy to provide more/better lemmas if it's too inconvenient right now.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531730756\">said</a>:</p>\n<blockquote>\n<p>Also remember that <code>Ord</code> instances are data and therefore subject to diamond issues, regardless of propositional equality.</p>\n</blockquote>\n<p>Yet this is only a problem if there are non-canonical <code>Ord</code> instances. Why would one create a second non-definitionally-equal <code>Ord</code> instance while hoping that it's definitionally equal to the stdlib one? Mathlib doesn't need to redefine the <code>Ord</code> instances because classes such as <code>LinearOrder</code> extend <code>Ord</code> (forgetful instance principle).</p>",
        "id": 531760868,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753857733
    },
    {
        "content": "<p>I'm confused. I don't think we're talking about the same thing anymore.</p>\n<p>Lean provides two default comparison constructors: <code>compareOfLessAndEq</code> and <code>compareOfLessAndBEq</code>. There could be just one like <code>compareOfLE</code>, to pick one. Not only is <code>compareOfLE</code> propositionally equal to the two existing constructors in all use cases, it's easier to use. For example, <code>compareOfLE</code> does not require <code>DecidableEq</code> nor <code>BEq</code>. Furthermore, proving <code>TransCmp</code> for <code>compareOfLE</code> only needs two facts (<code>le_trans : ∀ x y z : α, x ≤ y → y ≤ z → x ≤ z</code> and <code>le_total : ∀ x y : α, x ≤ y ∨ y ≤ x</code>) whereas proving <code>TransCmp</code> for <code>compareOfLessAndEq</code> requires three or four facts.</p>",
        "id": 531810320,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753872694
    },
    {
        "content": "<p>Okay, let me try to get us aligned again...</p>\n<ul>\n<li>The problem I took away from your earlier post is that in Batteries, there seems to be the need to derive properties such as <code>TransOrd</code> directly from the definition of the <code>Ord</code> instances defined in stdlib. The way these instances are defined is annoying to use.</li>\n<li>Can we add <code>compareOfLE</code> and <code>compareOfLT</code> to the standard library, and perhaps lemmas for stdlib types stating that the <code>Ord</code> instances are propositionally equal to <code>compareOfLE</code>? I think so!</li>\n<li>Should we change the <code>Ord</code> instances in the standard library, such as <code>Ord Nat</code>, such that they are definitionally equal to <code>compareOfLE</code>? As long as users rely on the exact definition of these instances, as Batteries currently does, it would be a breaking change (in other words, changing this is affected by the weeds you were mentioning?).</li>\n</ul>\n<p>Regarding the third point, what I don't understand is why Batteries is unfolding the definition of the instances and relying on definitional equality at all. Are there lemmas missing that make this necessary? Or is there some reason why proving <code>LawfulOrd</code> instances without relying on definitional equality isn't nice either?</p>\n<p>(Side note: Actually, the standard library already <a href=\"https://loogle.lean-lang.org/?q=Std.TransOrd\">provides <code>TransOrd</code> instances for most types</a>, including <code>Nat</code>. But a similar point holds for <code>LawfulOrd</code>. Here, stdlib at least provides <code>Nat.compare_eq_lt</code> etc.)</p>\n<p>Let me give an ad-hoc example in Lean pseudocode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- LawfulOrd.ofAxioms doesn't exist right now</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulOrd</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LawfulOrd</span><span class=\"bp\">.</span><span class=\"n\">ofAxioms</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_lt</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_gt</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_eq</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">isLE_compare</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">isGE_compare</span>\n</code></pre></div>\n<p>All the suffering w.r.t. <code>compareOfLessAndEq</code> is then limited to stdlib authors.</p>\n<p>Not sure whether this already helps to clear up misunderstandings, but at least I hope so.</p>",
        "id": 531831354,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753878839
    },
    {
        "content": "<p>Ah! We were definitely on two different pages. I think I understand the disconnect.</p>\n<p>You view <code>compareOfLessAndEq</code> and <code>compareOfLessAndBEq</code> as implementation details for <code>Ord</code> instances in stdlib. I wish that were true! Unfortunately, they are used downstream and that makes them \"weeds\" to me as a Batteries maintainer. That is: <code>compareOfLessAndEq</code> and <code>compareOfLessAndBEq</code> are the \"weeds\", not individual uses thereof.</p>\n<p>While working on <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a>, I was concerned by how many theorems like <code>LawfulCmp.compareOfLessAndEq_of_irrefl_of_trans_of_not_lt_of_antisymm</code> there were in Batteries. I don't think these belong in stdlib, at least not for public use. I then got worried since matching theorems for <code>compareOfLessAndBEq</code> are missing...</p>\n<p>My original suggestion is perhaps better phrased like this: </p>\n<blockquote>\n<p>If stdlib is to provide a <code>compareOfBlah</code> for public use, with accompanying theorems, please let that be something more reasonable like <code>compareOfLT</code> or <code>compareOfLE</code>. And, ideally, remove <code>compareOfLessAndEq</code> and <code>compareOfLessAndBEq</code> from public view.</p>\n</blockquote>",
        "id": 531851197,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753883973
    },
    {
        "content": "<p>I see! Indeed, I thought you were mainly concerned with the Ord instances in stdlib that rely on compareOfBlah. Thanks for clarifying.</p>",
        "id": 531854395,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1753884714
    },
    {
        "content": "<p>The reason I originally wrote these lemmas was because there were a ton of Ord instances which were not proved lawful (indeed at the time there wasn't even a LawfulOrd class) in std. So I was saddled with the task of proving a bunch of messy lemmas about how std internals work, which I never like to do. It should have been upstream to begin with</p>",
        "id": 531897969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753897939
    },
    {
        "content": "<p>if <code>LawfulOrd</code> and <code>compareOfLessAndEq</code> are upstream, then <code>LawfulOrd.compareOfLessAndEq</code> should be upstream too.</p>",
        "id": 531898114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753897996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a> was a lot of work and it is subject to quick rotting. I think we should aim to merge soon.</p>",
        "id": 531960825,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753925282
    },
    {
        "content": "<p>I agree. I'm happy to merge asap.</p>",
        "id": 531961070,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753925433
    },
    {
        "content": "<p>There's currently a merge conflict in <code>RBMap</code>. I've been holding off adding deprecations to <code>RBMap</code> (in favour of <code>Std.Data.TreeMap</code>) as we won't have parity with the <code>Stream</code> interface until Q4. However it's unused in Mathlib, and I'm unaware of any users of the Stream interface elsewhere (but would appreciate knowing about any, to help inform the Q4 work on TreeMap).</p>",
        "id": 531961076,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753925435
    },
    {
        "content": "<p>I hadn't noticed. Fixed now!</p>",
        "id": 531962524,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753926346
    },
    {
        "content": "<p>(Update; in a separate thread, I'm convinced there's no need to deprecate RBMap, and it serves a different purpose than TreeMap.)</p>",
        "id": 531962537,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753926356
    },
    {
        "content": "<p>??? There's nothing in <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a> that deprecates RBMap.</p>",
        "id": 531962858,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753926570
    },
    {
        "content": "<p>This was just in reference to my (retracted) comment above that I <em>wanted</em> to deprecate RBMap in future. I said that in response to your statement above that preparing <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a> was a lot of work -- it would have been less work if the changes to RBMap hadn't had to be part of it.</p>",
        "id": 531963018,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753926674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, do you want to have a look at the changes in <a href=\"https://github.com/leanprover-community/batteries/pull/1306\">batteries#1306</a> to RBMap files?</p>",
        "id": 531963059,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753926710
    },
    {
        "content": "<p>I didn't see any changes that were not cosmetic</p>",
        "id": 531963232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753926815
    },
    {
        "content": "<p>The changes to RBMap are entirely superficial.</p>",
        "id": 531963251,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753926827
    },
    {
        "content": "<p>a lot of things got longer, I'm not super happy about that, but not enough to block it</p>",
        "id": 531963350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753926886
    },
    {
        "content": "<p>I imagine that the added <code>Std.</code> everywhere will go away once the deprecation is removed</p>",
        "id": 531963398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753926913
    },
    {
        "content": "<p>did these get upstreamed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">TransOrd</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">compareOfLessAndEq</span>\n<span class=\"w\">  </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_antisymm</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">LTOrd</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">compareOfLessAndEq</span>\n<span class=\"w\">  </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_antisymm</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">BEqOrd</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">compareOfLessAndEq</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_irrefl</span>\n</code></pre></div>",
        "id": 531963508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753926984
    },
    {
        "content": "<p>I'm not quite clear on why we don't need these yet we do need</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulLTOrd</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulLTCmp</span><span class=\"bp\">.</span><span class=\"n\">compareOfLessAndEq_of_irrefl_of_trans_of_antisymm</span>\n<span class=\"w\">    </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_antisymm</span>\n</code></pre></div>",
        "id": 531963615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753927067
    },
    {
        "content": "<p>Yes, a lot of the added crud is expected to disappear once deprecations run through. The absurdly long names are my bad and intentional as I mentioned above.</p>\n<p>I also just noticed that some instances were redundant. I'll fix those in a few of hours -- I have some non-lean I need  to deal with until then :/</p>",
        "id": 531963942,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753927246
    },
    {
        "content": "<p>Also, is there a reason dot notation doesn't work above?</p>",
        "id": 531964419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753927528
    },
    {
        "content": "<p><code>Std.LawfulLTOrd</code> is not upstreamed yet.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531964419\">said</a>:</p>\n<blockquote>\n<p>Also, is there a reason dot notation doesn't work above?</p>\n</blockquote>\n<p>Where?</p>",
        "id": 531965576,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753928245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531963615\">said</a>:</p>\n<blockquote>\n<p>I'm not quite clear on why we don't need these yet we do need</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulLTOrd</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">LawfulLTCmp</span><span class=\"bp\">.</span><span class=\"n\">compareOfLessAndEq_of_irrefl_of_trans_of_antisymm</span>\n<span class=\"w\">    </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">lt_antisymm</span>\n</code></pre></div>\n</blockquote>",
        "id": 531965587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753928257
    },
    {
        "content": "<p>note that the code it replaces was using dot notation</p>",
        "id": 531965655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753928302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531965576\">said</a>:</p>\n<blockquote>\n<p><code>Std.LawfulLTOrd</code> is not upstreamed yet.</p>\n</blockquote>\n<p>Right, but it wasn't being proved before, so I assume it followed from the other classes</p>",
        "id": 531965761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753928370
    },
    {
        "content": "<p>or is this just a new theorem?</p>",
        "id": 531965789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753928391
    },
    {
        "content": "<p>oh wait, this is the equivalent of the <code>LTOrd</code> instance. What do you mean it is not upstreamed, it has <code>Std</code> namespace?</p>",
        "id": 531965937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753928483
    },
    {
        "content": "<p>Dot notation does work, that was a \"typo\".</p>\n<p><code>LawfulLTCmp</code>, <code>LawfulLECmp</code> are still in batteries after this PR but they are in the <code>Std</code> namespace. They should be upstreamed to core eventually.</p>",
        "id": 531966232,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753928736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531831354\">said</a>:</p>\n<blockquote>\n<p>Let me give an ad-hoc example in Lean pseudocode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- LawfulOrd.ofAxioms doesn't exist right now</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulOrd</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LawfulOrd</span><span class=\"bp\">.</span><span class=\"n\">ofAxioms</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_total</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_lt</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_gt</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">compare_eq_eq</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">isLE_compare</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">isGE_compare</span>\n</code></pre></div>\n<p>All the suffering w.r.t. <code>compareOfLessAndEq</code> is then limited to stdlib authors.</p>\n<p>Not sure whether this already helps to clear up misunderstandings, but at least I hope so.</p>\n</blockquote>\n<p>Let me try to address this again. There should be no need to use <code>Nat.compare_eq_lt</code> in a theorem such as this, because that is literally the content of the <code>LawfulLTOrd</code> class, and similarly for the others. A <code>LawfulOrd Nat</code>  instance follows directly from <code>LawfulLTOrd</code>, <code>LawfulLEOrd</code> and some others, although it can sometimes be convenient to prove <code>LawfulOrd</code> first and get the others as a result. Either way, you ultimately need to reduce to things not involving <code>compare</code> because this is supposed to be the first theorem one proves about <code>compare</code> on the type, and also (for a core type like <code>Nat</code>) this theorem should be in std to begin with. When it appears in Batteries that's because Std was lacking the lemma and it should be upstreamed.</p>\n<p>For types not in Std/Init, obviously some proof work has to be left for the downstream library, and Std should provide lemmas to make this as easy as possible. The best thing would be to have a deriving handler, but this seems to be difficult, so until then lemmas like <code>LawfulCmp.compareOfLE</code> are used when the <code>Ord</code> instance is pre-existing or otherwise defined using <code>compareOfLE</code>. When the <code>Ord</code> instance is derived and recursive, right now I think the proof is basically impossible, and I've been avoiding the issue thus far and ensuring that such instances are just avoided altogether.</p>",
        "id": 531966710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753929043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/348111-batteries/topic/Batteries.2EOrientedCmp.20et.20al/near/531966710\">said</a>:</p>\n<blockquote>\n<p>When the <code>Ord</code> instance is derived and recursive, right now I think the proof is basically impossible, and I've been avoiding the issue thus far and ensuring that such instances are just avoided altogether.</p>\n</blockquote>\n<p>Yet another way that weeds propagate... I hope we can fix this!</p>\n<p>With the new module system, it should be possible to hide things like <code>compareOfLessAndEq</code> and make something better instead!</p>",
        "id": 531969023,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753930538
    },
    {
        "content": "<p>I'm not sure that hiding solves the problem here</p>",
        "id": 531969573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753930875
    },
    {
        "content": "<p>in fact, hiding is part of the reason that the derived Ord instance is difficult to work with</p>",
        "id": 531969592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1753930891
    },
    {
        "content": "<p>My opinion is that <code>compareOfLE</code> (or something like that) should be made default, have lots of lemmas and should be used in derive handlers (when that makes sense). There should also be derive handlers for <code>LawfulOrdBlah</code> that work without unnecessary requirements...</p>",
        "id": 531970289,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753931303
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I checked all the instances you mentioned. They were all upstreamed. I also removed a few redundant instances that I had missed. I also fixed your additional comments on GitHub.</p>",
        "id": 531974168,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1753933873
    }
]