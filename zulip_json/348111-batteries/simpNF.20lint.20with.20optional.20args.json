[
    {
        "content": "<p>My scan PR for arrays is currently failing CI because simpNF wants me to specify the optional arguments (start and stop indices) on the LHS of every theorem. </p>\n<p>so e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">scanl_reverse</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">scanr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>would need to be written as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">scanl_reverse</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">scanr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>To me it seems like this clutters up the theorem definitions. Should I make this change to every theorem, or if not is it possible to disable this lint?</p>",
        "id": 567015885,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767900186
    },
    {
        "content": "<p>(the fact that the array versions have start/stop indices is just for parity with <code>Array.foldl/foldr</code> and so <code>Subarray.scan*</code> can be implemented in terms of the array version.</p>",
        "id": 567016108,
        "sender_full_name": "cmlsharp",
        "timestamp": 1767900249
    },
    {
        "content": "<p>It's a bit hard to help if you don't share the error message of simpNF</p>",
        "id": 567486041,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768212478
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">.../</span><span class=\"n\">Batteries</span><span class=\"bp\">/</span><span class=\"n\">Data</span><span class=\"bp\">/</span><span class=\"n\">Array</span><span class=\"bp\">/</span><span class=\"n\">Scan</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">355</span><span class=\"o\">:</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">scanl_reverse</span><span class=\"w\"> </span><span class=\"n\">Left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">simplifies</span><span class=\"w\"> </span><span class=\"k\">from</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span>\n<span class=\"n\">to</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n<span class=\"kn\">using</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">size_reverse</span><span class=\"o\">]</span>\n<span class=\"n\">Try</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"bp\">-</span><span class=\"n\">hand</span><span class=\"w\"> </span><span class=\"n\">side</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simplified</span><span class=\"w\"> </span><span class=\"n\">term!</span>\n</code></pre></div>",
        "id": 567552696,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768228890
    },
    {
        "content": "<p>I suppose the issue here is that the default argument ends up becoming 'as.reverse.size', which simpNF wants to simplify to <code>as.size</code>. That's fair enough I suppose but it requires me to specify the default argument in the theorem statement.</p>\n<p>Analogous theorems for <a href=\"https://github.com/leanprover/lean4/blob/2fcce7258eeb6e324366bc25f9058293b04b7547/src/Init/Data/Array/Lemmas.lean#L3428\">Array.foldl</a> in the standard library do not infect the theorem statement like this</p>",
        "id": 567554132,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768229229
    },
    {
        "content": "<p>(just for reference this is the type of <code>Array.scanl</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">scanl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>",
        "id": 567554642,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768229334
    },
    {
        "content": "<p>Exactly, and the <code>simpNF</code> linter has a good point: if you have the LHS with <code>as.reverse.size</code>, then this <code>simp</code> lemma is useless. <del>Those theorems in the standard library are also useless <code>simp</code> theorems.</del></p>",
        "id": 567555229,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768229455
    },
    {
        "content": "<p>Sorry I was wrong, in the standard library they do address this issue correctly. They have the following theorem for <code>simp</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Variant of `foldl_reverse` with a side condition for the `stop` argument. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foldl_reverse'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">stop</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 567557768,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768229949
    },
    {
        "content": "<p>ah I see, so the righgt way to handle such cases is to provide two versions of the lemma, one \"main\" version without optional args specified or a simp annotation and then an equivalent lemma with the simp annotation and the optional arguments specified (and simplified)?</p>",
        "id": 567558786,
        "sender_full_name": "cmlsharp",
        "timestamp": 1768230129
    },
    {
        "content": "<p>Indeed. Their <code>Array.foldl_reverse'</code> version has an extra <code>stop</code> variable with a hypothesis <code>stop = xs.size</code>. I presume that this comes in handy if <code>xs</code> is e.g. a literal array, something like <code>#[x,y,z]</code>, in which case the simplified form of <code>#[x,y,z].reverse.size</code> is <code>3</code>. If the lemma had <code>xs.size</code> inlined in <code>xs.reverse.foldl f b 0 xs.size</code>, then unification would fail to unify <code>#[x,y,z].size</code> with <code>3</code>.</p>",
        "id": 567561048,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1768230626
    }
]