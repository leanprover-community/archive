[
    {
        "content": "<p>Per <a href=\"#narrow/channel/428973-nightly-testing/topic/Mathlib.20status.20updates/near/547053119\">this message</a>, Aesop is currently detecting cycles in its search trees. I use a somewhat tricky encoding of the search trees as an <code>unsafe</code> inductive type, to get pointers pointing up the tree. (Questionable value for sure.) Does that ring any bells? Any recent Lean changes that could be messing with this? cc <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span></p>",
        "id": 547297480,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1761576704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> might be interested(/horrified) as well. I guess the BaseIO refactoring does fall in the date range in question but I'm not sure I want to even imagine how that could be relevant</p>",
        "id": 547325434,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1761583137
    },
    {
        "content": "<p>The unsafe construction in question is here: <a href=\"https://github.com/leanprover-community/aesop/blob/1fa48c6a63b4c4cda28be61e1037192776e77ac0/Aesop/Tree/Data.lean#L386\">https://github.com/leanprover-community/aesop/blob/1fa48c6a63b4c4cda28be61e1037192776e77ac0/Aesop/Tree/Data.lean#L386</a></p>\n<p>Maybe the answer is \"well, don't do that!\", but I feel like what I'm doing is not too crazy.</p>",
        "id": 547333317,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1761585321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>  I've looked into this, but I can't find anything fishy in my code, so there might be an actual Lean bug. The function that checks for cycles is <a href=\"https://github.com/leanprover-community/aesop/blob/1da2f2d2945f8740802cc38c48d2ce6723ef6154/Aesop/Tree/Check.lean#L41\">here</a>. It traverses the tree, collects the <code>IO.Ref</code>s that hold each node and checks that none of the <code>Ref</code>s are pointer-equal to a previously visited node. Does this sound reasonable?</p>",
        "id": 553196053,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1762036756
    },
    {
        "content": "<p>I know what it is</p>",
        "id": 553196154,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762036853
    },
    {
        "content": "<p>I overlooked to fix one in the hundreds of IO/ST functions and of course we don't actually test it anywhere so it went unnoticed</p>",
        "id": 553196195,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762036913
    },
    {
        "content": "<p>Nice, happy to hear that! Thanks!</p>",
        "id": 553196213,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1762036937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> I actually think lean_st_ref_ptr_eq was broken the entire time btw, check:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lean_to_ref</span><span class=\"p\">(</span><span class=\"n\">ref1</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">m_value</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">lean_to_ref</span><span class=\"p\">(</span><span class=\"n\">ref2</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">m_value</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>This tests if the containing value if ptr eq, not if the cell is ptr eq, the documentation says:</p>\n<blockquote>\n<p>Checks whether two reference cells are in fact aliases for the same cell.</p>\n<p>Even if they contain the same value, two references allocated by different executions of <code>IO.mkRef</code><br>\nor <code>ST.mkRef</code> are distinct. Modifying one has no effect on the other. Likewise, a single reference<br>\ncell may be aliased, and modifications to one alias also modify the other.</p>\n</blockquote>\n<p>But if I currently have two <code>IO.mkRef</code> with the same <code>0</code> in them they are ptr_eq. I will change that.</p>",
        "id": 553196648,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762037486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> you can test  aesop with the PR toolchain on <a href=\"https://github.com/leanprover/lean4/pull/11056\">https://github.com/leanprover/lean4/pull/11056</a> in a bit or when you wake up tomorrow.</p>",
        "id": 553197093,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762038118
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>! <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span>, I've confirmed aesop works against that toolchain, so everything should come good by itself later today. (I need to restore the <code>lake built AesopTest</code> step in Mathlib CI, still.)</p>",
        "id": 553292072,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1762136429
    }
]