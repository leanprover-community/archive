[
    {
        "content": "<p>Is one of the authors of <code>Mathlib.Tactic.ToAdditive</code>, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, <span class=\"user-mention\" data-user-id=\"385895\">@Jon Eugster</span> available to help understand a failure of <code>@[to_additive]</code> on the <code>lean-pr-testing-4595</code> branch?</p>\n<p>(This is an experimental branch changing the proofs that <code>simp</code> generates when using <code>dsimp</code> lemmas, attempting to reduce the occurrence of \"unguided\" defeq problems in the kernel after <code>simp</code>.)</p>\n<p>I am seeing failures in <code>Mathlib.Data.Part</code>, and in <code>Mathlib.RingTheory.OreLocalization</code>, where the <code>@[to_additive]</code> attribute is failing, and I'm not sure why.</p>\n<p>Typical errors are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"s2\">\"A difference is equal to its expansion by a summand from `S`.\"</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">expand'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">/ₒ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OreLocalization</span><span class=\"bp\">.</span><span class=\"n\">expand</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_cast</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_mem</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>producing </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Subsemigroup</span><span class=\"bp\">.</span><span class=\"n\">Operations</span><span class=\"bp\">._</span><span class=\"n\">auxLemma</span><span class=\"bp\">.</span><span class=\"m\">7</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">AddZeroClass</span><span class=\"bp\">.</span><span class=\"n\">toAdd</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulMemClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">S'</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">some_mul_some</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>producing </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">mul_def</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Part</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">      </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Note this is not a complete failure of <code>@[to_additive]</code>, it is working fine still in basic files.</p>",
        "id": 448468854,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719881494
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/pull/10830\">#10830</a>. The issue is that <code>simp</code> generates subterms that don't have enough context to translate. They are lambda-terms quantifying over multiplicative type-classes, but applied to terms. We need to know what the terms are to decide whether we should translate these multiplicative type-classes (currently we do translate them).<br>\nPossible solutions:</p>\n<ul>\n<li>adapt simp to not generate applied lambda-terms</li>\n<li>adapt <code>to_additive</code> to beta-reduce the value before translating anything (this might actually be pretty feasible - but we also need to look at generated auxiliary declarations, which will be harder)</li>\n<li>adapt <code>to_additive</code> to be more context-aware during the translation (probably not feasible).</li>\n<li>Live with the status quo: the workaround is to specify the type explicitly in a few simp-rules.</li>\n</ul>",
        "id": 448536370,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719908881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, could you explain what the workaround would look like here? Which simp rules do I need to look at to fix </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">some_mul_some</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>What type needs to be specified explicitly?</p>",
        "id": 448554452,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719912992
    },
    {
        "content": "<p>This has nothing to do with <a href=\"https://github.com/leanprover-community/mathlib4/pull/10830\">#10830</a>. It is fixed by adding <code>@[to_additive]</code> to <code>Part.mul_def</code>.</p>",
        "id": 448569898,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719916552
    },
    {
        "content": "<p>I don't know why those lemmas don't have that...</p>",
        "id": 448570009,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719916570
    },
    {
        "content": "<p>I pushed to the branch fixing <code>Data.Part</code>.</p>",
        "id": 448570290,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719916630
    },
    {
        "content": "<p>We just didn't see it on master, since <code>simp [mul_def]</code> created a proof term that doesn't mention <code>mul_def</code>.</p>",
        "id": 448570719,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719916718
    },
    {
        "content": "<p>Do you know the internals of <code>simp</code>? <br>\nGiven a new declaration (to which we want to add the <code>to_additive</code> attribute) it would be very helpful to know which declarations were automatically generated by this declaration. <code>to_additive</code> needs to (potentially) additivize these declarations as well.<br>\nThe current heuristic when adding declaration <code>foo</code> it will consider the following declarations that (may) have been added to the environment when elaborating <code>foo</code>:</p>\n<ol>\n<li>It has to occur in <code>foo</code> (or in a declaration automatically generated by <code>foo</code>)</li>\n<li>\n<p>It has to be of one of these forms</p>\n<ul>\n<li><code>foo.&lt;something&gt;</code></li>\n<li><code>Mathlib.MyFile._auxLemma.&lt;something&gt;</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LeanisPrivateName#doc\">docs#LeanisPrivateName</a> holds</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Name.hasMacroScopes#doc\">docs#Lean.Name.hasMacroScopes</a> holds</li>\n</ul>\n</li>\n</ol>",
        "id": 448574193,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719917386
    },
    {
        "content": "<p>(ran off to lunch, now I'm back)<br>\nThe first error in <code>OreLocalization.Basic</code> is a case where <code>simp</code> generates <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code>, and <code>to_additive</code> currently doesn't consider additivizing this.</p>",
        "id": 448585989,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719920813
    },
    {
        "content": "<p>Why is that?</p>",
        "id": 448586034,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719920825
    },
    {
        "content": "<p>Surely this occurs everywhere?</p>",
        "id": 448586075,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719920835
    },
    {
        "content": "<p>It wasn't created during <code>expand'</code> (at least according to <code>whatsnew in</code>)</p>",
        "id": 448586233,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719920875
    },
    {
        "content": "<p>but presumably that just means that someone had previously used it as simp lemma.</p>",
        "id": 448586341,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719920891
    },
    {
        "content": "<p>Oh, when you said \"one of these forms\": <code>Mathlib.MyFile._auxLemma.&lt;something&gt;</code> did you literally mean that <code>MyFile</code> had to match the current file?</p>",
        "id": 448586657,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719920987
    },
    {
        "content": "<p>Yes</p>",
        "id": 448586783,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921020
    },
    {
        "content": "<p>I don't recall why we did it this way. We could try to additivize everything that satisfies <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Name.isInternalDetail#doc\">docs#Lean.Name.isInternalDetail</a>.</p>",
        "id": 448587064,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921122
    },
    {
        "content": "<p>I think the reason is that there is a problem if files <code>B</code> and <code>C</code> both import file <code>A</code>, and both separately additivize <code>A.something</code>, then you now have two additive translations.</p>",
        "id": 448587213,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921178
    },
    {
        "content": "<p>Ah -- at least for theorems this is allowed now.</p>",
        "id": 448587274,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719921198
    },
    {
        "content": "<p>How does <code>simp</code> deal with this? Can it be the case that two files both generate <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code>?</p>",
        "id": 448587294,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921206
    },
    {
        "content": "<p>Yes, and we arrange that lean doesn't complain about the duplication in these cases!</p>",
        "id": 448587339,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719921222
    },
    {
        "content": "<p>So hopefully to_additive could take advantage of the same.</p>",
        "id": 448587370,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719921231
    },
    {
        "content": "<p>So <code>simp</code> guarantees that all generated declarations with the name <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code> have exactly the same type?</p>",
        "id": 448587457,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921251
    },
    {
        "content": "<p>That is a good question. I'm not confident there.</p>",
        "id": 448587516,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719921270
    },
    {
        "content": "<p>But presumably the answer is yes??</p>",
        "id": 448587559,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719921281
    },
    {
        "content": "<p>Then I'm a bit surprised what the 7 indicates... It somehow must encode for what declaration it is generating an equation lemma.</p>",
        "id": 448587680,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/428973-nightly-testing/topic/lean-pr-testing-4595/near/448586075\">said</a>:</p>\n<blockquote>\n<p>Surely this occurs everywhere?</p>\n</blockquote>\n<p><code>to_additive</code> calls <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.getEqnsFor%3F#doc\">docs#Lean.Meta.getEqnsFor?</a> with <code>nonrec := true</code> on all declarations it additivizes. This ensures that most equation lemmas are already generated (and correctly additivized). This is a hack that maybe we can get rid of now...</p>",
        "id": 448588135,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921451
    },
    {
        "content": "<p>Though I'm still not sure if <code>nonrec := false</code> is the correct default for Mathlib. I expect that for most declarations we will use the equational lemmas multiple times, so it is cheaper to just always compute it once, instead of computing it potentially multiple times. (I can imagine that in other contexts this is the right default behavior.)</p>",
        "id": 448588417,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719921555
    },
    {
        "content": "<p>I believe </p>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/428973-nightly-testing/topic/lean-pr-testing-4595/near/448588135\">said</a>:</p>\n<blockquote>\n<p>This is a hack that maybe we can get rid of now...</p>\n</blockquote>\n<p>Probably we cannot (easily). A comment in the source code mentions</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>/- We need to generate all equation lemmas for `src` and `tgt`, even for non-recursive\ndefinitions. If we don&#39;t do that, the equation lemma for `src` might be generated later\nwhen doing a `rw`, but it won&#39;t be generated for `tgt`. -/\n</code></pre></div>\n\n</blockquote>",
        "id": 448589994,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719922041
    },
    {
        "content": "<p>Ooh, so I made a hacky change so it will additivize everything, even from different files.</p>",
        "id": 448590542,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922222
    },
    {
        "content": "<p>OreLocalization then succeeds.</p>",
        "id": 448590585,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922233
    },
    {
        "content": "<p>I'll see if the rest of mathlib survives.</p>",
        "id": 448590607,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922240
    },
    {
        "content": "<p>I expect that in some random file you will get a clash of additivized names. But let's see.</p>",
        "id": 448590708,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719922277
    },
    {
        "content": "<p>Somewhat unexpectedly the first error is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">././././</span><span class=\"n\">Mathlib</span><span class=\"bp\">/</span><span class=\"n\">Algebra</span><span class=\"bp\">/</span><span class=\"n\">BigOperators</span><span class=\"bp\">/</span><span class=\"n\">Group</span><span class=\"bp\">/</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span><span class=\"mi\">1712</span><span class=\"o\">:</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">one_ne_zero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝¹</span>\n<span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">One</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>Shouldn't it already know not to touch this?</p>",
        "id": 448592649,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922798
    },
    {
        "content": "<p>The big issues of <code>simp</code>(/<code>rw</code>) + <code>to_additive</code> interactions that I currently see:</p>\n<ol>\n<li>If large lambda-terms are generated (that abstract over multiplicative classes), we should beta-reduce these beta-redexes before translation.</li>\n<li>We should correctly additivize generated auxiliary declarations (and manage if they come from different modules)</li>\n<li>If we generate an auxiliary declaration that cannot be additivized (maybe for a lemma about <code>Ring</code>) then we should have a mechanism that decides not to additivize it.</li>\n</ol>\n<p>I believe the workaround of specifying types explicitly (mentioned in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10830\">#10830</a>) can work around both issues 1 and 3.<br>\nThere are probably other issues I'm not seeing at the moment, though.</p>",
        "id": 448592651,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719922798
    },
    {
        "content": "<p>This is on <a href=\"https://github.com/leanprover-community/mathlib4/tree/to_additive_all\">branch#to_additive_all</a> if you want to take a look.</p>",
        "id": 448592870,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922841
    },
    {
        "content": "<p>Well, <code>one_ne_zero</code> doesn't have a <code>to_additive</code> tag, but depending on your implementation you now basically made it have one?</p>",
        "id": 448592894,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719922848
    },
    {
        "content": "<p>I think I only changed anything about <code>_auxLemma</code>.</p>",
        "id": 448592924,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922862
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/compare/master...to_additive_all\">diff</a></p>",
        "id": 448593039,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922905
    },
    {
        "content": "<p>Oh</p>",
        "id": 448593251,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922971
    },
    {
        "content": "<p>I see, but as soon as someone uses it manually in <code>simp</code>...</p>",
        "id": 448593300,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719922991
    },
    {
        "content": "<p>Not sure why you get that error on Master. But it is completely expected that <code>to_additive</code> translates <code>One α</code> to <code> Zero α</code></p>",
        "id": 448593313,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719922995
    },
    {
        "content": "<p>Hrmm... is the additive version of <code>OreLocalization</code> even a useful thing? I would be just as happy here to rip out all the <code>to_additive</code>s in this file!</p>",
        "id": 448593539,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719923069
    },
    {
        "content": "<p>Algebraic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>K</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">K_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> was mentioned by Johan</p>",
        "id": 448593691,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1719923124
    },
    {
        "content": "<p>Hmm, my hack breaks master pretty thoroughly. :-(</p>",
        "id": 448594377,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719923358
    },
    {
        "content": "<p>Actually, I don't even know when and why <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code> is generated. It looks like the symmetric version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulMemClass.coe_mul#doc\">docs#MulMemClass.coe_mul</a> (and not an equational lemma for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulMemClass.mul#doc\">docs#MulMemClass.mul</a> ). Is that changing in <a href=\"https://github.com/leanprover/lean4/pull/4595\">lean4#4595</a> ?</p>",
        "id": 448595926,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719923905
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/4595\">lean#4595</a> is a pretty big change. It actually rewrites by all simp lemmas, even if they are <code>rfl</code> lemmas (previously we just omitted the proof, and this gave the kernel lots of hard defeq problems).</p>",
        "id": 448596538,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719924116
    },
    {
        "content": "<p>So yes, we are generating many more auxiliary lemmas (for all the <code>rfl</code> lemmas that we ever rewrite by).</p>",
        "id": 448596652,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719924138
    },
    {
        "content": "<p>Can we generate them the moment that a declaration is tagged <code>simp</code>? (or when a definition is declared)?</p>",
        "id": 448597098,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719924291
    },
    {
        "content": "<p>Though I guess when a definition is declared we already do that in <code>to_additive</code>.</p>",
        "id": 448597168,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719924317
    },
    {
        "content": "<p>Or if we already do... Is there a way to figure out what the name is?</p>",
        "id": 448597582,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719924467
    },
    {
        "content": "<p>Note: there is another hack in <code>to_additive</code> to figure out what lemmas are generated by <code>simp</code>. I expect this hack doesn't survive this change. <br>\nIf this information is somehow available in the environment after the <code>simp</code> attribute is executed, that would make the behavior of <code>to_additive</code> less hacky, and we might then be able to find (and generate) the newly generated simp-lemmas.</p>",
        "id": 448597881,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719924563
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.Simp.addSimpAttrFromSyntax#doc\">docs#Lean.Meta.Simp.addSimpAttrFromSyntax</a> (which is in <code>Mathlib</code>, despite its name)</p>",
        "id": 448598517,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719924746
    },
    {
        "content": "<p>Looking at the pr-branch.<br>\n<code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code> is generated the moment that <code>MulMemClass.coe_mul</code> is declared, but not currently caught and additivized by the current implementation of <code>to_additive</code> (probably because of the very hacky <code>Lean.Meta.Simp.addSimpAttrFromSyntax</code>)</p>",
        "id": 448600151,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719925215
    },
    {
        "content": "<p>I have to run now.</p>",
        "id": 448600179,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719925220
    },
    {
        "content": "<p>I'm investigating this a bit further. These declarations are generated by <code>norm_cast</code>. The attribute <code>@[to_additive (attr := norm_cast)]</code> applies the <code>norm_cast</code> attribute to both the multiplicative and additive declaration, creating the lemmas <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.7</code> and <code>Mathlib.Algebra.Group.Subsemigroup.Operations._auxLemma.8</code>. What is missing is that these lemmas should be put in the \"multiplicative -&gt; additive\" dictionary that <code>to_additive</code> is using. <br>\nThis is currently done in a very hacky way for the <code>simp</code> and <code>simps</code> attributes specifically, but not for other attributes.<br>\nI'm not sure what the best way forward is. <br>\nFrom the perspective of <code>to_additive</code>, it would be nice if every attribute could report \"I generated this list of declarations\" (in order). <br>\nI could try to extend the hack further to <code>norm_cast</code>, but maybe other attributes are also affected.<br>\nI could try something else hacky but more general, by comparing the environment before and after executing the command, and collecting the new attributes that way (but then I lose the order in which the declarations were added...)</p>",
        "id": 450166609,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720530243
    },
    {
        "content": "<p>Thanks Floris. My suggestoin would be to try extending the hack further to <code>norm_cast</code> for now. Given that we seem to get a fair way into Mathlib before this problem occurs, perhaps we can hope to get lucky.</p>",
        "id": 450183872,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720534257
    },
    {
        "content": "<p>Testing out the consequences of <a href=\"https://github.com/leanprover-community/mathlib4/pull/4595\">#4595</a> is moderately high priority: if this is something that we can make work we'd really like to.</p>",
        "id": 450183948,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1720534281
    },
    {
        "content": "<p>I think I will have time for this today.</p>",
        "id": 450398799,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720604590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/428973-nightly-testing/topic/lean-pr-testing-4595/near/450183948\">said</a>:</p>\n<blockquote>\n<p>Testing out the consequences of <a href=\"https://github.com/leanprover-community/mathlib4/pull/4595\">#4595</a> is moderately high priority: if this is something that we can make work we'd really like to.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/4595\">lean4#4595</a>, right?</p>",
        "id": 450430143,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1720612615
    },
    {
        "content": "<p>This was a bit more painful since <code>norm_cast</code> is in Core now, but on <a href=\"https://github.com/leanprover-community/mathlib4/tree/to-additive-4595\">branch#to-additive-4595</a> this issue is now fixed by increasing the hack. <code>RingTheory.OreLocalization</code> builds now.</p>",
        "id": 450515615,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720632392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> would Core be open to decreasing the depth of the hack? <br>\nThis requires three things:</p>\n<ul>\n<li>have <code>Lean.Meta.addSimpTheorem</code> return an array of declaration names that were generated. Two implementation options are <a href=\"https://github.com/leanprover-community/mathlib4/blob/5b4d4576b22671341b82c83c6aa14ec7cd3f57f6/Mathlib/Lean/Meta/Simp.lean#L90\">on Mathlib master</a> and <a href=\"https://github.com/leanprover-community/mathlib4/blob/af9cb23b0f280974380a44b2a314dd33b8fbcf4e/Mathlib/Lean/Meta/Simp.lean#L65\">on this branch</a> (these are not equivalent, since on master we return the empty array if no declaration was generated, and on the branch we return <code>#[declName]</code>, but both work well for me).</li>\n<li>all declarations that use <code>addSimpTheorem</code> (currently, AFAIK: <code>simp</code> and <code>norm_cast</code>) and are used in attributes should also return an <code>Array Name</code></li>\n<li>The <code>add</code> field of the attributes should be separated out as definitions that also return an <code>Array Name</code>.</li>\n<li>An alternative 3rd thing is that the <code>add</code> field <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.AttributeImpl#doc\">docs#Lean.AttributeImpl</a> have return type <code>Lean.AttrM A</code> for some configurable <code>A</code> and that for <code>simp</code> and <code>norm_cast</code> we have <code>A := Array Name</code>, but that might be too invasive.</li>\n</ul>",
        "id": 450518289,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633005
    },
    {
        "content": "<p>What's the feasibility of avoiding working with <code>_auxLemma</code>s by unfolding them? (And perhaps using an <code>Expr.beta</code> to fold in the arguments?)</p>",
        "id": 450518919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720633135
    },
    {
        "content": "<p>Another alternative is that we store in the environment all <code>simp</code> lemmas associated to a declaration (separately, somewhere), and that <code>to_additive</code> has access to that.</p>",
        "id": 450518944,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/428973-nightly-testing/topic/lean-pr-testing-4595/near/450518919\">said</a>:</p>\n<blockquote>\n<p>What's the feasibility of avoiding working with <code>_auxLemma</code>s by unfolding them? (And perhaps using an <code>Expr.beta</code> to fold in the arguments?)</p>\n</blockquote>\n<p>Unclear: some proofs generated by <code>simp</code> that do <em>not</em> use declarations are actually hard to translate, as described in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10830\">#10830</a>. But maybe both of them can be solved by beta-reducing more.</p>",
        "id": 450519479,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633256
    },
    {
        "content": "<p>oh wait, that's not the right issue</p>",
        "id": 450519663,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633295
    },
    {
        "content": "<p>maybe <a href=\"https://github.com/leanprover-community/mathlib4/pull/10830\">#10830</a> is also solved by your suggestion... So it's probably worth looking into...</p>",
        "id": 450520175,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633418
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/tree/to-additive-4595\">branch#to-additive-4595</a> builds successfully. Feel free to force-push it into <code>lean-pr-testing-4595</code> (that will remove your last commit).</p>",
        "id": 450521729,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633851
    },
    {
        "content": "<p>oh, unsuccesfully, but significantly more</p>",
        "id": 450521836,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720633880
    },
    {
        "content": "<p>And it looks like the remaining failures have nothing to do with <code>to_additive</code>.</p>",
        "id": 450522356,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720634053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/428973-nightly-testing/topic/lean-pr-testing-4595/near/450518919\">said</a>:</p>\n<blockquote>\n<p>What's the feasibility of avoiding working with <code>_auxLemma</code>s by unfolding them? (And perhaps using an <code>Expr.beta</code> to fold in the arguments?)</p>\n</blockquote>\n<p>testing on <a href=\"https://github.com/leanprover-community/mathlib4/tree/fvd%2Fto_additive_unfold_aux\">branch#fvd/to_additive_unfold_aux</a> . It seems to work quite well.</p>",
        "id": 450531115,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720636445
    },
    {
        "content": "<p>It works! <a href=\"https://github.com/leanprover-community/mathlib4/pull/14628\">#14628</a></p>",
        "id": 450550554,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1720641455
    }
]