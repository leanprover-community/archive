[
    {
        "content": "<p>Hi, I thought I'd try my hand at working on the coherent iso. Not because it is currently the most relevant part, but because it looks \"doable\" for me (ample experience in UniMath, but almost none with mathlib).</p>\n<p>I tried proving that the morphisms into <code>coherentIso</code> have some \"coherence\" (Note that <code>WalkingIso</code> is just a category structure on Fin 2):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">yonedaEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">yonedaEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X₀</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">hom_pt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I have advanced the proof up to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₁</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>but am not entirely sure how to proceed. <code>dsimp</code> gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">match</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Preord</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">PartOrd</span><span class=\"w\"> </span><span class=\"n\">Preord</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">          </span><span class=\"o\">((</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">Lat</span><span class=\"w\"> </span><span class=\"n\">PartOrd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">            </span><span class=\"o\">((</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">LinOrd</span><span class=\"w\"> </span><span class=\"n\">Lat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">              </span><span class=\"o\">((</span><span class=\"n\">forget₂</span><span class=\"w\"> </span><span class=\"n\">NonemptyFinLinOrd</span><span class=\"w\"> </span><span class=\"n\">LinOrd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">                </span><span class=\"o\">(</span><span class=\"n\">NonemptyFinLinOrd</span><span class=\"bp\">.</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"bp\">.</span><span class=\"n\">toOrderHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))))))))</span>\n<span class=\"w\">      </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isLt</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isLt</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>It seems like something that is \"almost, but not quite\" definitionally true. I have tried unfolding a couple of the terms here, but that seems to only increase the complexity of the goal.<br>\nWhich triviality am I missing? Should I delve deeper into the definition, or instead use a more high-level lemma?</p>",
        "id": 565634783,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1766998701
    },
    {
        "content": "<p>What does <code>simp</code> do?</p>",
        "id": 565644728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1767003279
    },
    {
        "content": "<p>If I let <code>simp</code> run on the \"match ... 0 with ... = 0\" goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"ss\">`simp</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">made</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">progress</span>\n</code></pre></div>",
        "id": 565645249,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767003553
    },
    {
        "content": "<p>If you use the injectivity of <code>yonedaEquiv</code>, the equality should translate as an equality in <code>ComposableArrows _ 2</code>, and there you may use <code>ComposableArrows.ext₂</code> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows/Basic.html#CategoryTheory.ComposableArrows.ext%E2%82%82\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/ComposableArrows/Basic.html#CategoryTheory.ComposableArrows.ext%E2%82%82</a> and five goals will appear: the first three are likely to be provable by <code>rfl</code>.</p>",
        "id": 565651777,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767006631
    },
    {
        "content": "<p>Ah, I used <code>ComposableArrows.ext</code>, which got me in this place. I will try the 2 version</p>",
        "id": 565651860,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767006684
    },
    {
        "content": "<p>Ah, It is actually an equality in ComposableArrows _ 0. So</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">hom_pt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"n\">yonedaEquiv</span><span class=\"w\"> </span><span class=\"n\">CosimplicialObject</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq_symm_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">uliftYonedaEquiv_naturality</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">ext₀</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span>\n</code></pre></div>\n<p>gives exactly</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₁</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>again.</p>",
        "id": 565652248,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767006901
    },
    {
        "content": "<p>Have you tried <code>rfl</code>?</p>",
        "id": 565652537,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767007032
    },
    {
        "content": "<p>Tactic <code>rfl</code> failed: The left-hand side<br>\n  ((nerve WalkingIso).map (SimplexCategory.δ 0).op (ComposableArrows.mk₁ PUnit.unit)).obj 0<br>\nis not definitionally equal to the right-hand side<br>\n  0</p>",
        "id": 565652584,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767007052
    },
    {
        "content": "<p>Ok, I will have a closer look.</p>",
        "id": 565652765,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767007129
    },
    {
        "content": "<p>Ah, please also try <code>fin_cases i</code> because there is a \"for all\".</p>",
        "id": 565653011,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767007218
    },
    {
        "content": "<p>Ah, I did that with <code>revert i; simp; constructor</code>, but <code>fin_cases</code> is shorter indeed. Again, this gives the same goal as the two times before (the previous goals also did not contain an <code>i</code>) (every time, there is a similar goal where two zeroes have been replaced by ones):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₁</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 565653392,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767007421
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/HWl6WqlmqaDm8b-aNctsZ0Wb/CoherentIso.lean\">CoherentIso.lean</a><br>\nHere is my current file</p>",
        "id": 565653564,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767007513
    },
    {
        "content": "<p>Maybe the statement is wrong. The zeroth face \"forgets\" the index <code>0</code>, while the first face \"forgets\" the index <code>1</code>: the zeroth face of this map is <code>one</code> and the first face is <code>zero</code>.</p>",
        "id": 565654829,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767008078
    },
    {
        "content": "<p>(In general, it should be possible to prove equalities in the nerve of <code>coherentIso</code> by <code>decide</code>, as it suffices to check equalities of objects (as there is always a unique map between two objects), and there is an obvious <code>DecidableEq</code> instance on objects).</p>",
        "id": 565654988,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767008162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/Proving.20equality.20in.20a.20nerve/near/565654829\">said</a>:</p>\n<blockquote>\n<p>Maybe the statement is wrong. The zeroth face \"forgets\" the index <code>0</code>, while the first face \"forgets\" the index <code>1</code>: the zeroth face of this map is <code>one</code> and the first face is <code>zero</code>.</p>\n</blockquote>\n<p>Ooooh, of course <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 565663954,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767012342
    },
    {
        "content": "<p>Yep, that was the problem. Thanks!</p>",
        "id": 565664087,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767012410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/Proving.20equality.20in.20a.20nerve/near/565654988\">said</a>:</p>\n<blockquote>\n<p>(In general, it should be possible to prove equalities in the nerve of <code>coherentIso</code> by <code>decide</code>, as it suffices to check equalities of objects (as there is always a unique map between two objects), and there is an obvious <code>DecidableEq</code> instance on objects).</p>\n</blockquote>\n<p>What is exactly the setup for calling <code>decide</code>? Because if I try to just throw that tactic somewhere in the middle of my proof, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Decidable</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">uliftYoneda</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">uliftYonedaEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₁</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">uliftYonedaEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk₀</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 565664412,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767012559
    },
    {
        "content": "<p>You may look at <a href=\"https://github.com/leanprover-community/mathlib4/blob/725c803ee924f55342e93f2c75976051ab902b54/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean#L61\">https://github.com/leanprover-community/mathlib4/blob/725c803ee924f55342e93f2c75976051ab902b54/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean#L61</a></p>",
        "id": 565665167,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767012907
    },
    {
        "content": "<p>By the Yoneda lemma, we also have decidable equality on the natural transformations to <code>coherentIso</code>. Is it a bad idea to create this instance?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"bp\">_⦋</span><span class=\"n\">n</span><span class=\"bp\">⦌</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"w\"> </span><span class=\"n\">coherentIso_equiv_fun</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"w\"> </span><span class=\"n\">yonedaEquiv</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 565672008,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767015740
    },
    {
        "content": "<p>If we go down that route, shouldn't we instead introduce a general class for \"decidable\" simplicial sets (those for which the value on each [n] are decidable) and have it derive instances for homs from standard simplices?</p>",
        "id": 565675716,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1767017258
    },
    {
        "content": "<p>Is this a rhetorical question?<br>\nI have too little experience with the typeclass system to determine the best amount of abstraction to wield here.</p>",
        "id": 565675930,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767017338
    },
    {
        "content": "<p>It’s not rethorical. I genuinely feel like we could use some general abstraction here because the coherent iso is not the only simplicial set on which we’ll want to decide that kind of low-dimensional computations/coherence, but at the same time I’m wary of making it a \"proper\" proposal because we also don’t have a lot of decidability/computability for the rest of the category-theory side of the library; I don’t think we bothered defining <code>DecidableEq</code> instances on underlying type and hom-type of many \"explicit\" small diagrams categories, and to properly leverage it on the simplicial side one would need to go around registering instances in the category-theory side as well (at least if we want to use that nerves of \"decidable categories\" are \"decidable simplicial sets\").</p>",
        "id": 565678377,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1767018293
    },
    {
        "content": "<p>Could we back up this conversation a bit to explain some more of the background. How does mathlib think about which types support <code>DecidableEq</code>? I thought the whole system was meant to be classical, so why not have this on all types?</p>",
        "id": 565692267,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1767023966
    },
    {
        "content": "<p>it's so you can <code>decide</code> things</p>",
        "id": 565693275,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767024494
    },
    {
        "content": "<p>and also so you can run code</p>",
        "id": 565693281,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767024499
    },
    {
        "content": "<p>if you want to use the classical instance you can always <code>open scoped Classical in</code></p>",
        "id": 565693364,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767024554
    },
    {
        "content": "<p>To rephrase another way: you can have a noncomputable instance for any type classically, but it is still valuable to distinguish for tactics like <code>decide</code> that actually use the computation.</p>",
        "id": 565693412,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767024577
    },
    {
        "content": "<p>and then it will be on all types</p>",
        "id": 565693414,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767024577
    },
    {
        "content": "<p>Recently, I had already added a few more <code>DecidableEq</code> instances (like <a href=\"https://github.com/leanprover-community/mathlib4/blob/cfceff41988aab4846af3b0f67e2a44b030be117/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean#L121-L123\">https://github.com/leanprover-community/mathlib4/blob/cfceff41988aab4846af3b0f67e2a44b030be117/Mathlib/AlgebraicTopology/SimplicialSet/StdSimplex.lean#L121-L123</a>). In the very draft RFC/PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/33386\">#33386</a> I show that if <code>Arrow C</code> has a <code>DecidableEq</code> instance, then the simplices of the nerve of <code>C</code> also have <code>DecidableEq</code> instances.</p>",
        "id": 565703840,
        "sender_full_name": "Joël Riou",
        "timestamp": 1767030161
    },
    {
        "content": "<p>Is <code>decide</code> a tactic that gives you a non-computable element? I've never used it so I don't know how it works.</p>\n<p>Aside: I know the mathlib/lean folks are working on improving documentation, which is great, but I still haven't the slightest idea where I should be looking for tactic documentation.</p>",
        "id": 565713616,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1767036781
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.decide#doc\">docs#Lean.Parser.Tactic.decide</a> has docs for the tactic</p>",
        "id": 565714011,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767037110
    },
    {
        "content": "<p>There is some subtlety in that you can configure where the calculation happens (elaborator, kernel, or compiler), but how I would phrase it is that if you have an instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a>, essentially an explicit procedure for computation, the tactic then uses this to derive a proof.</p>",
        "id": 565714386,
        "sender_full_name": "Chris Henson",
        "timestamp": 1767037419
    }
]