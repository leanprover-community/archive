[
    {
        "content": "<p>Given a lax monoidal functor from <code>V</code> to <code>W</code> any <code>V</code>-enriched category <code>C</code> can be turned into a <code>W</code>-enriched category by means of something Mathlib calls <code>TransportEnrichment</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A type synonym for `C`, which should come equipped with a `V`-enriched category structure.</span>\n<span class=\"sd\">In a moment we will equip this with the `W`-enriched category structure</span>\n<span class=\"sd\">obtained by applying the functor `F : LaxMonoidalFunctor V W` to each hom object.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">nolint</span><span class=\"w\"> </span><span class=\"n\">unusedArguments</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TransportEnrichment</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">LaxMonoidal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u‚ÇÅ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">C</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">LaxMonoidal</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">LaxMonoidal</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EnrichedCategory</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TransportEnrichment</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Œµ</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eId</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Œº</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eComp</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The objective of <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> is to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">laxMonoidal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LaxMonoidal</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">ofChosenFiniteProducts</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLaxMonoidal</span>\n</code></pre></div>\n<p>so that we can convert the <code>SSet</code>-enriched category of quasi-categories into <code>Cat</code>-enriched category of quasi-categories.</p>\n<p>But in fact quasi-categories form a <code>SSet</code>-enriched ordinary category and if we used an enriched ordinary category version of <code>TransportEnrichment</code> I believe we would get a <code>Cat</code>-enriched ordinary category that has a better underlying 1-category, as we explain at the introduction to the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Bicategory/CatEnriched.html\">this recently merged PR</a>.</p>\n<p>Thus does <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> or anyone want to try to extend <code>TransportEnrichment</code> to enriched ordinary categories, perhaps under the additional hypotheses mentioned in the blueprint <a href=\"https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-change-of-base.html#lem:pro-normal-monoidal\">here</a>?</p>",
        "id": 531157634,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753629221
    },
    {
        "content": "<p>Will give it a shot. <code>TransportEnrichment</code> is not yet a 2-functor, maybe I'll need that first, base on my open V-cat as a bicategory PR.</p>\n<p>1.6.10. should come with an equivalence of <code>ForgetEnrichment (TransportEnrichment C) </code> and <code>ForgetEnrichment C</code> , right?</p>",
        "id": 531204280,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1753646966
    },
    {
        "content": "<p>That's right.</p>\n<p>When <code>C : EnrichedOrdinaryCategory V</code> it comes with:</p>\n<ul>\n<li>a category structure</li>\n<li>a V-enriched category structure</li>\n<li>an equivalence between the former and <code>ForgetEnrichment</code> of the latter.</li>\n</ul>\n<p>So to define <code>TransportEnrichment C : EnrichedOrdinaryCategory W</code> I'm hoping you can provide</p>\n<ul>\n<li>the same category structure</li>\n<li><code>TransportEnrichment C</code> as the W-category structure</li>\n<li>and then the equivalence between them that you just mentioned.</li>\n</ul>",
        "id": 531651406,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753806233
    },
    {
        "content": "<p>PRed the construction at <a href=\"https://github.com/leanprover-community/mathlib4/pull/28165\">#28165</a>, it's actually just two lines. The equivalence of categories that I envisioned has my brain in knots a bit, is this what we want?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u''</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v''</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">LaxMonoidal</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EnrichedCategory</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">LaxMonoidal</span><span class=\"bp\">.</span><span class=\"n\">Œµ</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EnrichedOrdinaryCategory</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TransportEnrichment</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForgetEnrichment</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">TransportEnrichment</span><span class=\"bp\">.</span><span class=\"n\">enrichedOrdinaryCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForgetEnrichment</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">TransportEnrichment</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForgetEnrichment</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âå</span>\n<span class=\"w\">      </span><span class=\"n\">ForgetEnrichment</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TransportEnrichment</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 533606978,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754781033
    },
    {
        "content": "<p>Ah, I think I got it now...</p>",
        "id": 533608323,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754782911
    },
    {
        "content": "<p>There's multiple equivalences that are still missing: The one from your third bullet point is also not there yet.</p>",
        "id": 533608568,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754783218
    },
    {
        "content": "<p>The fourth point is implicit since we already put the category structure of <code>C</code> on the <code>TransportEnrichment F C</code>.</p>",
        "id": 533608804,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754783559
    },
    {
        "content": "<p>(This  is ready for review now, if the <code>erw</code> are okay as they are, they're the consequence of cutting corners by pushing through defeqs at some points)</p>",
        "id": 533680464,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754864853
    },
    {
        "content": "<p>This looks good to me aside from a question about the noncomputability, which I've left as a comment there.</p>",
        "id": 534270474,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1755104639
    },
    {
        "content": "<p>Could get around this by requiring the inverse function as an argument instead of the <code>Prop</code>...  Maybe <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> knows better if this matters downstream or if when we build the <code>IsEquiv</code> in any example, we'll be able to reduce the definition of the inverse anyways.</p>",
        "id": 534334018,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1755140615
    },
    {
        "content": "<p>Instead of one assumption, you may need two: 1) a family of <code>Equiv</code>, 2) the property that the <code>toFun</code> property is what you want.</p>",
        "id": 534335098,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1755141658
    },
    {
        "content": "<p>That, or the inverse function plus the property that it is the inverse function (though that would be a <code>Function.LeftInverse</code> plus a <code>Function.RightInverse</code> (don't we  have the property of a bothsided inverse?))</p>",
        "id": 534335335,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1755141896
    },
    {
        "content": "<p>Just looked at the new code. This is great. It's cool too that the computability helped you get rid of the <code>erw</code>s for reasons I don't really understand...</p>",
        "id": 534657690,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1755266226
    },
    {
        "content": "<p>Ah, no I just fixed both at the same time. It's still not 100% clean because I have to unfold <code>ForgetEnrichment.to</code></p>",
        "id": 534740059,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1755322157
    }
]