[
    {
        "content": "<p>I've been thinking about universe issues both in the specific case of <code>SSet</code> and in the more general case of doing category theory in Mathlib.</p>\n<p>Call a construction \"u-flexible\" if it relates objects in different universes, and \"u-rigid\" if it demands that the objects it relates have the same universe(s). So, for example, the type <code>Functor C D</code> is u-flexible in <code>C</code> and <code>D</code>, since <code>C</code> and <code>D</code> can live in different universes, but the hom <code>(.of C) ⟶ (.of D)</code> in <code>Cat</code> is u-rigid, since both categories must live in the same universe.</p>\n<p>Note that, in this case, the hom in <code>Cat</code> is in some sense the <strong>u-rigidification</strong> of the u-flexible <code>Functor</code>; conversely, we'll say <code>Functor</code> is a <strong>u-relaxation</strong> of hom. This isn't intended to be precise, but just to give us some terminology for the situation where two constructions are expressing the same facts but with different universe constraints.</p>\n<p>Importantly for us, <code>Equiv</code>s among types are u-flexible, and u-rigidify to <code>Iso</code>s in the category on <code>Type _</code>.</p>\n<p>But, interestingly, I can't see anything which is the u-relaxation of <code>Iso</code>s in the (1-)category on <code>Cat</code>, which would be a <code>StrictEquivalence</code>. (Am I missing it?)</p>\n<p><code>Equivalence</code> is u-flexible, but of course is 2-categorical, and does not correspond to the u-rigid <code>Iso</code>s in the 1-category <code>Cat</code> that we actually have in Mathlib.</p>\n<p>It seems like this is in some part responsible for the universe issues seen earlier when attempting to use <code>simplexIsNerve</code>: the <code>Iso</code>s we were composing all needed to relate items in the same universe, so <code>nerve (Fin _)</code> had to be lifted somehow. We didn't have the option of u-flexibly composing <code>StrictEquivalence</code>s, and then rigidifying by constructing an <code>Iso</code> out of the composite (which hopefully would happen to have the right universe parameters at either end).</p>\n<p>Therefore, we currently have to \"frontload\" the universe polymorphism with <code>ULiftFin</code> because we must rigidify <em>before</em> putting our pieces together with <code>Iso.trans</code>.</p>\n<p>But if we flip the script and put u-flexible pieces together instead...then maybe we can then just rigidify at the end, when we need to. u-rigidifying \"at the end\" (which, if your endpoints are in the right universe already, might mean \"not at all\"!) sounds like it might be nicer than having to go back and make every individual factor universe polymorphic (e.g. <code>Fin</code> → <code>ULiftFin</code>) only after we realize it's needed.</p>\n<p>This approach would of course mean getting <code>StrictEquivalence</code> right: there are at least 3 broad approaches for implementing it, with choices to make within each. (Having tried it for a bit, none of them seem to be obviously nice out of the gate...) We'd also want some API for the right sort of <code>ULift</code>ing here to help us u-rigidify on demand.</p>\n<p>The obvious red flag is that <code>StrictEquivalence</code>s are not very category-minded! But we are already implicitly using them in Mathlib \"accidentally\" simply by talking about <code>Iso</code>s in the 1-category <code>Cat</code>—we're just not <em>also</em> using them u-flexibly, unlike with other constructions.</p>",
        "id": 525607740,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1750805784
    },
    {
        "content": "<p>I could of course be wrong about this approach! Maybe there are insurmountable obstacles, or inconveniences down the line. But I thought I'd propose it with a grain of salt.</p>\n<p>The motto \"prefer constructing u-flexible relationships\" would also provide an answer to the question of how best to construct isos among types, by the way: it would tell us to prefer <code>Equiv</code>, then turn it into an <code>Iso</code> only when necessary.</p>\n<p>Ideally, we can build ways to easily interconvert between u-rigid and u-flexible constructions on the fly so that no finicky management needs to be done at all (this is what I'm secretly hoping). Moreover, it would be great to say not only \"prefer u-flexible relationships\", but \"prefer u-flexible relationships between objects in the lowest possible universe in cases where the higher universes are all obtained through <code>ULift</code>ing of some sort\". Whether this is a good idea depends on the strength of the ulifting API, I think.</p>",
        "id": 525607807,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1750805835
    },
    {
        "content": "<p>This is very interesting. It would be great if someone who has more interest handling universe issues would comment. Maybe you should repost this on the mathlib channel?</p>",
        "id": 526262739,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751195457
    },
    {
        "content": "<p>One thought: there is an analogous u-rigid notion of equivalence, namely equivalence in a bicategory. But the notion of equivalence of types isn't defined this way. Soon though the infinity-cosmos project will give us various (equivalent) notions of equivalence of quasi-categories, all of which will be u-rigid.</p>",
        "id": 526262862,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751195584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/Universe.20issues.3A.20relating.20across.20universes/near/525607740\">said</a>:</p>\n<blockquote>\n<p>This approach would of course mean getting <code>StrictEquivalence</code> right: there are at least 3 broad approaches for implementing it, with choices to make within each. (Having tried it for a bit, none of them seem to be obviously nice out of the gate...) We'd also want some API for the right sort of <code>ULift</code>ing here to help us u-rigidify on demand.</p>\n</blockquote>\n<p>If you do ask in <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4\">#mathlib4</a> then maybe also post some of your suggestions that you tried here?</p>",
        "id": 526272536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751206577
    }
]