[
    {
        "content": "<p>Is anybody working on defining equivalences of quasi-categories and proving <a href=\"https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#lem:qcat-htpy-cat-equiv\">Lemma 1.2.36</a>? I plan to formalize this with help from Dalton Sakthivadivel and we want to check that nobody is working on it to avoid effort duplication.</p>",
        "id": 491775230,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1735919199
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"580947\">@Rida Hamadani</span>; sorry to be slow.</p>\n<p>We have an experimental definition of equivalence (of sorts) that can be found <a href=\"https://emilyriehl.github.io/infinity-cosmos/docs/InfinityCosmos/ForMathlib/AlgebraicTopology/SimplicialSet/Homotopy.html#SSet.Equiv\">here</a>. The idea of it would be to specialize to a particular interval (the coherent iso) and to the case where <code>A</code> and <code>B</code> are quasi-categories. </p>\n<p>Whether it is a good idea to factor that specific notion of equivalence through this general framework is unclear to me, so feel free to ignore and start from scratch.</p>\n<p>No one is working on lemma 1.2.36 I believe so that's all yours! Good luck and let us know if there's anything you want to discuss.</p>",
        "id": 492162849,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736189378
    },
    {
        "content": "<p>I've started formalizing the first part (the equivalence) of the lemma and there are a few issues:</p>\n<p>First, <code>SSet.Homotopy</code> is missing a basic API, in particular I'll need a <code>Homotopy.symm</code> lemma. </p>\n<p>Second, I will need something of the form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"bp\">.</span><span class=\"n\">hoFunctorIso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think this could follow from Lemma 1.2.24, but please let me know if you have other ideas. </p>\n<p>There is also an issue regarding <code>functor_unitIso_comp</code> but I haven't thought about it yet.</p>\n<p>Should I start working on Lemma 1.2.24 or is someone else working on it?</p>\n<p>Note: The lemma name in the blueprint was changed to 1.3.16. The initial code can be found here: <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/134/files\">https://github.com/emilyriehl/infinity-cosmos/pull/134/files</a>.</p>",
        "id": 527845326,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752053154
    },
    {
        "content": "<p>Regarding the first issue, do you have suggestions to make working with <code>Homotopy</code> easier? For example, you can see in the draft PR that I've tried proving that it is reflexive, but honestly I have no idea how to do that using the homotopy I've constructed (maybe I should be using a different homotopy?).</p>",
        "id": 527845498,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1752053199
    },
    {
        "content": "<p>Note that the homotopy relation on arbitrary simplicial sets is reflexive, but not symmetric nor transitive in general. I have formalized the fact it is an equivalence relation when the target simplicial set is a Kan complex. For the <code>coherentIso</code> interval, the symmetry should hold though.<br>\nAbout <code>Homotopy.hoFunctorIso</code>, you cannot prove it using <code>Quotient.lift_unique'</code>: the functors <code>hoFunctor.map f</code> and <code>hoFunctor.map g</code> are not equal. You should probably use <code>NatIso.ofComponents</code>: for each <code>0</code>-simplex, the homotopy gives a \"double-sided path\" between the images by both <code>f</code> and <code>g</code> (which should give an iso in the homotopy category), and then you need to check it is natural. I have shown a similar result at <a href=\"https://github.com/joelriou/topcat-model-category/blob/e5705bfcc6944a0f8119f7b1cf717b686f39fbfd/TopCatModelCategory/SSet/KanComplexWHomotopy.lean#L143\">https://github.com/joelriou/topcat-model-category/blob/e5705bfcc6944a0f8119f7b1cf717b686f39fbfd/TopCatModelCategory/SSet/KanComplexWHomotopy.lean#L143</a></p>",
        "id": 527859180,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1752057765
    },
    {
        "content": "<p>Thanks Jo√´l! I proved that the simplicial homotopy relation is symmetric when using the <code>coherentIso</code> interval, it is line 275 of:<br>\n<a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/134/files\">https://github.com/emilyriehl/infinity-cosmos/pull/134/files</a><br>\nHowever, for some reason, now the file makes my computer crash every time I open it. I don't understand why that is happening. <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 529659493,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753000464
    },
    {
        "content": "<p>It just keeps compiling at this lemma:<br>\n<a href=\"/user_uploads/3121/CUWkSXQz61OEry9l8KhTOF1P/image.png\">image.png</a><br>\nNote that <code>rfl</code> was suggested by <code>exact?</code>, so it is supposed to close the goal correctly right?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CUWkSXQz61OEry9l8KhTOF1P/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1087x337\" src=\"/user_uploads/thumbnail/3121/CUWkSXQz61OEry9l8KhTOF1P/image.png/840x560.webp\"></a></div>",
        "id": 529660229,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753000636
    },
    {
        "content": "<p>do you have a mwe</p>",
        "id": 529663800,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753001483
    },
    {
        "content": "<p>ideas:</p>\n<ul>\n<li>try extracting the goal at <code>rfl</code> as a separate <code>theorem</code></li>\n<li>try extracting <code>source_eq</code> and <code>target_eq</code> as a separate theorem</li>\n<li>try putting <code>change _</code> before <code>simp_rw</code></li>\n<li>try putting <code>change _</code> after <code>simp_rw</code></li>\n<li>try extracting <code>homotopy</code> as a separate definition</li>\n<li>try making <code>homotopy</code> an <code>irreducible_def</code></li>\n</ul>",
        "id": 529666005,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753002002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/equivalences.20of.20quasi-categories/near/529663800\">said</a>:</p>\n<blockquote>\n<p>do you have a mwe</p>\n</blockquote>\n<p>I've tried making one, but there are far many prerequisites, sorry.</p>",
        "id": 529666506,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753002073
    },
    {
        "content": "<p>Here is my attempt for an mwe, sorry since its lengthy, but it demonstrates the issue on Lean4 web:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialCategory</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">Nerve</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">StdSimplex</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Closed</span><span class=\"bp\">.</span><span class=\"n\">FunctorToTypes</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Combinatorics</span><span class=\"bp\">.</span><span class=\"n\">Quiver</span><span class=\"bp\">.</span><span class=\"n\">ReflQuiver</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Simplicial</span><span class=\"w\"> </span><span class=\"n\">SimplicialCategory</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü©</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coev</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">mk‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isTerminalZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚¶ã</span><span class=\"mi\">0</span><span class=\"bp\">‚¶å</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">ofUniqueHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚¶ã</span><span class=\"mi\">0</span><span class=\"bp\">‚¶å</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq_const_to_zero</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Œ¥_zero_mkOfLe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Œ¥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">mkOfLe</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">fin_cases</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Œ¥_one_mkOfLe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Œ¥</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">mkOfLe</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">fin_cases</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SSet</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplicialCategory</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toEnrichedCategory</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EnrichedCategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">homEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚äó</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"bp\">‚ü®</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÅ_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÅ_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">homObjEquiv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">functorHomEquiv</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">homEquiv_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n<span class=\"w\">  </span><span class=\"n\">homEquiv_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">closed</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">rightAdj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sHomFunctor</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">A</span><span class=\"bp\">‚ü©</span>\n<span class=\"w\">    </span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">FunctorToTypes</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">yonedaEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">coev</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">I</span>\n<span class=\"w\">  </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">I</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">isoInterval</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">one</span>\n\n<span class=\"sd\">/-- The object `Œî[0]` is terminal in `SSet`.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isTerminalDeltaZero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">isTerminalZero</span><span class=\"bp\">.</span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">isTerminalZero</span><span class=\"bp\">.</span><span class=\"n\">hom_ext</span>\n\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pointIsUnit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">uniqueUpToIso</span><span class=\"w\"> </span><span class=\"n\">isTerminalDeltaZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">ofUnique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">))</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expUnitNatIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">ihom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">unitNatIso</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expPointNatIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ihom</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"mi\">ùü≠</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span><span class=\"w\"> </span><span class=\"n\">expUnitNatIso</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">pointIsUnit</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n<span class=\"w\">    </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">pointIsUnit</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">    </span><span class=\"n\">hom_inv_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pointIsUnit</span><span class=\"bp\">.</span><span class=\"n\">hom_inv_id</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre_id</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">inv_hom_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pointIsUnit</span><span class=\"bp\">.</span><span class=\"n\">inv_hom_id</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre_id</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expPointIsoSelf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sHom</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expPointNatIso</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Interval</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Interval</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sHom</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">expPointIsoSelf</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">expPointIsoSelf</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">one</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">swapFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">swap</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">nerveMap</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"bp\">.</span><span class=\"n\">swapFunctor</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">    </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">sHom</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"n\">source_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">target_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> doesn't stop compiling, note that `rfl` is suggested by `exact?`. -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"bp\">.</span><span class=\"n\">coherentIso_symm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidalClosed</span><span class=\"bp\">.</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"n\">source_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">target_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">target_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">source_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SSet</span>\n</code></pre></div>",
        "id": 529902550,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753107819
    },
    {
        "content": "<p>Adding a few lemmas fixes the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reassoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coherentIso.src_swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval.src</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">coherentIso.swap</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Interval.tgt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reassoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coherentIso.tgt_swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval.tgt</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">coherentIso.swap</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Interval.src</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reassoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coherentIso.pre_swap_app_comp_src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">MonoidalClosed.pre</span><span class=\"w\"> </span><span class=\"n\">coherentIso.swap</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">pathSpace.src</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">pathSpace.tgt</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pathSpace.src</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pathSpace.tgt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">NatTrans.comp_app_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed.pre_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">src_swap</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reassoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">attr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">coherentIso.pre_swap_app_comp_tgt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">MonoidalClosed.pre</span><span class=\"w\"> </span><span class=\"n\">coherentIso.swap</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">pathSpace.tgt</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">pathSpace.src</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pathSpace.src</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pathSpace.tgt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pathSpace</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">NatTrans.comp_app_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">MonoidalClosed.pre_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tgt_swap</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Homotopy.coherentIso_symm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h.homotopy</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidalClosed.pre</span><span class=\"w\"> </span><span class=\"n\">coherentIso.swap</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"n\">source_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h.target_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">target_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h.source_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 529910795,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753110366
    },
    {
        "content": "<p>Wow, thank you!</p>",
        "id": 529912146,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753110769
    },
    {
        "content": "<p>Should the previous behavior be reported as an issue somewhere? I feel like lean shouldn't get stuck on a proof that <code>exact?</code> suggests.</p>",
        "id": 529912362,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753110833
    },
    {
        "content": "<p>I would assume that the issue comes from <code>MonoidalClosed.pre_map</code> which may be <code>rfl</code> in case of <code>SSet</code>? but the cost of the verification that it is indeed <code>rfl</code> is extremely high!? It is unclear to me whether this is a bug.</p>",
        "id": 529917260,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753112434
    },
    {
        "content": "<p>I'm following this plan:<br>\n<span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/equivalences.20of.20quasi-categories/near/527859180\">said</a>:</p>\n<blockquote>\n<p>You should probably use <code>NatIso.ofComponents</code>: for each <code>0</code>-simplex, the homotopy gives a \"double-sided path\" between the images by both <code>f</code> and <code>g</code> (which should give an iso in the homotopy category), and then you need to check it is natural.</p>\n</blockquote>\n<p>I've searched a bit for a lemma/def that takes a double-sided path and gives out an Iso in the homotopy category, but couldn't find any. Do we have it yet?</p>\n<p>Another question: I believe the following to be the desired path, but I'm not sure how to get the \"two-sidedness\", is pre-composing with a hom <code>I ‚ü∂ I</code> that swaps the endpoints enough?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pathOfHomotopy</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_‚¶ã</span><span class=\"mi\">0</span><span class=\"bp\">‚¶å</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">homEquiv'</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">homotopy</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opposite</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">‚¶ã</span><span class=\"mi\">0</span><span class=\"bp\">‚¶å</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 530224264,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753219052
    },
    {
        "content": "<p>Could you push something to your draft PR so I can look at some code? I haven't been paying as close attention to what you've been up to as I should.</p>\n<p>In particular, I don't get what question you're asking in relation to the code block displayed here...</p>",
        "id": 530398641,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753291608
    },
    {
        "content": "<p>Pushed a new commit.<br>\nI'm asking about whether there is lemma I can use to turn this path into an <code>Iso</code> in the homotopy category, or if that's missing.</p>",
        "id": 530401834,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753292797
    },
    {
        "content": "<p>Thanks. I understand now. </p>\n<p>I think there are some missing lemmas here. The first I'd try to prove is this result from category theory:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">missing</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">√ó</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Rather than using NatIso.ofComponents I'd curry the functor H then use <code>WalkingIso.toIso</code> to get an isomorphism in the functor category.</p>\n<p>To get from your homotopy <code>h : A -&gt; sHom I B</code> to a functor <code>H</code> as above you'll need (in addition to some currying/uncurrying):<br>\n(i) : the fact that hoFunctor (nerve walkingIso) is isomorphic to walkingIso (via <code>nerveAdjunction.isIso_counit</code>) <br>\n(ii) the fact that hoFunctor preserves binary products.</p>\n<p>The latter is in a mathlib PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a>. You could sorry this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">binaryProductIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>which will be provided once that is merged.</p>",
        "id": 530409218,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753295430
    },
    {
        "content": "<p>Thank you. Would this be assuming that <code>I</code> is <code>CoherentIso</code>?</p>",
        "id": 530423086,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753300779
    },
    {
        "content": "<p>Both approaches are probably worth investigating. What I suggested is probably easier to implement. Emily's suggestion is more conceptual, but I guess that a lot of \"invisible mathematics\" will pop up (for example, once we get a functor <code>WalkingIso ‚•§ A.HomotopyCategory ‚•§ B.HomotopyCategory</code> out of an homotopy <code>H</code>, the image of the two objects of <code>WalkingIso</code> should identify to <code>hoFunctor.map f</code> and <code>hoFunctor.map g</code>, but probably not definitionally, etc).</p>",
        "id": 530520375,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753351532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"580947\">Rida Hamadani</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/equivalences.20of.20quasi-categories/near/530423086\">said</a>:</p>\n<blockquote>\n<p>Thank you. Would this be assuming that <code>I</code> is <code>CoherentIso</code>?</p>\n</blockquote>\n<p>Yes, sorry, I meant <code>I</code> as an abbreviation for <code>CoherentIso</code>. </p>\n<p><span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> is right to point out that I'm not very good (yet) and anticipating or avoiding \"invisible mathematics\". I'm hopeful that as we collectively gain formalization experience we'll figure out a way to make the conceptual proofs more easily formalizable. But in the meanwhile, if you want to pick the route the experts suggest is more expedient of course you should feel free..</p>",
        "id": 530622845,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753381676
    },
    {
        "content": "<p>I'm trying to follow Jo√´l's advice construct an isomorphism in the homotopy category from the double-sided path, but at the moment I find the homotopy category part of the library confusing so I'll appreciate some help.<br>\nAt first I thought it would be formalized this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">homotopyCategory_iso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Homotopy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">coherentIso</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">truncation</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">HomotopyCategory</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">truncation</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">HomotopyCategory</span>\n</code></pre></div>\n<p>But then I'm not sure what <code>hom</code> and <code>inv</code> are supposed to be, I'd assume <code>hom</code> would be something like <code>(mapHomotopyCategory ((truncation 2).map f)).obj</code> but then how would we construct <code>inv</code>?</p>",
        "id": 531505809,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1753761306
    },
    {
        "content": "<p>My suggestion was to use <code>NatIso.ofComponents</code> in order to construct an isomorphism between the functors induced by <code>f</code> and <code>g</code> on the homotopy categories. For any <code>0</code>-simplex <code>x</code> of <code>X</code>, we want to construct an isomorphism between <code>f(x)</code> and <code>g(x)</code> in the homotopy category of <code>Y</code>. The homotopy <code>h</code> induces a map from <code>coherentIso</code> to <code>Y</code> with sends <code>zero</code> to <code>f(x)</code> and <code>one</code> to <code>g(x)</code>. Then, the <code>hom</code> field will be given by the <code>1</code>-simplex obtained by evaluating at the unique map from <code>zero</code> to <code>one</code> in <code>WalkingIso</code> and similarly for <code>inv</code>. Checking the <code>hom_inv_id/inv_hom_id</code> relations are a little bit more tricky as it will require considering certain <code>2</code>-simplices in <code>coherentIso</code> which correspond to suitable commutative triangles.<br>\nFor the naturality with respect to a path <code>x ‚ü∂ y</code>, you may restrict to the case of a \"direct\" path given by a <code>1</code>-simplex of <code>X</code>. Then, you may have to prove a lemma in the homotopy category saying that if you have a map <code>Œî[1] ‚äó Œî[1] ‚ü∂ Y</code>, then there is an induced commutative square in the homotopy category of <code>Y</code>. (This would be similar to <a href=\"https://github.com/joelriou/topcat-model-category/blob/e5705bfcc6944a0f8119f7b1cf717b686f39fbfd/TopCatModelCategory/SSet/KanComplexWHomotopy.lean#L48C48-L48C63\">https://github.com/joelriou/topcat-model-category/blob/e5705bfcc6944a0f8119f7b1cf717b686f39fbfd/TopCatModelCategory/SSet/KanComplexWHomotopy.lean#L48C48-L48C63</a> )</p>",
        "id": 531509514,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753763457
    }
]