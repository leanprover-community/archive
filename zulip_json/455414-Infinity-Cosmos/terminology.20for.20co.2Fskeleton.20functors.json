[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and I have an open PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16781\">#16781</a> under review. One suggestion made by <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> is to introduce terminology for the co/skeleton functors. It's not clear to me which functors those should be and so I wanted to consult with creators/users like <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>.</p>",
        "id": 473484047,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727637950
    },
    {
        "content": "<p>I'm aware of two conventions in the literature, where <br>\n(i) <code>skeleton := lan (Truncated.inclusion (n := n)).op</code> and where <br>\n(ii) <code>skeleton := truncation.{u} n &gt;&gt;&gt; lan (Truncated.inclusion).op</code>.</p>\n<p>In the current draft version of the SimplicialSets file, (i) would be more useful because we prove <code>lan (Truncated.inclusion (n := n)).op</code> is a fully faithful left adjoint, during which it might be useful to have a name for that functor. </p>\n<p>But I suspect definition (ii) would be more useful to folks interacting with simplicial sets in Mathlib. </p>\n<p>What do others think? (Whatever we choose, \"coskeleton\" should be defined dually.)</p>",
        "id": 473484277,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> should probably weigh in here as well, since he has been working on skeleton functors.</p>",
        "id": 473484322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638153
    },
    {
        "content": "<p>Note the current version of mathlib actually uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/SimplicialObject.html#CategoryTheory.SimplicialObject.sk\">sk</a> to refer to the functor I've called \"truncation\" above. I think this should be called \"truncation\" and so far no one has objected ;)</p>",
        "id": 473484405,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638210
    },
    {
        "content": "<p>You're right, it should indeed be called truncation. As I understand it, Jack has been working on defining the skeleton in terms of subsets of the types of n-simplices of a given simplicial set.</p>",
        "id": 473484493,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638284
    },
    {
        "content": "<p>But I think his result is again a full blown simplicial set, not a truncated one.</p>",
        "id": 473484508,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/455414-Infinity-Cosmos/topic/terminology.20for.20co.2Fskeleton.20functors/near/473484493\">said</a>:</p>\n<blockquote>\n<p>As I understand it, Jack has been working on defining the skeleton in terms of subsets of the types of n-simplices of a given simplicial set.</p>\n</blockquote>\n<p>That's right, so I have no overlap with <a href=\"https://github.com/leanprover-community/mathlib4/pull/16781\">#16781</a> just yet.</p>",
        "id": 473484591,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1727638366
    },
    {
        "content": "<p>Using lan/ran is indeed convenient as that gives you the adjunctions for free.</p>",
        "id": 473484707,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638495
    },
    {
        "content": "<p>Do you have a terminological preference, though? Should <code>sk n</code> be an endofunctor of SSet or a functor from SSet.truncation n to SSet?</p>",
        "id": 473484717,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638505
    },
    {
        "content": "<p>Oh good question, I think it should be from <code>SSet</code> to itself.</p>",
        "id": 473484735,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638526
    },
    {
        "content": "<p>This was my thinking too. Then e.g. <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> could prove that under certain conditions <code>X</code> is n-skeletal meaning the counit map <code>sk n X -&gt; X</code> is an iso.</p>",
        "id": 473484802,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638564
    },
    {
        "content": "<p>But I think that giving some name to the functors from the truncated categories is also worthwhile? I guess \"inductive\" and \"coinductive\" are off the table ? :)</p>",
        "id": 473484871,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638612
    },
    {
        "content": "<p>We also have the adjunction <code>sk n -| cosk n</code> as endofunctors of SSet. This can be useful independently of the adjucntions above.</p>",
        "id": 473484875,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638621
    },
    {
        "content": "<p>In the literature both functors are called <code>sk n</code> with context to disambiguate ;)</p>",
        "id": 473484900,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638649
    },
    {
        "content": "<p>I guess the same can be done here... one in the <code>SSet</code> namespace and one in the <code>SSet.Truncated</code> namespace.</p>",
        "id": 473484917,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638679
    },
    {
        "content": "<p>The latter should probably be protected.</p>",
        "id": 473484959,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1727638687
    },
    {
        "content": "<p>That's a good idea.</p>",
        "id": 473484968,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727638694
    },
    {
        "content": "<p>Though could you explain exactly what \"protected\" means?</p>",
        "id": 473485661,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727639366
    },
    {
        "content": "<p>the <code>protected</code> keyword on a declaration means it can't be used un-namespaced, <code>open</code> ignores it</p>",
        "id": 473485681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727639397
    },
    {
        "content": "<p>this can prevent name clashes if you <code>open</code> lots of things</p>",
        "id": 473485742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727639420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/455414-Infinity-Cosmos/topic/terminology.20for.20co.2Fskeleton.20functors/near/473484917\">said</a>:</p>\n<blockquote>\n<p>I guess the same can be done here... one in the <code>SSet</code> namespace and one in the <code>SSet.Truncated</code> namespace.</p>\n</blockquote>\n<p>I've just pushed a revision to <a href=\"https://github.com/leanprover-community/mathlib4/pull/16781\">#16781</a> implementing this suggestion in case anyone wants to check it out (in the SimplicialSet file).</p>",
        "id": 473486597,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727640227
    },
    {
        "content": "<p>If it is applicable, I would suggest definitions of (co)skeleton should be done for simplicial objects in a general category (under the suitable typeclass assumptions under which <code>lan/ran</code> are defined) rather than for <code>SSet</code> only.<br>\n(Also, in the case of simplicial sets, the notion of split simplicial objects <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/SplitSimplicialObject.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/SplitSimplicialObject.html</a> may be helpful in a detailed analysis of the skeleton, using the notion of nondegenerate simplices.)</p>",
        "id": 473653676,
        "sender_full_name": "Joël Riou",
        "timestamp": 1727687115
    },
    {
        "content": "<p>Interesting. <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> is this the sort of thing you've been working on/with? </p>\n<p>I'm used to the term \"split simplicial object\" referring to (augmented) simplicial objects that extend along canonical maps  <code>Δ → Δ^+ → Δ^⊥</code> or  <code>Δ → Δ^+ → Δ^⊤</code>. Sometimes these maps are called \"extra degeneracies\". See eg <a href=\"https://kerodon.net/tag/04S6\">Kerodon</a>.</p>",
        "id": 473725930,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727701966
    },
    {
        "content": "<p>I have also formalized extradegeneracies <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/ExtraDegeneracy.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicTopology/ExtraDegeneracy.html</a> (this is used in the formalization of group cohomology), but I was using \"split\" in the sense of <a href=\"https://stacks.math.columbia.edu/tag/017O\">https://stacks.math.columbia.edu/tag/017O</a><br>\nAll simplicial sets are split in that sense, and it seems to me that the skeletal filtration of a split simplicial object can be described easily in terms of a splitting.</p>",
        "id": 473753341,
        "sender_full_name": "Joël Riou",
        "timestamp": 1727706770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> this is closer to what I've been working on. I've been formalising most of <a href=\"https://kerodon.net/tag/0010\">https://kerodon.net/tag/0010</a> (on the skeletal filtration). In particular I need <a href=\"https://kerodon.net/tag/001B\">this construction</a></p>",
        "id": 473784619,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1727712840
    }
]