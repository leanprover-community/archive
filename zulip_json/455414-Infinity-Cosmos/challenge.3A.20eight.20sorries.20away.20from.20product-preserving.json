[
    {
        "content": "<p>A long standing goal is to show that the functor <code>hoFunctor : SSet ⥤  Cat</code> preserves binary products. We are now eight sorries away from this result, and the corresponding result for the restriction <code>hoFunctor : QCat ⥤ Cat</code>. This will be used to construct the 2-category of quasi-categories, modulo a major theorem from <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>.</p>",
        "id": 519225133,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689066
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"455414\" href=\"/#narrow/channel/455414-Infinity-Cosmos/topic/eight.20sorries.20away.20from.20a.20product-preserving.20functor\">#Infinity-Cosmos &gt; eight sorries away from a product-preserving functor</a> by <span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span>.</p>",
        "id": 519225356,
        "sender_full_name": "Notification Bot",
        "timestamp": 1747689130
    },
    {
        "content": "<p>The eight sorries together with documentation can be found in the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a>. I'm hoping to challenge some folks here, both past contributors to the infinity cosmos project and other lurkers to help finish them.</p>",
        "id": 519225392,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689140
    },
    {
        "content": "<p>The first is a component of a natural isomorphism that someone could also try to construct:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The Yoneda embedding from the `SimplexCategory` into simplicial sets is naturally</span>\n<span class=\"sd\">isomorphic to `SimplexCategory.toCat ⋙ nerveFunctor` with component isomorphisms</span>\n<span class=\"sd\">`Δ[n] ≅ nerve (Fin (n + 1))`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 519225521,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689181
    },
    {
        "content": "<p>The second observes that the triple composite defined by <code>nerveAdjunction</code> preserves binary products because it is naturally isomorphic to the right adjoint of that adjunction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Via the whiskered counit (or unit) of `nerveAdjunction`, the triple composite</span>\n<span class=\"sd\">`nerveFunctor ⋙ hoFunctor ⋙ nerveFunctor` is naturally isomorphic to `nerveFunctor`.</span>\n<span class=\"sd\">As `nerveFunctor` is a right adjoint, this functor preserves binary products.</span>\n<span class=\"sd\">Note Mathlib does not seem to recognize that `Cat.{v, u}` has binary products. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">nerveHoNerve</span><span class=\"bp\">.</span><span class=\"n\">binaryProductIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerveFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Note this might be easier to prove in the form </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">PreservesLimitsOfShape</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">WalkingPair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerveFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>in which case the instance <code>CategoryTheory.Limits.instIsIsoProdComparison</code> should be able to infer this result.</p>",
        "id": 519226145,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689369
    },
    {
        "content": "<p>The third sorry follows from the first two results as well as the following proof, which needs golfing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- This proof can surely be golfed. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">binaryProductNerveIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerveFunctor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prodComparison_comp</span>\n<span class=\"w\">        </span><span class=\"n\">nerveFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nerveFunctor_obj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"bp\">.</span><span class=\"n\">of_isIso_fac_left</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"bp\">.</span><span class=\"n\">of_isIso_fac_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison_comp</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isIso_of_fully_faithful</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span>\n\n<span class=\"sd\">/-- By `simplexIsNerve` this is isomorphic to a map of the form</span>\n<span class=\"sd\">`hoFunctor.binaryProductNerveIsIso`. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">binarySimplexProductIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 519226321,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689431
    },
    {
        "content": "<p>The fourth and fifth sorries are two instances of the same proof, up to symmetry. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Modulo composing with a symmetry on both ends, the natural transformation</span>\n<span class=\"sd\">`prodComparisonNatTrans hofunctor Δ[m]` is a natural transformation between cocontinuous</span>\n<span class=\"sd\">functors whose component at `X : SSet` is `prodComparison hoFunctor X Δ[m]`. This makes use</span>\n<span class=\"sd\">of cartesian closure of both `SSet.{u}` and `Cat.{u,u}` to establish cocontinuity of the</span>\n<span class=\"sd\">product functors on both categories.</span>\n\n<span class=\"sd\">Using the colimit `Presheaf.colimitOfRepresentable (C := SimplexCategory) X` this reduces to</span>\n<span class=\"sd\">the result proven in `hoFunctor.binarySimplexProductIsIso`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">binaryProductWithSimplexIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">Xcolim</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Presheaf</span><span class=\"bp\">.</span><span class=\"n\">colimitOfRepresentable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULiftHom</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- The natural transformation `prodComparisonNatTrans hofunctor X` is a natural</span>\n<span class=\"sd\">transformation between cocontinuous functors whose component at `Y : SSet` is</span>\n<span class=\"sd\">`prodComparison hoFunctor X Y`. This makes use of cartesian closure of both `SSet.{u}`</span>\n<span class=\"sd\">and `Cat.{u,u}` to establish cocontinuity of the product functors on both categories.</span>\n\n<span class=\"sd\">/-- The natural transformation `prodComparisonNatTrans hofunctor X` is a natural</span>\n<span class=\"sd\">transformation between cocontinuous functors whose component at `Y : SSet` is</span>\n<span class=\"sd\">`prodComparison hoFunctor X Y`. This makes use of cartesian closure of both `SSet.{u}`</span>\n<span class=\"sd\">and `Cat.{u,u}` to establish cocontinuity of the product functors on both categories.</span>\n\n<span class=\"sd\">Using the colimit `Presheaf.colimitOfRepresentable (C := SimplexCategory) Y` this reduces to</span>\n<span class=\"sd\">the result proven in `hoFunctor.binaryProductWithSimplexIsIso`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">binaryProductIsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">):</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prodComparison</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"w\"> </span><span class=\"n\">SimplicialObject</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">Ycolim</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Presheaf</span><span class=\"bp\">.</span><span class=\"n\">colimitOfRepresentable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULiftHom</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prodComparisonNatTrans</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>UPDATE: The sixth sorry was related to a universe issue in the above that has now been fixed.</p>",
        "id": 519226555,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689496
    },
    {
        "content": "<p>The seventh and eighth sorries are independent of the above, and aim to show that the inclusion of the full subcategory of quasi-categories preserves binary products. (In this case, it preserves all products, though that is not true of the nerve functor.) These should be direct verifications. Perhaps someone like <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> or <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> have proven this already?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">QCat is the category of quasi-categories defined as the full subcategory of the category of `SSet`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ObjectProperty</span><span class=\"bp\">.</span><span class=\"n\">FullSubcategory</span><span class=\"w\"> </span><span class=\"n\">Quasicategory</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ObjectProperty</span><span class=\"bp\">.</span><span class=\"n\">FullSubcategory</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"w\"> </span><span class=\"n\">Quasicategory</span>\n\n<span class=\"sd\">/-- As objects characterized by a right lifting property, it is straightforward to directly</span>\n<span class=\"sd\">verify that. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"bp\">.</span><span class=\"n\">hasBinaryProducts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- The construction above should form the product in the category `SSet` and verify that this</span>\n<span class=\"sd\">object is a quasi-category. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"bp\">.</span><span class=\"n\">inclusionPreservesBinaryProducts</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">PreservesLimitsOfShape</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">WalkingPair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ObjectProperty</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">Quasicategory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 519227124,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747689707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/519227124\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- As objects characterized by a right lifting property, it is straightforward to directly</span>\n<span class=\"sd\">verify that. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"bp\">.</span><span class=\"n\">hasBinaryProducts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasBinaryProducts</span><span class=\"w\"> </span><span class=\"n\">QCat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The relevant API to show this is <code>ClosedUnderLimitsOfShape</code> in <code>Limits.FullSubcategory</code>.</p>",
        "id": 519232546,
        "sender_full_name": "Joël Riou",
        "timestamp": 1747691610
    },
    {
        "content": "<p>Update: <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> solved the universe error, so now only seven sorries remain. I've updated the code above to reflect the current state of the pull request.</p>",
        "id": 520686847,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748357215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Just checking, is it alright to push directly to <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a>? I have some straightforward golfing, and hopefully a proof of the first sorry soon. :)</p>",
        "id": 521376013,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1748641509
    },
    {
        "content": "<p>Excellent. Absolutely. Please do!</p>",
        "id": 521376636,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748641908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> this is really great, congrats! Do you want to keep your code as part of this PR or break it out into something separate? Either works for me. If it's easiest to keep it here, we can start cleaning things up and trying to put them in their correct place.</p>\n<p>In particular, I think it would be good to ask the question on Zulip about the best way to build isomorphisms in Type (or Type-valued functors) from equivalences of types. I'm sure this has come up before and it would be good to ask around about what others have seen. Do you want to ask a question of this nature on the mathlib4 thread (or some general thread if you have another idea) and point to some of your code as an example? If you don't mind, @ me so I'll see it.</p>",
        "id": 521438883,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748694789
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> (or anyone else), if you're looking for something else to do, here's a place where I could use some help.</p>\n<p>In <a href=\"https://github.com/emilyriehl/infinity-cosmos/blob/main/InfinityCosmos/ForMathlib/InfinityCosmos/Goals.lean\">this file</a> in the infinity-cosmos repository, we apply the results of PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a> and the construction of the strict bicategory of a Cat-enriched category to construct the 2-category of quasi-categories. But there is one more result we need: namely that the homotopy category functor preserves the terminal object. I tried to prove this, using the result that <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> just proved, but got stuck (update: at just one) at a few places:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">iso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">mapIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simplexIsNerve</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span><span class=\"w\"> </span><span class=\"n\">nerveFunctorCompHoFunctorIso</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">finOneTerminalIso'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toCatHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">star</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toCatHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fromPUnit</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">hom_inv_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">ext₀</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">inv_hom_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">ofUniqueHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">star</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">punit_ext'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">finOneTerminalIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⊤_</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">terminalIsoIsTerminal</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">terminalIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">mapIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">terminalIsoIsTerminal</span><span class=\"w\"> </span><span class=\"n\">isTerminalDeltaZero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span><span class=\"w\"> </span><span class=\"n\">iso</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span>\n<span class=\"w\">    </span><span class=\"n\">finOneTerminalIso'</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span><span class=\"w\"> </span><span class=\"n\">finOneTerminalIso</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"c1\">--- Why can't I just exact this?</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">preservesTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreservesLimit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">preservesTerminal_of_iso</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">terminalIso</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Update: I made some progress with the universe errors and now am a lot closer. Can anyone help?</p>",
        "id": 521449811,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748703712
    },
    {
        "content": "<p>If there is a more efficient way to do this that would also be appreciated. This code is pretty ugly!</p>",
        "id": 521449903,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748703754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/521438883\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> this is really great, congrats! Do you want to keep your code as part of this PR or break it out into something separate?</p>\n</blockquote>\n<p>I'm fine with either too! On the one hand these definitely belong somewhere else, but on the other hand splitting PRs can be, well, kind of a pain—especially because the home is not clear for some of these, so discussion might be needed. <code>OrderHom.isoFunctor</code> needs the category instance on <code>Type u</code>, which leads <code>#find_home!</code> to list a bunch of mostly unrelated files where the imports happen to be available. Or, should it just be an equivalence of types, and we leave the isomorphism to be built on the fly? Etc.</p>\n<p>If we can leave it here with a TODO (and I'll relocate them once this is discussed) that might be easiest! :)</p>\n<blockquote>\n<p>In particular, I think it would be good to ask the question on Zulip about the best way to build isomorphisms in Type (or Type-valued functors) from equivalences of types.</p>\n</blockquote>\n<p>Just to be clear, do you mean whether we should in fact be defining and composing isomorphisms in <code>Type _</code> in the first place (as opposed to defining <code>Equiv</code>s, then using <code>Equiv.toIso</code> only when necessary after composing those as <code>Equiv</code>s), or the thing about whether to use <code>RepresentableBy</code>? (Or something else?) (There are a lot of questions I have at this stage, so I could ask a lot of things! <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span>)</p>\n<p>(If there's some doubt about using isomorphisms in Type in the first place over equivs, I'll hold off on asking about locations for <code>OrderHom.isoFunctor</code> for a moment, in case it shouldn't exist!)</p>\n<blockquote>\n<p>In <a href=\"https://github.com/emilyriehl/infinity-cosmos/blob/main/InfinityCosmos/ForMathlib/InfinityCosmos/Goals.lean\">this file</a> in the infinity-cosmos repository [...]</p>\n</blockquote>\n<p>Ooh, interesting. I'll take a look!</p>",
        "id": 521607872,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1748816394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span>  I just pushed some code Dom and I wrote which you can find in the infinity-cosmos repository to  <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a>. </p>\n<p>We had to build a lot of infrastructure about terminal categories in arbitrary universes to get everything to work. In particular, this uses a higher universe version of your <code>SimplexIsNerve</code> that we left with a sorry. </p>\n<p>It would be great to find out that all of this is unnecessary: i.e., if we can check that <code>hoFunctor</code> preserves the terminal object at universe level zero and then conclude that it does so at any universe level. If you can figure out how to do that let me know and I'll gladly cut much of what we just added!</p>",
        "id": 521854068,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748902550
    },
    {
        "content": "<p>In the meanwhile, if you want to get zulip's advice on any of your code, please go ahead. In particular, if you want to ask about some of the questions you had in comments, that would be great.</p>",
        "id": 521854255,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1748902635
    },
    {
        "content": "<p>(Just wanted to mention that I've been busy the past day or two and might continue to be busy for the next day or two, but am still thinking about this, and will post some thoughts when I get the chance :) )</p>",
        "id": 522425120,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1749061682
    },
    {
        "content": "<p>Great! In the meanwhile, an update: a new approach to the preservation of terminal objects is now in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25459\">#25459</a> (suggested by <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>). Along the way we're finally PRing stuff about terminal objects in simplicial sets developed by <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> and <span class=\"user-mention\" data-user-id=\"754695\">@Zeyi Zhao</span> to mathlib. </p>\n<p>I still think we might need some generalization of your <code>simplexIsNerve</code>to arbitrary universe levels so that issue (plus the remaining sorries here) is wide open.</p>",
        "id": 522603541,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749133121
    },
    {
        "content": "<p>Update: because of the new PR from fork infrastructure, the four PRs associated with this challenge now have new numbers: <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/25781\">#25781</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/25782\">#25782</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/25784\">#25784</a>.</p>\n<p>(Aside, if you are confused about how to move exiting PRs to a newly created mathlib fork, I can tell you how I did this. Once I had a few questions answered, it wasn't so difficult.)</p>",
        "id": 523960971,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749826027
    },
    {
        "content": "<p>A disadvantage of the new set up is that it's a little more complicated to contribute collaboratively to PRs. Either </p>\n<p>(i) I can add you as a collaborator on my mathlib fork, or<br>\n(ii) you can make a PR to one of these branches on my mathlib fork.</p>\n<p>I don't really understand how (ii) works but either way I want to make it clear that I'd very much welcome further golfing, edits, or contributions of any sort. So let me know if you want to try to change something on them and we'll figure out how to make it work.</p>",
        "id": 523961318,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749826147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/522425120\">said</a>:</p>\n<blockquote>\n<p>busy for the next day or two</p>\n</blockquote>\n<p>Well...turns out I was busy for almost three weeks! <span aria-label=\"face with spiral eyes\" class=\"emoji emoji-1f635-200d-1f4ab\" role=\"img\" title=\"face with spiral eyes\">:face_with_spiral_eyes:</span> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  But, I'm a lot more (reliably) free now. :)</p>\n<p>In the past couple weeks I've had some thoughts on managing universe issues in category theory and in this project specifically.</p>\n<p>I'm going to put more extensive thoughts in new topics. But tl;dr:</p>\n<ul>\n<li>Some relationships like <code>Functor</code> and <code>Equivalence</code> do not demand the universe levels of the things they relate are the same, but some, e.g. <code>Iso</code>s, do. We're missing a \"u-flexible\" analogue of <code>Iso</code>s in Mathlib's 1-cat <code>Cat</code>, where <code>Iso</code>s correspond to strict equivalences between categories, not <code>Equivalence</code>s. This forces us to solve universe issues <em>before</em> composing instead of after, and the latter might be smoother. (<a class=\"stream-topic\" data-stream-id=\"455414\" href=\"/#narrow/channel/455414-Infinity-Cosmos/topic/Universe.20issues.3A.20relating.20across.20universes/with/525607740\">#Infinity-Cosmos &gt; Universe issues: relating across universes</a>)</li>\n<li>Some relevant constructions like <code>Δ[n]</code> are universe polymorphic, but nonetheless get all their data from a single low universe level. We could maybe create automation to ulift definitions when possible and then apply this ulifting appropriately during composition. (<a class=\"stream-topic\" data-stream-id=\"455414\" href=\"/#narrow/channel/455414-Infinity-Cosmos/topic/Universe.20issues.3A.20ulifting.20from.20low-u.20data/with/525610375\">#Infinity-Cosmos &gt; Universe issues: ulifting from low-u data</a> )</li>\n</ul>\n<p>Disclaimer: I say some very basic things in those messages! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> This is because I'm still familiarizing myself with the situation, and am writing in a way that I myself can understand. So please assume that any very basic statement is directed only at myself! <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 525606741,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1750805112
    },
    {
        "content": "<p>Note: I've just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/26415\">#26415</a> which should split out the basic <code>OrderHom</code> definitions into a small PR. :)</p>",
        "id": 525795342,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1750888062
    },
    {
        "content": "<p>I'm trying to get <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> ready for review. So in particular, it would be helpful if <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> could fill me in on what code should stay here vs what has been/is being migrated elsewhere. In particular, I can't find your original <code>simplexIsNerve</code> nor do I remember the status of our attempts to generalize to an arbitrary universe level.</p>\n<p>There's also something broken that <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> wrote that I haven't figured out how to fix. There used to be an import of a file <code>AlgebraicTopology.SimplicialSet.ColimitOfRepresentable</code> that I cut because it doesn't seem to exist. But now there seems to be some difficulty in applying the general <code>CategoryTheory.Presheaf.colimitOfRepresentable</code> in the case of a simplicial set <code>X</code> because Lean fails to unify <code>SSet</code> with a type of presheaves.</p>",
        "id": 530399611,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753291926
    },
    {
        "content": "<p>Okay—I will do these things tomorrow! :)</p>",
        "id": 530471960,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1753330056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/530471960\">said</a>:</p>\n<blockquote>\n<p>Okay—I will do these things tomorrow! :)</p>\n</blockquote>\n<p>Thanks! LMK how it goes...</p>",
        "id": 530622187,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753381470
    },
    {
        "content": "<p>Alright, I've done some work on this!</p>\n<ul>\n<li>I've removed the <code>OrderHom</code> functionality being upstreamed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26415\">#26415</a> (and effectively based the PR on that one, which I hope will be merged soon)</li>\n<li>I've also restored <code>simplexIsNerve</code> (as far as I'm aware, it's the original—was there another?), and included the <code>ULiftFin</code> version for now.</li>\n<li>and I've golfed some things, as well as cleaned up the <code>ULiftFin</code> API a bit (but without major changes).</li>\n</ul>\n<p>I've made <a href=\"https://github.com/emilyriehl/mathlib4/pull/1\">a PR to your fork</a>; would it be alright to gain write access and push directly to the branch in future? :) (Or, if you prefer to receive changes in PR form, that's of course fine with me too!)</p>",
        "id": 530696307,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1753421900
    },
    {
        "content": "<p>Re: the status of generalizing to arbitrary universe levels, there were three things that might be relevant (iirc):</p>\n<ul>\n<li>It could be nice to move from <code>ULfitHom &lt;| ULift C</code> to <code>ULiftCat C</code>. I'd be happy to do the work to change the API here if desired; I'd like to ask what people think in #mathlib4.</li>\n<li>I've also been working on finding a good <code>StrictEquivalence</code> definition. This would give us a u-flexible means of composing things which are morally isomorphisms in <code>Cat</code>, but which can't be so due to the u-rigidity of <code>Cat</code> isos. Then we could compose a string of u-flexible <code>StrictEquivalence</code>s whose start and end are in the same universe, and put <em>that</em> in <code>Cat</code>, maybe(??) letting us get rid of <code>ULiftFin</code>.</li>\n<li>I'm interested in figuring out how to move between universes in general! The error you mention above is actually (potentially) another example, as it happens. <code>Presheaf.colimitOfRepresentable</code> makes a choice that constrains a universe in its argument to be smaller than necessary. (If it were too big, that would be fine—just ulift.) Generalizing this universe parameter in the original file seems plausible, but then the <em>whole</em> file needs to be reworked (starting all the way up at <code>functorToRepresentables</code>), <code>uliftFunctors</code> need to be inserted everywhere, potential pitfalls await, etc.</li>\n</ul>\n<p>I've found that <code>ULift</code>ing in general suffers from a number of unfortunate properties, such as <code>ULift.{u,u}</code> not being the identity, <code>ULift.{v} &lt;| ULift.{w} A</code> not being defeq to <code>ULift.{max v w} A</code>, the implications for manipulating terms of these types, etc. (since it's really just a one-field structure). So, one has to rely on the \"algebraic\" properties surrounding <code>ULift</code>s (if they can be called that): the properties of equivs, equivalences, functors, etc.</p>\n<p>I'd love to figure out some sort of automation as hinted at in <a class=\"stream-topic\" data-stream-id=\"455414\" href=\"/#narrow/channel/455414-Infinity-Cosmos/topic/Universe.20issues.3A.20ulifting.20from.20low-u.20data/with/525610375\">#Infinity-Cosmos &gt; Universe issues: ulifting from low-u data</a>, but I'm not sure how it would even work yet in principle.</p>\n<p>I'll post about <code>StrictEquivalence</code> and <code>ULiftCat</code> in #mathlib4 tomorrow or Saturday. :)</p>",
        "id": 530699297,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1753423649
    },
    {
        "content": "<p>I'm also a little confused by lean's refusal to see <code>X</code> as something of type <code>?_ᵒᵖ ⥤ Type ?u</code> after <code>Presheaf.colimitOfRepresentable</code>. If I try to recreate the issue with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>it shows no signs of trouble.</p>\n<p>If I add a coercion of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">id</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>the application type mismatch for <code>X</code> disappears, and is replaced by a failure to synthesize a certain <code>Category</code> (which I believe, in this case, hints at the deeper universe issue I mentioned above).</p>\n<p>I wonder if the application mismatch wouldn't have occurred if the typeclass synthesis would succeed, or something strange like that? (If so, I'd suspect that something to do with backtracking and/or metavariable synthesis order/postponement was to blame...)</p>",
        "id": 530700317,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1753424179
    },
    {
        "content": "<p>Invite sent. Let me look at all of this now.</p>",
        "id": 530948943,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1753537490
    },
    {
        "content": "<p>An update for <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> and anyone else who might be interested. After bumping mathlib (with the update from the now merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/26415\">#26415</a>) I copied across a few definitions and one sorried theorem from <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/27576\">#27576</a> and then was finally able to fix the rest of our proof at a generic universe level! See the current version of <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a>.</p>",
        "id": 532369918,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1754078010
    },
    {
        "content": "<p>It would be more natural to just base <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27576\">#27576</a> but I don't actually know how to do this...</p>\n<p>Anyway we're nearly there. If folks want to help with the golfing that would be appreciated.</p>",
        "id": 532369969,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1754078037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/532369969\">said</a>:</p>\n<blockquote>\n<p>It would be more natural to just base <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27576\">#27576</a></p>\n</blockquote>\n<p>I think it's fine to just merge the branch of <a href=\"https://github.com/leanprover-community/mathlib4/pull/27576\">#27576</a> and then indicate the dependence in the PR! :) I've pushed this change (but can't edit the PR description) along with some minor golfing and small modifications (but happy to revert if you'd rather not, after all).</p>",
        "id": 533020302,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1754452820
    },
    {
        "content": "<p>Updated the description. Let me know if you'd like me to add/change anything.</p>",
        "id": 533099908,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1754485971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> I attempted to fix an unused argument error by cutting the <code>[Category.{v} C]</code> from </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The type-level equivalence between `C` and `ULiftHom (ULift C)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ULiftHomULiftCategory</span><span class=\"bp\">.</span><span class=\"n\">objEquiv</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"n\">objEquiv</span>\n</code></pre></div>\n<p>Since this is an equivalence between underlying type aliases, it makes sense that the category instance isn't needed. But does dropping the universe variable v mess something up?</p>",
        "id": 533119646,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1754491645
    },
    {
        "content": "<p>Oops, sorry, I indeed shouldn’t have left <code>[Category.{v} C]</code> in there in the first place! It should be fine, but if that does somehow cause any universe issues, they ought to be fixed without touching that <code>def</code> anyway.</p>",
        "id": 533140537,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1754497518
    },
    {
        "content": "<p>(Huh, there's a weird error involving the cache. I've merged master, but don't see anything particularly cache-y or dependency related in the new commits...I guess we'll see if it happens again!)</p>",
        "id": 533149083,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1754500596
    },
    {
        "content": "<p>By the way: if, in the PR description, below the <code>---</code>, you format the dependence as</p>\n<div class=\"codehilite\" data-code-language=\"null\"><pre><span></span><code>- [ ] depends on: #27576\n</code></pre></div>\n<p>(without code fencing) the dependent-issues bot will pick it up, and keep the PR labeled appropriately!</p>",
        "id": 533150079,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1754501026
    },
    {
        "content": "<p>Thanks. I think it's finally ready for review (modulo the dependency)!</p>",
        "id": 533158275,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1754504659
    },
    {
        "content": "<p>Whelp the dreaded PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> is broken again with a universe error I can't fix. I've just pushed a commit that I hope clarifies exactly where the <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780/commits/2c6b83db63c001d1bea5fbf48e0d8928913fa6b1\">problem lies</a></p>",
        "id": 537370215,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1756850358
    },
    {
        "content": "<p>This first thing that seems weird is in the <code>SimplexCategory/Defs.lean</code> file where we have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Homs in `SimplexCategory` are equivalent to functors between finite linear orders, with</span>\n<span class=\"sd\">codomain lifted to a higher universe. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">homEquivFunctorULiftRight</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">homEquivOrderHom</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">OrderHom</span><span class=\"bp\">.</span><span class=\"n\">equivFunctor</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">ULiftHomULiftCategory</span><span class=\"bp\">.</span><span class=\"n\">equivCongrLeft</span>\n</code></pre></div>\n<p>In particular I can't replace the universe level 0 by a generic universe level <code>u</code> even though I think <code>ULiftHomULiftCategory.equivCongrLeft</code> should let me do this.</p>",
        "id": 537370446,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1756850478
    },
    {
        "content": "<p>I suspect this is the reason why the proof shown here only works when the first universe level of ULiftFin is 0:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The n-simplex is isomorphic to the nerve of the ordinal category `ULiftFin (n + 1)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerveULiftFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toIso</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">objEquiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">homEquivFunctorULiftRight</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The n-simplex is isomorphic to the nerve of the ordinal category `ULiftFin (n + 1)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerveULiftFin'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The second sorried statement is the one we actually need in the <code>NerveAdjunction</code> file.</p>",
        "id": 537370611,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1756850560
    },
    {
        "content": "<p>Got pinged for this thread, and while unfortunately I have very little time in general this week, I was curious! The issue comes from the following chain of facts:</p>\n<ul>\n<li>the category instance for <code>ULiftFin</code> comes from <code>ULiftHom.category</code> applied to the category instance for <code>ULift (Fin _)</code></li>\n<li>the category instance for <code>ULift (Fin _)</code> comes from the <code>SmallCategory</code> instance on it (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder.smallCategory#doc\">docs#Preorder.smallCategory</a>) (which in turn comes from the <code>Preorder</code> instance on <code>ULift</code>ed <code>Preorder</code>s, which is fine as-is and not an obstacle)</li>\n<li>The universe level for objects in small categories is by definition the same as the universe level for arrows; so by lifting the objects in <code>Fin _</code> to <code>u</code> and then relying on its small category instance, we've inadvertently lifted the arrows in the category <code>ULift.{u} (Fin _)</code> to <code>u</code> as well!</li>\n</ul>\n<p>In general, maybe we should not get category instances on <code>Preorder</code>s from small categories—is there a good reason why the library is set up this way? Currently the <code>Hom U V</code> is <code>ULift (PLift (U ≤ V))</code>, but we don't need the outer <code>ULift</code>. (Is there a better instance elsewhere? I notice this one has lower priority.)</p>\n<p>In the meantime, I wonder if supplying a different instance just for <code>ULiftFin</code> somehow would be acceptable; if we do so by writing e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Don't lift arrows</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">uliftCategory</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n</code></pre></div>\n<p>in <code>Mathlib.CategoryTheory.ComposableArrows</code>, it does get the job done! (Though I'm not sure this is exactly what we should do; there are many ways to \"fix\" this, and this is just a quick proof of concept.)</p>",
        "id": 537394932,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756870812
    },
    {
        "content": "<p>Can we make the category instance on preorders a <code>Category.{v, u}</code> (with universe parameters in both arguments) instead of <code>SmallCategory.{u}</code> (which is <code>Category.{u, u}</code>)? Or is that a bad idea since it leads to multiple category instances (they're in different universes so it's probably fine?)</p>",
        "id": 537462446,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756901725
    },
    {
        "content": "<p>I think this also gets rid of the diamond with <code>uLiftCategory</code> (but I haven't checked)</p>",
        "id": 537463582,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756902133
    },
    {
        "content": "<p>An alternative is making it a <code>Category.{0, u}</code>, and relying on <code>ULiftHom</code> when we want to lift the arrows (to avoid diamonds there)</p>",
        "id": 537489170,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756909702
    },
    {
        "content": "<p>Just wondering, do you know of a situation where you want to lift arrows? I was also thinking of making it <code>Category.{0, u}</code> for an entirely different problem (the <code>ThinSkeleton</code> of a category is defined as a poset, and therefore if a category <code>HasLimits</code> it does not follow that its <code>ThinSkeleton</code> has limits too).</p>",
        "id": 537509983,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756915589
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> pointed out the problem (from the point of view of our main theorem) might not be with universe levels but with category instances, so perhaps there is an easier fix? What I need in that the n-simplex as an object of type <code>SSet.{u}</code> (for arbitrary <code>u</code>) is isomorphic to the nerve of some category. If our ULiftFin has objects at universe level u and morphisms at universe level 0 then its nerve should be a simplicial set at universe level max {0,u} = u, which should be fine? But I couldn't get the code to work ...</p>",
        "id": 537520286,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1756919016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/537520286\">said</a>:</p>\n<blockquote>\n<p>But I couldn't get the code to work ...</p>\n</blockquote>\n<p>what's wrong?</p>",
        "id": 537520470,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756919085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/537520470\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/537520286\">said</a>:</p>\n<blockquote>\n<p>But I couldn't get the code to work ...</p>\n</blockquote>\n<p>what's wrong?</p>\n</blockquote>\n<p>See the <code>sorry</code> above!</p>",
        "id": 537520726,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756919168
    },
    {
        "content": "<p>there's a lot above, where above?</p>",
        "id": 537520826,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756919213
    },
    {
        "content": "<p>oh is it</p>\n<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/challenge.3A.20eight.20sorries.20away.20from.20product-preserving/near/537370611\">said</a>:</p>\n<blockquote>\n<p>I suspect this is the reason why the proof shown here only works when the first universe level of ULiftFin is 0:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The n-simplex is isomorphic to the nerve of the ordinal category `ULiftFin (n + 1)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerveULiftFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toIso</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">objEquiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">homEquivFunctorULiftRight</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The n-simplex is isomorphic to the nerve of the ordinal category `ULiftFin (n + 1)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerveULiftFin'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The second sorried statement is the one we actually need in the <code>NerveAdjunction</code> file.</p>\n</blockquote>",
        "id": 537520933,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756919250
    },
    {
        "content": "<p>I can't figure out which namespaces to open to get this compiling</p>",
        "id": 537521054,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756919292
    },
    {
        "content": "<p>I’d say pull the PR, and play with them in their respective files instead of trying to get them to work in a standalone fashion</p>",
        "id": 537521188,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756919345
    },
    {
        "content": "<p>(Though to be clear modifying the instance as I mentioned <em>does</em> get things working! :) )</p>",
        "id": 537521313,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756919387
    },
    {
        "content": "<p>Unless, <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>, are you saying that ideally we shouldn’t actually need <code>ULiftFin.{u,u}</code> there in the first place, and the <code>NerveAdjunction</code> file shouldn’t require <del><code>ULiftFin.{u,u}</code> (with arrows at <code>u</code>) but only <code>ULiftFin.{u,0}</code> (with arrows at <code>0</code>)</del>? (hang on, I think I got myself turned around here)</p>",
        "id": 537521631,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756919497
    },
    {
        "content": "<p>If you swap the <code>ULift</code>s around you can get <code>ULiftFin.{u, v}</code> to have arrows in <code>v</code> instead of <code>max u v</code> which might be simpler</p>",
        "id": 537522847,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756919966
    },
    {
        "content": "<p>Okay, so just to recap (at least for myself!): the issue is that the current category instance for <code>ULiftFin</code> requires the arrows to be in a higher universe than the objects, and this is due to relying on <code>Preorder.smallCategory</code> (and can be fixed by relying on <code>uliftCategory</code> instead).</p>",
        "id": 537522876,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1756919978
    },
    {
        "content": "<p>At this point <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> understands things better than I do. I suspect (but am not 100% certain) that we don't actually need <code>ULiftFin.{u,u}</code> and perhaps the currently non-sorried <code>simplexIsNerveULiftFin</code> would be fine once we resolve some the confusing about category instances.</p>",
        "id": 537754265,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1757019803
    },
    {
        "content": "<p>If anyone has advice on the easiest way to fix this, that would be great. Even better if it's something that can be done in this PR, so we don't have to rebase it on something else. But if this uncovers a longer term issue that needs fixing than so be it.</p>",
        "id": 537754446,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1757019866
    },
    {
        "content": "<p>Thanks to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <a href=\"https://github.com/leanprover-community/mathlib4/pull/25780\">#25780</a> is finally fixed and ready for review!</p>",
        "id": 544253354,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1760133225
    }
]