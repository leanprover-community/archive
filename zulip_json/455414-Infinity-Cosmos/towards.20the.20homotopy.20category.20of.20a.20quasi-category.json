[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> are you still working on defining the various homotopy relations on 1-simplices via a 2-simplex? If you've made any preliminary progress, would you mind sharing your code (even if incomplete)?</p>",
        "id": 484419936,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732585409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Sure, please see <a href=\"https://github.com/KunhongDu/infinity-cosmos/blob/76a6c16bbe53cf4b63a022303c9deca1b36ef888/InfinityCosmos/ForMathlib/AlgebraicTopology/SimplicialSet/Homotopy.lean#L84\">here</a>. I have only finished the definition and showed the reflexivity holds. Compared from this <a href=\"https://github.com/leanprover-community/mathlib4/pull/10006/files#diff-d9401595c03bcfddf1ecc22aa64fe6a62f82ae75b237ef92269c4c42f967f04f\">pr</a>, I define the homotopy on morphisms rather than on objects, I think it is more consistent with other notions of homotopy. Also, I define the homotopy as sturcture rather than class as recommended by <a href=\"https://github.com/leanprover-community/mathlib4/pull/10006/files#r1476794301\">this comment</a>.</p>\n<p>I guess for further properties we need a complete api for horn filling. The pr mentioned before already did some work on that. Maybe I should first merge them into our repository?</p>",
        "id": 484508352,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732626099
    },
    {
        "content": "<p>This looks great. Would you mind creating a PR for us (it's okay to still have sorries; we have several in the repository) to review? There are various things that aren't obvious to me that are worth discussing, e.g.:</p>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n<li>If the latter should the 1-simplices be parametrized over zero simplices <code>x y : A _[0]</code> and come already with proofs that they are parallel from <code>x</code> to <code>y</code>?</li>\n</ul>",
        "id": 484572176,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645332
    },
    {
        "content": "<p>Part of the reason I ask is that <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> is looking for something new to do and one thought was to suggest he work on re-defining the homotopy category functor in the special case where the simplicial set is a quasi-category.</p>",
        "id": 484572311,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645389
    },
    {
        "content": "<p>While <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> is working on something like this</p>\n<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/welcome!/near/481395007\">said</a>:</p>\n<blockquote>\n<p>... since the hoFunctor PR is still being reviewed (<a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a>), I think it makes sense to start with results that don't require it.</p>\n<p>Maybe we call the thing where the degenerate 1-simplex is the 0-th face of a 2-simplex a <em>left homotopy</em>; \"left\" because it defines a 1-simplex in Hom^L(x,y). The other case, where the degenerate 1-simplex is the 2nd face of a 2-simplex is then a <em>right homotopy</em>. </p>\n<p>Your first task would be to show that if the ambient simplicial set is a quasi-category then left and right homotopy are each equivalence relations and moreover coincide.</p>\n</blockquote>\n<p>Perhaps <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> could work on defining a functor from <code>QCat</code> to <code>Cat</code> that sends a quasi-category <code>X</code> to the category whose type of objects is <code>X _[0]</code> and whose type of morphisms is a further question of the homs defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A simplicial set `S` has an underlying refl quiver with `S _[0]` as its underlying type.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The source vertex of `f : S _[1]` for use in defining the underlying refl quiver.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"sd\">/-- The target vertex of `f : S _[1]` for use in defining the underlying refl quiver.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"sd\">/-- The hom-types of the refl quiver underlying a simplicial set `S` are subtypes of `S _[1]`.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 484573044,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645702
    },
    {
        "content": "<p>The further quotienting is then by the homotopy relation. </p>\n<p>Unlike the construction of <code>def SSet.hoFunctor' : SSet.{u} ⥤ Cat.{u,u}</code> which first forms a free category on a ReflQuiver and then quotients by a hom relation, in this case once can show directly that the quotiented homs defined above have a well-defined composition function.</p>",
        "id": 484573550,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645888
    },
    {
        "content": "<p>The proof would require several lemmas about the homotopy relation that <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> could state sooner (and then prove later) so that <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> could work on this in parallel.</p>",
        "id": 484573910,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732646034
    },
    {
        "content": "<p>If this sounds vaguely interesting, let me know, and I'll see if I can whip up a blueprint with more details about all of the above. One thing that should be achievable once this is done is the proof that if <code>X</code> is <code>StrictSegal</code>, then an explicit map <code>η</code> from <code>X</code> to the nerve of its homotopy category (via the construction above) is an isomorphism.</p>",
        "id": 484574107,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732646132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> sounds great!</p>\n<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> if it's alright I might bother you with some questions as I try to get a feel for the interface here. I'm also happy to work at the same time on some of the background stuff that might be needed (e.g. the more complete api for horn filling that you mentioned).</p>",
        "id": 484577134,
        "sender_full_name": "Nick Ward",
        "timestamp": 1732647427
    },
    {
        "content": "<p>In the meanwhile <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span>, if you have any suggestions for <a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a> they would be very welcome.</p>",
        "id": 484584100,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732650006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I just opened a PR.</p>\n<p>For your question, I think <code>A _[1]</code> might be easier to work with when we want to prove the properties of homotopy relations, but is it the case that in the context of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>-category, we talk about morphisms more frequently? If so, maybe it would be helpful to define two versions of homotopy and state that they are somehow equivalent via Yoneda.</p>\n<p>For the second question, I did require the 1-simplicies to be parametrized by 0-simplcies in my first approach.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ParallelPair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ParallelPair</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n</code></pre></div>\n<p>Bad thing about this is being redundant, but we do have that <code>f</code> and <code>g</code> are parallel <em>definitionally</em>, rather than propositional equalities for the correpsonding vertices. And I believe not being equal definitionally may cause many problems when working on catgeories in Lean. Under this consideration, maybe an explicit parametrization may be better.</p>",
        "id": 484601597,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732657547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> Feel free to ask me any questions. I'm glad that I could help. You can tell me what lemmas you may want for your proof and I can state them. And we can discuss about the API for horn fillings, which should be interesting <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 484602544,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732657993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> it occurred to me to also suggest that as a warmup you define this simpler version of the homotopy category first for <code>StrictSegal</code> simplicial sets. I don't know that we'll want that version in mathlib but you could PR it to  the Infinity-Cosmos repository for folks to play around with.</p>",
        "id": 484745686,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732721021
    },
    {
        "content": "<p>For StrictSegal things two 1-simplices will be related by <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>'s homotopy relation iff they are equal so the homotopy category doesn't have any quotienting. Instead you are showing that the underlying reflQuiver of a strict segal simplicial set already has a category structure with composition defined by taking the diagonal of the 2-simplex formed by a path of length 2.</p>",
        "id": 484745922,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732721084
    },
    {
        "content": "<p>By request <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> opened up an early PR containing the following definitions</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopicL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopicR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now we'd be grateful for some advice on the best way to handle these structures and relations.</p>",
        "id": 484939800,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806083
    },
    {
        "content": "<p>A few that aren't obvious to me that are worth discussing, e.g.:</p>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n<li>If the latter should the 1-simplices be parametrized over zero simplices <code>x y : A _[0]</code> and come already with proofs that they are parallel from <code>x</code> to <code>y</code>?</li>\n</ul>",
        "id": 484940025,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806139
    },
    {
        "content": "<p>Future theorems will show, for instance, that when <code>A</code> is a quasi-category:</p>\n<ul>\n<li><code>HomotopicL</code> and <code>HomotopyR</code> are equivalence relations </li>\n<li>in fact they are the same equivalence relation</li>\n<li>moreover, these relations precisely capture the class of 1-simplices that are sent to the same arrow in the homotopy category of <code>A</code>.</li>\n</ul>",
        "id": 484940468,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>'s code had some of these things, right?</p>",
        "id": 485211964,
        "sender_full_name": "Dean Young",
        "timestamp": 1732959552
    },
    {
        "content": "<p>I had some early sketches of things like this, but nothing worth digging up</p>",
        "id": 485219360,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1732965857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> I think the easiest thing might be to just merge your branch now and just do some experiments on the main branch. Do you have any objections?</p>",
        "id": 485887345,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733240949
    },
    {
        "content": "<p>Maybe we can open a github issue to organize any discussion? Alternatively, I think keeping all of the discussion here has its benefits as well.</p>",
        "id": 485927301,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733251823
    },
    {
        "content": "<p>Seems like a good idea to me. Go for it, if you like!</p>",
        "id": 485963640,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733263840
    },
    {
        "content": "<p>Please do the merge. I think the further experiments can tell which of the possible definitions is better.</p>",
        "id": 485975628,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733268987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/485927301\">said</a>:</p>\n<blockquote>\n<p>Maybe we can open a github issue to organize any discussion?</p>\n</blockquote>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/60\">cosmos#60</a></p>",
        "id": 486170040,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733342807
    },
    {
        "content": "<p>Let me know if you want me to port the dashboard-based workflow into InfinityCosmos (see <a class=\"stream-topic\" data-stream-id=\"416277\" href=\"/#narrow/channel/416277-FLT/topic/Project.20Dashboard\">#FLT &gt; Project Dashboard</a> for more info). </p>\n<p>It will just require a few steps for <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>, but it would allow us to have have an issue per task, <code>claim</code> tasks directly on GitHub and having technical discussions within the same issue and / or related PR which is supposed to close it. </p>\n<p>I'll be able to assist with that tomorrow.</p>",
        "id": 486170744,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1733343084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/484745686\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> it occurred to me to also suggest that as a warmup you define this simpler version of the homotopy category first for <code>StrictSegal</code> simplicial sets.</p>\n</blockquote>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> includes a (partial) definition of the homotopy category for <code>StrictSegal</code> simplicial sets. I don't know that we'll actually want to merge this one. My intention is to open a competing PR that uses <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>'s definition of the homotopy relations in <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/51\">cosmos#51</a> for comparison. Hopefully this will provide some insight into which version of the homotopy relations might be easier to work with.</p>",
        "id": 486376549,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733425945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/484940025\">said</a>:</p>\n<blockquote>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n</ul>\n</blockquote>\n<p>I will try to better express this opinion on the github issue once I have a bit more evidence to back it up, but so far working on <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> I have strongly preferred the definition of the homotopy relations using 1-simplices <code>f g : A _[1]</code>. I believe this is primarily because the <code>Path</code> structure and <code>StrictSegal</code> class are defined on arrows of the same type. It has proven fairly tedious translating back and forth between these definitions.</p>\n<p>That being said, it's possible that this will start to matter less once the basics of quasicategories are out of the way. Additionally, there is always the option of altering the definition of <code>Path</code> to use 1-simplices <code>f : Δ[1] ⟶ A</code> if there are advantages to this approach. But, my opinion would be that it's best to pick a preferred form for 1-simplices and use it consistently in definitions.</p>",
        "id": 486597119,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733520349
    },
    {
        "content": "<p>I opened a <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">PR</a>, where I redefined <code>HomotopyL</code> and <code>HomotopyR</code> according to <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> 's suggestions.</p>",
        "id": 486759695,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733655792
    },
    {
        "content": "<p>I noticed that my commits include [Merge remote-tracking branch 'upstream/main'], which seems a little messy. Do I need to clean it?</p>",
        "id": 486759700,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733655803
    },
    {
        "content": "<p>In FLT we're squash merging when merging PRs to main</p>",
        "id": 486765009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733660077
    },
    {
        "content": "<p>This is great <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>! I would be curious to know if anyone else thinks working with 1-simplices <code>f g : Δ[1] ⟶ A</code> might be easier in the long run. It's possible my opinion is influenced by mostly working with <code>StrictSegal</code> things thus far rather than <code>Quasicategory</code>.</p>\n<p>It looks to me like the infinity-cosmos repo is also set up for squash merging, so I wouldn't worry about altering your commits.</p>",
        "id": 486780659,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733673254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> have you made any progress toward an improved api for defining maps from the horn? I have also found myself blocked by this while sketching out the construction of the homotopy category of a quasicategory <a href=\"https://github.com/emilyriehl/infinity-cosmos/compare/main...gio256:infinity-cosmos:qcat\">here</a>.</p>\n<p>I'm happy to work on this, but don't want to duplicate efforts too much.</p>",
        "id": 487095788,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733777407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> Ah I happen to be working with it right now. I actually sort of finished the framework months ago but it's a total mess and probably only understandable to myself. It'd be great if we could work on it together.</p>",
        "id": 487102899,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733779754
    },
    {
        "content": "<p>Yeah sounds great! I think the best way is probably either opening an infinity-cosmos PR or we could collaborate directly on a mathlib branch. Depending on where your work so far is maybe there's another way that's easier for you, though.</p>",
        "id": 487104593,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733780387
    },
    {
        "content": "<p>No need to clean things up for my sake, but also no rush if it's a hassle to move your existing work over to infinity-cosmos or mathlib.</p>",
        "id": 487104969,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733780510
    },
    {
        "content": "<p>I see I've missed a lot of work from <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> and <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> while I've been offline. Congrats to both of you. </p>\n<p>Do you have advice on the correct order to review and integrate your respective PRs?</p>",
        "id": 487307873,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733852429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I won't speak for <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>, but I think <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">cosmos#63</a> is fairly independent and probably just a matter of deciding which form of the homotopy relations are best to have on <code>main</code> for the time being.</p>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> is probably not ready to be merged at this point (with inevitable merge conflicts being among the reasons). The two things of interest are <code>StrictSegal.homotopic_iff_eq</code> and the anonymous <code>Category (OneTruncation S)</code> instance. My guess is that <code>StrictSegal.homotopic_iff_eq</code> is worth cleaning up and merging, possibly in a separate PR. I'm not as sure about the <code>StrictSegal</code> homotopy category instance. I have a complete proof scattered across two branches at this point, but I am unsure whether to clean it up now or just view it as a warm-up for the homotopy category of a quasicategory.</p>",
        "id": 487312966,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733854113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/487312966\">said</a>:</p>\n<blockquote>\n<p>I won't speak for <span class=\"user-mention silent\" data-user-id=\"709554\">Kunhong Du</span>, but I think <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">cosmos#63</a> is fairly independent and probably just a matter of deciding which form of the homotopy relations are best to have on <code>main</code> for the time being.</p>\n</blockquote>\n<p>I agree. I think it can be merged to main now.</p>",
        "id": 487351943,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733869990
    },
    {
        "content": "<p>Just left a review (finally). The code looks good but I think style conventions suggest we need more evocative names for the fields of the structure. I like \"simplex\" and then perhaps something like <code>δ₀_eq</code> which is a conventional way to name equalities.</p>",
        "id": 488132889,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733932885
    },
    {
        "content": "<p>But modulo a name change to something like the above I agree this is ready to merge.</p>",
        "id": 488132939,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733932901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> I suggested a name change on your PR. How do you feel about it?</p>",
        "id": 489559598,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734464508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Changed. Sorry for the delay. I've been a little busy.</p>",
        "id": 489576149,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1734471425
    },
    {
        "content": "<p>No rush and no need to apologize. It just occurred to me that perhaps you missed the comments from earlier. Anyway, merged!</p>",
        "id": 489581325,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734473736
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> provides a description of the boundary <code>∂Δ[n]</code> as a colimit of the standard simplices. </p>\n<p>The tentative plan is to use this as the basis for an api that makes it easier to define maps out of the horn / boundary. We will presumably need a very similar proof for the colimit description of <code>Λ[n, i]</code>, so any feedback is very appreciated.</p>",
        "id": 491785133,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735924199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/491785133\">said</a>:</p>\n<blockquote>\n<p>The tentative plan is to use this as the basis for an api that makes it easier to define maps out of the horn / boundary. We will presumably need a very similar proof for the colimit description of <code>Λ[n, i]</code>, so any feedback is very appreciated.</p>\n</blockquote>\n<p>I had not planned to make this public as early, but I am currently working on constructing the standard model category structures on <code>TopCat</code> and <code>SSet</code>, and as part of this work (which is at an early stage, following my work on the small object argument), I have thought about the following design. In <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Subsheaf.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Subsheaf.html</a> we have the notion of a <code>Subpresheaf</code> of a presheaf of types (the presheaf part of this file should be moved to a better place), and I have verified that it is a complete lattice. In this file <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/Boundary.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/Boundary.lean</a> I define the faces of the standard simplex (<code>face S</code> for <code>S : Set (Fin (n + 1))</code>) and show the following lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">face_inter_face</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">subcomplexBoundary_eq_iSup</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">subcomplexBoundary</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">standardSimplex.face</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">subcomplexHorn_eq_iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">subcomplexHorn</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))),</span><span class=\"w\"> </span><span class=\"n\">standardSimplex.face</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In general, if a subcomplex is the <code>⨆</code> of subcomplexes <code>Z i</code>, then it should be easy to show there is a multicoequalizer diagram involving the <code>Z i</code> and the <code>Z i ⊓ Z j</code> (it suffices to show this in a category of sets instead of the category of presheaves). In the situation above, the subcomplexes <code>Z i</code> and their intersections are (empty or) representable in the simplex category.</p>",
        "id": 491794280,
        "sender_full_name": "Joël Riou",
        "timestamp": 1735928778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> very neat, thanks for sharing!</p>",
        "id": 491805440,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735934405
    },
    {
        "content": "<p>If I understand correctly, this would subsume the work in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> and perhaps even provide a better \"backend\" for a horn filling api. Do you have an opinion on the best place to draw the interface between your work and such an api?</p>",
        "id": 491805465,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735934417
    },
    {
        "content": "<p>Yes, from the colimit cocone I suggest, yours should be obtained (up to reindexing) by excluding <code>i = j</code> and focusing on <code>i &lt; j</code> (which is obviously possible). I will test a little bit my API while working on the various descriptions of the Gabriel-Zisman anodyne extensions, and then I will PR the basic subcomplexes API. It may take a few weeks before I start PRing this.</p>",
        "id": 491807389,
        "sender_full_name": "Joël Riou",
        "timestamp": 1735935551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> do you see any reason to push <a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> forward in the meantime (or anything that should be salvaged into a separate PR)? If not, I will close it.</p>",
        "id": 491902670,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736019747
    },
    {
        "content": "<p>Also, I'm happy to help port the subcomplexes api when the time comes, although I assume it is still evolving along with the other work you shared.</p>",
        "id": 491902821,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736019913
    },
    {
        "content": "<p>I think it is better to wait for the subcomplexes API. (I just want to prove a few basic lemmas using it so that it stabilizes before PRing it; it should not be too long.)</p>",
        "id": 491906128,
        "sender_full_name": "Joël Riou",
        "timestamp": 1736023150
    },
    {
        "content": "<p>I'm inclined to agree. No rush of course!</p>",
        "id": 491909510,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736026086
    },
    {
        "content": "<p>See <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Name.20suggestions.20for.20lattice.2Fcategory.20theory.20notions.3F\">#mathlib4 &gt; Name suggestions for lattice/category theory notions?</a> for a call for suggestions for the name of some new definitions related to the above discussion.</p>",
        "id": 495106880,
        "sender_full_name": "Joël Riou",
        "timestamp": 1737479819
    },
    {
        "content": "<p>I would like to mention that while working on the homotopy theory of simplicial sets, I have done significant steps towards the construction of the fundamental groupoid of a Kan complex. It seems (?) that the homotopy category of a quasi-category <a href=\"https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#lem:htpy-cat-of-qcat\">https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#lem:htpy-cat-of-qcat</a> is obtained using the same arguments. For the fundamental groupoid, we use outer horns in order to obtain left and right inverses, but otherwise, it would suffice to check the argumentation only requires inner horns. For example, when showing the associativity of the composition, I use an (inner) horn in <code>Δ[3]</code>. The uniqueness of path composition up to homotopy is more tricky as it uses the inclusion of the union of <code>{0, 1} × Δ[2]</code> and <code>Δ[1] ×  Λ[2, 1]</code> in <code>Δ[1] × Δ[2]</code>, which requires general results on anodyne extensions. I have reduced one of the most technical lemmas about anodyne extensions (as initially defined by Gabriel and Zisman) to an equality of two subcomplexes (hopefully, I did not do mistakes with the indices...), but this will need some more work. (And Jack is working specifically on inner anodyne extensions.) I do not intend to work on quasi-categories (as I am very much focusing on the model category structure on topological spaces and simplicial sets), but there are significant chunks of code that will be useful for the infinity-cosmos project.<br>\nThis is <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean</a> and <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/AnodyneExtensions.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/AnodyneExtensions.lean</a><br>\nI will do mathlib PRs about some general API about subpresheaves and gluing as it was mentionned above (see for example <a href=\"https://github.com/joelriou/topcat-model-category/blob/e6e1c795171ab4e27551eaf433d004202aa553e9/TopCatModelCategory/SSet/Horn.lean#L310\">https://github.com/joelriou/topcat-model-category/blob/e6e1c795171ab4e27551eaf433d004202aa553e9/TopCatModelCategory/SSet/Horn.lean#L310</a> ).</p>",
        "id": 495257015,
        "sender_full_name": "Joël Riou",
        "timestamp": 1737544445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> let me know if I can be of any help in the mathlib port.</p>",
        "id": 495346470,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737569585
    },
    {
        "content": "<p>Thanks for sharing <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>. This does sound very helpful. </p>\n<p>Getting this construction of the homotopy of a quasi-category and proving that the homotopy category functor preserves products are high priorities as far as I'm concerned that I was hoping to renew interest in as soon as some current PRs are merged.</p>",
        "id": 495386032,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737585350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I think interest is still high! It's just that <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has come up with a much better solution to our problems than I managed to, so we are patiently awaiting these fancy new tools.</p>",
        "id": 495386853,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737585771
    },
    {
        "content": "<p>I'm grateful also that you've fixed all the truncated segal stuff so that maybe one day I'll finally be able to merge that PR from september...</p>",
        "id": 495392548,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737588803
    },
    {
        "content": "<p><del>Modulo a very mild sorry,</del> I have obtained that the inclusion of the union of <code>{1} ⊗ Δ[n]</code> and <code>Δ[1] ⊗ ∂Δ[n]</code> in <code>Δ[1] ⊗ Δ[n]</code> is an anodyne extension (here it is a finite composition of pushouts of horn inclusions) (and the proof for <code>{0} ⊗ Δ[n]</code> instead of <code>{1} ⊗ Δ[n]</code> should be very similar) <a href=\"https://github.com/joelriou/topcat-model-category/blob/28ae20d3b8b50b2f379a17d112c8745d19a5bcdd/TopCatModelCategory/SSet/AnodyneExtensions.lean#L319-L321\">https://github.com/joelriou/topcat-model-category/blob/28ae20d3b8b50b2f379a17d112c8745d19a5bcdd/TopCatModelCategory/SSet/AnodyneExtensions.lean#L319-L321</a><br>\nThis is one of main technical results towards the description of anodyne extensions (not inner anodyne extensions), and this uses heavily the API that I have started to PR to mathlib, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/20840\">#20840</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21096\">#21096</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21098\">#21098</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21103\">#21103</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21174\">#21174</a>, and which should be soon usable for the infinity cosmos project...</p>",
        "id": 496403520,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738090339
    },
    {
        "content": "<p>This is great, I think I'll also be able to use some of this!</p>",
        "id": 496410244,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1738092744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> my only complaint is that I can't keep up! I will try to work my way through your recent PRs, but please don't hesitate to flag any that need more (unsophisticated) opinions or review.</p>",
        "id": 496862019,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738268673
    },
    {
        "content": "<p>I have <del>mostly</del> formalized the fundamental groupoid of a Kan complex, and it turns out the proofs can be done by using very directly the lifting with respect to horn inclusions (instead of more intricate anodyne extensions).</p>",
        "id": 498321195,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928644
    },
    {
        "content": "<p>The most useful tool in this work is the following definition <code>CompStruct</code>, where <code>FundamentalGroupoid X</code> is a type synonym for <code>X</code> and <code>Edge x₀ x₁</code> is a <code>1</code>-simplex \"from <code>x₀</code> to <code>x₁</code>\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroupoid</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">CompStruct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₀₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₀₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">h₀₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₀₁.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n<span class=\"w\">  </span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₁₂.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n<span class=\"w\">  </span><span class=\"n\">h₀₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₀₂.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean</a>)</p>",
        "id": 498321221,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928653
    },
    {
        "content": "<p>This structure expresses that the homotopy class of <code>p₀₂</code> is the composition of <code>p₀₁</code> and <code>p₁₂</code>. That there is such a structure for some <code>p₀₂</code> when <code>p₀₁</code> and <code>p₁₂</code> are given uses the inner horn inclusion in <code>Δ[2]</code>. The homotopy relation <code>HomotopyL</code> and <code>HomotopyR</code> mentionned above in this thread are special cases of <code>CompStruct</code>. Then, two \"associativity\" lemmas using the two inner horns in <code>Δ[3]</code> can be used in order to show the equivalence of <code>HomotopyL/R</code> and to prove the compatibilities required in order to get the category structure on homotopy classes of \"paths\". The outer horns are used only in order to get the groupoid structure. (I have also mostly formalized the higher dimensional analogues of this in order to define the homotopy groups of a Kan complex.)</p>",
        "id": 498321249,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928664
    },
    {
        "content": "<p>(In this ongoing formalization work of simplicial homotopy theory, I found that details about the homotopy relation(s) on simplices are left under the carpet in the reference book I am mostly following. Here, the homotopy relation on paths may also be defined as a particular case of the general homotopy relation using homotopies <code>X ⊗ Δ[1] ⟶ Y</code>, i.e. as maps from the square <code>Δ[1] ⊗ Δ[1]</code>, which contains two non degenerate <code>2</code>-simplices. I do not see how to prove certain results without using <code>CompStruct</code> or <code>HomotopyL/R</code>...)</p>",
        "id": 498321265,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928672
    },
    {
        "content": "<p>As the construction of the category structure only use inner horns, the definition of the fundamental groupoid of a Kan complex should be done as a particular case of the homotopy category of a quasi-category.</p>",
        "id": 498321300,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/498321249\">said</a>:</p>\n<blockquote>\n<p>The homotopy relation <code>HomotopyL</code> and <code>HomotopyR</code> mentionned above in this thread are special cases of <code>CompStruct</code>. </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> just flagging this as something that we will need.</p>",
        "id": 498376678,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> thanks for all this work, and for your patience in explaining it to us.</p>",
        "id": 498377364,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945323
    },
    {
        "content": "<p>Would you be willing to share more info on the reference book you mentioned?</p>",
        "id": 498377429,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945328
    },
    {
        "content": "<p>I am using <em>Simplicial homotopy theory</em> by Goerss-Jardine. They define the homotopy relation by using maps <code>X ⊗ Δ[1] ⟶ Y</code>, but when we need a more precise result (Lemma I.7.4: an <code>n</code>-simplex <code>s</code> of a pointed Kan complex <code>(X, x)</code> represents the trivial element of the homotopy group iff there is a <code>n+1</code>-simplex whose faces are <code>(x, ...,x, s)</code> [Actually, <code>s</code> can be put in any place in the list]), they just left this as an exercice without any hint (this appears when doing the homotopy sequence of a fibration between Kan complexes). I could fill in the details only by looking at the original paper by Daniel Kan, <em>Ann. of Math. 67 (1958)</em>.</p>",
        "id": 498385752,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738947806
    },
    {
        "content": "<p>Thanks, these should be helpful resources in my efforts to follow along here.</p>",
        "id": 498398359,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738951666
    },
    {
        "content": "<p>Given <code>X : Type u</code>, <code>A : Set X</code>, <code>U : ι → Set X</code> and <code>V : ι → ι → Set X</code> such that <code>A</code> is the union of the <code>U i</code>, and the <code>V i j</code> are the intersections (this is <code>CompleteLattice.MulticoequalizerDiagram A U V</code>), I show in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23872\">#23872</a> that the type <code>A</code> is the multicoequalizer of the <code>U i</code>s along the <code>V i j</code>s. This depends on a few other PRs: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23364\">#23364</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23339\">#23339</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22205\">#22205</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21032\">#21032</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22203\">#22203</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21026\">#21026</a>. In a subsequent PR, a similar result will be deduced for <code>SSet.Subcomplex</code> instead of <code>Set</code>, and this will allow the construction of maps from horns.</p>",
        "id": 511188210,
        "sender_full_name": "Joël Riou",
        "timestamp": 1744208653
    }
]