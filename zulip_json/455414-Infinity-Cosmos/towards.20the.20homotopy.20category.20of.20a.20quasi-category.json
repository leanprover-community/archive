[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> are you still working on defining the various homotopy relations on 1-simplices via a 2-simplex? If you've made any preliminary progress, would you mind sharing your code (even if incomplete)?</p>",
        "id": 484419936,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732585409
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Sure, please see <a href=\"https://github.com/KunhongDu/infinity-cosmos/blob/76a6c16bbe53cf4b63a022303c9deca1b36ef888/InfinityCosmos/ForMathlib/AlgebraicTopology/SimplicialSet/Homotopy.lean#L84\">here</a>. I have only finished the definition and showed the reflexivity holds. Compared from this <a href=\"https://github.com/leanprover-community/mathlib4/pull/10006/files#diff-d9401595c03bcfddf1ecc22aa64fe6a62f82ae75b237ef92269c4c42f967f04f\">pr</a>, I define the homotopy on morphisms rather than on objects, I think it is more consistent with other notions of homotopy. Also, I define the homotopy as sturcture rather than class as recommended by <a href=\"https://github.com/leanprover-community/mathlib4/pull/10006/files#r1476794301\">this comment</a>.</p>\n<p>I guess for further properties we need a complete api for horn filling. The pr mentioned before already did some work on that. Maybe I should first merge them into our repository?</p>",
        "id": 484508352,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732626099
    },
    {
        "content": "<p>This looks great. Would you mind creating a PR for us (it's okay to still have sorries; we have several in the repository) to review? There are various things that aren't obvious to me that are worth discussing, e.g.:</p>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n<li>If the latter should the 1-simplices be parametrized over zero simplices <code>x y : A _[0]</code> and come already with proofs that they are parallel from <code>x</code> to <code>y</code>?</li>\n</ul>",
        "id": 484572176,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645332
    },
    {
        "content": "<p>Part of the reason I ask is that <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> is looking for something new to do and one thought was to suggest he work on re-defining the homotopy category functor in the special case where the simplicial set is a quasi-category.</p>",
        "id": 484572311,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645389
    },
    {
        "content": "<p>While <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> is working on something like this</p>\n<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/welcome!/near/481395007\">said</a>:</p>\n<blockquote>\n<p>... since the hoFunctor PR is still being reviewed (<a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a>), I think it makes sense to start with results that don't require it.</p>\n<p>Maybe we call the thing where the degenerate 1-simplex is the 0-th face of a 2-simplex a <em>left homotopy</em>; \"left\" because it defines a 1-simplex in Hom^L(x,y). The other case, where the degenerate 1-simplex is the 2nd face of a 2-simplex is then a <em>right homotopy</em>. </p>\n<p>Your first task would be to show that if the ambient simplicial set is a quasi-category then left and right homotopy are each equivalence relations and moreover coincide.</p>\n</blockquote>\n<p>Perhaps <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> could work on defining a functor from <code>QCat</code> to <code>Cat</code> that sends a quasi-category <code>X</code> to the category whose type of objects is <code>X _[0]</code> and whose type of morphisms is a further question of the homs defined in <a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A simplicial set `S` has an underlying refl quiver with `S _[0]` as its underlying type.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The source vertex of `f : S _[1]` for use in defining the underlying refl quiver.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"sd\">/-- The target vertex of `f : S _[1]` for use in defining the underlying refl quiver.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"sd\">/-- The hom-types of the refl quiver underlying a simplicial set `S` are subtypes of `S _[1]`.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">OneTruncation</span><span class=\"bp\">.</span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 484573044,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645702
    },
    {
        "content": "<p>The further quotienting is then by the homotopy relation. </p>\n<p>Unlike the construction of <code>def SSet.hoFunctor' : SSet.{u} ⥤ Cat.{u,u}</code> which first forms a free category on a ReflQuiver and then quotients by a hom relation, in this case once can show directly that the quotiented homs defined above have a well-defined composition function.</p>",
        "id": 484573550,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732645888
    },
    {
        "content": "<p>The proof would require several lemmas about the homotopy relation that <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> could state sooner (and then prove later) so that <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> could work on this in parallel.</p>",
        "id": 484573910,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732646034
    },
    {
        "content": "<p>If this sounds vaguely interesting, let me know, and I'll see if I can whip up a blueprint with more details about all of the above. One thing that should be achievable once this is done is the proof that if <code>X</code> is <code>StrictSegal</code>, then an explicit map <code>η</code> from <code>X</code> to the nerve of its homotopy category (via the construction above) is an isomorphism.</p>",
        "id": 484574107,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732646132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> sounds great!</p>\n<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> if it's alright I might bother you with some questions as I try to get a feel for the interface here. I'm also happy to work at the same time on some of the background stuff that might be needed (e.g. the more complete api for horn filling that you mentioned).</p>",
        "id": 484577134,
        "sender_full_name": "Nick Ward",
        "timestamp": 1732647427
    },
    {
        "content": "<p>In the meanwhile <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span>, if you have any suggestions for <a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">#16783</a> they would be very welcome.</p>",
        "id": 484584100,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732650006
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I just opened a PR.</p>\n<p>For your question, I think <code>A _[1]</code> might be easier to work with when we want to prove the properties of homotopy relations, but is it the case that in the context of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>-category, we talk about morphisms more frequently? If so, maybe it would be helpful to define two versions of homotopy and state that they are somehow equivalent via Yoneda.</p>\n<p>For the second question, I did require the 1-simplicies to be parametrized by 0-simplcies in my first approach.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ParallelPair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Interval</span><span class=\"bp\">.</span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ParallelPair</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n</code></pre></div>\n<p>Bad thing about this is being redundant, but we do have that <code>f</code> and <code>g</code> are parallel <em>definitionally</em>, rather than propositional equalities for the correpsonding vertices. And I believe not being equal definitionally may cause many problems when working on catgeories in Lean. Under this consideration, maybe an explicit parametrization may be better.</p>",
        "id": 484601597,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732657547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> Feel free to ask me any questions. I'm glad that I could help. You can tell me what lemmas you may want for your proof and I can state them. And we can discuss about the API for horn fillings, which should be interesting <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 484602544,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1732657993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> it occurred to me to also suggest that as a warmup you define this simpler version of the homotopy category first for <code>StrictSegal</code> simplicial sets. I don't know that we'll want that version in mathlib but you could PR it to  the Infinity-Cosmos repository for folks to play around with.</p>",
        "id": 484745686,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732721021
    },
    {
        "content": "<p>For StrictSegal things two 1-simplices will be related by <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>'s homotopy relation iff they are equal so the homotopy category doesn't have any quotienting. Instead you are showing that the underlying reflQuiver of a strict segal simplicial set already has a category structure with composition defined by taking the diagonal of the 2-simplex formed by a path of length 2.</p>",
        "id": 484745922,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732721084
    },
    {
        "content": "<p>By request <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> opened up an early PR containing the following definitions</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">face0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">face1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"n\">face2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">homotopy</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">standardSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopicL</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopicR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now we'd be grateful for some advice on the best way to handle these structures and relations.</p>",
        "id": 484939800,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806083
    },
    {
        "content": "<p>A few that aren't obvious to me that are worth discussing, e.g.:</p>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n<li>If the latter should the 1-simplices be parametrized over zero simplices <code>x y : A _[0]</code> and come already with proofs that they are parallel from <code>x</code> to <code>y</code>?</li>\n</ul>",
        "id": 484940025,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806139
    },
    {
        "content": "<p>Future theorems will show, for instance, that when <code>A</code> is a quasi-category:</p>\n<ul>\n<li><code>HomotopicL</code> and <code>HomotopyR</code> are equivalence relations </li>\n<li>in fact they are the same equivalence relation</li>\n<li>moreover, these relations precisely capture the class of 1-simplices that are sent to the same arrow in the homotopy category of <code>A</code>.</li>\n</ul>",
        "id": 484940468,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1732806269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>'s code had some of these things, right?</p>",
        "id": 485211964,
        "sender_full_name": "Dean Young",
        "timestamp": 1732959552
    },
    {
        "content": "<p>I had some early sketches of things like this, but nothing worth digging up</p>",
        "id": 485219360,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1732965857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> I think the easiest thing might be to just merge your branch now and just do some experiments on the main branch. Do you have any objections?</p>",
        "id": 485887345,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733240949
    },
    {
        "content": "<p>Maybe we can open a github issue to organize any discussion? Alternatively, I think keeping all of the discussion here has its benefits as well.</p>",
        "id": 485927301,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733251823
    },
    {
        "content": "<p>Seems like a good idea to me. Go for it, if you like!</p>",
        "id": 485963640,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733263840
    },
    {
        "content": "<p>Please do the merge. I think the further experiments can tell which of the possible definitions is better.</p>",
        "id": 485975628,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733268987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/485927301\">said</a>:</p>\n<blockquote>\n<p>Maybe we can open a github issue to organize any discussion?</p>\n</blockquote>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/60\">cosmos#60</a></p>",
        "id": 486170040,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733342807
    },
    {
        "content": "<p>Let me know if you want me to port the dashboard-based workflow into InfinityCosmos (see <a class=\"stream-topic\" data-stream-id=\"416277\" href=\"/#narrow/channel/416277-FLT/topic/Project.20Dashboard\">#FLT &gt; Project Dashboard</a> for more info). </p>\n<p>It will just require a few steps for <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>, but it would allow us to have have an issue per task, <code>claim</code> tasks directly on GitHub and having technical discussions within the same issue and / or related PR which is supposed to close it. </p>\n<p>I'll be able to assist with that tomorrow.</p>",
        "id": 486170744,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1733343084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/484745686\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> it occurred to me to also suggest that as a warmup you define this simpler version of the homotopy category first for <code>StrictSegal</code> simplicial sets.</p>\n</blockquote>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> includes a (partial) definition of the homotopy category for <code>StrictSegal</code> simplicial sets. I don't know that we'll actually want to merge this one. My intention is to open a competing PR that uses <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>'s definition of the homotopy relations in <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/51\">cosmos#51</a> for comparison. Hopefully this will provide some insight into which version of the homotopy relations might be easier to work with.</p>",
        "id": 486376549,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733425945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/484940025\">said</a>:</p>\n<blockquote>\n<ul>\n<li>should the 1-simplices be terms of type <code>f g : Δ[1] ⟶ A</code> or of type <code>f g : A _[1]</code>?</li>\n</ul>\n</blockquote>\n<p>I will try to better express this opinion on the github issue once I have a bit more evidence to back it up, but so far working on <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> I have strongly preferred the definition of the homotopy relations using 1-simplices <code>f g : A _[1]</code>. I believe this is primarily because the <code>Path</code> structure and <code>StrictSegal</code> class are defined on arrows of the same type. It has proven fairly tedious translating back and forth between these definitions.</p>\n<p>That being said, it's possible that this will start to matter less once the basics of quasicategories are out of the way. Additionally, there is always the option of altering the definition of <code>Path</code> to use 1-simplices <code>f : Δ[1] ⟶ A</code> if there are advantages to this approach. But, my opinion would be that it's best to pick a preferred form for 1-simplices and use it consistently in definitions.</p>",
        "id": 486597119,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733520349
    },
    {
        "content": "<p>I opened a <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">PR</a>, where I redefined <code>HomotopyL</code> and <code>HomotopyR</code> according to <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> 's suggestions.</p>",
        "id": 486759695,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733655792
    },
    {
        "content": "<p>I noticed that my commits include [Merge remote-tracking branch 'upstream/main'], which seems a little messy. Do I need to clean it?</p>",
        "id": 486759700,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733655803
    },
    {
        "content": "<p>In FLT we're squash merging when merging PRs to main</p>",
        "id": 486765009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733660077
    },
    {
        "content": "<p>This is great <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>! I would be curious to know if anyone else thinks working with 1-simplices <code>f g : Δ[1] ⟶ A</code> might be easier in the long run. It's possible my opinion is influenced by mostly working with <code>StrictSegal</code> things thus far rather than <code>Quasicategory</code>.</p>\n<p>It looks to me like the infinity-cosmos repo is also set up for squash merging, so I wouldn't worry about altering your commits.</p>",
        "id": 486780659,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733673254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> have you made any progress toward an improved api for defining maps from the horn? I have also found myself blocked by this while sketching out the construction of the homotopy category of a quasicategory <a href=\"https://github.com/emilyriehl/infinity-cosmos/compare/main...gio256:infinity-cosmos:qcat\">here</a>.</p>\n<p>I'm happy to work on this, but don't want to duplicate efforts too much.</p>",
        "id": 487095788,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733777407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> Ah I happen to be working with it right now. I actually sort of finished the framework months ago but it's a total mess and probably only understandable to myself. It'd be great if we could work on it together.</p>",
        "id": 487102899,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733779754
    },
    {
        "content": "<p>Yeah sounds great! I think the best way is probably either opening an infinity-cosmos PR or we could collaborate directly on a mathlib branch. Depending on where your work so far is maybe there's another way that's easier for you, though.</p>",
        "id": 487104593,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733780387
    },
    {
        "content": "<p>No need to clean things up for my sake, but also no rush if it's a hassle to move your existing work over to infinity-cosmos or mathlib.</p>",
        "id": 487104969,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733780510
    },
    {
        "content": "<p>I see I've missed a lot of work from <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> and <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> while I've been offline. Congrats to both of you. </p>\n<p>Do you have advice on the correct order to review and integrate your respective PRs?</p>",
        "id": 487307873,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733852429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I won't speak for <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>, but I think <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">cosmos#63</a> is fairly independent and probably just a matter of deciding which form of the homotopy relations are best to have on <code>main</code> for the time being.</p>\n<p><a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/61\">cosmos#61</a> is probably not ready to be merged at this point (with inevitable merge conflicts being among the reasons). The two things of interest are <code>StrictSegal.homotopic_iff_eq</code> and the anonymous <code>Category (OneTruncation S)</code> instance. My guess is that <code>StrictSegal.homotopic_iff_eq</code> is worth cleaning up and merging, possibly in a separate PR. I'm not as sure about the <code>StrictSegal</code> homotopy category instance. I have a complete proof scattered across two branches at this point, but I am unsure whether to clean it up now or just view it as a warm-up for the homotopy category of a quasicategory.</p>",
        "id": 487312966,
        "sender_full_name": "Nick Ward",
        "timestamp": 1733854113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/487312966\">said</a>:</p>\n<blockquote>\n<p>I won't speak for <span class=\"user-mention silent\" data-user-id=\"709554\">Kunhong Du</span>, but I think <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/63\">cosmos#63</a> is fairly independent and probably just a matter of deciding which form of the homotopy relations are best to have on <code>main</code> for the time being.</p>\n</blockquote>\n<p>I agree. I think it can be merged to main now.</p>",
        "id": 487351943,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1733869990
    },
    {
        "content": "<p>Just left a review (finally). The code looks good but I think style conventions suggest we need more evocative names for the fields of the structure. I like \"simplex\" and then perhaps something like <code>δ₀_eq</code> which is a conventional way to name equalities.</p>",
        "id": 488132889,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733932885
    },
    {
        "content": "<p>But modulo a name change to something like the above I agree this is ready to merge.</p>",
        "id": 488132939,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1733932901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> I suggested a name change on your PR. How do you feel about it?</p>",
        "id": 489559598,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734464508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Changed. Sorry for the delay. I've been a little busy.</p>",
        "id": 489576149,
        "sender_full_name": "Kunhong Du",
        "timestamp": 1734471425
    },
    {
        "content": "<p>No rush and no need to apologize. It just occurred to me that perhaps you missed the comments from earlier. Anyway, merged!</p>",
        "id": 489581325,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734473736
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> provides a description of the boundary <code>∂Δ[n]</code> as a colimit of the standard simplices. </p>\n<p>The tentative plan is to use this as the basis for an api that makes it easier to define maps out of the horn / boundary. We will presumably need a very similar proof for the colimit description of <code>Λ[n, i]</code>, so any feedback is very appreciated.</p>",
        "id": 491785133,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735924199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/491785133\">said</a>:</p>\n<blockquote>\n<p>The tentative plan is to use this as the basis for an api that makes it easier to define maps out of the horn / boundary. We will presumably need a very similar proof for the colimit description of <code>Λ[n, i]</code>, so any feedback is very appreciated.</p>\n</blockquote>\n<p>I had not planned to make this public as early, but I am currently working on constructing the standard model category structures on <code>TopCat</code> and <code>SSet</code>, and as part of this work (which is at an early stage, following my work on the small object argument), I have thought about the following design. In <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Subsheaf.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Subsheaf.html</a> we have the notion of a <code>Subpresheaf</code> of a presheaf of types (the presheaf part of this file should be moved to a better place), and I have verified that it is a complete lattice. In this file <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/Boundary.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/Boundary.lean</a> I define the faces of the standard simplex (<code>face S</code> for <code>S : Set (Fin (n + 1))</code>) and show the following lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">face_inter_face</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">face</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">subcomplexBoundary_eq_iSup</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">subcomplexBoundary</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">standardSimplex.face</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">subcomplexHorn_eq_iSup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">subcomplexHorn</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))),</span><span class=\"w\"> </span><span class=\"n\">standardSimplex.face</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">j</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>In general, if a subcomplex is the <code>⨆</code> of subcomplexes <code>Z i</code>, then it should be easy to show there is a multicoequalizer diagram involving the <code>Z i</code> and the <code>Z i ⊓ Z j</code> (it suffices to show this in a category of sets instead of the category of presheaves). In the situation above, the subcomplexes <code>Z i</code> and their intersections are (empty or) representable in the simplex category.</p>",
        "id": 491794280,
        "sender_full_name": "Joël Riou",
        "timestamp": 1735928778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> very neat, thanks for sharing!</p>",
        "id": 491805440,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735934405
    },
    {
        "content": "<p>If I understand correctly, this would subsume the work in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> and perhaps even provide a better \"backend\" for a horn filling api. Do you have an opinion on the best place to draw the interface between your work and such an api?</p>",
        "id": 491805465,
        "sender_full_name": "Nick Ward",
        "timestamp": 1735934417
    },
    {
        "content": "<p>Yes, from the colimit cocone I suggest, yours should be obtained (up to reindexing) by excluding <code>i = j</code> and focusing on <code>i &lt; j</code> (which is obviously possible). I will test a little bit my API while working on the various descriptions of the Gabriel-Zisman anodyne extensions, and then I will PR the basic subcomplexes API. It may take a few weeks before I start PRing this.</p>",
        "id": 491807389,
        "sender_full_name": "Joël Riou",
        "timestamp": 1735935551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> do you see any reason to push <a href=\"https://github.com/leanprover-community/mathlib4/pull/20448\">mathlib4#20448</a> forward in the meantime (or anything that should be salvaged into a separate PR)? If not, I will close it.</p>",
        "id": 491902670,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736019747
    },
    {
        "content": "<p>Also, I'm happy to help port the subcomplexes api when the time comes, although I assume it is still evolving along with the other work you shared.</p>",
        "id": 491902821,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736019913
    },
    {
        "content": "<p>I think it is better to wait for the subcomplexes API. (I just want to prove a few basic lemmas using it so that it stabilizes before PRing it; it should not be too long.)</p>",
        "id": 491906128,
        "sender_full_name": "Joël Riou",
        "timestamp": 1736023150
    },
    {
        "content": "<p>I'm inclined to agree. No rush of course!</p>",
        "id": 491909510,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736026086
    },
    {
        "content": "<p>See <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Name.20suggestions.20for.20lattice.2Fcategory.20theory.20notions.3F\">#mathlib4 &gt; Name suggestions for lattice/category theory notions?</a> for a call for suggestions for the name of some new definitions related to the above discussion.</p>",
        "id": 495106880,
        "sender_full_name": "Joël Riou",
        "timestamp": 1737479819
    },
    {
        "content": "<p>I would like to mention that while working on the homotopy theory of simplicial sets, I have done significant steps towards the construction of the fundamental groupoid of a Kan complex. It seems (?) that the homotopy category of a quasi-category <a href=\"https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#lem:htpy-cat-of-qcat\">https://emilyriehl.github.io/infinity-cosmos/blueprint/sec-simplicial-sets.html#lem:htpy-cat-of-qcat</a> is obtained using the same arguments. For the fundamental groupoid, we use outer horns in order to obtain left and right inverses, but otherwise, it would suffice to check the argumentation only requires inner horns. For example, when showing the associativity of the composition, I use an (inner) horn in <code>Δ[3]</code>. The uniqueness of path composition up to homotopy is more tricky as it uses the inclusion of the union of <code>{0, 1} × Δ[2]</code> and <code>Δ[1] ×  Λ[2, 1]</code> in <code>Δ[1] × Δ[2]</code>, which requires general results on anodyne extensions. I have reduced one of the most technical lemmas about anodyne extensions (as initially defined by Gabriel and Zisman) to an equality of two subcomplexes (hopefully, I did not do mistakes with the indices...), but this will need some more work. (And Jack is working specifically on inner anodyne extensions.) I do not intend to work on quasi-categories (as I am very much focusing on the model category structure on topological spaces and simplicial sets), but there are significant chunks of code that will be useful for the infinity-cosmos project.<br>\nThis is <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean</a> and <a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/AnodyneExtensions.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/AnodyneExtensions.lean</a><br>\nI will do mathlib PRs about some general API about subpresheaves and gluing as it was mentionned above (see for example <a href=\"https://github.com/joelriou/topcat-model-category/blob/e6e1c795171ab4e27551eaf433d004202aa553e9/TopCatModelCategory/SSet/Horn.lean#L310\">https://github.com/joelriou/topcat-model-category/blob/e6e1c795171ab4e27551eaf433d004202aa553e9/TopCatModelCategory/SSet/Horn.lean#L310</a> ).</p>",
        "id": 495257015,
        "sender_full_name": "Joël Riou",
        "timestamp": 1737544445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> let me know if I can be of any help in the mathlib port.</p>",
        "id": 495346470,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737569585
    },
    {
        "content": "<p>Thanks for sharing <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>. This does sound very helpful. </p>\n<p>Getting this construction of the homotopy of a quasi-category and proving that the homotopy category functor preserves products are high priorities as far as I'm concerned that I was hoping to renew interest in as soon as some current PRs are merged.</p>",
        "id": 495386032,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737585350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I think interest is still high! It's just that <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has come up with a much better solution to our problems than I managed to, so we are patiently awaiting these fancy new tools.</p>",
        "id": 495386853,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737585771
    },
    {
        "content": "<p>I'm grateful also that you've fixed all the truncated segal stuff so that maybe one day I'll finally be able to merge that PR from september...</p>",
        "id": 495392548,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737588803
    },
    {
        "content": "<p><del>Modulo a very mild sorry,</del> I have obtained that the inclusion of the union of <code>{1} ⊗ Δ[n]</code> and <code>Δ[1] ⊗ ∂Δ[n]</code> in <code>Δ[1] ⊗ Δ[n]</code> is an anodyne extension (here it is a finite composition of pushouts of horn inclusions) (and the proof for <code>{0} ⊗ Δ[n]</code> instead of <code>{1} ⊗ Δ[n]</code> should be very similar) <a href=\"https://github.com/joelriou/topcat-model-category/blob/28ae20d3b8b50b2f379a17d112c8745d19a5bcdd/TopCatModelCategory/SSet/AnodyneExtensions.lean#L319-L321\">https://github.com/joelriou/topcat-model-category/blob/28ae20d3b8b50b2f379a17d112c8745d19a5bcdd/TopCatModelCategory/SSet/AnodyneExtensions.lean#L319-L321</a><br>\nThis is one of main technical results towards the description of anodyne extensions (not inner anodyne extensions), and this uses heavily the API that I have started to PR to mathlib, see <a href=\"https://github.com/leanprover-community/mathlib4/pull/20840\">#20840</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21096\">#21096</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21098\">#21098</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21103\">#21103</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21174\">#21174</a>, and which should be soon usable for the infinity cosmos project...</p>",
        "id": 496403520,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738090339
    },
    {
        "content": "<p>This is great, I think I'll also be able to use some of this!</p>",
        "id": 496410244,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1738092744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> my only complaint is that I can't keep up! I will try to work my way through your recent PRs, but please don't hesitate to flag any that need more (unsophisticated) opinions or review.</p>",
        "id": 496862019,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738268673
    },
    {
        "content": "<p>I have <del>mostly</del> formalized the fundamental groupoid of a Kan complex, and it turns out the proofs can be done by using very directly the lifting with respect to horn inclusions (instead of more intricate anodyne extensions).</p>",
        "id": 498321195,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928644
    },
    {
        "content": "<p>The most useful tool in this work is the following definition <code>CompStruct</code>, where <code>FundamentalGroupoid X</code> is a type synonym for <code>X</code> and <code>Edge x₀ x₁</code> is a <code>1</code>-simplex \"from <code>x₀</code> to <code>x₁</code>\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"w\"> </span><span class=\"n\">x₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FundamentalGroupoid</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">CompStruct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₀₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₁</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p₀₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Edge</span><span class=\"w\"> </span><span class=\"n\">x₀</span><span class=\"w\"> </span><span class=\"n\">x₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"n\">h₀₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₀₁.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n<span class=\"w\">  </span><span class=\"n\">h₁₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₁₂.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n<span class=\"w\">  </span><span class=\"n\">h₀₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">stdSimplex.δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p₀₂.map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_cat</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean\">https://github.com/joelriou/topcat-model-category/blob/master/TopCatModelCategory/SSet/FundamentalGroupoid.lean</a>)</p>",
        "id": 498321221,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928653
    },
    {
        "content": "<p>This structure expresses that the homotopy class of <code>p₀₂</code> is the composition of <code>p₀₁</code> and <code>p₁₂</code>. That there is such a structure for some <code>p₀₂</code> when <code>p₀₁</code> and <code>p₁₂</code> are given uses the inner horn inclusion in <code>Δ[2]</code>. The homotopy relation <code>HomotopyL</code> and <code>HomotopyR</code> mentionned above in this thread are special cases of <code>CompStruct</code>. Then, two \"associativity\" lemmas using the two inner horns in <code>Δ[3]</code> can be used in order to show the equivalence of <code>HomotopyL/R</code> and to prove the compatibilities required in order to get the category structure on homotopy classes of \"paths\". The outer horns are used only in order to get the groupoid structure. (I have also mostly formalized the higher dimensional analogues of this in order to define the homotopy groups of a Kan complex.)</p>",
        "id": 498321249,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928664
    },
    {
        "content": "<p>(In this ongoing formalization work of simplicial homotopy theory, I found that details about the homotopy relation(s) on simplices are left under the carpet in the reference book I am mostly following. Here, the homotopy relation on paths may also be defined as a particular case of the general homotopy relation using homotopies <code>X ⊗ Δ[1] ⟶ Y</code>, i.e. as maps from the square <code>Δ[1] ⊗ Δ[1]</code>, which contains two non degenerate <code>2</code>-simplices. I do not see how to prove certain results without using <code>CompStruct</code> or <code>HomotopyL/R</code>...)</p>",
        "id": 498321265,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928672
    },
    {
        "content": "<p>As the construction of the category structure only use inner horns, the definition of the fundamental groupoid of a Kan complex should be done as a particular case of the homotopy category of a quasi-category.</p>",
        "id": 498321300,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738928686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/498321249\">said</a>:</p>\n<blockquote>\n<p>The homotopy relation <code>HomotopyL</code> and <code>HomotopyR</code> mentionned above in this thread are special cases of <code>CompStruct</code>. </p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span> just flagging this as something that we will need.</p>",
        "id": 498376678,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> thanks for all this work, and for your patience in explaining it to us.</p>",
        "id": 498377364,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945323
    },
    {
        "content": "<p>Would you be willing to share more info on the reference book you mentioned?</p>",
        "id": 498377429,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738945328
    },
    {
        "content": "<p>I am using <em>Simplicial homotopy theory</em> by Goerss-Jardine. They define the homotopy relation by using maps <code>X ⊗ Δ[1] ⟶ Y</code>, but when we need a more precise result (Lemma I.7.4: an <code>n</code>-simplex <code>s</code> of a pointed Kan complex <code>(X, x)</code> represents the trivial element of the homotopy group iff there is a <code>n+1</code>-simplex whose faces are <code>(x, ...,x, s)</code> [Actually, <code>s</code> can be put in any place in the list]), they just left this as an exercice without any hint (this appears when doing the homotopy sequence of a fibration between Kan complexes). I could fill in the details only by looking at the original paper by Daniel Kan, <em>Ann. of Math. 67 (1958)</em>.</p>",
        "id": 498385752,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738947806
    },
    {
        "content": "<p>Thanks, these should be helpful resources in my efforts to follow along here.</p>",
        "id": 498398359,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738951666
    },
    {
        "content": "<p>Given <code>X : Type u</code>, <code>A : Set X</code>, <code>U : ι → Set X</code> and <code>V : ι → ι → Set X</code> such that <code>A</code> is the union of the <code>U i</code>, and the <code>V i j</code> are the intersections (this is <code>CompleteLattice.MulticoequalizerDiagram A U V</code>), I show in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23872\">#23872</a> that the type <code>A</code> is the multicoequalizer of the <code>U i</code>s along the <code>V i j</code>s. This depends on a few other PRs: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23364\">#23364</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23339\">#23339</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22205\">#22205</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21032\">#21032</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22203\">#22203</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21026\">#21026</a>. In a subsequent PR, a similar result will be deduced for <code>SSet.Subcomplex</code> instead of <code>Set</code>, and this will allow the construction of maps from horns.</p>",
        "id": 511188210,
        "sender_full_name": "Joël Riou",
        "timestamp": 1744208653
    },
    {
        "content": "<p>After seeing how much pain <span class=\"user-mention\" data-user-id=\"879277\">@Julian Komaromy</span> had to endure to work with 2-truncated quasi-categories in resolving <a href=\"https://github.com/emilyriehl/infinity-cosmos/issues/103\">issue #103</a>. I've been worried that my suggested blueprint, to develop the homotopy category of a quasi-category in the 2-truncated setting, was a mistake.</p>\n<p>I've just opened a PR that adapts his code to the non-truncated setting . Using this and some code I stole from <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s work on the fundamental groupoid of a Kan complex linked above, modulo some incomplete dualization and one sorry, the <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/123\">following PR</a> addresses issue <a href=\"https://github.com/leanprover-community/mathlib4/pull/104\">#104</a> (proving the left and right homotopy relations are equivalence relations and coincide in a quasi-category). I'm very curious what both of you think.</p>\n<p>Essentially what made this easier (besides the fact that all of the hard work had been done by <span class=\"user-mention\" data-user-id=\"879277\">@Julian Komaromy</span> and <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>) was the fact that the infrastructure for non-truncated simplicial sets is better developed. In particular we have things like <code>δ_comp_δ_apply</code> (that were surprisingly hard to use because of issues I think with the inequality arguments; if a lean wizard could golf my code to try to avoid the <code>erw</code>s that would be great).</p>",
        "id": 518962528,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747605869
    },
    {
        "content": "<p>There's one other thing to note in the PR: I introduced also the notion of an <code>AlgebraicQuasicategory</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AlgebraicQuasicategory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hornFilling'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)⦄</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Λ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"n\">hornFilling_comm'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)⦄</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Λ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"n\">σ₀</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Λ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hornFilling'</span><span class=\"w\"> </span><span class=\"n\">σ₀</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">hn</span>\n</code></pre></div>\n<p>where the difference is that horn fillers are specified. Note that the main example of quasi-categories in mathlib, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span>'s nerves of categories, can be made algebraic, essentially as just demonstrated by <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> (because strict segal simplicial sets define algebraic quasi-categories). (An algebraic Kan complex would of course also define an algebraic quasi-category.) So I'd argue that we should actually change <code>Quasicategory</code> to refer to this notion and introduce <code>IsQuasicategory</code> for the predicate on simplicial sets. The rationale is that this makes the following constructive, where this would all be tagged as <code>noncomputable</code> otherwise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- In a quasi-category, the left homotopy relation is symmetric. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">compId</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">compId</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- In a quasi-category, the right homotopy relation is symmetric. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc'</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">idComp</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">idComp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- In a quasi-category, left homotopy implies right homotopy. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"bp\">.</span><span class=\"n\">homotopyR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HomotopyR</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc'</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">idComp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">compId</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- In a quasi-category, right homotopy implies left homotopy. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"bp\">.</span><span class=\"n\">homotopyL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HomotopyL</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">compId</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">idComp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- In a quasi-category, the left homotopy relation is transitive. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HomotopyL</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">idComp</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyL</span><span class=\"bp\">.</span><span class=\"n\">homotopyR</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- In a quasi-category, the right homotopy relation is transitive. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">HomotopyR</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">assoc'</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CompStruct</span><span class=\"bp\">.</span><span class=\"n\">compId</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HomotopyR</span><span class=\"bp\">.</span><span class=\"n\">homotopyL</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 518962743,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747606084
    },
    {
        "content": "<p>With apologies to <span class=\"user-mention\" data-user-id=\"709554\">@Kunhong Du</span>, <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span>, I had to comment some of their past work on this to avoid duplication of names. So this PR should be considered a draft. And apologies to <span class=\"user-mention\" data-user-id=\"879277\">@Julian Komaromy</span> for moving some of his stuff from the <code>SSet</code>namespace (where it belongs) to <code>SSet.Truncated</code> for the same reason. Apologies to all.</p>",
        "id": 518964410,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747607658
    },
    {
        "content": "<p>Some notions can be defined and made computable in the \"algebraic\" context, with specified horn fillers, but I think this may lead to issues when studying the stability properties of quasicategories/Kan complexes. I do not think that <code>AlgebraicQuasiCategory</code> should replace the definition of <code>QuasiCategory</code>, and I would be extremely unhappy if a notion of <code>AlgebraicKanComplex</code> were to replace the notion of <code>KanComplex</code>. For example, if <code>i : A ⟶ B</code> is a monomorphism, <code>p : X ⟶ Y</code> is a Kan fibration, and <code>sq</code> is a commutative square (a map from the arrow <code>i</code> to the arrow <code>p</code>), the subcomplex of <code>(ihom B).obj X</code> consisting of \"morphisms\" <code>B ⟶ X</code> which makes the two triangles commute is a Kan complex.<br>\n<a href=\"https://github.com/joelriou/topcat-model-category/blob/4b4b46eda5c6038efa64d7c70e9c46cfb6e5b6dd/TopCatModelCategory/SSet/Fibrations.lean#L386-L389\">https://github.com/joelriou/topcat-model-category/blob/4b4b46eda5c6038efa64d7c70e9c46cfb6e5b6dd/TopCatModelCategory/SSet/Fibrations.lean#L386-L389</a><br>\nIf we wanted to define an <code>AlgebraicKanComplex</code> instance for this, we may have to know that <code>p</code> is an \"algebraic\" Kan fibration and as we would have to track down all the uses of lifting properties, we would have to replace the notion of anodyne extension (which is a property) with data saying that for any algebraic Kan fibration, we have a specified lift in all squares involving algebraic Kan fibrations, etc. Even monomorphisms would have to include data because we may need a computable way of making them transfinite compositions of boundary inclusions. This seems extremely unpractical to me. I do not know the details about how to construct quasicategories out of other quasicategories, but similar issues would certainly arise when replacing anodyne extensions with inner anodyne extensions.<br>\nIncluding data may make the definition of the composition of maps in the homotopy category computable, but I certainly do not expect we could get a <code>DecidableEq</code> instance on the type of maps! Then, is it really so important to have computable definitions? Does it outweight the serious issues I have mentionned?</p>",
        "id": 518978397,
        "sender_full_name": "Joël Riou",
        "timestamp": 1747619541
    },
    {
        "content": "<p>Would it make sense to write the main API in terms of the current notion of quasicategory, but to allow algebraic quasicats for certain constructions, where the computability pays of?</p>",
        "id": 519004262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1747635337
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s objection. Making quasicategories \"algebraic\" is likely to turn proofs of facts like \"internal hom from a simplicial set to a quasicategory is a quasicategory\", stability of isofibrations with respect to joins (required to show that \"slices\" of quasicategories are quasicategories), or basically anything about it the Joyal model structure into a lot of pain.</p>",
        "id": 519063045,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1747650221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/519063045\">said</a>:</p>\n<blockquote>\n<p>I agree with <span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span>'s objection. Making quasicategories \"algebraic\" is likely to turn proofs of facts like \"internal hom from a simplicial set to a quasicategory is a quasicategory\", stability of isofibrations with respect to joins (required to show that \"slices\" of quasicategories are quasicategories), or basically anything about it the Joyal model structure into a lot of pain.</p>\n</blockquote>\n<p>I would argue it's already a lot of pain. But I guess I take the point that since anything defined using the universal property of a limit or a colimit is <code>noncomputable</code> (according to Mathlib) anyway, the benefit is less than I was expecting. </p>\n<p>It does bother me every time I have to tag something as <code>noncomputable</code> when the proof gives an explicit construction. But I'll let this go until it bothers someone else enough to be worth revisiting.</p>",
        "id": 519216184,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1747686403
    },
    {
        "content": "<p>I totally agree with the second paragraph, my way to cope with it has been to tag sections noncomputable so that the compiler doesn't remind me about it every time.</p>",
        "id": 519237844,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1747693571
    },
    {
        "content": "<p>I certainly don't know much about computability but this conversation feels very reminiscent of e.g. the two ways of defining finiteness of a set in mathlib; we have <code>S : Finset X</code> (data, computable) and <code>S : Set X</code> + <code>hS : Set.Finite S</code> (a prop, noncomputable), and API for <em>both</em> constructions, with some proofs on one side just \"stolen\" from the other side (e.g. the API for the noncomputable <code>finsum</code>, sums over noncomputable sets which gives the sum if it's finite and 0 if it's infinite, was often written by \"if it's infinite then the sum is 0 and the lemma is easy, else use the axiom of choice, make a <code>Finset</code>, apply the <code>Finset</code> sum lemma and convert back\". Because everything was a proof this worked fine. There are advantages and disadvantages to this approach, the most obvious disadvantage being that it's an instance of <a href=\"https://xkcd.com/927/\">https://xkcd.com/927/</a> and the most obvious advantage being that everyone can have what they want (it's just that it might be hard for everyone to talk to each other). </p>\n<p>There is a constant tension in mathlib between \"those that want to compute\" and \"those that want to prove\". The first time I understood this properly was when there were a lot of people intensely discussing computability of polynomials and how it was making proofs more annoying, and then mathlib was updated to make polynomials noncomputable and all of a sudden a student of mine who had defined Chebyshev polynomials when formalizing a past Imperial exam question suddenly found that their proof of things like \"the 4th Chebyshev polynomial is (blah) by <code>rfl</code>\" stopped working, and they now had to use <code>ring</code>. Fortunately for them, the tactic was there when they needed it, because it had been written a few months earlier by Mario. If the analogous quasicategory tactic is not there in category theory then I can imagine that a noncomputable API might be frustrating for those that want to compute.</p>\n<p>I don't think it makes sense for mathlib to have two definitions of a polynomial, the whole philosophy of mathlib is that there's one definition of everything, and unfortunately most of the active people in the community were not around when the decision to make them noncomputable was made (and I didn't understand the discussion at the time so it's difficult to summarise it). But sometimes people talk about a solution to this problem being <code>@[csimp]</code>. I have absolutely no idea whether this helps here (indeed I only have the vaguest idea about what <code>@[csimp]</code> does). If this doesn't help, dare you consider developing both a computable and a noncomputable theory like we have for finite sets, and trying to glue them together somehow (like we do for finite sums)?</p>",
        "id": 519293958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747718919
    },
    {
        "content": "<p>I do not understand what <code>@[csimp]</code> does and if it is relevant here, but what is happening here is that we are defining the homotopy category of a simplicial set <code>X</code>. It is possible to define it by generators and relations in general, but in the favourable case of quasicategories, it is a quotient category. Given two vertices <code>x</code> and <code>y</code>, the morphims <code>x ⟶ y</code> identify to a quotient of a type of edges from <code>x</code> to <code>y</code>. In order to define the composition, we need to define the homotopy class of the composition of an edge from <code>x</code> to <code>y</code> and an edge from <code>y</code> to <code>z</code>. The quasicategory axioms involve lifting properties which allow to find a 2-simplex <code>t</code>, which can be thought as a \"triangle\", such that two sides correspond to two given edges, and the composition shall be defined as the remaining side of the triangle (and its homotopy class is independent of the choices). If we have some magic data which gives us the triangle <code>t</code>, we can make the composition law in the homotopy category computable. I have argued that in downstream applications, including data in the definitions would have very bad consequences. And the gain would be very little because the composition law is defined on a quotient type, where we certainly do not have a decidable equality (there is no easy way to determine that two edges are homotopic). Roughly, it is likely that the only case where we can prove <code>f ≫ g = h</code> by <code>rfl</code> is when <code>h</code> is exactly the third side of the very specific triangle that would be part of the magic data. Something would be \"computable\" in the Lean sense, but it would be completely inoperative. (The situation is much worse as compared to polynomials, where definitions are \"noncomputable\", but we can still make computations using the <code>ring</code> tactic.)</p>",
        "id": 519307034,
        "sender_full_name": "Joël Riou",
        "timestamp": 1747724865
    },
    {
        "content": "<p>(Mostly, it is like attempting computations in the quotient of a ring by an ideal you do not know much about.)</p>",
        "id": 519307771,
        "sender_full_name": "Joël Riou",
        "timestamp": 1747725117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/towards.20the.20homotopy.20category.20of.20a.20quasi-category/near/519293958\">said</a>:</p>\n<blockquote>\n<p>But sometimes people talk about a solution to this problem being <code>@[csimp]</code>. I have absolutely no idea whether this helps here (indeed I only have the vaguest idea about what <code>@[csimp]</code> does).</p>\n</blockquote>\n<p>Just to give extra context on this: There are two ways to \"compute\" in lean, kernel and interpreted. (Actually three if you include compiled to C but it's mostly the same as interpreted, just faster.) Kernel computation is used when you use <code>by decide</code> or <code>rfl</code> to prove a theorem, and interpreted computation is used when you use <code>by native_decide</code> or <code>#eval</code>, or run a tactic (the tactic itself is interpreted, the proof it generates is kernel checked).</p>\n<p>As a result of this, most discussion around polynomials being computable is about <em>kernel</em> computation. That's what will let you prove things by <code>rfl</code>. <code>@[csimp]</code> is an attribute which lets the interpreter use a different evaluation strategy than the kernel, so it is not useful for improving kernel computation.</p>",
        "id": 519347912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747736484
    }
]