[
    {
        "content": "<p>Some relevant constructions like <code>Δ[n]</code> are universe polymorphic, but nonetheless get all their data from a single low universe level.</p>\n<p>For example, with <code>∆[n] := stdSimplex.obj ⦋n⦌</code>, we can see that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CosimplicialObject</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">yoneda</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">uliftFunctor</span>\n</code></pre></div>\n<p>and when printing the universe levels, we see</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CosimplicialObject</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">yoneda</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">uliftFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>i.e., all of the higher universe compatibility comes from <code>uliftFunctor</code>—which makes sense when we think through how <code>yoneda</code> decides where to live. Its universe levels here come from those of <code>SimplexCategory</code> (which demands one ulift, but not necessarily any more!).</p>\n<p>In e.g. the case of <code>Δ[n]</code>, we can express this internally as <code>(SSet.uliftFunctor.obj Δ[n]) ≅ Δ[n]</code> (with appropriate universe freedom):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uliftSimplexIsoSimplex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\"> </span><span class=\"n\">uliftFunctor</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toIso</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>Similarly, we have <code>nerve (ULiftCat.{v', u'} C) ≅ SSet.uliftFunctor.obj.{max u' v'} &lt;| nerve C</code> (i.e., <em>if</em> all of a category's data comes from a lower universe level, so does <code>nerve _</code>'s):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nerveULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">,</span><span class=\"n\">u'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">uliftFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toIso</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">upRightEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>(where I'm using <code>Functor.upRightEquiv : X ⥤ Y ≃ X ⥤ ULiftCat Y</code> from my own bespoke ulifting API for now).</p>\n<p>But proving individual things like this—and constructing the right squares, e.g. chaining <code>Δ[0] ≅ SSet.uliftFunctor.obj Δ[0]</code>, <code>SSet.uliftFunctor.obj Δ[0] ≅ SSet.uliftFunctor.obj (nerve (Fin 1))</code> (which we have for free since <code>SSet.uliftFunctor</code> is a functor), and <code>SSet.uliftFunctor.obj (nerve (Fin 1)) ≅ nerve (ULiftCat (Fin 1))</code>, inserting the right <code>symm</code>s—is tedious.</p>\n<p>I'm wondering if some metaprogramming can be done to move things between universe levels easily, so that</p>\n<ol>\n<li>we can generate the \"ulift isomorphisms\" automatically, e.g. by attaching some attribute (<code>@[ulifts]</code>?) to <code>stdSimplex.obj</code> and <code>nerve</code> when declared</li>\n<li>we can insert those isomorphisms automatically when we need to move between universe levels. Ideally, we could just write something like <code>u(simplexIsNerve 0)</code> and it would modify the universes as appropriate for the expected type.</li>\n</ol>\n<p>One part of this issue, imo, is \"freezing\" (and rigidifying!) the universe levels when moving inside <code>Cat</code>, and I'd hope that the above would also help us move more fluidly between <code>Cat</code> data at different universes somehow.</p>",
        "id": 525610375,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1750807650
    }
]