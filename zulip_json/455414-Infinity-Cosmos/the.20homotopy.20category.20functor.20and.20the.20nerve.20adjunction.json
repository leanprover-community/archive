[
    {
        "content": "<p>Thanks to the tireless work of <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>, the functor <br>\n<code>hoFunctor : SSet.{u} ⥤ Cat.{u, u}</code> <br>\nthat takes a simplicial set to its homotopy category is now in Mathlib!</p>\n<p>Now there is only one PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/16784\">#16784</a>) from last summer's work with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  remaining: the construction of </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">nerveAdjunction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"w\"> </span><span class=\"bp\">⊣</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor</span>\n</code></pre></div>\n<p>There is (at least) one aspect of this construction that could use some golfing, and I thought I'd start a discussion here to solicit suggestions.</p>",
        "id": 490088368,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734665873
    },
    {
        "content": "<p>The <code>nerveAdjunction</code> is actually defined as a composite of two other adjunctions: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">coskAdj</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">truncation</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">⊣</span><span class=\"w\"> </span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"n\">cosk</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>between simplicial sets and 2-truncated simplicial sets and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">nerve₂Adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hoFunctor₂</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⊣</span><span class=\"w\"> </span><span class=\"n\">nerveFunctor₂</span>\n</code></pre></div>\n<p>which involves similar functors but using 2-truncated simplicial sets instead of simplicial sets. The bulk of the work in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16784\">#16784</a> is in constructing <code>nerve₂Adj </code>.</p>",
        "id": 490088508,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734665999
    },
    {
        "content": "<p>The construction directly defines the unit and counit and checks the triangle equalities. The counit is straightforward: its components are functors mapping out of <code>hoFunctor₂ (nerveFunctor₂ C)</code> for some category <code>C</code> and <code>hoFunctor₂</code> is a quotient of some other category, so has a mapping out universal property. After pre-composing with the quotient functor, the counit component is, up to isomorphism, the counit component <code>ReflQuiv.adj.counit.app C</code>of another adjunction .</p>",
        "id": 490088784,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734666208
    },
    {
        "content": "<p>The construction of the unit components are much more interesting. We have an analogous unit component <code>ReflQuiv.adj.counit.app</code> and morally the unit component is obtained by postcomposing this with the quotient functor, with one big caveat: the map I just described is a map of <code>ReflQuivers</code> (morally 1-truncated simplicial sets) and we require a map of 2-truncated simplicial sets. But because this map is valued in <code>nerveFunctor₂ (hoFunctor₂ X)</code> for some 2-truncated simplicial set <code>X</code> and nerves of categories are 2-coskeletal, the map of reflexive quivers lifts to define the map we want.</p>",
        "id": 490089158,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734666492
    },
    {
        "content": "<p>Here's way the proof needs golfing: in establishing the infrastructure needed to make the lift; see lines 96-442 (the bulk) of the PR. </p>\n<p>This was written before <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> suggested we re-prove 2-coskeletality in a more abstract way using <code>StrictSegal</code> simplicial sets. My instinct is that these stuff could be streamlined via something like that abstraction.</p>\n<p>I've started to implement this in a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a> but this seems to require a lot of new infrastructure, because all of the strict segal stuff was developed for simplicial sets rather than 2-truncated simplicial sets. Thus, I'd love some advice about whether we can reuse any of this or whether we have to simply redevelop it. See the file <code>Truncated</code> in that PR which contains all the new development. Any thoughts <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> or anyone? Suggestions or help would be very welcome.</p>",
        "id": 490089483,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734666769
    },
    {
        "content": "<p>I'll just say that I hope messages 2,3,4 in this thread will end up in some form in the module docstring in mathlib, in whatever form this gets merged.</p>",
        "id": 490091586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734668407
    },
    {
        "content": "<p>Also, I agree that it's good to take a step back and think about how the new infrastructure can be reused here. Maybe by appropriately abstracting. But I haven't thought about this particular question before, so I don't have any concrete advice atm.</p>",
        "id": 490091721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1734668485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/490089483\">said</a>:</p>\n<blockquote>\n<p>I've started to implement this in a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a> but this seems to require a lot of new infrastructure, because all of the strict segal stuff was developed for simplicial sets rather than 2-truncated simplicial sets. Thus, I'd love some advice about whether we can reuse any of this or whether we have to simply redevelop it. See the file <code>Truncated</code> in that PR which contains all the new development. Any thoughts <span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> or anyone? Suggestions or help would be very welcome.</p>\n</blockquote>\n<p>I have just added some suggestion of a slightly more general design.</p>",
        "id": 490134244,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734690813
    },
    {
        "content": "<p>Exciting to see <a href=\"https://github.com/leanprover-community/mathlib4/pull/16783\">mathlib4#16783</a> merged!</p>\n<p>I will take a closer look, but I think I generally agree with <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> that rather than outright duplicating existing constructions, it might make sense to redefine them in terms of the most natural truncation level. This probably requires  some thought around how best to unify constructions defined in terms of different truncation levels.</p>",
        "id": 490212292,
        "sender_full_name": "Nick Ward",
        "timestamp": 1734719831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> if you have any ideas about how best to implement this, I'd be very grateful. <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s suggest to redefine paths using 1-truncated simplicial sets makes sense to me but we should also think about whether and how to try to unify this notion with the existing infrastructure of Paths in Quivers. The just merged PR also contains the definition of the underlying ReflQuiver of a 2-truncated simplicial set (because this is the thing we need to define the homotopy category). Should this be generalized to 1-truncated simplicial sets (which we don't need right now) or will that just make it harder to use in the case we care about? This isn't so clear to me...</p>",
        "id": 490243191,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1734736157
    },
    {
        "content": "<p>There are some subtleties about the exact types of paths we consider. For simplicial sets, we have <code>Path X n</code> for a fixed <code>n</code>, without any condition about the source and target <code>0</code>-simplex, because we want to relate this type with <code>X_ [n]</code>. In the context of quivers, we have a type of paths from <code>a</code> to <code>b</code> (without any condition on the length). These notions have quite distinct uses.</p>",
        "id": 490292659,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734782302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> I will play around with redefining <code>Path</code> and some of the <code>StrictSegal</code> infrastructure and see if that inspires any concrete ideas.</p>\n<p>My only thought right now (which may be obvious), is that we should try to maintain a canonical definition of each construction (e.g. defining <code>Path₁</code> and then defining <code>Path X</code> as <code>Path₁ &lt;| (SSet.truncation 1).obj X</code>). I think duplication of some APIs is inevitable (and not necessarily a bad thing), but hopefully we can avoid ad hoc duplication of translations between the different definitions.</p>",
        "id": 490329073,
        "sender_full_name": "Nick Ward",
        "timestamp": 1734813988
    },
    {
        "content": "<p>Whether the canonical definition needs to be the \"right one\" is also a good question. I think, for instance, whether we should first define the underlying ReflQuiver in terms of 1-truncated simplicial sets depends a lot on how hard it is to work with the truncation functor, which I don't have a great idea of yet.</p>",
        "id": 490329593,
        "sender_full_name": "Nick Ward",
        "timestamp": 1734814457
    },
    {
        "content": "<p>The truncation functor has very good definitional properties. (You will probably need to define the functors <code>SimplexCategory.Truncated n ⥤ SimplexCategory.Truncated m</code> when <code>n ≤ m</code>.)</p>",
        "id": 490334934,
        "sender_full_name": "Joël Riou",
        "timestamp": 1734819465
    },
    {
        "content": "<p>I still have relatively little to contribute here, but I have discovered that the following slight generalization of the <code>X _[0]₂</code> notation is valid. I'm sure any metaprogramming experts will be able to improve what I have here (or explain why it is a bad idea altogether).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Util</span><span class=\"bp\">.</span><span class=\"n\">Superscript</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">macro</span><span class=\"o\">:</span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\" _[\"</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">subscript</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">raw</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">⟩</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Opposite</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"bp\">⟩</span><span class=\"o\">))</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">₁</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">₂</span>\n</code></pre></div>",
        "id": 491910908,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736027128
    },
    {
        "content": "<p>It's still just a sketch, but <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...gio256:mathlib4:trunc\">here</a> is what I've been thinking for redefining the <code>StrictSegal</code> infrastructure. </p>\n<p>The short summary is that <code>SSet.StrictSegal</code> would be defined in terms of <code>SSet.Truncated.StrictSegal</code>, and the same for <code>SSet.Path</code> and <code>SSet.spine</code>. I believe this is approximately what <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has suggested, though I suspect at least the definition of <code>SSet.StrictSegal</code> can be still be improved significantly.</p>",
        "id": 491990640,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736104138
    },
    {
        "content": "<p>I think the next steps would be to make sure this is actually helpful for the work in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">mathlib4#20090</a>, then to work on a PR that replaces the existing definitions. It's possible <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> is already way ahead of me on this, though.</p>",
        "id": 491990924,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736104413
    },
    {
        "content": "<p>(I also haven't touched on the questions related to quivers yet).</p>",
        "id": 491991032,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736104514
    },
    {
        "content": "<p>At first glance, it looks like what I was thinking of. I recently noticed that the design of <code>StrictSegal</code> could be slightly improved. Currently there is the data of an inverse map in the definition. I suggest we should make <code>StrictSegal</code> a structure (not a class), and define <code>IsStrictSegal X : Prop</code> which could be used by lemmas that do not depend on the definitional properties of the <code>StrictSegal</code> structure, like this one I found today:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">SSet.mono_iff_of_strictSegal</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">X.StrictSegal</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Mono</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Function.Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f.app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]))</span>\n</code></pre></div>",
        "id": 492000687,
        "sender_full_name": "Joël Riou",
        "timestamp": 1736113131
    },
    {
        "content": "<p>The refactor for the truncated case could be an occasion to do this other refactor at the same time.</p>",
        "id": 492000705,
        "sender_full_name": "Joël Riou",
        "timestamp": 1736113156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> this looks really great. Thanks for taking it on. I've done no work at all on this in the last few weeks but am slowly coming back online.</p>\n<p>For experimental purposes, it looks like I could just copy the code from your Elephant file into <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a> and see what I can do with it. That PR was always meant to be experimental (and will either be overwritten or deleted) once we've got a more concrete plan. Or is there another workflow that you'd suggest?</p>\n<p>Happy new year everyone!</p>",
        "id": 492162109,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736189129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> if it's helpful in its current state, certainly feel free to copy any code into <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a>. However, I suspect we won't really know if the <code>StrictSegal</code> machinery is helpful for <a href=\"https://github.com/leanprover-community/mathlib4/pull/16784\">#16784</a> until we have a more complete development of the truncated versions of things beyond just the definitions themselves.</p>\n<p>Assuming nothing looks obviously wrong with the definitions I proposed <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...gio256:mathlib4:trunc\">here</a>, I will work on a proper PR that replaces the current definitions (and works through any bugs in the proposed definitions). Looking briefly at <a href=\"https://github.com/leanprover-community/mathlib4/pull/16784\">#16784</a>, it should be relatively easy to rebase on top of such a PR in order to experiment further with <code>SSet.Truncated.StrictSegal</code>.</p>",
        "id": 492167588,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736191101
    },
    {
        "content": "<p>One quick question: are we sure that an <code>n</code>-truncated simplicial set should be considered <code>SSet.Truncated.StrictSegal</code> if its <code>n</code>-simplices are uniquely determined by their spine? It occurred to me that we could also ask for all <code>m</code>-simplices for <code>m ≤ n</code> to be uniquely determined by their <code>m</code>-spine. I do think that the former translates more cleanly into the un-truncated definition, though.</p>",
        "id": 492168453,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736191437
    },
    {
        "content": "<p>Ah, sorry, it should definitely mean the latter (m-simplices determined by their spine for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">m \\leq n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>). I was just thinking of the case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> where these notions coincide.</p>",
        "id": 492168868,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736191579
    },
    {
        "content": "<p>Oh that makes more sense, thank you! I obviously just copied your definition for <code>n = 2</code> without giving it enough thought.</p>",
        "id": 492169240,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736191722
    },
    {
        "content": "<p>I have opened a WIP PR redefining <code>StrictSegal</code> and related constructions in terms of truncated simplicial sets at <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>. There are still a lot of changes to be made, but there should be enough work in place to enable experimenting with the new definitions. Any feedback is of course also appreciated.</p>",
        "id": 493134156,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736636361
    },
    {
        "content": "<p>Some of the TODOs include:</p>\n<ul>\n<li>Cleaning up the new / replacement proofs</li>\n<li>Getting rid of lots of <code>erw</code>s</li>\n<li>Deciding on namespaces, notation, etc.</li>\n<li>Adding <code>IsStrictSegal : Prop</code></li>\n</ul>",
        "id": 493134537,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736636751
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20688\">mathlib4#20688</a> breaks out the truncated notations <code>[m]ₙ</code> and <code>X _[m]ₙ</code> from <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>.</p>",
        "id": 493211841,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736707295
    },
    {
        "content": "<p>I'm very into these truncated notions, the former of which is broken in the experimental PR I'm working with (for reasons I don't understand) and is making everything very verbose. Will you ping me when these are merged?</p>",
        "id": 493244420,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736735135
    },
    {
        "content": "<p>I'll have a look at the rest of the PR tomorrow afternoon.</p>",
        "id": 493244533,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736735209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> can you explain why <code>StrictSegal</code> is no longer an instance?</p>",
        "id": 493470784,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736809936
    },
    {
        "content": "<p>Regarding API, I also added a version of your <code>Path₁.ext'</code> (but for <code>Path</code> instead of <code>Path₁</code>) in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090/files#diff-d686071124e5fefb0c3f6ffd271aad47751d0eebef29e9e7790e1e41f60f44da\">my experimental extension of your code</a>. I used this to define the following (a bit long winded):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Two simplices in a `StrictSegal` truncated simplicial set agree iff their spines agree. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ext'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"bp\">ₙ₊₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">spine</span><span class=\"w\"> </span><span class=\"n\">hmn</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">spine</span><span class=\"w\"> </span><span class=\"n\">hmn</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">spineInjective</span><span class=\"w\"> </span><span class=\"n\">hmn</span><span class=\"w\"> </span><span class=\"n\">hyp</span>\n\n<span class=\"sd\">/-- Two simplices in a `StrictSegal` truncated simplicial set agree iff the 1-simplices along their</span>\n<span class=\"sd\">spines agree. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ext''</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hmn'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">ₙ₊₁</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mkOfSucc</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_add_left</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">hmn'</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">Δ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">mkOfSucc</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_add_left</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">hmn'</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Δ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Δ'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ext'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Path</span><span class=\"bp\">.</span><span class=\"n\">ext'</span><span class=\"w\"> </span><span class=\"n\">hyp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 493471200,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736810104
    },
    {
        "content": "<p>But in the horrible thing <code>toStrictSegal₂.mk </code> that I'm trying to prove what was most useful was the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StrictSegal</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This is similiar to one of the famous Segal maps, except valued in a product rather than a</span>\n<span class=\"sd\">pullback.-/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">seagull</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">₂</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">₂</span><span class=\"w\"> </span><span class=\"bp\">⨯</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkOfSucc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkOfSucc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">seagull</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">right_cancellation</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">seagull</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"n\">eq2</span>\n<span class=\"w\">    </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"n\">eq2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"n\">eq2</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"n\">eq2</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">StrictSegal</span><span class=\"bp\">.</span><span class=\"n\">ext''</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">eq1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">eq2</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>which could be generalized from 2 to any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n \\geq 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>. The point is then this allows be to reason using composition identities in <code>SimplexCategory</code> rather than applications of the composition identities in a situation where the <code>ext''</code> might otherwise be used.</p>",
        "id": 493471731,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736810291
    },
    {
        "content": "<p>So essentially what I'm suggesting is a version of this monomorphism exactly where your <code>Path₁.ext'</code> is defined (with a better name).</p>",
        "id": 493472133,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736810461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/493470784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> can you explain why <code>StrictSegal</code> is no longer an instance?</p>\n</blockquote>\n<p>This is unrelated to the \"truncation\" refactor, and was suggested by <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/492000687\">here</a>. However, I haven't actually gotten around to finishing this portion of the refactor.</p>",
        "id": 493473518,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736811066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/493472133\">said</a>:</p>\n<blockquote>\n<p>So essentially what I'm suggesting is a version of this monomorphism exactly where your <code>Path₁.ext'</code> is defined.</p>\n</blockquote>\n<p>I'm all in favor of the above, which looks rather elegant. I'm still trying to understand if this suggestion somehow excludes the existence of <code>Path₁.ext'</code> (which I have no particular attachment to), or if you just mean that is where it belongs in the file.</p>",
        "id": 493474857,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736811632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/493473518\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/493470784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> can you explain why <code>StrictSegal</code> is no longer an instance?</p>\n</blockquote>\n<p>This is unrelated to the \"truncation\" refactor, and was suggested by <span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/492000687\">here</a>. However, I haven't actually gotten around to finishing this portion of the refactor.</p>\n</blockquote>\n<p>The idea is that instead, there will be a <code>IsStrictSegal</code> instance (as a property, which does not involve the data of the inverse maps).</p>",
        "id": 493531802,
        "sender_full_name": "Joël Riou",
        "timestamp": 1736842414
    },
    {
        "content": "<p>This was meant as an addition to <code>Path₁.ext'</code> rather than a replacement of it. I suspect we'll find both versions useful.</p>\n<p>A naive question: since <code>Path</code> is just an abbreviation for <code>Path₁</code> we don't also need a <code>Path.ext'</code> I assume?</p>",
        "id": 493598939,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736865301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/493598939\">said</a>:</p>\n<blockquote>\n<p>since <code>Path</code> is just an abbreviation for <code>Path₁</code> we don't also need a <code>Path.ext'</code> I assume?</p>\n</blockquote>\n<p>I'm actually not sure yet. I found that restating many of the lemmas for <code>Path</code> (and proving them in terms of the <code>Path₁</code> version) helped type inference and made other lemmas easier to state without dropping down to <code>Path₁</code>. But, maybe this is too much duplication.</p>",
        "id": 493619370,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736871000
    },
    {
        "content": "<p>I've just merged <a href=\"https://github.com/leanprover-community/mathlib4/pull/20719\">#20719</a> into <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>. This should fix the CI issues (which were related to <a href=\"https://github.com/leanprover-community/mathlib4/pull/20355\">#20355</a>).</p>\n<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> would it be helpful if we took the time to rebase <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>? It might take some tedious work, and <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> isn't particularly clean or stable yet. The upside is that we would be working with the same definitions again, and you wouldn't need to manually fix all the bugs in my original truncated definitions.</p>",
        "id": 493647713,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736880594
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">mathlib4#20668</a> has reached a reviewable state. The two notation PRs it depends on have not been reviewed yet, so be aware that the diff is large and subject to change. But, if anyone has spare cycles for a first-pass review, feedback is of course appreciated.</p>",
        "id": 494900329,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737402139
    },
    {
        "content": "<p>Maybe I'll chat here so I don't clutter the review...</p>\n<p>First Q: did you write an \"leq\" tactic, or did that exist? I've wasted ages trying to find the proofs that 1 ≤ 2 or whatever. Does the code <code>(h : m ≤ n + 1 := by leq)</code> mean that even though this is an explicit argument of various things a user might be able to get away by just supplying the explicit argument <code>m</code>?</p>",
        "id": 494905177,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737404172
    },
    {
        "content": "<p>Second Q: should a lemma like <code>spine_spineToSimplex_apply</code> be tagged for <code>simp</code>? I never know when this is appropriate.</p>",
        "id": 494905716,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737404366
    },
    {
        "content": "<p>(I left one comment on the PR because it seemed more important than the above.)</p>",
        "id": 494906994,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737404830
    },
    {
        "content": "<p>Thank you for the feedback!</p>",
        "id": 494910952,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737406215
    },
    {
        "content": "<p>I did write the <code>leq</code> tactic (<a href=\"https://github.com/leanprover-community/mathlib4/blob/4a7364c0b016676ea122cbf319cf863bb7307ff5/Mathlib/AlgebraicTopology/SimplexCategory.lean#L756-L764\">here</a>), though it really just tries to apply a few lemmas and then delegates to <code>omega</code>. There were a few places in the PR where I replaced <code>omega</code> with <code>leq</code> for conformity, but for the most part I only used <code>leq</code> in places where the goal was solved without delegating to <code>omega</code>.</p>",
        "id": 494911608,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737406498
    },
    {
        "content": "<p>The notation <code>(h : m ≤ n + 1 := by leq)</code> is indeed a \"default argument\" which sometimes the caller can get away without providing explicitly. However, I think my usage of these leaves something to be desired. I suspect there may be some heuristics like \"use default arguments for defs but not for lemmas\", because they often seem to actually require specifying more arguments when rewriting.</p>",
        "id": 494912706,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737406942
    },
    {
        "content": "<p>Is there a worry that some term won't definitionally equal some other term because <code>leq</code> (or the user) found different proofs of the inequality in each case?</p>",
        "id": 494913072,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737407110
    },
    {
        "content": "<p>I think you are probably correct that <code>spine_spineToSimplex_apply</code> should be a simp lemma. I did have some trouble tagging many lemmas that I thought should be in the simpset because the lhs contained an abbrev that further simplified, but I don't think thats the case here (at least for <code>Truncated.StrictSegal.spine_spineToSimplex_apply</code>).</p>",
        "id": 494913284,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737407191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/494913072\">said</a>:</p>\n<blockquote>\n<p>Is there a worry that some term won't definitionally equal some other term because <code>leq</code> (or the user) found different proofs of the inequality in each case?</p>\n</blockquote>\n<p>As I understand it, lean's kernel treats any any two terms inhabiting a proposition <code>P : Prop</code> as definitionally equal. I'm not confident enough to say that this would never be a concern, though.</p>",
        "id": 494914112,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737407564
    },
    {
        "content": "<p>That could totally be right. I don't know one way or the other.</p>",
        "id": 494928149,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737414150
    },
    {
        "content": "<p>Yeah all proofs of a theorem are equal by definition in lean, this is different from HoTT and has a name (proof irrelevance I think?)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 494929184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737414652
    },
    {
        "content": "<p>I'm skeptical that <code>leq</code> is a good idea. Does it actually solve anything that <code>omega</code> can't do by itself? In practice on small problems <code>omega</code> is quite fast. I'd be skeptical if <code>leq</code> is ever 1000 heartbeats faster than <code>omega</code>. If you just use <code>omega</code> the proof are more robust, and more portable.</p>",
        "id": 494943239,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737421257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/494943239\">said</a>:</p>\n<blockquote>\n<p>Does it actually solve anything that <code>omega</code> can't do by itself?</p>\n</blockquote>\n<p>It does not. </p>\n<p>It is essentially the ComposableArrows <a href=\"https://github.com/leanprover-community/mathlib4/blob/3c2c5041203a2782a0772001c640ecccfe364a5a/Mathlib/CategoryTheory/ComposableArrows.lean#L69-L71\"><code>valid</code></a> tactic. My only real motivation for adding it was that we already needed a small wrapper for <code>omega</code> for the notation <code>[m]ₙ</code> (<code>dsimp only [SimplexCategory.len_mk]; omega</code>), and the vast majority of the proofs ended up being by <code>decide</code> or <code>assumption</code>. From <a href=\"https://github.com/leanprover-community/mathlib4/pull/9594\">#9594</a>, which added the <code>valid</code> tactic, I inferred that we might save some cycles by fishing for an assumption before deferring to <code>omega</code>. </p>\n<p>It sounds like that is not the case, though!</p>",
        "id": 494947813,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737423520
    },
    {
        "content": "<p>Is it generally worth trying anything before deferring to <code>omega</code>, or would you recommend just replacing the whole wrapper with <code>dsimp only [SimplexCategory.len_mk]; omega</code>?</p>",
        "id": 494948824,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737424000
    },
    {
        "content": "<p>I'd be inclined to do unfolding (and translating any custom types in <code>Int</code>, if irrelevant), but not attempt to do any arithmetic yourself. That's what the black boxes are for. :-)</p>",
        "id": 494953747,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737426673
    },
    {
        "content": "<p>run <code>#count_heartbeats</code> on things and make sure you are saving at least 1000 heartbeats, preferably 10,000, before optimising black box tactics.</p>",
        "id": 494953803,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737426714
    },
    {
        "content": "<p>(and then tell the black box authors about the performance problem before rolling your own!)</p>",
        "id": 494953889,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737426744
    },
    {
        "content": "<p>That's a very helpful guideline, thanks <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>!</p>",
        "id": 495077344,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737471980
    },
    {
        "content": "<p>If anyone is able to point me in the right direction, I'd be quite curious to learn more about <code>omega</code> and <code>grind</code>. I'm particularly interested in their performance characteristics, but any information is appreciated.</p>",
        "id": 495077947,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737472123
    },
    {
        "content": "<p>Thanks to <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span>'s insights, the <code>trunc</code> tactic is now much simpler. This automates the truncation proofs for the notations <code>[m]ₙ</code> and <code>X _[m]ₙ</code>.</p>\n<p>I have temporarily removed the <code>leq</code> tactic, though I still find myself wanting a simple <code>omega</code> wrapper for autoParams that tries <code>assumption</code> before deferring to <code>omega</code>. Maybe it's the result of too much HoTT, but I see the benefit being that you can state a lemma without providing the autoParam and still know that it found your hypothesis of the same type, rather than a long <code>omega</code> proof that could have just been <code>h</code>.</p>\n<p>Some rudimentary <code>#check_heartbeats</code> benchmarking suggests that such a tactic is justified (or at least break-even) in the context of <code>SimplexCategory.Truncated</code>. But, is it too confusing to see an unfamiliar tactic in a default argument (would you rather just see <code>h : m ≤ n := by omega</code> everywhere)?</p>",
        "id": 495365116,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737576466
    },
    {
        "content": "<p>I can't comment on <code>omega</code> vs <code>leq</code>; that's way above my expertise.</p>\n<p>Could you tell  us more about the tactic <code>trunc</code>, what is does, and when to use it?</p>",
        "id": 495383150,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737583972
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> <code>trunc</code> is really just an implementation detail of the <code>[m]ₙ</code> notation for the <code>m</code>-dimensional simplex in the <code>n</code>-truncated simplex category. Every instance of <code>[m]ₙ</code> could be more verbosely written as <code>[m, by trunc]ₙ</code>, where <code>by trunc</code> is a proof that <code>[m].len ≤ n</code>. The <code>trunc</code> tactic itself tries <code>decide</code> and <code>assumption</code>, then simplifies the goal to <code>m ≤ n</code> before asking <code>omega</code> to solve it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"trunc\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">len_mk</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n<span class=\"w\">    </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"s2\">\"Failed to prove truncation property.\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 495389420,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737587081
    },
    {
        "content": "<p>While I have also used it for some autoParams, probably the more useful thing to know is what to do when it doesn't work. If you write <code>[m]ₙ</code> and get the error \"Failed to prove truncation property\", you can instead write <code>[m, by ...]ₙ</code> to prove the truncation property manually.</p>",
        "id": 495389771,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737587275
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> if you have a chance, could you take a quick look at the two comment threads on <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>? I am in the midst of refactoring the refactor, and I'm not sure what to do with the case <code>n = 0</code>. The problem seems to be that both the spine and the <code>StrictSegal</code> condition make sense for <code>0</code>-simplices / paths of length <code>0</code> in a simplicial set, but not for truncated simplicial sets (because <code>Path</code> is not defined for <code>0</code>-truncated simplicial sets).</p>",
        "id": 495904384,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737838498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/495389771\">said</a>:</p>\n<blockquote>\n<p>While I have also used it for some autoParams, probably the more useful thing to know is what to do when it doesn't work. If you write <code>[m]ₙ</code> and get the error \"Failed to prove truncation property\", you can instead write <code>[m, by ...]ₙ</code> to prove the truncation property manually.</p>\n</blockquote>\n<p>This suggests that the error message should be replaced with \"Failed to prove truncation property, try writing <code>[m, by ...]ₙ</code>.\"!</p>",
        "id": 496110743,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737981063
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21331\">#21331</a> is an experiment with yet another definition of paths for truncated simplicial sets. The basic definitions are below.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Mathlib/AlgebraicTopology/SimplicialSet/Path.lean</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">Horn</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Opposite</span><span class=\"w\"> </span><span class=\"n\">Simplicial</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">SSet</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Truncated</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">SimplicialObject</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span>\n\n<span class=\"sd\">/-- A path of length `m` in a 0-truncated simplicial set `X` consists of `m + 1`</span>\n<span class=\"sd\">0-simplices in `X`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Path₀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">vertex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">₀</span>\n\n<span class=\"sd\">/-- A path `f` of length `m` in a 1-truncated simplicial set `X` is a directed</span>\n<span class=\"sd\">path of `m` edges. The vertices of `f` live in the further 0-truncation of `X`.  -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Path₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Path₀</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">trunc</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- A path includes the data of `m` 1-simplices in `X`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">₁</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The source of a 1-simplex in a path is identified with the source vertex</span>\n<span class=\"sd\">  in the further 0-truncation of `X`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">arrow_src</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">vertex</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The target of a 1-simplex in a path is identified with the target vertex</span>\n<span class=\"sd\">  in the further 0-truncation of `X`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">arrow_tgt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">vertex</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"sd\">/-- A path of length `m` in an `n`-truncated simplicial set `X` includes the</span>\n<span class=\"sd\">data of `m + 1` vertices — 0-simplices in the further 0-truncation of `X`. If</span>\n<span class=\"sd\">`X` contains 1-simplices (`n &gt; 0`), then a path in `X` additionally contains the</span>\n<span class=\"sd\">data of `m` arrows — 1-simplices in the further 1-truncation of `X`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Path₀</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Path₁</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Truncated</span>\n\n<span class=\"sd\">/-- A path of length `n` in a simplicial set `X` is defined by 1-truncating `X`,</span>\n<span class=\"sd\">then taking the 1-truncated path. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">truncation</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- Alternatively, the below definition works well with the inductive definition</span>\n<span class=\"c1\">-- of `StrictSegal`.</span>\n\n<span class=\"sd\">/-- Unfolding the definition of `Truncated.Path`, a path of length `n + 1` in a</span>\n<span class=\"sd\">simplicial set `X` is defined as a `Truncated.Path₁` structure on the</span>\n<span class=\"sd\">1-truncation of `X`. A path of length 0 in `X` is defined as a `Truncated.Path₀`</span>\n<span class=\"sd\">structure on the 0-truncation of `X`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Path'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">truncation</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">SSet</span>\n</code></pre></div>\n</div></div>",
        "id": 497280208,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738521676
    },
    {
        "content": "<p>I think we have a variety of alternative definitions now that we can \"plug and play\". This version of truncated paths is a bit more complicated, but it does allow us to talk about paths in 0-truncated simplicial sets.</p>\n<p>The next step is probably to choose the simplest combination of these definitions that work for what we need right now, then we can always incorporate more complexity if we find that it's needed.</p>",
        "id": 497281002,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738522319
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 497283253,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738524152
    },
    {
        "content": "<p>My preference is to simply ignore <code>0</code>-truncated simplicial sets when defining paths and <code>StrictSegal</code>.</p>",
        "id": 497283650,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738524493
    },
    {
        "content": "<p>(Note that the definition <code>Path₀</code> above is not very sound, mathematically speaking. According to it, if <code>X</code> is <code>0</code>-truncated, there would be a path of length <code>1</code> between two arbitrary <code>0</code>-simplices, which we certainly do not want.)</p>",
        "id": 497283999,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738524752
    },
    {
        "content": "<p>Yes, I think calling <code>Path₀</code> a path is a bit of a stretch.</p>",
        "id": 497285235,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738525684
    },
    {
        "content": "<p>I appreciate all the input on my various experiments here. I think the conclusion is that we want to keep the definitions in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21146\">#21146</a> (although I'm not sure of the state of that branch). I will get it cleaned up and back into a reviewable state.</p>",
        "id": 497285561,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738525980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> do you foresee needing <code>Path</code> or <code>StrictSegal</code> to be defined for 0-truncated simplicial sets? </p>\n<p>It seems to me that we mostly want to work with truncated simplicial sets where the truncation level is fixed (and nonzero), so I'm inclined to agree with <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>'s suggestion to ignore 0-truncated simplicial sets for now. It shouldn't be too difficult to go back and include them in the definitions if we discover a need for them.</p>",
        "id": 497285915,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738526236
    },
    {
        "content": "<p>I agree that makes sense as the best way forward.</p>",
        "id": 497286621,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1738526805
    },
    {
        "content": "<p>I've been (mostly) holding off reworking the proof that the homotopy category functor is left adjoint to the nerve until this is done, but you can see a few of the constructions I'll need in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a>.</p>",
        "id": 497286688,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1738526874
    },
    {
        "content": "<p>One thing I use is this where <code>OneTruncation₂</code> is the underlying <code>ReflQuiver</code> of a 2-truncated simplicial set. Note this is definable in fact for 1-truncated simplicial sets though we use it in the 2-truncated case. One thing I'll have to experiment with, I guess, is whether giving the more general forms of the construction make them less usable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A refl prefunctor between the underlying refl quivers of a 2-truncated simplicial sets induces a</span>\n<span class=\"sd\">map on paths. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reflPrefunctorPathMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path₂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">vertex</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">vertex</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_src</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_tgt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge</span>\n<span class=\"w\">      </span><span class=\"n\">arrow_src</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_src</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_tgt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">src_eq</span>\n<span class=\"w\">      </span><span class=\"n\">arrow_tgt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_src</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">arrow_tgt</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tgt_eq</span>\n</code></pre></div>",
        "id": 497286900,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1738527049
    },
    {
        "content": "<p>That is used to show that under a hypothesis a <code>ReflPrefunctor</code> between reflexive quivers that arise in this way actually extends to a map of 2-truncated simplicial sets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The components of a map of 2-truncated simplicial sets built from a map on underlying reflexive</span>\n<span class=\"sd\">quivers, under the assumption that the codomain is `StrictSegal`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toStrictSegal₂</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StrictSegal₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">edge</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">StrictSegal₂</span><span class=\"bp\">.</span><span class=\"n\">spineToSimplex₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reflPrefunctorPathMap</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">spine₂</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toStrictSegal₂</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">StrictSegal₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"n\">OneTruncation₂</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ev02₂</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">edge</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">StrictSegal₂</span><span class=\"bp\">.</span><span class=\"n\">spineToDiagonal₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reflPrefunctorPathMap</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spine₂</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">toStrictSegal₂</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">unop</span>\n<span class=\"w\">  </span><span class=\"n\">naturality</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>where the proof of naturality is long and tedious. This is used to construct the unit of the adjunction.</p>",
        "id": 497287060,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1738527177
    },
    {
        "content": "<p>This is all helpful, thanks.</p>",
        "id": 497287747,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738527792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/497286688\">said</a>:</p>\n<blockquote>\n<p>I've been (mostly) holding off reworking the proof that the homotopy category functor is left adjoint to the nerve until this is done.</p>\n</blockquote>\n<p>Hopefully this refactor will be in a more stable state soon. It will still be blocked on the question of notation, but there are some options for working around this so that it doesn't hold up any other work:</p>\n<ul>\n<li>Make <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> independent of the notation PRs.</li>\n<li>Rebase <a href=\"https://github.com/leanprover-community/mathlib4/pull/20090\">#20090</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> once the latter is more stable.</li>\n</ul>",
        "id": 497288108,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738528037
    },
    {
        "content": "<p>I assume you mean <a href=\"https://github.com/leanprover-community/mathlib4/pull/21146\">#21146</a> instead of <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a>?</p>",
        "id": 497289455,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738529128
    },
    {
        "content": "<p>That was confusing, apologies. My plan is to merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/21146\">#21146</a> into <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> for review, but I am indeed talking about the content currently in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21146\">#21146</a>.</p>",
        "id": 497289561,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738529223
    },
    {
        "content": "<p>I like this plan. I feel like the notation will be easy to update later so if we can avoid being blocked on this now, that would be great! I appreciate your diligent efforts on all of this &lt;3</p>",
        "id": 497290041,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1738529697
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> is now notation-free and ready for review. Thanks to everyone who has already given feedback on the new definitions.</p>",
        "id": 497720517,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738690278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> should I rebase <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>? As I think we definitely want your proofs wherever the two conflict.</p>",
        "id": 497721000,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738690429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/497721000\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> should I rebase <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>? As I think we definitely want your proofs wherever the two conflict.</p>\n</blockquote>\n<p>This would be less work for me if you do so, then I would not say no!</p>",
        "id": 497726057,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738692079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776338\">Nick Ward</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/the.20homotopy.20category.20functor.20and.20the.20nerve.20adjunction/near/497721000\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> should I rebase <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> on top of <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>?</p>\n</blockquote>\n<p>Done in commit <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668/commits/0b22a2e8127c97c36e6776cee0e6f7dbe1d05e79\"><code>0b22a2e</code></a>. In the process I uncovered some ugliness that I believe is caused by the change to the definition of <code>SSet.Path</code> (specifically <code>SSet.Path.arrow</code>). I will see if I can't rectify this.</p>",
        "id": 497750729,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738700956
    },
    {
        "content": "<p>You can see the problem by grepping for <code>@id</code> in the commit linked above.</p>",
        "id": 497750983,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738701053
    },
    {
        "content": "<p>It seems you have found a solution :)</p>",
        "id": 497758560,
        "sender_full_name": "Joël Riou",
        "timestamp": 1738703992
    },
    {
        "content": "<p>Indeed! Although I have raised a related question on <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> related to the definitional properties of <code>SSet.Path</code>.</p>",
        "id": 497759745,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738704448
    },
    {
        "content": "<p>I think I mostly managed to avoid damaging any of the nice proofs in <a href=\"https://github.com/leanprover-community/mathlib4/pull/21090\">#21090</a>.</p>",
        "id": 497760263,
        "sender_full_name": "Nick Ward",
        "timestamp": 1738704634
    },
    {
        "content": "<p>The truncated paths refactor in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> is now merged. Thanks to <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> and <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> for lots of early feedback and review!</p>",
        "id": 509506941,
        "sender_full_name": "Nick Ward",
        "timestamp": 1743527676
    },
    {
        "content": "<p>Congrats. I really REALLY appreciate this. Next week I'll try to apply this to golf some of the worst proofs in the nerve adjunction. I'm sure I'll have questions for you then.</p>",
        "id": 509733904,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1743608801
    }
]