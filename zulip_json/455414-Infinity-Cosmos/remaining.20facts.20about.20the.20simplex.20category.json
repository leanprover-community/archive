[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> I have a bit of capacity to work on a few things, and was wondering if there's any good self contained tasks open on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span>, I think 1.2.4 of the blueprint is just lacking the uniqueness of the epi-mono-factorization?</p>",
        "id": 525895256,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1750941669
    },
    {
        "content": "<p>Yes, uniqueness was not part of what I proved when proving that the simplex category has generators and relations.</p>\n<p>To state this, I think this could be worth to introduce a typeclass asserting that a morphism property has <em>unique</em> factorization with respect to an other. This is a slightly evil notion because it bundles an equality of objects, but given that \"strict\" factorization systems like this are part of the definition of a Reedy category (or Cisinski’s variant that he calls \"Eilenberg-Zilber categories\" in his book (def 1.3.1 <a href=\"https://cisinski.app.uni-regensburg.de/CatLR.pdf\">here</a>)) of which the simplex category is an example, maybe it’s a \"necessary evil\" we’ll want at some point? Maybe <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has an opinion on the value of such a def?</p>",
        "id": 525898534,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750942624
    },
    {
        "content": "<p>Mathlib already knows about the (essential) uniqueness of the epi/mono factorization in the <code>SimplexCategory</code> (I used it already when I formalized the Dold-Kan equivalence), see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimplexCategory.instHasStrongEpiMonoFactorisations#doc\">docs#SimplexCategory.instHasStrongEpiMonoFactorisations</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.functorialEpiMonoFactorizationData#doc\">docs#CategoryTheory.Limits.functorialEpiMonoFactorizationData</a> and the definitions nearby.</p>",
        "id": 525901549,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750943519
    },
    {
        "content": "<p>I can think of two things around <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> that could be nice to have, but they’re not part of the blueprint and I’ll let <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> decide if they’re valuable or not within the framework of the Infinity-Cosmos project:</p>\n<ul>\n<li>\n<p>Something that could be nice to investigate (but that would need for my series of PR to be fully merged) would be to also describe truncated simplex categories by generators and relations, this is a bit boring though, as it’s basically redoing the definition of <code>SimplexCategoryGenRel</code> with an extra parameter <code>n : N</code>, and have explicit <code>Fin n</code> parameters in the morphisms. I do wonder if <code>ENNat</code> would help us have something unified.</p>\n</li>\n<li>\n<p>We also don’t have finality (or cofinality? I always mix them up...) of the inclusion of 2-trucated simplex category  (in fact, the k-truncated for k&gt;1) in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span>, so that colimits of simplicial objects \"are just\" colimits of their 2-truncation (which happen to be reflexive coequalizers if we prove that the 2-trucated simplex category is equivalent to the walking reflexive coequalizer, which would be almost tautological with the previous point). This fact shows that the colimit functor on simplicial sets commutes with finite products (we could probably also directly prove it is sifted), which I find is a nice fact.</p>\n</li>\n</ul>",
        "id": 525901632,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750943538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> my point was that in the case of the simplex category, we have the stronger statement of strict uniqueness rather than essential uniqueness. Would you say that actually we could make things like Reedy categories work with essential uniqueness everywhere? In the litterature they require strict uniqueness as far as I know.</p>",
        "id": 525902101,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750943690
    },
    {
        "content": "<p>Mathlib also knows that in <code>SimplexCategory</code>, two isomorphic objects are equal and the iso must be the identity, so that essential uniqueness implies strict uniqueness. I am not saying more than that.</p>",
        "id": 525903339,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750944019
    },
    {
        "content": "<p>I never said the proof was hard :D, but I was asking wether or not a typeclass encoding strict factorizations (that the simplex category would easily instanciate with this argument) would be a good idea.</p>",
        "id": 525904035,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750944188
    },
    {
        "content": "<p>Lemmas asserting the strict uniqueness of the factorization would not be very good looking... Unless we have more applications, I am not sure we need to create a new typeclass for that.</p>",
        "id": 525905069,
        "sender_full_name": "Joël Riou",
        "timestamp": 1750944483
    },
    {
        "content": "<p>Ok, so let’s wait until we actually run into more strict factorization systems then.</p>",
        "id": 525905811,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1750944677
    },
    {
        "content": "<p>Okay, didn't know we had essential uniqueness, that does indeed seem like it's enough</p>",
        "id": 525910049,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1750945983
    },
    {
        "content": "<p>Thanks for the suggestions, <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> !</p>",
        "id": 525910116,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1750946001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"286014\">Robin Carlier</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/remaining.20facts.20about.20the.20simplex.20category/near/525901632\">said</a>:</p>\n<blockquote>\n<ul>\n<li>We also don’t have finality (or cofinality? I always mix them up...) of the inclusion of 2-trucated simplex category  (in fact, the k-truncated for k&gt;1) in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span>, so that colimits of simplicial objects \"are just\" colimits of their 2-truncation (which happen to be reflexive coequalizers if we prove that the 2-trucated simplex category is equivalent to the walking reflexive coequalizer, which would be almost tautological with the previous point). This fact shows that the colimit functor on simplicial sets commutes with finite products (we could probably also directly prove it is sifted), which I find is a nice fact.</li>\n</ul>\n</blockquote>\n<p>We don't have the factorization of a morphism <code>Δ ⟶ Δ₁</code> with <code>Δ₁.len ≤ n</code> in <code>SimplexCategory</code> yet, that goes via <code>⦋n⦌</code>?</p>",
        "id": 526072469,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751026939
    },
    {
        "content": "<p>(I don't even find the right function on <code>Fin</code> that would be the second leg of that factorization)</p>",
        "id": 526072629,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751027006
    },
    {
        "content": "<p>If you can’t find it then we probably don’t have it... Since the simplex category is a split epi category, we could just build an epi from <code>⦋n⦌</code> to <code>Δ</code> for every <code>∆</code> of lenght <code>≤ n</code> (just by composing degeneracies), then take a section of that epi (which is automatically a mono), and compose <code>Δ ⟶ Δ₁</code> with this section?</p>",
        "id": 526074277,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751027610
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/26475\">#26475</a> fwiw, but that can be generalized at least to arbitrary full subcategory inclusions where the subcategory contains either a terminal or an initial object.</p>",
        "id": 526087053,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751031873
    },
    {
        "content": "<p>Turns out my suggestion was bogus in the way I phrased it and I feel very sorry for not stating things correctly and making you work on it before properly checking...</p>\n<p>It is true that any inclusion of a full subcategory containing the <del>initial</del> terminal object is final: in terms of colimits, this is telling us that the colimit of something out of the big category is the same as the colimit of something out of the  subcategory (via restriction), and since there is a <del>initial</del> terminal object, in both case, colimits are given by evaluation at the <del>initial</del> termial object. In the case of the simplex category, this translates to a statement colimits of <em>co</em>simplicial objects.</p>\n<p>What I really meant to ask was this inclusion, for <code>n &gt; 0</code> is <em>initial</em> (that’s what I was meaning in my original post when mulling over \"final vs cofinal\"), so that we can translate it to the statement about <em>co</em>limits of <em>simplicial</em> objects (no co) (or limits  of simplicial objects). What I was talking about when I mentioned colimits of simplicial objects being reflexive coequalizers really requires initiality (a.k.a cofinality) of that inclusion, and this one I believe is trickier and only valid for <code>n &gt; 0</code>.</p>",
        "id": 526092606,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751033451
    },
    {
        "content": "<p>Yes, I suspected that, since the result was entirely trivial (and I didn't need the map I mentioned above).</p>",
        "id": 526093265,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751033667
    },
    {
        "content": "<p>Apologies again... I always get tangled into the initial vs final mess.</p>",
        "id": 526093651,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751033763
    },
    {
        "content": "<p><del>Will still generalize the result (and maybe remove the concrete instantiation)</del></p>\n<p>Nvm, it's probably not worth it, since as you say, <code>colimitOfTerminal</code> gives us everything to evaluate those colimits anyway</p>",
        "id": 526093670,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751033767
    },
    {
        "content": "<p>I guess if you want to generalize the result (for subcategories w/ a final object I mean), mathlib knows that if an object <code>x : C</code>is terminal, then the (fully faithful) functor from <code>PUnit</code> to <code>C</code> sending unit to <code>x</code> is final (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.final_fromPUnit_of_isTerminal#doc\">docs#CategoryTheory.Functor.final_fromPUnit_of_isTerminal</a>) and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Fnuctor.Final.final_iff_final_comp#doc\">docs#CategoryTheory.Fnuctor.Final.final_iff_final_comp</a></p>",
        "id": 526095019,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751034107
    },
    {
        "content": "<p>But yeah, in the end for colimit-computation purposes colimitOfTerminal does everything.</p>",
        "id": 526095384,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751034190
    },
    {
        "content": "<p>Repurposed <a href=\"https://github.com/leanprover-community/mathlib4/pull/26475\">#26475</a> to just show that 0 is terminal.</p>",
        "id": 526104335,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751036751
    },
    {
        "content": "<p>Very late to weigh in here but as illustrated by <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>'s confusions, I'm strongly in favor of \"initial functor\" to generalize the case of including an initial object and \"final functor\" to generalize the case of including a final object. Note this contradicts (but improves upon) the original historical terminology.</p>\n<p>A functor <code>k : I -&gt; J</code> is initial iff any cone over a J-shaped diagram is a limit cone iff its restriction along k to a cone over an I-shaped diagram is a limit cone. Dually, a functor <code>k : I -&gt; J</code> is final if it has the same property for colimits. </p>\n<p>Note the inclusion of the 1-truncated simplex category (spanned by just the objects 0 and 1) into Δ is initial; this was eroniously called the \"2-truncated simplex category\" above.</p>",
        "id": 526261300,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751193573
    },
    {
        "content": "<p>Yes, my confusions are not just with initial/final, but also with indices <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I was meaning the one spanned by 0 and 1 indeed.</p>",
        "id": 526263880,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751196828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> Yes, the definitions of initial and final functors that we have in mathlib are equivalent to this, but defined as the category of (co)structured arrows being connected.</p>",
        "id": 526264582,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751197756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/remaining.20facts.20about.20the.20simplex.20category/near/526104335\">said</a>:</p>\n<blockquote>\n<p>Repurposed <a href=\"https://github.com/leanprover-community/mathlib4/pull/26475\">#26475</a> to just show that 0 is terminal.</p>\n</blockquote>\n<p>As Joël noted there, we had done something similar in another PR, which I've added you to. (I also used your code to improve ours.) We needed this fact to show that <code>hoFunctor : SSet -&gt; Cat</code> is lax monoidal, in this case preserving the terminal object and binary products. <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> if you have any suggestions on anything you see in there, they would be very welcome.</p>",
        "id": 526267572,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751200992
    },
    {
        "content": "<p>Regarding self contained tasks on Δ, anything that makes its truncations easier to work with would be very welcome <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> . If you look at the top of the <code>HomotopyCat</code> file under <code>SimplicialSet</code> in mathlib, you'll find some API that Mario and I developed specific to the 2-truncated case. Essentially we reproved a bunch of simplicial identities in that special case because we found them hard to use when we needed them. <span class=\"user-mention\" data-user-id=\"879277\">@Julian Komaromy</span> had similar issues with 2-truncated quasi-categories (in the infinity cosmos repository).</p>\n<p>And all this should be extended to n-truncated things.</p>",
        "id": 526268086,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751201617
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>  Initiality shown in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26490\">#26490</a>. (Tell me if I should remove the helper construction in <code>Limits.Final</code> that I ended up not using at all)</p>",
        "id": 526275941,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751209959
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/remaining.20facts.20about.20the.20simplex.20category/near/526268086\">said</a>:</p>\n<blockquote>\n<p>Regarding self contained tasks on Δ, anything that makes its truncations easier to work with would be very welcome <span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> . If you look at the top of the <code>HomotopyCat</code> file under <code>SimplicialSet</code> in mathlib, you'll find some API that Mario and I developed specific to the 2-truncated case. Essentially we reproved a bunch of simplicial identities in that special case because we found them hard to use when we needed them. <span class=\"user-mention silent\" data-user-id=\"879277\">Julian Komaromy</span> had similar issues with 2-truncated quasi-categories (in the infinity cosmos repository).</p>\n<p>And all this should be extended to n-truncated things.</p>\n</blockquote>\n<p>You mean having more identities hardcoded in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mrow><mo>≤</mo><mi>n</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_{\\le n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9285em;vertical-align:-0.2452em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2952em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2452em;\"><span></span></span></span></span></span></span></span></span></span> with suitable autoparams?</p>",
        "id": 526352165,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751273962
    },
    {
        "content": "<p>Oh and speaking of monoidal functors, would it actually be helpful to have the monoidal structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> (with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo stretchy=\"false\">]</mo><mo>⊗</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo stretchy=\"false\">[</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[m] \\otimes [n] = [m + n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span>) as well?</p>",
        "id": 526389461,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751286451
    },
    {
        "content": "<p>I have an open PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/25743\">#25743</a>) that puts a monoidal structure on the <em>augmented</em> simplex category which corresponds to ordinal sum and is given by <code> n \\ot m = n + m + 1</code>. I intend to use this (+ my ongoing series of PR on Day convolution) to define joins of (augmented) simplicial sets and monoidal Bar constructions.</p>",
        "id": 526391930,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751287259
    },
    {
        "content": "<p>Do you know by heart if the infrastructure for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> to inherit that monoidal structure is already there (i.e. as a full subcat containing the unit or so)</p>",
        "id": 526582427,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751367927
    },
    {
        "content": "<p>Ah yes, we have that :)</p>",
        "id": 526582893,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751368098
    },
    {
        "content": "<p>It doesn't contain the unit, the unit in the augmented simplex category is the initial object that is added.<br>\nI don't think there is a nice monoidal structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span>... With the formula you gave, I'm not sure how to define the whisker lefts and whisker right other than by putting identities (which basically \"ignores\" the morphisms of the simplex category and only care about its discrete subcategory in its type of object)</p>",
        "id": 526583047,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751368154
    },
    {
        "content": "<p>Ah, yes, off-by-one error in my head, you're right</p>",
        "id": 526584212,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751368557
    },
    {
        "content": "<p>Yes this is always confusing. Kudos on defining that monoidal structure.</p>",
        "id": 527067853,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751574154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> or <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>  if you want to construct something fun you could use the monoidal structure on the augmented simplex category to define a strict bicategory Adj which has the universal property of being the free 2-category containing an adjunction. It has:</p>\n<ul>\n<li>two objects we can call + and - </li>\n<li>hom(+,+) = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> (the augmented simplex category)</li>\n<li>hom(-,-) = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Δ</mi><mo>+</mo><mrow><mi>o</mi><mi>p</mi></mrow></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Delta_+^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0642em;vertical-align:-0.2819em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7823em;\"><span style=\"top:-2.4765em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span><span style=\"top:-3.1809em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span></span></span></span> (its opposite; also the subcategory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> containing maps that preserve both the top and bottom element in each ordinal)</li>\n<li>hom(-,+) = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mi mathvariant=\"normal\">⊤</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_\\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊤</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (the subcategory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> containing only the maps that preserve the top element in each ordinal)</li>\n<li>hom(+,-) = <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mi mathvariant=\"normal\">⊥</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_\\bot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊥</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (the subcategory of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> containing only the maps that preserve the bottom element in each ordinal; also the opposite of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mi mathvariant=\"normal\">⊤</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_\\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">⊤</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>)</li>\n</ul>\n<p>Composition is defined by ordinal sum and its restriction to the various subcategories.</p>",
        "id": 527068301,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751574400
    },
    {
        "content": "<p>The original reference is \"The free adjunction\" by Schanuel and Street but a few more details are in definition 9.1.1 <a href=\"https://emilyriehl.github.io/files/more-elements.pdf\">here</a></p>",
        "id": 527068500,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751574496
    },
    {
        "content": "<p>Thanks for the suggestion and reference! The definition in itself should be doable, but I don’t see myself tackling the proof that it is the free adjunction just yet (as mentioned above, one of my current focus is to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> is the free monoid, which is already painful enough formally..., looks like chapter 10 of the PDF might contains things that could interest me in that regard).</p>",
        "id": 527069403,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1751574983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/455414-Infinity-Cosmos/topic/remaining.20facts.20about.20the.20simplex.20category/near/526268086\">said</a>:</p>\n<blockquote>\n<p>If you look at the top of the <code>HomotopyCat</code> file under <code>SimplicialSet</code> in mathlib, you'll find some API that Mario and I developed specific to the 2-truncated case.</p>\n</blockquote>\n<p>Generalized those abbreviations as <code>Truncated.δ</code> and <code>Truncated.σ</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26738\">#26738</a>. To keep using a subscript for the truncation level, we'd have to use different characters, maybe underlined ones like <code>δ̲ </code></p>",
        "id": 527175097,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1751633441
    },
    {
        "content": "<p>It wasn't ever obvious to me that the subscripts were a good idea. <span class=\"user-mention\" data-user-id=\"879277\">@Julian Komaromy</span> or <span class=\"user-mention\" data-user-id=\"776338\">@Nick Ward</span> do you have opinions about this API?</p>",
        "id": 527266296,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1751706322
    },
    {
        "content": "<p>I personally don't need anything other than the 2-truncated stuff, and I don't know if other truncation levels are going to be important elsewhere.  As to using subscripts or not, I don't really have an opinion.</p>",
        "id": 527334325,
        "sender_full_name": "Julian Komaromy",
        "timestamp": 1751792658
    }
]