[
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20688\">mathlib4#20688</a> introduces the following notations: </p>\n<ul>\n<li><code>[m]ₙ</code> denotes the <code>m</code>-dimensional simplex in the <code>n</code>-truncated simplex category. The proof <code>p : m ≤ n</code> can also be provided directly using the syntax <code>[m, p]ₙ</code>.</li>\n<li><code>X _[m]ₙ</code> denotes the <code>m</code>-th term of an <code>n</code>-truncated (co)simplicial object <code>X</code>. The proof <code>p : m ≤ n</code> can also be provided directly using the syntax <code>X _[m, p]ₙ</code>.</li>\n</ul>",
        "id": 493449854,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736802620
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/20719\">mathlib4#20719</a> provides a custom delaborator for the notation <code>[m]ₙ</code>, and the plan is to do the same for the <code>X _[m]ₙ</code> notation soon.</p>",
        "id": 493450362,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736802785
    },
    {
        "content": "<p>The reason for this thread is to solicit any advice or opinions on these notations and how they should be pretty-printed.</p>",
        "id": 493450679,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736802900
    },
    {
        "content": "<p>For instance, it's not obvious to me whether the subscript notation will be clear enough in the infoview (though this is currently what the delaborator uses, see the file <code>MathlibTest/SimplexCategory.lean</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20719\">#20719</a>).</p>",
        "id": 493451225,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736803053
    },
    {
        "content": "<p>Any feedback on the notations or the implementation is appreciated!</p>",
        "id": 493451481,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736803124
    },
    {
        "content": "<p>This thread might be a good place to confess that I don't know how to type \"n+1\" in a subscript (and thus have been doing a lot of copy pasting). I've been typing \\_n to get a subscript n.</p>",
        "id": 493458395,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1736805634
    },
    {
        "content": "<p>Generally you can just type \\_ before the character you want</p>",
        "id": 493459131,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1736805892
    },
    {
        "content": "<p>I also find getting a subscripted \"n+1\" to be a bit inconvenient. I think the most direct way (in vim) is to type \\_n,  leave insert mode (or do whatever is needed to activate your unicode replacement), then type \\_+, leave insert mode again, then type \\1.</p>",
        "id": 493460350,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736806300
    },
    {
        "content": "<p>In both VSCode and lean.nvim you can define a custom abbreviation if this kind of thing gets annoying, just in case that's helpful to mention (though  every person who types things ends up needing to do so).</p>",
        "id": 493460576,
        "sender_full_name": "Julian Berman",
        "timestamp": 1736806364
    },
    {
        "content": "<p>This, along with the fact that not all characters can be subscripted in unicode, could be a reason to go a different way with the notation (something like <code>[n]_m</code>)</p>",
        "id": 493460601,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736806372
    },
    {
        "content": "<p>Good point <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>. I guess the question also depends on whether <code>n + 1</code> is as expressive as we will need to be for the truncation level.</p>",
        "id": 493460901,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736806469
    },
    {
        "content": "<p>Related to the notation question above, I have decided we may need something like the definition below in order to avoid the proliferation of abbrevs like <code>SSet.δ₂</code> <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/AlgebraicTopology/SimplicialSet/HomotopyCat.lean#L53-L55\">here</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">Truncated</span><span class=\"bp\">.</span><span class=\"n\">mkHom</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trunc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trunc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Truncated</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>I believe the reason we need this is that, for all <code>a, b ≤ n</code>, <code>[a] ⟶ [b]</code> is defeq to <code>[a]ₙ ⟶ [b]ₙ</code>, but these types are not syntactically equal. So (I think) type ascription (as in <code>((δ 1) : [a]ₙ ⟶ [b]ₙ)</code>) or coercions are not useful here. We could always write morphisms in the truncated simplex category as <code>@id ([a]ₙ ⟶ [b]ₙ) (SimplexCategory.δ 1)</code>, but at that point we might as well use an explicit wrapper like <code>mkHom</code> above.</p>\n<p>I have a couple of questions about this:</p>\n<ul>\n<li>Is there a better solution I'm missing?</li>\n<li>Should <code>mkHom</code> be an <code>abbrev</code> or a <code>def</code>? </li>\n<li>I would think <code>abbrev</code>, but <code>SimplexCategory.Hom.toOrderHom</code> is a similar construction that uses <code>def</code>. Does anyone understand the reason this was chosen?</li>\n<li>What namespace does this belong in? Do we want to be writing <code>Truncated.mkHom (δ 1)</code> or <code>(δ 1).toTruncatedHom</code>?</li>\n<li>Should we make this a notation? Something like <code>⟨δ 1⟩ₙ</code> could work, but this always requires specifying the truncation level (which from some brief experiments can usually be inferred).</li>\n</ul>",
        "id": 493993295,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736966487
    },
    {
        "content": "<p>To be clear, if <code>X : SSet.Truncated n</code>, we can always just write <code>X.map (δ 1).op</code>. The reason for wanting to explicitly coerce  <code>δ 1</code> to be of type <code>[a]ₙ ⟶ [b]ₙ</code> (as in <code>X.map (mkHom (δ 1)).op</code>) is to avoid needing <code>erw</code> everywhere.</p>",
        "id": 493994241,
        "sender_full_name": "Nick Ward",
        "timestamp": 1736966817
    },
    {
        "content": "<p>Pinging the authors <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> of the SimplexCategory file.</p>",
        "id": 494410695,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737136356
    },
    {
        "content": "<p>This seems very useful to me. I imagine this would be called most often from within the <code>Truncated</code> namespace, so the name <code>Truncated.mkHom</code> would just be <code>mkHom</code>, which feels intuitive (this is how you make the arrows).</p>",
        "id": 494410852,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737136420
    },
    {
        "content": "<p>For reference, I've now implemented this change in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20668\">#20668</a> (calling it <code>SimplexCategory.Truncated.Hom.tr</code>). I was able to get rid of all of the <code>erw</code>s, but would still be very appreciative of any suggestions or preferences regarding e.g. naming or notation.</p>",
        "id": 494414227,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737137691
    },
    {
        "content": "<p>Getting rid of all the <code>erw</code> is a very good sign!</p>",
        "id": 494417861,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737139054
    },
    {
        "content": "<p>The new notations look good and useful to me. But I would appreciate if some (d)elaborator expert would also take a look at them.</p>",
        "id": 494418277,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737139208
    },
    {
        "content": "<p>If a(n) (d)elaborator expert does get a chance to take a look, the delaborator is broken out into <a href=\"https://github.com/leanprover-community/mathlib4/pull/20719\">#20719</a>.</p>",
        "id": 494458448,
        "sender_full_name": "Nick Ward",
        "timestamp": 1737157427
    }
]