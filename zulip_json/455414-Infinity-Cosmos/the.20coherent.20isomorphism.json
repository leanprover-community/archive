[
    {
        "content": "<p>A preliminary version of the homotopy coherent isomorphism is defined in a <a href=\"https://github.com/emilyriehl/infinity-cosmos/pull/11/commits\">branch</a>. We defined everything inductively and then proved a few simple lemmas with very inefficient inductive proofs. Golfing suggestions are very welcome. I'm also trying to determine whether <code>walkingIso</code> is already in mathlib.</p>",
        "id": 470754977,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726523837
    },
    {
        "content": "<p>I would not think <code>walkingIso</code> is already in mathlib, but is not it true that in this category, given two objects <code>X</code> and <code>Y</code>, there is exactly one morphisms from <code>X</code> to <code>Y</code>, in which case the definition of <code>Hom</code> could be just <code>Unit</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `A` should be replaced by a type-synonym in order to make an instance out of this</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n</code></pre></div>\n<p>Is there a canonical name for such a \"contractible\" category with a given set of objects <code>A</code>?</p>",
        "id": 470787322,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1726533818
    },
    {
        "content": "<p>Then, the main construction becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">WalkingIso.ofIso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"k\">fun</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.hom</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.inv</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 470789578,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1726534439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/stream/455414-Infinity-Cosmos/topic/the.20coherent.20isomorphism/near/470787322\">said</a>:</p>\n<blockquote>\n<p>I would not think <code>walkingIso</code> is already in mathlib, but is not it true that in this category, given two objects <code>X</code> and <code>Y</code>, there is exactly one morphisms from <code>X</code> to <code>Y</code>, in which case the definition of <code>Hom</code> could be just <code>Unit</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">category</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `A` should be replaced by a type-synonym in order to make an instance out of this</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n</code></pre></div>\n<p>Is there a canonical name for such a \"contractible\" category with a given set of objects <code>A</code>?</p>\n</blockquote>\n<p>I've seen it called the \"indiscrete\" or \"chaotic\" category, though \"contractible\" is perhaps an even better term. This defines the right adjoint to the forgetful functor <code>ob : Cat -&gt; Set</code>, whose right adjoint is given by the discrete category construction.</p>\n<p>It seems to me that this notion isn't in mathlib either. I have some students who are looking for a beginner project, so I might suggest this to them: define such categories (mirroring the existing definition of discrete categories) and construct these adjunctions.</p>",
        "id": 471034397,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726590906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span> we do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Discrete#doc\">docs#CategoryTheory.Discrete</a></p>",
        "id": 471035889,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726591365
    },
    {
        "content": "<p>Oh, I see, you're referring to the adjunction. Yes, you're right, we probably don't have that, although the API for <code>Discrete</code> does essentially give you the adjunction via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Discrete.functor#doc\">docs#CategoryTheory.Discrete.functor</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Discrete.natTrans#doc\">docs#CategoryTheory.Discrete.natTrans</a> etc.</p>",
        "id": 471035995,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726591398
    },
    {
        "content": "<p>Yes, I should have been clearer. Thanks for the suggestion.</p>",
        "id": 471042746,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726593262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Jo√´l Riou</span> <a href=\"#narrow/stream/455414-Infinity-Cosmos/topic/the.20coherent.20isomorphism/near/470789578\">said</a>:</p>\n<blockquote>\n<p>Then, the main construction becomes:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">‚ü®‚ü©</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">WalkingIso.ofIso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"k\">fun</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.hom</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.inv</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Could you explain <code>@fun</code>? In general, I don't know how to efficiently induct over multiple parameters, particularly implicit ones like we have here.</p>",
        "id": 471045864,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726594251
    },
    {
        "content": "<p><code>@fun</code> makes all the implicit variables explicit.</p>",
        "id": 471046010,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726594303
    },
    {
        "content": "<p>in this case (I think) you can just replace <code>  map := @fun</code> with <code>  map</code> (untested)</p>",
        "id": 471046220,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726594349
    },
    {
        "content": "<p>That's giving me a type mismatch error.</p>",
        "id": 471046436,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726594432
    },
    {
        "content": "<p>Ok, I was wrong. Anyway, maybe this version is clearer? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">WalkingIso.ofIso</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">WalkingIso</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.hom</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">e.inv</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">one</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 471046626,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726594481
    },
    {
        "content": "<p>The point is that the <code>map</code> field only has the morphism as an explicit parameter, with the two objects implicit. Doing <code>@fun</code> makes everything explicit, or alternatively you can match explicitly on the objects and morphism as I have done above.</p>",
        "id": 471046768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726594530
    },
    {
        "content": "<p>One subtle point to note is that you can't use recursion when defining a projection in a structure like this (IMO this is a defect that should be addressed). Here is an example illustrating how to get around this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">aux</span>\n<span class=\"n\">where</span><span class=\"w\"> </span><span class=\"n\">aux</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">aux</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Lean can't show termination for this:</span>\n\n<span class=\"cm\">def gg : F where</span>\n<span class=\"cm\">  f | 0 =&gt; 0</span>\n<span class=\"cm\">    | n+1 =&gt; gg.f n</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 471049122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726595192
    },
    {
        "content": "<p>Thanks this is a helpful explanation. A question I was asked in my tutorial yesterday that I couldn't answer was whether there's a way to get lean to automatically generate the cases for an induction (like Agda does). After I type match blah with I've been typing out the \"| case =&gt; sorry\" stuff manually for each case.</p>",
        "id": 471049502,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726595295
    },
    {
        "content": "<p>I know if you type \"induction X Y\" then you see the cases in infoview, but I find proofs written with \"match X Y\" to be much more readable.</p>",
        "id": 471049606,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726595331
    },
    {
        "content": "<p>Yes, that's done with code-actions. In vscode if you get the yellow lightbulb to pop up, one of the options would be \"generate skeleton for recursive definition\" (approx) as one of the options.</p>",
        "id": 471049694,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726595359
    },
    {
        "content": "<p>We don't have Agda's nice hole commands for case splitting on specific terms as far as I know.</p>",
        "id": 471049797,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726595390
    },
    {
        "content": "<p>For example, in the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">_</span>\n</code></pre></div>\n<p>if you put the cursor at the <code>_</code>, you should get such a lightbulb.</p>",
        "id": 471050191,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726595495
    },
    {
        "content": "<p>And indeed it seems that we don't have a nice code action for matching as in the following example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n</code></pre></div>\n<p>I wish we did have such an action though!</p>",
        "id": 471050444,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1726595552
    },
    {
        "content": "<p>One more (unrelated) question, while you're here. Do you know who accepts pull requests on the Lean blog? @herostrat made an announcement of this project for me, which is ready to go live if it meets with the moderators' approval:</p>\n<p><a href=\"https://github.com/leanprover-community/blog/pull/91\">https://github.com/leanprover-community/blog/pull/91</a></p>",
        "id": 471056534,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1726596866
    },
    {
        "content": "<p>I don't know who is allowed to pull the trigger but I left an approving review and raised a minor issue.</p>",
        "id": 471061267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726597977
    },
    {
        "content": "<p>There's a new file CoherentIso.lean which incorporates the suggestions made by several folks here. <span class=\"user-mention\" data-user-id=\"759801\">@Alvaro Belmonte</span> just contributed his very first lean code, in the file CodiscreteCat.lean on codiscrete categories.</p>",
        "id": 472339773,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727128879
    },
    {
        "content": "<p>It would be good to PR the codiscrete stuff to mathlib at some point, so feedback here would be very helpful. In particular, Alvaro gives two proofs that the codiscrete category functor is right adjoint to the object functor. I wasn't sure which is best. He could extract the data of the other and leave it as auxiliary definitions/theorems.</p>",
        "id": 472340034,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727129001
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A function induces a functor between codiscrete categories.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">funToFunc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Codiscrete</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">Codiscrete</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü©</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Codiscrete</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">funToFunc</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Adjunction</span><span class=\"w\"> </span><span class=\"n\">Cat</span>\n\n<span class=\"sd\">/-- For a category `C` and type `A`, there is an equivalence between functions `objects.obj C ‚ü∂ A`</span>\n<span class=\"sd\">and functors `C ‚•§ Codiscrete A`.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">homEquiv'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">objects</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lift</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">invlift</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- The functor that turns a type into a codiscrete category is right adjoint to the objects</span>\n<span class=\"sd\">functor.-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">objects</span><span class=\"w\"> </span><span class=\"bp\">‚ä£</span><span class=\"w\"> </span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkOfHomEquiv</span>\n<span class=\"w\">  </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">homEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">homEquiv'</span>\n<span class=\"w\">    </span><span class=\"n\">homEquiv_naturality_left_symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">homEquiv_naturality_right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A second proof of the same adjunction.  -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">adj'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">objects</span><span class=\"w\"> </span><span class=\"bp\">‚ä£</span><span class=\"w\"> </span><span class=\"n\">functor</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">      </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">‚ü®‚ü©</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">counit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">left_triangle_components</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">id_obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp_obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">right_triangle_components</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">id_obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">comp_obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">id_eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 472340305,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1727129128
    },
    {
        "content": "<p><code>adj'</code> looks like <code>aesop</code> can take care of the triangle identities (if that's the case the fields can be erased)</p>",
        "id": 472340764,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1727129334
    },
    {
        "content": "<p>I finish doing the PR# <a href=\"https://github.com/leanprover-community/mathlib4/pull/17174\">#17174</a> of codiscrete categories to mathlib. Since I am still pretty new to lean I don't know what else I could tackle, if there is anything else I could do for the project any pointers would be greatly appreciated.</p>",
        "id": 472969706,
        "sender_full_name": "Alvaro Belmonte",
        "timestamp": 1727382958
    }
]