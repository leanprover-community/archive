[
    {
        "content": "<p>I've now written up my preferred conventions for how to state IMO problems in Lean, if such statements are to be used as a challenge to AI or human solvers or formalizers. It also includes a more detailed geometry TODO list (list of geometry definitions that I think should be added to mathlib for cleanly stating all past IMO problems with geometrical elements) than my previous version that only looked at about ten years of problems.</p>\n<p><a href=\"https://github.com/jsm28/IMOLean\">https://github.com/jsm28/IMOLean</a></p>\n<p>I don't know if anyone has plans for using future IMOs as a formal-to-formal challenge, but if they do then I think it would be preferable for all entrants in a given year to use a single Lean version of the problems (modulo any complications around different entrants wanting to use different versions of mathlib), written according to conventions agreed in advance, and this is my initial suggestion for what such conventions should look like.</p>\n<p>I hope to add example statements following these conventions to this repository in future (somewhere between \"past few years\" and \"everything 2006 onwards for which definitions are in mathlib\"); they aren't ready yet because when I went to start writing them last night I ran into the problems with setting up / updating repositories using current mathlib.</p>",
        "id": 492177456,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736194769
    },
    {
        "content": "<p>Thanks a lot for putting your thoughts down! Yes, right now there is a cache issue, it will hopefully be fixed when 4.16-rc2 is released.</p>",
        "id": 492180750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736195947
    },
    {
        "content": "<p>A potential alternative to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">IMO1637P6</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">IMO1637P6</span>\n</code></pre></div>\n<p>would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">IMO1637P6</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Question</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">answer</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Question</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">IMO1637P6</span>\n</code></pre></div>\n<p>which means that you can perhaps drop <code>result</code> from the source file entirely</p>",
        "id": 492193391,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736200664
    },
    {
        "content": "<p>(which has the benefit of making the source file sorry-free)</p>",
        "id": 492193472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736200684
    },
    {
        "content": "<p>That does have the disadvantage of making things further from idiomatic Lean in the case of universally quantified statements (where as I've written it the hypotheses go before the colon as normal, but with this structure you'd have only <code>answer</code> before the colon in the definition of <code>Question</code>, I suppose, and everything else after it).</p>",
        "id": 492215422,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736209952
    },
    {
        "content": "<p>One advantage of this formalization is that it lets you state that two different formalizations of the question are equivalent to each other, without having to choose an answer to do so</p>",
        "id": 492216175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736210365
    },
    {
        "content": "<p>On another point, I think your plan to <code>#min_imports</code> is not a good one; this greatly increases the difficultly of bumping mathlib, as any file split is likely to leave you with broken imports. Of course, you could have a script that replaces all the imports with <code>import Mathlib</code>, updates lean, and re-minimizes, but I'm not sure what benefit the minimization is providing at this point.</p>",
        "id": 492216533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736210542
    },
    {
        "content": "<p>At least if the two formalizations choose the same type for <code>answer</code> (which in general they might not), otherwise you also need to provide a map between the types in the statement of equivalence.</p>",
        "id": 492216814,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736210635
    },
    {
        "content": "<p>(I didn't explicitly say it earlier, but despite my small quibbles this document is a great resource!)</p>",
        "id": 492217020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736210747
    },
    {
        "content": "<p>Using <code>#min_imports</code> is effectively just following idiomatic Lean/mathlib conventions; using <code>import Mathlib</code> would work equally well (and avoid AIs needing to add imports - though AIs might choose to remove imports internally if using Lean tactics to suggest intermediate steps that work better with fewer imports).</p>\n<p>One thing I don't have a sense of is how large the risk is, with minimized imports, that an AI that finds it needs to add imports to solve the problem also accidentally makes the statement no longer defeq to the original one (and so any solution no longer valid under the rules) because of different (propeq, hopefully, but not defeq) instances being found. We'd like the instances found with different imports to be defeq, but surely do have cases where that's not so.</p>",
        "id": 492217317,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736210901
    },
    {
        "content": "<p>Unfortunately, adding imports often results in compilation errors; for instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Nat.Factorial.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"c1\">-- syntax error with this line</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">scoped</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→+*</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>(edit: I previously said \"in the past\" referring to a similar clash with <code>π</code> notation)</p>",
        "id": 492217815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736211176
    },
    {
        "content": "<p>Most of these are cases of scoped notations sharing a namespace which should not, but I think it would be better to discover these in CI for your project (and then fix them in mathlib) than to have the AI agents discover them.</p>",
        "id": 492218238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736211399
    },
    {
        "content": "<p>Since I mentioned the issue of different AI entrants to a formal-to-formal challenge potentially wanting to use different mathlib versions, I should maybe elaborate on why I think there could be such an issue. Two things are in tension here:</p>\n<ul>\n<li>If an AI is trained with particular versions of mathlib and Lean, it will have learned lemma names, tactic usage etc. for those versions and may not work so well with other versions. This issue would tend to indicate AI entrants wanting an old version fixed well in advance of any challenge.</li>\n<li>But if the challenge wishes to encourage early sharing (like AIMO has its Early Sharing Prize), then you want any additions to Lean and mathlib to help solving IMO problems by AI (new lemmas, new or improved tactics, modifications to Lean to facilitate interaction with AIs, etc.) to be upstreamed by all entrants as they go along - you don't want entrants to hold onto those things for competitive advantage (and potentially end up producing solutions that start with a long sequence of prewritten lemmas and tactics). And being able to get the advantage of such early sharing requires using a recent mathlib version that has all the new features upstreamed by other entrants.</li>\n</ul>\n<p>There is also an argument here that if such a challenge wishes to promote more broadly useful AI then it's desirable for such AI to be able to adapt to new Lean and mathlib versions without requiring a huge amount of retraining, in which case it could be considered a feature for the rules to say \"the precise, recent version of mathlib master to be used will be announced shortly before the start of the competition\".</p>",
        "id": 492218340,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736211469
    },
    {
        "content": "<p>(Which could be the version of mathlib tagged to work with the most recent Lean release, for example.)</p>",
        "id": 492218534,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736211585
    },
    {
        "content": "<p>I second the idea that the latest stable version of Lean and Mathlib are used for the competition (modulo the slight technical issue if the competition is at the beginning of the month). </p>\n<p>This will favour systems that are more useful to Lean users and Mathematicians over those who purely use Lean to show technical AI skills.</p>",
        "id": 492239941,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1736223068
    },
    {
        "content": "<blockquote>\n<p>When a problem involves specific but arbitrary numbers (for example, the year of the competition), but only depends on more limited properties of such numbers (say, depends on the year being at least 3, or on it being an even number), it's likely appropriate in a formal solution to generalize to arbitrary N satisfying the required conditions</p>\n</blockquote>\n<p>I consider it is better to express the formalisation in terms of the original numbers rather than using the generalised version. To some extent using a more general statement could be a big hint towards the desired solution.</p>",
        "id": 492579862,
        "sender_full_name": "Marcelo Fornet",
        "timestamp": 1736368236
    },
    {
        "content": "<p>The quoted statement is talking about \"a formal <em>solution</em>\", not the problem statement, so generalization is appropriate I think.</p>",
        "id": 492593580,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736375187
    },
    {
        "content": "<p>Exactly. I've found that formalizing a solution often influences the formal problem statement. So problems in the mathlib archive and in compfiles may well have statements that were adjusted to make the solution more convenient to formalize, but that isn't wanted when giving a problem on its own as a challenge to a solver (or as a challenge to an autoformalizer along with a natural language solution, for that matter), hence this section discussing the differences between conventions for problems stated on their own and what might be appropriate for a problem accompanied by a solution.</p>",
        "id": 492617528,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1736389474
    },
    {
        "content": "<p>I've now changed the conventions to use <code>import Mathlib</code>, added statements of non-geometry problems from IMO 2022, 2023 and 2024 following these conventions (the IMO 2022 statements include some that don't currently have statements in Compfiles, though with the usual caveats about the risk of mistakes in a formal statement written without a solution), and expanded the conventions in various places based on writing those statements.</p>",
        "id": 496009888,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1737932261
    },
    {
        "content": "<p>I've also resurrected the old PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7478\">#7478</a> (defining congruence for indexed families of points) - as, while congruence is not among the missing geometry definitions for stating past IMO problems (no problems explicitly refer to congruence), I think it will be useful in setting up API for some of the missing definitions.</p>",
        "id": 496010147,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1737932425
    },
    {
        "content": "<p>I've now added statements of IMO 2020 and 2021 problems following these conventions (and expanded the conventions further for issues that showed up).</p>",
        "id": 498649361,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739147464
    },
    {
        "content": "<p>Having compared my choices with those in Compfiles, I think the Compfiles version of IMO 2020 P5 omits two conditions from the problem: I'd understand a pair of cards to be two different cards (possibly with the same number on them), and the geometric mean explicitly needs to be of a nonempty collection of cards. The two versions are easily equivalent, but I don't think the omission of those two conditions was intended in the informal statement.</p>",
        "id": 498649636,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739147664
    },
    {
        "content": "<p>PRs filed so far to work towards having more of the definitions to state more past IMO geometry problems: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21111\">#21111</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21588\">#21588</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21604\">#21604</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21617\">#21617</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21618\">#21618</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/21622\">#21622</a></p>",
        "id": 498649850,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1739147840
    },
    {
        "content": "<p>We now have evidence that formal statements following these conventions are of use to humans at least, in the form of Jovan's draft <a href=\"https://github.com/leanprover-community/mathlib4/pull/23431\">#23431</a> formalizing IMO 2020 P6 using my formal statement.</p>",
        "id": 509055769,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743361540
    },
    {
        "content": "<p>I don't know if such formalizations of past or future IMO problem statements are of use for AI developers, though they're intended to be, and I think these conventions do have various advantages over some choices that have been made in the past about how to state problems for AIs.</p>",
        "id": 509055913,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743361650
    },
    {
        "content": "<p>(i) Having a single, independently developed Lean version of a problem for use by all such AIs seems preferable for assessing the abilities of theorem-proving AIs compared to each developer of such an AI producing their own Lean problem statements (and especially for comparing the abilities of different AIs if more than one wishes to attempt problems from the same IMO).</p>",
        "id": 509056097,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743361814
    },
    {
        "content": "<p>(ii) Using separate <code>def</code>s and <code>structure</code>s in some cases as in my conventions seems preferable to artificially forcing all definitions into hypotheses of a single theorem statement as has sometimes been done for use with theorem provers. It's more idiomatic Lean in such cases, and more representative of non-competition mathematics where it's normal to have some new definition and wish to prove results about it, without necessarily being given any Lean API for that definition in advance.</p>",
        "id": 509056318,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743362045
    },
    {
        "content": "<p>(Using separate <code>def</code>s and <code>structure</code>s also makes it a lot simpler to state some more complicated problems such as IMO 2024 P5. An AI is of course always free to translate problems into a different form more convenient for that AI to work with, provided it can prove the equivalence of the two forms.)</p>",
        "id": 509056524,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743362258
    },
    {
        "content": "<p>(iii) Given the prevalence of recent informal reasoning models that produce mathematics that looks superficially plausible (and often guesses the right answer) but turns out to have fatally flawed reasoning when you inspect the details of the output, I think fully formal proofs should definitely be the gold standard for assessing the theorem proving abilities of AIs. An AI that could produce informal IMO solutions of sufficient quality to count as a full solution when coming from a human (and of human-verifiable length) would be of some interest, but if AIs are to contribute proofs in mathematical research, it would be problematic for humans to need to check for fatal mistakes manually in a claimed ten-thousand-page solution to an unsolved problem; any AI hoping to make serious research contributions of proofs really needs to be able to verify its work formally as it goes along.</p>",
        "id": 509057119,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743362772
    },
    {
        "content": "<p>My current PRs to enable stating more past IMO geometry problems: <a href=\"https://github.com/leanprover-community/mathlib4/pull/21960\">#21960</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22178\">#22178</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22483\">#22483</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22745\">#22745</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22747\">#22747</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/22751\">#22751</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23255\">#23255</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23323\">#23323</a>. I'm working towards setting up definitions of <code>incenter</code> and <code>excenter</code>. After that, the main missing geometry definitions relate to angle bisectors, arcs of circles and polygons, with a long tail of less frequently used definitions (including the previously discussed issue of Hausdorff measure normalization for talking about areas).</p>",
        "id": 509057700,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743363238
    },
    {
        "content": "<p>I do expect at some point to extend my collection of formal statements to cover more past IMOs, but I tend to give priority to setting up more definitions in mathlib to enable stating a greater proportion of problems, rather than stating incomplete sets of problems from more IMOs.</p>",
        "id": 509057836,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743363347
    },
    {
        "content": "<p>Thanks for the rapid reviews (all eight of those PRs are now in)! A few more notes:</p>",
        "id": 509325855,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743465483
    },
    {
        "content": "<ul>\n<li>Assessing an AI based on independent Lean formalizations of problem statements following known conventions (facilitating comparisons between different AIs) is of course not mutually exclusive with assessing it based on formalizations of problem statements by the AI developers; you can compare AI performance on different formalizations using different conventions and see what advantage or disadvantage arises from the different choices made.</li>\n</ul>",
        "id": 509326213,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743465640
    },
    {
        "content": "<ul>\n<li>Although there are still gaps in the problem statements covered in my collection (it now has five of the six problems from each year 2020 to 2024), it does have quite a few problems for which Compfiles lacks formal statements  (see also my remark above about the Compfiles version of IMO 2020 P5).</li>\n</ul>",
        "id": 509326900,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743465855
    },
    {
        "content": "<ul>\n<li>Since the conventions base formal statements on the English versions originally provided to contestants, any potential extension before 2006 would depend on scans of the English papers originally provided to contestants (as opposed to retyped and possibly reworded versions such as on imo-official) being contributed to <a href=\"https://www.imo-register.org.uk/papers/\">https://www.imo-register.org.uk/papers/</a> (but I don't expect to extend the formal statements as far back as 2006 any time soon).</li>\n</ul>",
        "id": 509327454,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743466130
    },
    {
        "content": "<ul>\n<li>While I'd hope to add formal statements following these conventions for future IMO problems as well as more past IMO problems, that's not something that will necessarily happen during or immediately after a given IMO without more specific planning to arrange it.</li>\n</ul>",
        "id": 509328567,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743466664
    },
    {
        "content": "<ul>\n<li>It's very likely that formalizing solutions to geometry (or combinatorial etc. geometry) problems using newly added definitions will show up missing API that should be added to mathlib (this does not mean that generating such formal solutions is out of reach for AI until the API is added, API lemmas aren't generally hard to prove, or to work around the absence of, and in any case the ability to identify and fill out missing API would be a good feature for a formalization AI). I might try formalizing a solution to IMO 2024 P4 at some point to complete the set of formal solutions to IMO 2024 problems. I don't expect to formalize solutions to many if any other past IMO geometry problems (though in general, the likelihood of showing up new API to add to mathlib makes a solution more interesting to me to formalize - there are lots of past algebra and number theory problems that aren't likely to involve any new API, and so that I'm unlikely to attempt formalizing myself in the absence of some personal connection such as having coordinated the problem, but that would make good formalization exercises for non-experts).</li>\n</ul>",
        "id": 509329936,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743467356
    },
    {
        "content": "<p><a href=\"https://github.com/dwrensha/compfiles/commit/06fa2da2f539bc599c43b7272eab4aa383d4f021\">Updated Compfiles Imo2020P5</a>. Thanks!</p>",
        "id": 509333277,
        "sender_full_name": "David Renshaw",
        "timestamp": 1743469217
    },
    {
        "content": "<p>Is there a reason why your problem statements contains names for hypotheses? These get picked up by the unused variable name linter, so that I would have to modify the statement to put it in mathlib.</p>",
        "id": 509967424,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743692962
    },
    {
        "content": "<p>In particular,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hSn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hSdist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">dist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">direction</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p₁</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p₁</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">SOppSide</span><span class=\"w\"> </span><span class=\"n\">p₁</span><span class=\"w\"> </span><span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Metric</span><span class=\"bp\">.</span><span class=\"n\">infDist</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>has <code>hn</code>, <code>hSn</code> and <code>hSdist</code> unused</p>",
        "id": 509967807,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743693052
    },
    {
        "content": "<ol>\n<li>Do we have a way yet to put one line in <code>lakefile.toml</code> that means \"always lint in mathlib mode\" (i.e. produce the same linter warnings as would appear if the code were copied into mathlib)? I'd like to apply mathlib mode linting to all my Lean projects (thus, it's not intended for the statements to do things that such linting warns about, beyond any lints for use of <code>sorry</code>); without it, issues shown by linter warnings that only appear in mathlib are very likely to be missed.</li>\n<li>What do you suggest as an alternative for avoiding that linter? Naming such hypotheses <code>_</code> (if something like that works to avoid the warning)? Using <code>→</code> not <code>∀</code> for such hypotheses (nested within the statement of the result after the <code>:</code>) that aren't referenced in what follows?</li>\n<li>You can't always avoid unused hypotheses with my conventions because sometimes the original problem might have an unused hypothesis. (Consider a problem involving a positive integer, where in fact the formal statement and Lean proof also work for zero. Then the formal statement will include <code>n &lt; 0</code> as part of accurately reflecting the informal statement, but that hypothesis will be unused when <code>sorry</code> is replaced by a proof.)</li>\n</ol>",
        "id": 510050544,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743721109
    },
    {
        "content": "<ol start=\"2\">\n<li>I think using <code>→</code> instead of <code>∀</code> is the usual way.</li>\n</ol>",
        "id": 510051022,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743721334
    },
    {
        "content": "<ol start=\"3\">\n<li>That is a bit unfortunate indeed. But it can be solved using <code>set_option linter.unusedVariables false</code>.</li>\n</ol>",
        "id": 510051243,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743721470
    },
    {
        "content": "<ol>\n<li>Not yet, but <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> is working on it!</li>\n</ol>",
        "id": 510052768,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1743722392
    },
    {
        "content": "<p>OK, I've changed two statements to use <code>→</code>. (There's at least one statement where the name isn't explicitly used but I think <code>∀</code> is required for it to be found in list indexing notation; see IMO 2023 P1. Hopefully the fact that the hypothesis is in fact used in the resulting terms, just not visibly in the input to Lean, suffices to avoid linter issues there.)</p>",
        "id": 510058261,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743725416
    },
    {
        "content": "<p>Another question I had about using the statement formalizations is about having other <code>variable</code>s in scope. Should there be the rule that all the preceding auxiliary theorems (and <code>variable</code>s) are inside of a (named) <code>section</code> to avoid accidentally changing the theorem statement?</p>",
        "id": 510058628,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1743725661
    },
    {
        "content": "<p>My README says that, for any system involving automated evaluation of proposed solutions, the statement must remain defeq (as a function of the <code>answer</code>, when applicable) to the statement presented to the solver. I haven't attempted to define in detail how such automated evaluation might work. (But I guess it would involve processing oleans through a validator, and confirming only the permitted standard axioms are used, as well as doing the defeq checks, and human inspection of the proposed <code>answer</code>.)</p>\n<p>This is not very relevant when solutions go through human review.</p>",
        "id": 510061254,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743727207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/208328-IMO-grand-challenge/topic/Suggested.20formalization.20conventions/near/510052768\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Not yet, but <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> is working on it!</li>\n</ol>\n</blockquote>\n<p>Oh that’s great. Are they also working on being able to disable all linter in downstream projects. I mean avoiding writing in desperation lakefile that look like <a href=\"https://github.com/PatrickMassot/proofs_with_lean/blob/master/lakefile.toml#L8-L20\">https://github.com/PatrickMassot/proofs_with_lean/blob/master/lakefile.toml#L8-L20</a> only to realize it has no effect and then write macros like <a href=\"https://github.com/PatrickMassot/proofs_with_lean/blob/master/ProofsWithLean/Lib.lean#L346-L349\">https://github.com/PatrickMassot/proofs_with_lean/blob/master/ProofsWithLean/Lib.lean#L346-L349</a> and use them at the top of every single file.</p>",
        "id": 510108906,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1743751382
    },
    {
        "content": "<p>I will make sure that disabling all linters can also be a oneliner, thanks for the complaint/bug report :)</p>",
        "id": 510118186,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1743754417
    },
    {
        "content": "<p>Next major piece of definitions for being able to state more IMO problems in Lean now posted: <a href=\"https://github.com/leanprover-community/mathlib4/pull/23752\">#23752</a> has <code>incenter</code>, <code>excenter</code> and related definitions (with significant pieces left to followups, considering that's already a 600-line PR). Depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/23712\">#23712</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/23751\">#23751</a>; my other open PRs <a href=\"https://github.com/leanprover-community/mathlib4/pull/23715\">#23715</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/23732\">#23732</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/23735\">#23735</a> are things I suspect might be relevant in such followups.</p>",
        "id": 510535515,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1743986374
    },
    {
        "content": "<p>Have you given any thought into making a formal version of <a href=\"https://matharena.ai/\">https://matharena.ai/</a> (by <span class=\"user-mention\" data-user-id=\"350365\">@Mislav Balunović</span>), which keeps track of how informal AI does on recent math competitions (including proof-based ones)?  How much work would it be to formalize the competition problems into Lean for each math competition?  (This seems more relevant now that we have Kimina-Prover.)</p>",
        "id": 512803046,
        "sender_full_name": "Jason Rute",
        "timestamp": 1744889302
    },
    {
        "content": "<p>This is definitely a direction we are considering to expand into at <a href=\"https://matharena.ai/\">https://matharena.ai/</a> now that the competitions with numerical answers only (which are the easiest to evaluate) have been almost fully saturated by the recent models. Regarding proofs, our first take on this was evaluating natural language proofs on USAMO using human judges - the bottleneck here is obviously creating a grading scheme, manually reading LLM solutions, etc. We are definitely also thinking about introducing a category where we evaluate methods that produce formal solutions in Lean - if you have ideas on this direction please reach out!</p>",
        "id": 513145493,
        "sender_full_name": "Mislav Balunović",
        "timestamp": 1745048489
    },
    {
        "content": "<p>A key step in doing such formal benchmarking is reviewing lots of past problems, identifying relevant definitions for those problems and adding them (+ at least minimal API) to mathlib in advance of possibly being of use in stating future problems. Otherwise the subset of problems in the benchmark is biased by what happens to be in mathlib at the time to allow the problems to be stated.</p>",
        "id": 513257906,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1745142187
    },
    {
        "content": "<p>I'm not so worried about the difficulty of producing formal <em>solutions</em> being biased by what lemmas are in mathlib, since (a) an AI of serious practical use for formal theorem proving in research needs to be able to deal with definitions with little to no API, and build up basic results for them itself, and (b) AI developers (and their AIs, working together with the developers or autonomously) are free to contribute to mathlib just like anyone else, including API improvements that might help performance on future benchmark evaluations.</p>",
        "id": 513258090,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1745142318
    },
    {
        "content": "<p>Once you have relevant definitions in mathlib, I don't think producing formal statements rapidly after a human competition is particularly hard. I think that the failure at DeepMind to get a formal statement of IMO 2024 P5 ready for AlphaProof on the day the problems were received (as mentioned in at least one talk) reflects the added difficulty of making such a statement <em>under the artificial constraint of putting everything in a single <code>theorem</code> statement</em> without separate <code>def</code>s using associated <code>structure</code>s; once you can use separate types and definitions, such a problem is quite straightforward to translate to Lean (and if you do apply such an artificial constraint, the way to do it is probably first to write the statement without the constraint, and then iteratively replace custom types by products with separate hypotheses, then separate definitions by extra pairs of hypotheses).</p>\n<p>Avoiding mistakes in the formal definitions is a separate issue; human formalizing a solution to check the formal statement is a lot of work for many olympiad combinatorics or geometry problems. Checklists of common pitfalls and having multiple people check each other's formal statements word by word in both directions against the informal version may help.</p>",
        "id": 513258772,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1745142960
    },
    {
        "content": "<p>I note incidentally that when Compfiles added a solution to IMO 2023 P1 recently, it also changed the statement to correspond less literally to the informal statement (removing the \"composite\" that's part of the informal statement), any particular reason why? I'd say that if you want to go via a more general statement when formalizing a solution, you should still end up with a formal deduction of some formal version of the original problem.</p>",
        "id": 519250109,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1747698458
    },
    {
        "content": "<p>Ah, good catch. I missed that in review. I think I can fix it up...</p>",
        "id": 519263480,
        "sender_full_name": "David Renshaw",
        "timestamp": 1747704190
    },
    {
        "content": "<p>Pushed a <a href=\"https://github.com/dwrensha/compfiles/commit/38b3b2680621d7fe45e6634c8c1be72cd8f80a06\">fix</a> and <a href=\"https://github.com/dwrensha/compfiles/pull/53/files#r2096690954\">commented on the PR</a> that made the change.</p>",
        "id": 519264760,
        "sender_full_name": "David Renshaw",
        "timestamp": 1747704752
    },
    {
        "content": "<p>This is an interesting case. It seems to me that removing the word \"composite\" from the problem statement makes the problem (and solution) more elegant. But I guess maybe the committee did not want the condition</p>\n<blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> divides <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">d_{i+1} + d_{i+2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9028em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9028em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> for every 1 ⩽ i ⩽ k − 2</p>\n</blockquote>\n<p>to be vacuous?</p>",
        "id": 519266026,
        "sender_full_name": "David Renshaw",
        "timestamp": 1747705336
    },
    {
        "content": "<p>Generally such a vacuous \"for all\", or an empty sum or product, etc., is considered liable to confuse and so conditions are added to avoid such things in problems even if the result would be true without such conditions; that avoids confusing students (especially less experienced ones, who P1 and P4 are meant to be accessible to) and possible consequent queries being sent to the Jury about the meaning of the problem in such degenerate cases. This may sometimes mean a formal statement has a hypothesis not used in a proof (say if the problem is for positive <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> but the formal proof also works for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>) which then needs to be nolinted as deliberately present despite being unused.</p>\n<p>Redundant configuration information may be present for geometry problems to reduce the potential for configuration dependence in solutions (and so reduce the need for solutions to either handle different configurations, or to put in some magic words about working with oriented angles modulo pi and then ensure that every angle in the solution is actually listed with a consistent orientation so that those words are valid, or to hope that they won't lose marks for any configuration dependence not handled in the solution). In that geometry case, adding such information cannot be perfect at avoiding configuration issues because new configuration issues can occur with geometrical elements that contestants construct as part of their solution (e.g. if they construct two lines and consider their intersection, they might have introduced a configuration issue when the lines they construct are parallel).</p>",
        "id": 519480719,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1747778106
    },
    {
        "content": "<p>On the topic of vacuousness and quantifiers, the official problem statement for <a href=\"https://dwrensha.github.io/compfiles/problems/Compfiles.Imo1971P5.html\">Imo 1971 P5</a> says \"... there exists a finite set ...\" but seems to actually mean \"... there exists a <em>nonempty</em> finite set ....\" (Otherwise the statement is trivially true.)</p>",
        "id": 540006867,
        "sender_full_name": "David Renshaw",
        "timestamp": 1758113476
    },
    {
        "content": "<p>Interestingly <a href=\"https://artofproblemsolving.com/community/c6h60830p366681\">https://artofproblemsolving.com/community/c6h60830p366681</a> has no mention of that solution</p>",
        "id": 540010539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758114483
    },
    {
        "content": "<p>The original paper <a href=\"https://www.imo-register.org.uk/papers/1971-English-day2.jpeg\">https://www.imo-register.org.uk/papers/1971-English-day2.jpeg</a> says \"non-empty\". I encourage people who competed at pre-2006 IMOs and still have the papers they were given to contribute more scans for <a href=\"https://www.imo-register.org.uk/papers/\">https://www.imo-register.org.uk/papers/</a> (especially but not limited to English papers) to help resolve such issues.</p>\n<div class=\"message_inline_image\"><a href=\"https://www.imo-register.org.uk/papers/1971-English-day2.jpeg\"><img src=\"https://uploads.zulipusercontent.net/c8c4100b757d6b8fc0587388b19fa661e78e640d/68747470733a2f2f7777772e696d6f2d72656769737465722e6f72672e756b2f7061706572732f313937312d456e676c6973682d646179322e6a706567\"></a></div>",
        "id": 540011374,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758114725
    },
    {
        "content": "<p>So <a href=\"https://www.imo-official.org/problems.aspx\">https://www.imo-official.org/problems.aspx</a> is not an official source either?</p>",
        "id": 540011856,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758114867
    },
    {
        "content": "<p>Pre-2006 papers there are generally retyped and sometimes paraphrased. 1981 P3 there has cubes that should be squares, as another example of a mistake in those retyped versions. 1982 P3 there is missing the \"for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>\" at the end of (b). (There may be other mistakes affecting mathematical content of problems that I don't know about. <a href=\"https://artofproblemsolving.com/wiki/index.php/1962_IMO_Problems/Problem_2\">https://artofproblemsolving.com/wiki/index.php/1962_IMO_Problems/Problem_2</a> claims IMO 1962 P2 is missing an outer square root but I can't find evidence that outer square root was actually in the original problem; the most nearly contemporaneous source I have for IMO 1962 problems is <a href=\"http://db.komal.hu/scan/1962/09/96209003.g4.png\">http://db.komal.hu/scan/1962/09/96209003.g4.png</a> which doesn't have that square root either.)</p>\n<div class=\"message_inline_image\"><a href=\"http://db.komal.hu/scan/1962/09/96209003.g4.png\"><img src=\"https://uploads.zulipusercontent.net/42153831ef69e08780d6de60385c8e4151e48790/687474703a2f2f64622e6b6f6d616c2e68752f7363616e2f313936322f30392f39363230393030332e67342e706e67\"></a></div><p>The missing \"non-empty\" for 1971 P5 appears to go back at least as far as Greitzer's MAA book (published 1978).</p>",
        "id": 540017264,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758116217
    },
    {
        "content": "<p>IMO 1962 P2 came up in a talk by <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I think, originally as \"this is misformalized\" but adapted to \"no one remembers what this problem was\"</p>",
        "id": 540024060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758117794
    }
]