[
    {
        "content": "<p>The following came up In Copenhagen.</p>\n<p>We have in mathlib the notion of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a>. So let <code>C</code> be a category that is Finitary Extensive. I want to define a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Coverage#doc\">docs#CategoryTheory.Coverage</a> as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ExtensiveSieve</span>  <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">S</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)),</span>\n    <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">Presieve.ofArrows</span> <span class=\"n\">X</span> <span class=\"n\">π</span> <span class=\"bp\">∧</span> <span class=\"n\">IsIso</span> <span class=\"o\">(</span><span class=\"n\">Sigma.desc</span> <span class=\"n\">π</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ExtensiveCoverage</span>  <span class=\"o\">:</span> <span class=\"n\">Coverage</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">covering</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>   <span class=\"n\">ExtensiveSieve</span> <span class=\"n\">B</span>\n  <span class=\"n\">pullback</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I understand the literature the condition \"Finitary Extensive\" means exactly (or at least implies) that the <code>sorry</code> can be filled. Does anyone know if this correct?</p>\n<p>Tagging <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Ásgeirsson</span> <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> <span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span>  that may be interested</p>",
        "id": 371104039,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688123479
    },
    {
        "content": "<p>I would define it inductively... let me sketch something</p>",
        "id": 371104387,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688123549
    },
    {
        "content": "<p>Another question is if the definition of <code>ExtensiveSieve</code> looks good: we want to express the idea that coverings are given by <em>disjoint</em> unions.</p>",
        "id": 371104741,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1688123625
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Sites.Coverage</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">extensiveCoverAux</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Presieve</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">HasCoproduct</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n      <span class=\"n\">extensiveCoverAux</span> <span class=\"o\">(</span><span class=\"bp\">∐</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Presieve.ofArrows</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Sigma.ι</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">extensiveCoverage</span> <span class=\"o\">:</span> <span class=\"n\">Coverage</span> <span class=\"n\">C</span> <span class=\"n\">where</span>\n  <span class=\"n\">covering</span> <span class=\"o\">:=</span> <span class=\"n\">extensiveCoverAux</span> <span class=\"n\">C</span>\n  <span class=\"n\">pullback</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- need extensive</span>\n</code></pre></div>",
        "id": 371105991,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1688123852
    },
    {
        "content": "<p>I plan to remove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Extensive#doc\">docs#CategoryTheory.Extensive</a> in favour of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> in a WIP PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a>.</p>\n<blockquote>\n<p>Not 100% sure this change is desired. <code>FinitaryExtensive</code> is stronger than <code>Extensive</code> as<br>\nthe former requires furthermore that coproducts satisfy some form of descent.<br>\nHowever the former is what the literature uses and has some better properties (e.g. coproducts are disjoint).<br>\nSuggestions Welcome!</p>\n</blockquote>",
        "id": 397179723,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1697575500
    },
    {
        "content": "<p>I came to the conclusion that something like this (at least adding the condition that coproducts are disjoint) would be a good idea recently when working on <a href=\"https://github.com/leanprover-community/mathlib4/pull/6877\">#6877</a>. Our <code>Extensive</code> was enough to define the coverage and prove that finite-product-preserving presheaves are sheaves, but when trying to prove that sheaves preserve finite products I ran into issues. </p>\n<p>However, I do think we should keep the old <code>Extensive</code> (perhaps renamed as <code>PreExtensive</code> or something), precisely because that's enough to define the coverage etc. Also, I think the old <code>Extensive</code> +  coproducts are disjoint is enough to prove what I want to do in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6877\">#6877</a> (sheaves preserve finite products), but I'm not sure.</p>",
        "id": 397262031,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697618647
    },
    {
        "content": "<p>Old Extensive + all finite coproducts are disjoint should be precisely <code>FinitaryExtensive</code>.</p>",
        "id": 397263957,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1697619384
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span> at the moment there is no relation between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Extensive#doc\">docs#CategoryTheory.Extensive</a>, right?</p>",
        "id": 397264064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697619426
    },
    {
        "content": "<p>If the old <code>Extensive</code> is still desired, I would be inclined to redefine it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">PreExtensive</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"n\">hasFiniteCoproducts</span> <span class=\"o\">:</span> <span class=\"n\">HasFiniteCoproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">hasPullbackInl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span> <span class=\"bp\">⨿</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">HasPullback</span> <span class=\"n\">coprod.inl</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n  <span class=\"n\">is_universal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">BinaryCofan</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">IsColimit</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">IsUniversalColimit</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>(which should be equivalent to the current one)</p>",
        "id": 397264458,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1697619555
    },
    {
        "content": "<p>However I don't have any example of \"pre-extensive\" categories (that aren't extensive).</p>",
        "id": 397264735,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1697619649
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/397264064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> at the moment there is no relation between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Extensive#doc\">docs#CategoryTheory.Extensive</a>, right?</p>\n</blockquote>\n<p>At the moment, no. But Andrew's PR gives that link, for example <code>FinitaryExtensive.sigma_desc_iso</code> on line 897 in <code>Mathlib/CategoryTheory/Extensive</code></p>",
        "id": 397264811,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697619673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/397264458\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">is_universal</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">BinaryCofan</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">IsColimit</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">IsUniversalColimit</span> <span class=\"n\">c</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Is <code>is_universal</code> really equivalent to the old <code>sigma_desc_iso</code>?</p>",
        "id": 397264968,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697619725
    },
    {
        "content": "<p>Well, if you think that going down the rabbit hole of finding the right categorical generalization to characterize sheaves is doable this is surely the right approach.</p>",
        "id": 397265942,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697620078
    },
    {
        "content": "<p>(I am almost sure there must be something like a regular category notion that takes care of covering of the other type, but the math is less clear)</p>",
        "id": 397266188,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697620150
    },
    {
        "content": "<p>I'm pretty sure I just need coproducts to be disjoint to be able to prove that sheaves preserve finite products, which completes the characterisation of sheaves.</p>",
        "id": 397266287,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697620182
    },
    {
        "content": "<p>Our <code>Preregular</code> is the right notion for the other type</p>",
        "id": 397266394,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697620208
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6919\">#6919</a> now has both directions there</p>",
        "id": 397266443,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697620227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/397264968\">said</a>:</p>\n<blockquote>\n<p>Is <code>is_universal</code> really equivalent to the old <code>sigma_desc_iso</code>?</p>\n</blockquote>\n<p><code>IsUniversalColimit</code> is just a fancy way of saying \"stable under pullbacks\".<br>\nAnd the proposed change has the benefits</p>\n<ol>\n<li>Parity with <code>Extensive</code>.</li>\n<li>It doesn't mention a particular colimit obtained by choice.</li>\n<li>It should be easier to show that binary coproducts are stable under pullbacks.</li>\n</ol>",
        "id": 397266476,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1697620242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/397266394\">said</a>:</p>\n<blockquote>\n<p>Our <code>Preregular</code> is the right notion for the other type</p>\n</blockquote>\n<p>So <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stonean.effectiveEpiFamily_tfae#doc\">docs#Stonean.effectiveEpiFamily_tfae</a> is used only to prove an abstract categorical notion and then the proof that a presheaf is a sheaf for the coherent topology iff the two conditions hold (one is automatic in this case of course) is completely general?</p>",
        "id": 397269598,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697621380
    },
    {
        "content": "<p>Yeah my claim is the following: </p>\n<p>Let <code>C</code> be a category which is <code>FinitaryExtensive</code>, <code>Preregular</code> and <code>Precoherent</code> (the last one probably follows from the other two, but we haven't proved that).</p>\n<ol>\n<li>\n<p>If every object of <code>C</code> is projective (e.g. in <code>C = Stonean</code>) then coherent sheaves are precisely the presheaves that preserve finite products. </p>\n</li>\n<li>\n<p>If <code>C</code> has the relevant pullbacks (e.g. <code>C = CompHaus</code> or <code>C = Profinite</code>), then coherent sheaves are precisely the presheaves that preserve finite products, and satisfy <code>EqualizerCondition</code>.</p>\n</li>\n</ol>\n<p>We already have one direction, but to prove that sheaves preserve finite products, I need coproducts to be disjoint.</p>",
        "id": 397272504,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697622414
    },
    {
        "content": "<p>Very nice! I thought we still used the explicit description of (effective/regular/whatever) epi in our three examples to prove the final theorem.</p>",
        "id": 397275087,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697623353
    },
    {
        "content": "<p>BTW I think this deserves a short paper somewhere. It's probably more or less known, but I bet it's not very easy to find someone who's sure about all the details.</p>",
        "id": 397275254,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1697623429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/397275087\">said</a>:</p>\n<blockquote>\n<p>Very nice! I thought we still used the explicit description of (effective/regular/whatever) epi in our three examples to prove the final theorem.</p>\n</blockquote>\n<p>We did that originally, but I extracted a proof for the more general setting from what we had!</p>",
        "id": 397350556,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697647456
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/7804\">#7804</a>, it's sorry-free but still needs some cleaning up. It's what we need to prove that extensive sheaves preserve finite products. It basically says that if a presheaf <code>isSheafFor</code> the empty presieve and a <code>Presieve.ofArrows</code>, then it preserves the product corresponding to the <code>Presieve.ofArrows</code>.</p>",
        "id": 397725443,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1697813094
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7949\">#7949</a> proves that sheaves for the extensive topology on a category which is <code>Extensive</code> and has disjoint finite coproducts (stated in terms of <code>Sigma.ι</code>, not <code>CoproductsDisjoint</code>, sorry), are precisely the presheaves which preserve finite products</p>",
        "id": 398698257,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698329526
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> what's the status of your PR which removes <code>Extensive</code>?</p>",
        "id": 398698439,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698329580
    },
    {
        "content": "<p>A prerequisite (<a href=\"https://github.com/leanprover-community/mathlib4/pull/7745\">#7745</a>) just got merged today. I'll tidy up the PR soon.</p>",
        "id": 398721588,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698336256
    },
    {
        "content": "<p>Ok, how much more work would it be for you to add the other direction of the equivalence of <code>FinitaryExtensive</code> iff old extensive plus disjoint coproducts? The forward direction is already there as I understand?</p>",
        "id": 398724447,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698337321
    },
    {
        "content": "<p>Do we need the inverse direction? Also we only know that binary coproducts are disjoint. I'll try to generalize it to finite coproducts.</p>",
        "id": 398726799,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698338169
    },
    {
        "content": "<p>I'm still not sure if we need the notion of \"pre-extensive\" though. I don't think there is any literature on this and I cannot find any examples that are not extensive.<br>\nEven if this condition is enough for the extensive coverage to be a coverage, it is only well behaved when the category is extensive.</p>",
        "id": 398770784,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698356009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398726799\">said</a>:</p>\n<blockquote>\n<p>Do we need the inverse direction? Also we only know that binary coproducts are disjoint. I'll try to generalize it to finite coproducts.</p>\n</blockquote>\n<p>I'm just wondering because I already have proofs at <a href=\"https://github.com/leanprover-community/mathlib4/pull/6731\">#6731</a> that <code>CompHaus</code>, <code>Profinite</code> and <code>Stonean</code> are <code>Extensive</code>.</p>",
        "id": 398771017,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698356138
    },
    {
        "content": "<p>Depends what you mean by well-behaved. Pre-extensive is enough to define the coverage, and to prove that all finite-product preserving functors are sheaves (but not the converse)</p>",
        "id": 398771176,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698356226
    },
    {
        "content": "<p>Shouldn't we always define things in the most general way possible in mathlib?</p>",
        "id": 398771247,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698356277
    },
    {
        "content": "<p>As general as possible, but no more</p>",
        "id": 398771834,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698356628
    },
    {
        "content": "<p>There is also this annoying thing with binary vs finite products. It seems that basically the only properties of products which mathlib knows is equivalent for binary and empty on the one hand and finite on the other hand is existence and being preserved by functors. And it's pretty difficult to relate them.</p>\n<p>In my PRs about preserving finite products (<a href=\"https://github.com/leanprover-community/mathlib4/pull/7949\">#7949</a> and the ones it depends on), I always use general products, and specialize to finite ones when I have to. This means that the results can easily be generalised to infinitary extensive categories etc. </p>\n<p>Is there a good reason why <code>FinitaryExtensive</code> is defined in terms of binary and not finite coproducts? I don't really see how binary coproducts are \"easier\" than finite ones, it's just harder to relate them to general products. Because binary products aren't products in mathlib, they're binary products, while finite products are just products with the extra property of being finite.</p>",
        "id": 398772195,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698356866
    },
    {
        "content": "<p>The only reason why <code>FinitaryExtensive</code> was defined in terms of binary coproducts is that I only needed binary coproducts back then. If <a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> lands, we will have all the properties for finite coproducts as well and I don't think the definition matters a lot after that?</p>",
        "id": 398774221,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698357867
    },
    {
        "content": "<p>Is there any \"pre-extensive\" category though? If not, this notion is not more general but merely redundant IMO.</p>",
        "id": 398775079,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698358338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398771017\">said</a>:</p>\n<blockquote>\n<p>I'm just wondering because I already have proofs at <a href=\"https://github.com/leanprover-community/mathlib4/pull/6731\">#6731</a> that <code>CompHaus</code>, <code>Profinite</code> and <code>Stonean</code> are <code>Extensive</code>.</p>\n</blockquote>\n<p>If the inverse direction is needed for the proofs I could add them.</p>",
        "id": 398775226,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698358436
    },
    {
        "content": "<p>But note that mathlib already knows that <code>TopCat</code> is extensive and reflective subcategories of extensive categories are extensive.</p>",
        "id": 398775300,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698358477
    },
    {
        "content": "<p>Yes, something like that would be much better than the proofs I already have</p>",
        "id": 398775403,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698358541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398774221\">said</a>:</p>\n<blockquote>\n<p>The only reason why <code>FinitaryExtensive</code> was defined in terms of binary coproducts is that I only needed binary coproducts back then. If <a href=\"https://github.com/leanprover-community/mathlib4/pull/6731\">#6731</a> lands, we will have all the properties for finite coproducts as well and I don't think the definition matters a lot after that?</p>\n</blockquote>\n<p>You mean if <a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> lands?</p>",
        "id": 398775567,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698358632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398775300\">said</a>:</p>\n<blockquote>\n<p>But note that mathlib already knows that <code>TopCat</code> is extensive and reflective subcategories of extensive categories are extensive.</p>\n</blockquote>\n<p>Specifically <a href=\"https://github.com/leanprover-community/mathlib4/pull/7721\">#7721</a> (it is on bors queue)</p>",
        "id": 398776080,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698358928
    },
    {
        "content": "<p>Ah you need pullbacks in the result about reflective subcategories though. Do you think that could be weakened to what I call <code>HasPullbacksOfInclusions</code> on the target category (i.e. has those pullbacks where one morphism is an iota map into a finite coproduct)?</p>",
        "id": 398776472,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698359174
    },
    {
        "content": "<p><code>Stonean</code> doesn't have pullbacks but it <code>HasPullbacksOfInclusions</code></p>",
        "id": 398776503,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698359203
    },
    {
        "content": "<p>Re pre-extensive: I guess I just think about the property of being extensive as two distinct properties (one being pre-extensive, i.e. coproducts are preserved by pullback, and the other being that finite coproducts are disjoint). But I realise this is not the definition of <code>FinitaryExtensive</code></p>",
        "id": 398776758,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698359399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398776472\">said</a>:</p>\n<blockquote>\n<p>Ah you need pullbacks in the result about reflective subcategories though. Do you think that could be weakened to what I call <code>HasPullbacksOfInclusions</code> on the target category (i.e. has those pullbacks where one morphism is an iota map into a finite coproduct)?</p>\n</blockquote>\n<p>Should be possible. Will try once <a href=\"https://github.com/leanprover-community/mathlib4/pull/7721\">#7721</a> lands in mathlib.</p>",
        "id": 398776869,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698359458
    },
    {
        "content": "<p>If I get disjoint finite coproducts then I'll be very happy to see <a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> merged. I would still argue for keeping what I call <code>Extensive</code> as <code>PreExtensive</code> but I don't feel that strongly about it. It adds a nice symmetry with <code>Precoherent</code> and <code>Preregular</code> which were notions we kind of just invented for mathlib, so I don't see there not being any literature on it as an argument against it.</p>",
        "id": 398777883,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698360121
    },
    {
        "content": "<p>If you don't add disjoint finite coproducts (that's of course fine, I won't make you do anything), just hold off a bit on changing the file <code>CategoryTheory/Sites/RegularExtensive</code>, so I can try to add it in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7949\">#7949</a></p>",
        "id": 398778234,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698360359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398776869\">said</a>:</p>\n<blockquote>\n<p>Should be possible. Will try once <a href=\"https://github.com/leanprover-community/mathlib4/pull/7721\">#7721</a> lands in mathlib.</p>\n</blockquote>\n<p>I took a quick look and the bare minimum my proof needs is the fact that the left adjoint preserves pullbacks of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mover><mo stretchy=\"true\" minsize=\"3.0em\">→</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow></mpadded></mover><mi>R</mi><mo stretchy=\"false\">(</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mover><mo stretchy=\"true\" minsize=\"3.0em\">←</mo><mpadded width=\"+0.6em\" lspace=\"0.3em\"><msub><mi>η</mi><mi>Y</mi></msub></mpadded></mover><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">R(X) \\xrightarrow{R(f)} R(L(Y)) \\xleftarrow{\\eta_Y} Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.397em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.147em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose mtight\">)</span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.011em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1734em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel x-arrow\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9234em;\"><span style=\"top:-3.322em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight x-arrow-pad\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">η</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3567em;margin-left:-0.0359em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">Y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1433em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"svg-align\" style=\"top:-2.689em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"hide-tail\" style=\"height:0.522em;min-width:1.469em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.011em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f : X \\to L(Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>. This seems to be an iff per theorem 4 of <a href=\"http://www.mat.uc.pt/preprints/ps/p0660.pdf\">this preprint</a> so this might be the best one can do.</p>",
        "id": 398778720,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698360646
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> already has disjoint finite coproducts.</p>",
        "id": 398778757,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698360669
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span> to keep <code>Extensive</code> as <code>PreExtensive</code>, especially since it is already there and it is more general (we have plenty of examples in mathlib where we are much more general that any reasonable literature). Maybe <code>FinitaryExtensive</code> can become <code>Extensive</code>?</p>",
        "id": 398846264,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698393753
    },
    {
        "content": "<p>What is the mathematical difference between the two?</p>",
        "id": 398846582,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698393875
    },
    {
        "content": "<p>The mathematical difference is that Pre-extensive doesn't require disjoint coproducts</p>",
        "id": 398846920,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698394017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398778757\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> already has disjoint finite coproducts.</p>\n</blockquote>\n<p>I thought you said only binary?</p>",
        "id": 398846964,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698394035
    },
    {
        "content": "<p>OK, so I indeed think it is mathematically irrelevant, but who knows, let's keep both of them.</p>",
        "id": 398847029,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698394064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"519559\">Dagur Asgeirsson</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398846964\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/398778757\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7731\">#7731</a> already has disjoint finite coproducts.</p>\n</blockquote>\n<p>I thought you said only binary?</p>\n</blockquote>\n<p>Yeah but I added it yesterday.</p>",
        "id": 398848712,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698394675
    },
    {
        "content": "<p>Where is the fact the <code>CompHaus</code> and friends are <code>Extensive/Preextensive</code>?  Is it in a PR?</p>",
        "id": 399029828,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698484262
    },
    {
        "content": "<p>It’s in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6731\">#6731</a> (unpolished). But for Comphaus and Profinite, we can now deduce it from abstract nonsense. We might still have to do it directly for Stonean though</p>",
        "id": 399074388,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698518778
    },
    {
        "content": "<p>I managed to show <code>Stonean</code> is extensive using abstract nonsense as well. See <a href=\"https://github.com/leanprover-community/mathlib4/pull/8012\">#8012</a>.</p>",
        "id": 399148620,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698582310
    },
    {
        "content": "<p>Are you modifying again <code>FinitaryExtensive</code>? Maybe you can split the PR into two, where in the first one you don't touch <code>CompHaus</code> and friends?</p>",
        "id": 399149988,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698583290
    },
    {
        "content": "<p>The class it self was not changed. I just pulled a field out into a new definition.</p>",
        "id": 399157626,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698588969
    },
    {
        "content": "<p>I've splitted the <code>Extensive</code> part of the PR into <a href=\"https://github.com/leanprover-community/mathlib4/pull/8015\">#8015</a>.</p>",
        "id": 399157660,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698588995
    },
    {
        "content": "<p>Wow, thanks Andrew! This looks great, I'll take a closer look either in a couple of hours or tomorrow. I'll also update <a href=\"https://github.com/leanprover-community/mathlib4/pull/7949\">#7949</a> with the new pre-extensive/extensive definitions. When <a href=\"https://github.com/leanprover-community/mathlib4/pull/7949\">#7949</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/8012\">#8012</a> are merged we basically have the explicit description of condensed sets!</p>",
        "id": 399179282,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698607274
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8015\">#8015</a> is merged.</p>",
        "id": 399350344,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698688028
    },
    {
        "content": "<p>BTW, the docstring of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryPreExtensive#doc\">docs#CategoryTheory.FinitaryPreExtensive</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> are identical...</p>",
        "id": 399352630,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698688975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/399350344\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8015\">#8015</a> is merged.</p>\n</blockquote>\n<p>Great! <a href=\"https://github.com/leanprover-community/mathlib4/pull/8012\">#8012</a> is now ready for review.</p>",
        "id": 399401980,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698714391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Extensive.20Coverage/near/399352630\">said</a>:</p>\n<blockquote>\n<p>BTW, the docstring of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryPreExtensive#doc\">docs#CategoryTheory.FinitaryPreExtensive</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.FinitaryExtensive#doc\">docs#CategoryTheory.FinitaryExtensive</a> are identical...</p>\n</blockquote>\n<p>Oops. Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/8048\">#8048</a>.</p>",
        "id": 399402016,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698714411
    },
    {
        "content": "<p>I left some minor comments and suggestions on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8012\">#8012</a></p>",
        "id": 399538505,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698764072
    },
    {
        "content": "<p>I didn't see them though?</p>",
        "id": 399539305,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1698764317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"519559\">@Dagur Asgeirsson</span> you probably didn't hit \"submit review\" or something like that.</p>",
        "id": 399539521,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698764393
    },
    {
        "content": "<p>Sorry, done!</p>",
        "id": 399556699,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698768660
    },
    {
        "content": "<p>There was an issue with universes in the proof that <code>Stonean</code> is finitary extensive, it didn't find the instance when I tried to use it in the explicit description of condensed sets (<a href=\"https://github.com/leanprover-community/mathlib4/pull/6731\">#6731</a>). Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/8131\">#8131</a></p>",
        "id": 400025975,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1698962905
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 400027250,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698963660
    },
    {
        "content": "<p><code>FinitaryPreExtensive</code> (note the \"pre\") and <code>Preregular</code> together imply <code>Precoherent</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/8399\">#8399</a>. <br>\nI'll clean it up tomorrow and maybe use it to refactor the proofs that <code>CompHaus</code> and friends are precoherent.</p>",
        "id": 401863720,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1699918727
    },
    {
        "content": "<p>This is great! The analogue without <code>Pre</code> is clear?</p>",
        "id": 401931140,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699950476
    },
    {
        "content": "<p>We don't have <code>Regular</code> and <code>Coherent</code> in mathlib. But <code>Regular</code> + <code>FinitaryExtensive</code> implies <code>Coherent</code> is well known, I think it's proved e.g. in an appendix of Lurie's Ultracategories paper. The main difference is that without the <code>Pre</code> the existence of many more limits is required.</p>",
        "id": 401933969,
        "sender_full_name": "Dagur Asgeirsson",
        "timestamp": 1699951213
    }
]