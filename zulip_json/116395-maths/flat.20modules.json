[
    {
        "content": "<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>\n<p>Tagging <span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> since you seem to have asked some related questions before.<br>\nAlso <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> since you are working on cogenerators in abelian categories; this result follows from Baer's criterion if we know that  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(M, X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> is injective iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is flat for <code>X</code> being a (injective?) cogenerator (if I am not mistaken). I'm not sure if this is in your plan.<br>\nAnd also <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> since Baer's criterion is your work.</p>",
        "id": 290078233,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658225786
    },
    {
        "content": "<p>This has been a major todo ever since I added the definition of flat modules. It would be awesome to close it.</p>",
        "id": 290078574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658226006
    },
    {
        "content": "<p>This is not on my roadmap.</p>",
        "id": 290079460,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1658226583
    },
    {
        "content": "<p>Will your work imply that <code>Module R</code> has an injective cogenerator?</p>",
        "id": 290079847,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658226845
    },
    {
        "content": "<p>Yes, when combined with <a href=\"https://github.com/jjaassoonn/twist/blob/8b12ca696c19c239c2e9deeab51c5dc04e586fed/src/enough_injectives/adjunction_Ab.lean#L183\">Jujian's proof that <code>Module R</code> has enough injectives</a></p>",
        "id": 290080073,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1658227014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/290078233\">said</a>:</p>\n<blockquote>\n<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>\n</blockquote>\n<p>I have this project on flat modules working towards that: <a href=\"https://github.com/mpenciak/flat_modules\">https://github.com/mpenciak/flat_modules</a></p>\n<p>It's funny you should bring it up because I hadn't touched the project in months, but I just dusted it off last night (bumped mathlib) and intended on trying to make some more progress.</p>",
        "id": 290088150,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232067
    },
    {
        "content": "<p>What a coincidence!<br>\nHave you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>",
        "id": 290088553,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658232306
    },
    {
        "content": "<p>So far I've managed to prove a couple technical things that are used in the Stacks project proof:</p>\n<p>1) Any module is a direct limit of its f.g. submodules. <br>\n2) Tensor product commutes with direct limit (turns out I did more work than needed for this, because it's easy to deduce from some lemmas already in mathlib)</p>\n<p>I got stuck on the next part of the proof because at the time I found the API around short exact sequences in mathlib wasn't quite there to state/prove things like <code>0 → R¹ → Rⁿ⁺¹ → Rⁿ → 0</code>is short exact</p>",
        "id": 290088560,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/290088553\">said</a>:</p>\n<blockquote>\n<p>What a coincidence!<br>\nHave you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>\n</blockquote>\n<p>I'd have to look at the proof using Baer's criterion, but it sounds like it should be more do-able!</p>",
        "id": 290088708,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232397
    },
    {
        "content": "<p>The proof goes like:<br>\nLet <code>M*</code> denote <code>Hom(M, X)</code>, then by the tensor-hom adjunction, <code>Hom(- , M*)</code> is naturally isomorphic to <code>(_ ⊗ M)*</code>.<br>\nSince <code>-* = Hom(-, X)</code> preserves mono, and reflects mono when it is faithful (<code>X</code> is a cogenerator), <code>M*</code> is injective iff <code>Hom(- , M*)</code> preserves mono iff <code>_ ⊗ M</code> preserves mono iff <code>M</code> is flat.<br>\nBut Baer's criterion tells you that it suffices to check if <code>Hom(- , M*)</code> preserves mono of the form <code>I → R</code>, so we only need to check such morphisms when checking flatness.</p>",
        "id": 290089813,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658233132
    },
    {
        "content": "<p>I would say <code>-* = Hom(-, X)</code> sends epi to mono, and <code>Hom(- , M*)</code> sends mono to epi, but maybe you are implicitly working in the opposite category ...</p>",
        "id": 290110191,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658242312
    },
    {
        "content": "<p>Yeah that's what I meant. <code>-*</code> is contravariant.</p>",
        "id": 290110439,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658242403
    },
    {
        "content": "<p>I am confused, as the argument seems to require <code>-*</code> reflects epi to mono, instead of reflecting mono to epi ...</p>",
        "id": 290114685,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658244042
    },
    {
        "content": "<p>Sorry, I should have made things clearer. I meant <code>-*</code> (and <code>Hom(-, M*)</code>) as the contravariant functor taking <code>R-Mod</code> to <code>R-Mod^op</code>.</p>",
        "id": 290116047,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658244546
    },
    {
        "content": "<p>Yes but I don't see how <code>-*</code> reflects mono.</p>",
        "id": 290119013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658245680
    },
    {
        "content": "<p>Since <code>X</code> is a cogenerator, <code>Hom(-, X)</code> is faithful, and thus reflects mono (and also epi).</p>",
        "id": 290119480,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658245880
    },
    {
        "content": "<p>At <a href=\"https://github.com/jjaassoonn/flat/blob/master/src/flat'.lean\">here</a>, there is a proof that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>R</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">I \\otimes M \\to R \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective for all ideals, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is flat in the sense that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><msup><mi>N</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">N \\otimes M \\to N&#x27; \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>→</mo><msup><mi>N</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">N\\to N&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is injective, i.e. <a href=\"https://stacks.math.columbia.edu/tag/00HD\">00HD (3) implies (2)</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flat'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">N</span> <span class=\"n\">N'</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">⟶</span> <span class=\"n\">N'</span><span class=\"o\">),</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">L</span> <span class=\"bp\">→</span>\n  <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.map</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">linear_map.id</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`tensor_embedding M I` is the canonical map `I ⊗ M ⟶ R ⊗ M`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">flat'_of_ideal</span> <span class=\"o\">(</span><span class=\"n\">hIs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">tensor_embedding</span> <span class=\"n\">M</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">flat'</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The only sorry in this repo is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Q / \\mathbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mord\">/</span><span class=\"mord mathbb\">Z</span></span></span></span> is injective as a group which is proved elsewhere</p>\n<p>It basically follows the approach suggested by <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  with everything de-categorified.</p>",
        "id": 323718734,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1674739798
    },
    {
        "content": "<p>Update: <a href=\"https://github.com/jjaassoonn/flat\">this</a> contains a full proof of 00HD:  flat iff tensoring is exact iff tensoring preserves injective functions iff  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>R</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">I \\otimes M \\to R \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective for all ideals iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>R</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">I \\otimes M \\to R \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective for all finitely generated ideals.</p>",
        "id": 325291046,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1675294930
    },
    {
        "content": "<p>Oh nice! So now we actually have a working definition of flatness! </p>\n<p>A cool thing to do next would be to show flat iff the relevant Tor_1 vanishes a la <a href=\"https://stacks.math.columbia.edu/tag/00M5\">stacks 00M5</a></p>",
        "id": 325291540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1675295205
    },
    {
        "content": "<p>Another todo would be to remove the unnecessary comm_ring assumptions :-)</p>",
        "id": 325361554,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1675333839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/325291540\">said</a>:</p>\n<blockquote>\n<p>Oh nice! So now we actually have a working definition of flatness! </p>\n<p>A cool thing to do next would be to show flat iff the relevant Tor_1 vanishes a la <a href=\"https://stacks.math.columbia.edu/tag/00M5\">stacks 00M5</a></p>\n</blockquote>\n<p>By copying enough from liquid tensor experiment's snake lemma and short exact sequences turning into long exact sequences, a formalisation stakcs 00M5 can be found <a href=\"https://github.com/jjaassoonn/flat/blob/bab2f5c18fdee0042680c31b0350c69d241e9a82/src/free_modules_etc.lean#L214\">here</a>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">equiv_defs</span> <span class=\"o\">:</span> <span class=\"n\">tfae</span>\n  <span class=\"o\">[</span> <span class=\"n\">module.flat.ses</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"o\">,</span> <span class=\"n\">module.flat.inj</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"o\">,</span> <span class=\"n\">module.flat.ideal</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"o\">,</span> <span class=\"n\">module.flat.fg_ideal</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"o\">,</span> <span class=\"n\">module.flat.exact</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(((</span><span class=\"n\">Tor'</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">M</span> <span class=\"bp\">≅</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(((</span><span class=\"n\">Tor'</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">Module.of</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⧸</span> <span class=\"n\">I</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">M</span> <span class=\"bp\">≅</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">,</span> <span class=\"bp\">∀</span>  <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">I.fg</span><span class=\"o\">),</span>\n    <span class=\"n\">nonempty</span> <span class=\"o\">(((</span><span class=\"n\">Tor'</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">Module.of</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⧸</span> <span class=\"n\">I</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">M</span> <span class=\"bp\">≅</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n    <span class=\"n\">nonempty</span> <span class=\"o\">(((</span><span class=\"n\">Tor'</span> <span class=\"o\">(</span><span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">M</span> <span class=\"bp\">≅</span> <span class=\"mi\">0</span><span class=\"o\">)]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 345913592,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1680261126
    },
    {
        "content": "<p><code>(4) → (3)</code> (short version):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct.RightExactness</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Flat</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.RewriteSearch</span>\n\n<span class=\"c1\">-- Remove the `FG` condition from `Module.Flat.iff_rTensor_injective`</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n<span class=\"n\">suppress_compilation</span>\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Every `x : I ⊗ M` is the image of some `y : J ⊗ M` where `J ≤ I` is finitely generated,</span>\n<span class=\"c1\">-- under the tensor product of the inclusion `J.subtype.codRestrict .. : J → I`</span>\n<span class=\"c1\">-- and the identity `M → M`.</span>\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">TensorProduct</span> <span class=\"n\">LinearMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_fg_le_tensor_eq_rTensor_subtype_codRestrict_tensor</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">⊗</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">J.FG</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">≤</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⊗</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n      <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">J.subtype.codRestrict</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hle.subset</span> <span class=\"n\">c.property</span><span class=\"o\">))</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">⊥</span><span class=\"o\">,</span> <span class=\"n\">fg_bot</span><span class=\"o\">,</span> <span class=\"n\">zero_le</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">i</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">R</span> <span class=\"bp\">∙</span> <span class=\"n\">i.val</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">i.val</span><span class=\"o\">,</span> <span class=\"n\">mem_span_singleton_self</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">fg_span_singleton</span> <span class=\"n\">i.val</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">span_le</span><span class=\"o\">,</span> <span class=\"n\">Set.singleton_subset_iff</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Subtype.mem</span> <span class=\"n\">i</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span> <span class=\"n\">ihx₁</span> <span class=\"n\">ihx₂</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J₁</span><span class=\"o\">,</span> <span class=\"n\">hfg₁</span><span class=\"o\">,</span> <span class=\"n\">hle₁</span><span class=\"o\">,</span> <span class=\"n\">y₁</span><span class=\"o\">,</span> <span class=\"n\">hy₁</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihx₁</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J₂</span><span class=\"o\">,</span> <span class=\"n\">hfg₂</span><span class=\"o\">,</span> <span class=\"n\">hle₂</span><span class=\"o\">,</span> <span class=\"n\">y₂</span><span class=\"o\">,</span> <span class=\"n\">hy₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ihx₂</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">J₁</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">le_sup_left</span> <span class=\"o\">:</span> <span class=\"n\">J₁</span> <span class=\"bp\">≤</span> <span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"n\">c.property</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">le_sup_right</span> <span class=\"o\">:</span> <span class=\"n\">J₂</span> <span class=\"bp\">≤</span> <span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"n\">c.property</span>\n    <span class=\"k\">let</span> <span class=\"n\">z₁</span> <span class=\"o\">:=</span>\n      <span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">J₁.subtype.codRestrict</span> <span class=\"o\">(</span><span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"n\">y₁</span> <span class=\"bp\">+</span>\n      <span class=\"n\">rTensor</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">J₂.subtype.codRestrict</span> <span class=\"o\">(</span><span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">)</span> <span class=\"n\">h₂</span><span class=\"o\">)</span> <span class=\"n\">y₂</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">J₁</span> <span class=\"bp\">⊔</span> <span class=\"n\">J₂</span><span class=\"o\">,</span> <span class=\"n\">FG.sup</span> <span class=\"n\">hfg₁</span> <span class=\"n\">hfg₂</span><span class=\"o\">,</span> <span class=\"n\">sup_le</span> <span class=\"n\">hle₁</span> <span class=\"n\">hle₂</span><span class=\"o\">,</span> <span class=\"n\">z₁</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rTensor_comp</span><span class=\"o\">,</span> <span class=\"n\">comp_codRestrict</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rTensor_comp</span><span class=\"o\">,</span> <span class=\"n\">comp_codRestrict</span><span class=\"o\">]</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">subtype_comp_codRestrict</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hy₁</span><span class=\"o\">,</span> <span class=\"n\">hy₂</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Remove the `FG` condition from `Module.Flat.iff_rTensor_injective`</span>\n<span class=\"kn\">open</span> <span class=\"n\">LinearMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">iff_rTensor_injective'</span> <span class=\"o\">:</span>\n    <span class=\"n\">Module.Flat</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">M</span> <span class=\"n\">I.subtype</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">Module.Flat.iff_rTensor_injective</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">I</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">I</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">I</span><span class=\"o\">⟩</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- injective_iff_map_eq_zero cannot find this</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">injective_iff_map_eq_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx₀</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">hfg</span><span class=\"o\">,</span> <span class=\"n\">hle</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_fg_le_tensor_eq_rTensor_subtype_codRestrict_tensor</span> <span class=\"n\">x</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hy₀</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hy₀</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rTensor_comp</span><span class=\"o\">,</span> <span class=\"n\">subtype_comp_codRestrict</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx₀</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span> <span class=\"c1\">-- injective_iff_map_eq_zero cannot find this</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">injective_iff_map_eq_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">hfg</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"n\">hx₀</span>\n</code></pre></div>\n<p>Is this any use? Would you prefer to keep the gnarly colimits argument?</p>",
        "id": 402873609,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700311617
    },
    {
        "content": "<p>I would rather see this material in mathlib, however it gets there. It's a little frustrating having code kicking around \"in the wild\" which people can't use; I will need finite flat group schemes for FLT and so the sooner there are more lemmas characteristing flatness in mathlib, the better :-)</p>",
        "id": 402874404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700312386
    },
    {
        "content": "<p>I should presumably commit this in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7225\">#7225</a>, if anywhere</p>",
        "id": 402875226,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700312941
    },
    {
        "content": "<p>There is no gnarly colimits argument, sorry. The argument uses Baer's criterion, and it's a little beyond me.<br>\n<code>exists_fg_le_tensor_eq_rTensor_subtype_codRestrict_tensor</code> might be nice to have anyway. I'm just not sure the name is ugly enough yet.</p>",
        "id": 402875996,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700313560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/402874404\">said</a>:</p>\n<blockquote>\n<p>I would rather see this material in mathlib, however it gets there. It's a little frustrating having code kicking around \"in the wild\" which people can't use; I will need finite flat group schemes for FLT and so the sooner there are more lemmas characteristing flatness in mathlib, the better :-)</p>\n</blockquote>\n<p>It would be great if <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> 's work on flat modules could be ported to Lean4!</p>",
        "id": 402876439,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700313896
    },
    {
        "content": "<p>I have started porting dependencies already for example ![here](<a href=\"https://github.com/leanprover-community/mathlib4/pull/8473\">https://github.com/leanprover-community/mathlib4/pull/8473</a>) is direct limit and tensor products commutes which is used in finitely generated ideals are already sufficient for checking flatness</p>",
        "id": 402876569,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1700314015
    },
    {
        "content": "<p>\"finitely generated ideals are already sufficient for checking flatness\" is what my thing above shows, too.</p>",
        "id": 402877048,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700314388
    },
    {
        "content": "<p>Kind of. The existing Mathlib4 definition of <code>Flat</code> makes that a tautology. I show it implies a stronger version, but still only \"all ideals\", not the full-strength \"all submodules\" definition.</p>",
        "id": 402877424,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700314673
    },
    {
        "content": "<p>Your version is actually shorter than mine. The other blocking dependency I need is the tensor-hom adjunction from <a href=\"https://en.m.wikipedia.org/wiki/Tensor-hom_adjunction\">https://en.m.wikipedia.org/wiki/Tensor-hom_adjunction</a>. This is almost what we have in the <code>TensorProduct.Tower</code> file but not really because of the algebra instances in the said file.</p>",
        "id": 402877666,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1700314843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> I know you explained this to me verbally the other day, but can you write down exactly what is blocking you here? I would really like to get flatness back on the move.</p>",
        "id": 402877902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700314998
    },
    {
        "content": "<p>I will open another pr writing down the adjunction I need and inside the pr explain why I could not use the existing file this afternoon.</p>",
        "id": 402878229,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1700315304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252627\">Jujian Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/402877666\">said</a>:</p>\n<blockquote>\n<p>Your version is actually shorter than mine. The other blocking dependency I need is the tensor-hom adjunction from <a href=\"https://en.m.wikipedia.org/wiki/Tensor-hom_adjunction\">https://en.m.wikipedia.org/wiki/Tensor-hom_adjunction</a>. This is almost what we have in the <code>TensorProduct.Tower</code> file but not really because of the algebra instances in the said file.</p>\n</blockquote>\n<p>Want me to do anything about it? Say, should I make a new PR for my version, in <code>Mathlib.RingTheory.Flat</code>, mentioning <a href=\"https://github.com/leanprover-community/mathlib4/pull/8473\">#8473</a>?</p>",
        "id": 402878353,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700315416
    },
    {
        "content": "<p>Yes please! But <a href=\"https://github.com/leanprover-community/mathlib4/pull/8473\">#8473</a> is really just to show an ideal is isomorphic to direct limit of its finitely generated subideals so that ideal tensoring with another module is also related to fg ideals tensoring with another module. Since your code doesn’t need it, you don’t have to mention it. <a href=\"https://github.com/leanprover-community/mathlib4/pull/8473\">#8473</a> is probably useful on its own. But ideal is isomorphic to direct limit of its finitely generated subideals is probably less useful.</p>",
        "id": 402878743,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1700315796
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8494\">#8494</a></p>",
        "id": 402882999,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700319035
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8495\">#8495</a><br>\nset up: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> commutative ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo separator=\"true\">,</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">R, S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-bimodule,  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module, we want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>Y</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>R</mi></msub><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}_S(X⊗_R Y, Z) \\cong \\operatorname{Hom}_R(Y, \\operatorname{Hom}_S(X, Z))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">))</span></span></span></span>.  so to use the <code>Tower</code> file, we need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra which is a luxury we do not have here.<br>\nBut note that in <code>Tower</code> file, <code>curry</code> and <code>uncurry</code> are both tri-linear maps. So <code>Tower</code> file<br>\nallows interplay of 3 rings which is not allowed in this PR.</p>\n<p>definition in question: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.AlgebraTensorModule.uncurry#doc\">docs#TensorProduct.AlgebraTensorModule.uncurry</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.AlgebraTensorModule.lcurry#doc\">docs#TensorProduct.AlgebraTensorModule.lcurry</a></p>\n<hr>\n<p>another issue is that we can't have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>Y</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>X</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>R</mi></msub><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><msub><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo></mrow><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}_S(Y⊗_R X, Z) \\cong \\operatorname{Hom}_R(Y, \\operatorname{Hom}_S(X, Z))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">))</span></span></span></span> (the order of argument is flipped) because in mathlib4 we know <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\otimes_R Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module but we don't know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">Y\\otimes_R X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module as well. (At least I think this is the case)</p>",
        "id": 402888492,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1700322894
    },
    {
        "content": "<p>Aside about reviewing: when there are multiple people working on similar topics in Mathlib, it is <em>super</em> useful if they can write reviews of each others PRs. If a review has already taken place, responses made, and there is an \"approval\" tick, it is then much easier and faster for a maintainer or \"official\" reviewer to put it on the queue. Reviews can be done by everyone, not just  \"official\" reviewers, and indeed Mathlib can only scale if we get good at this.</p>\n<p>Moreover, if you've reviewed someone's PR, and would like to see it merged soon, writing on the <a class=\"stream\" data-stream-id=\"144837\" href=\"/#narrow/stream/144837-PR-reviews\">#PR reviews</a> stream something like \"I've reviewed #NNN and it now looks good to me. Could a maintainer please take a look?\" is very welcome.</p>\n<p>I wrote this message specifically because it would be great to see <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span>'s green tick on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8494\">#8494</a>, and <span class=\"user-mention\" data-user-id=\"400544\">@Richard Copley</span>'s green tick on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8495\">#8495</a>! :-)</p>",
        "id": 402949029,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1700363218
    },
    {
        "content": "<p>Reiterating my comment on <a href=\"https://github.com/leanprover-community/mathlib4/pull/8495\">#8495</a>; I would rather we work out how to generalize the existing curry/uncurry rather than add a third copy of the API.</p>",
        "id": 403036686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700416667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252627\">Jujian Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/402888492\">said</a>:</p>\n<blockquote>\n<p>another issue is that we can't have $\\operatorname{Hom}_S(Y⊗_R X, Z) \\cong \\operatorname{Hom}_R(Y, \\operatorname{Hom}_S(X, Z))$ (the order of argument is flipped) because in mathlib4 we know $X\\otimes_R Y$ is $S$-module but we don't know that $Y\\otimes_R X$ is $S$-module as well. (At least I think this is the case)</p>\n</blockquote>\n<p>It's not that mathlib <em>doesn't</em> know this, it that it <em>can't</em> know it without issues for instance diamonds in the case when <code>R = S</code></p>",
        "id": 403036767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700416712
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8494\">#8494</a> is merged (to staging). Thanks all!</p>",
        "id": 403058382,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700433434
    },
    {
        "content": "<p>Nice job finding <code>inclusion</code> just after I renamed it; that's good evidence that <code>ofLe</code> was a lousy name.</p>",
        "id": 403060376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700435227
    },
    {
        "content": "<p><code>inclusion</code> is easier to get a handle on, yeah. I reckon I had seen <code>ofLe</code> and forgotten all about it.</p>",
        "id": 403062092,
        "sender_full_name": "Richard Copley",
        "timestamp": 1700436769
    },
    {
        "content": "<p>Free modules are flat: <a href=\"https://github.com/leanprover-community/mathlib4/tree/richard-copley%2Ffree-modules-are-flat\">branch#richard-copley/free-modules-are-flat</a></p>\n<p>I'm not sure if this is needed. I just thought it would be fun!</p>\n<p>Thanks to <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> for the <a href=\"#narrow/stream/113489-new-members/topic/TensorProduct.20is.20zero.20iff/near/404970347\">advice</a>.</p>",
        "id": 407319391,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702328580
    },
    {
        "content": "<p>We surely want this! How long is it?</p>",
        "id": 407320695,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702329169
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo><mn>934</mn></mrow><annotation encoding=\"application/x-tex\">+934</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span><span class=\"mord\">934</span></span></span></span></p>",
        "id": 407320864,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702329242
    },
    {
        "content": "<p>I'm confused. Can't we deduce this easily from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.self#doc\">docs#Module.Flat.self</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.directSum#doc\">docs#Module.Flat.directSum</a> the fact that tensoring commutes with direct sums (I don't remember the name, but it's there), and some lemma about transferring flatness across isomorphisms (i.e. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.of_linearEquiv#doc\">docs#Module.Flat.of_linearEquiv</a> )?</p>",
        "id": 407321143,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702329344
    },
    {
        "content": "<p>934 lines seems indeed a lot</p>",
        "id": 407321275,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702329391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407320695\">said</a>:</p>\n<blockquote>\n<p>We surely want this! How long is it?</p>\n</blockquote>\n<p>Really long :)</p>",
        "id": 407321357,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407321143\">said</a>:</p>\n<blockquote>\n<p>I'm confused. Can't we deduce this easily from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.self#doc\">docs#Module.Flat.self</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.directSum#doc\">docs#Module.Flat.directSum</a> the fact that tensoring commutes with direct sums (I don't remember the name, but it's there), and some lemma about transferring flatness across isomorphisms (i.e. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.of_linearEquiv#doc\">docs#Module.Flat.of_linearEquiv</a> )?</p>\n</blockquote>\n<p>Sounds plausible. I just plodded through the argument in Dummit and Foote.</p>",
        "id": 407321624,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329556
    },
    {
        "content": "<p>Does that only work for <em>finite and</em> free modules?</p>",
        "id": 407321845,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329650
    },
    {
        "content": "<blockquote>\n<p>the fact that tensoring commutes with direct sums (</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.directSum#doc\">docs#TensorProduct.directSum</a></p>",
        "id": 407321887,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702329671
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Module.Flat</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">I</span><span class=\"o\">,⟨</span><span class=\"bp\">𝓑</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:</span> <span class=\"n\">Module.Free</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Module.Flat.of_linearEquiv</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"bp\">𝓑</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It was much easier.</p>",
        "id": 407321928,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702329689
    },
    {
        "content": "<p>It is very unfortunate that neither TensorProduct nor DirectSum notation appears in the docs</p>",
        "id": 407321972,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702329714
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.of_free#doc\">docs#Module.Flat.of_free</a><br>\n(the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7567\">#7567</a> was 133 lines)</p>",
        "id": 407322122,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702329773
    },
    {
        "content": "<p>Oh sure, but this is because our definition of flat is wrong, isn't it?</p>",
        "id": 407322153,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329797
    },
    {
        "content": "<p>The result is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">lTensor_free_injective_of_injective</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">N</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℤ</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hψ</span> <span class=\"o\">:</span> <span class=\"n\">Injective</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Injective</span> <span class=\"o\">(</span><span class=\"n\">lTensor</span> <span class=\"n\">M</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 407322166,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407322153\">said</a>:</p>\n<blockquote>\n<p>Oh sure, but this is because our definition of flat is wrong, isn't it?</p>\n</blockquote>\n<p>No, our definition of flatness is correct. But it's a theorem that it's equivalent to the definition of flatness that you see in books.</p>",
        "id": 407322256,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702329847
    },
    {
        "content": "<p>I thought we had that theorem in mathlib, but maybe we dont?</p>",
        "id": 407322298,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702329872
    },
    {
        "content": "<p>Not last time I looked.</p>",
        "id": 407322317,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329881
    },
    {
        "content": "<p>But it's a short step from this result (the short step is the next part of the Dummit and Foote exercise)</p>",
        "id": 407322449,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702329955
    },
    {
        "content": "<p>The doc says \"This is equivalent to the claim that for all injective R-linear maps f : M₁ → M₂ the induced map M₁ ⊗ M → M₂ ⊗ M is injective. See . This result is not yet formalised.\"</p>",
        "id": 407322554,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702329998
    },
    {
        "content": "<p>Note that there is literally \"See .\" I don't know why</p>",
        "id": 407322598,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330023
    },
    {
        "content": "<p>Yes, sorry for the unclarity. This is towards that result.</p>",
        "id": 407322637,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702330038
    },
    {
        "content": "<p>Perhaps a porting error?</p>",
        "id": 407322638,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330038
    },
    {
        "content": "<p>Who wants to fix the doc? It should take like 30 seconds, but here it's late</p>",
        "id": 407322758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330086
    },
    {
        "content": "<p>It says <code>See &lt;https://stacks.math.columbia.edu/tag/00HD&gt;.</code></p>",
        "id": 407322781,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702330099
    },
    {
        "content": "<p>Oh, that's a bug in docgen then!</p>",
        "id": 407322836,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330127
    },
    {
        "content": "<p>I assume Riccardo was looking at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Flat.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Flat.html</a></p>",
        "id": 407322910,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330168
    },
    {
        "content": "<p>Yes, with Firefox on Debian I see \"See .\"</p>",
        "id": 407322965,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330201
    },
    {
        "content": "<p>I assume the link doesn't show up because it's not a markdown link.</p>",
        "id": 407322969,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> how far are we from this result?</p>",
        "id": 407323190,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330313
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>## TODO\n\n* Show that tensoring with a flat module preserves injective morphisms.\n  Show that this is equivalent to be flat.\n</code></pre></div>\n<p>One can do this TODO item using the result I proved (<code>lTensor_free_injective_of_injective</code>) and a diagram chasing argument.</p>\n<p>Like I said, this was for my own edification. I won't be at all offended if someone else does it better.</p>",
        "id": 407323350,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702330387
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8473\">#8473</a> just got a maintainer merge by <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> , so we are at least moving towards the result</p>",
        "id": 407323508,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330470
    },
    {
        "content": "<p>Another question: Why does <code>Module.DirectLimit</code> even exist?</p>",
        "id": 407323708,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330588
    },
    {
        "content": "<blockquote>\n<p>I thought we had that theorem in mathlib, but maybe we dont?</p>\n</blockquote>\n<p>00HD is done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7225\">#7225</a> by <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> and he's opening PRs to move it into mathlib piece by piece. <a href=\"https://github.com/leanprover-community/mathlib4/pull/8906\">#8906</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/8559\">#8559</a> are currently pending PRs.</p>",
        "id": 407323744,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702330615
    },
    {
        "content": "<p>Pinging <span class=\"user-mention\" data-user-id=\"587941\">@Coleton Kotch</span> since he is interested in applying this.</p>",
        "id": 407323857,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702330679
    },
    {
        "content": "<blockquote>\n<p>Another question: Why does Module.DirectLimit even exist?</p>\n</blockquote>\n<p>Why should it not exist? If what you have in mind is to apply the category theory library, I outlined some difficulties <a href=\"https://github.com/leanprover-community/mathlib4/pull/8692#pullrequestreview-1761924595\">here</a>.</p>",
        "id": 407324023,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702330765
    },
    {
        "content": "<p>Can someone who really understand <code>UnivLE.{u, v}</code> have a look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/8905\">#8905</a>?</p>",
        "id": 407324254,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702330889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407323744\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I thought we had that theorem in mathlib, but maybe we dont?</p>\n</blockquote>\n<p>00HD is done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7225\">#7225</a> by <span class=\"user-mention silent\" data-user-id=\"252627\">Jujian Zhang</span> and he's opening PRs to move it into mathlib piece by piece. <a href=\"https://github.com/leanprover-community/mathlib4/pull/8906\">#8906</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/8559\">#8559</a> are currently pending PRs.</p>\n</blockquote>\n<p>OK, no need for a PR from me</p>",
        "id": 407324295,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702330915
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407324023\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Another question: Why does Module.DirectLimit even exist?</p>\n</blockquote>\n<p>Why should it not exist? If what you have in mind is to apply the category theory library, I outlined some difficulties <a href=\"https://github.com/leanprover-community/mathlib4/pull/8692#pullrequestreview-1761924595\">here</a>.</p>\n</blockquote>\n<p>Yes, I was thinking precisely of just using the category theory colimits. Is there anything you get by having an explicit description of the colimit that you can't get by using (or appropriately extending) the API for (co)limits in concrete categories?</p>",
        "id": 407324663,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702331084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407322969\">said</a>:</p>\n<blockquote>\n<p>I assume the link doesn't show up because it's not a markdown link.</p>\n</blockquote>\n<p>I think &lt;<a href=\"http://example.com\">http://example.com</a>&gt; is valid in most markdown dialects, just not the one that doc-gen4 uses. They're in <a href=\"https://spec.commonmark.org/0.30/#autolink\">the spec</a>.</p>",
        "id": 407324890,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331199
    },
    {
        "content": "<p>module.direct_limit has a 4+ years <a href=\"https://github.com/leanprover-community/mathlib/pull/754\">history</a> so it's not surprising that people have built a lot on it :)</p>",
        "id": 407324896,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702331203
    },
    {
        "content": "<p>ok, fair enough, but now you have to also duplicate the API every time you introduce a new algebraic gadget when you want to take a direct limit.</p>",
        "id": 407324994,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702331250
    },
    {
        "content": "<p>Presumably <code>Module.DirectLimit</code> is universe polymorphic and the category spelling isn't?</p>",
        "id": 407325245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331363
    },
    {
        "content": "<p>yes, that's true.</p>",
        "id": 407325274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702331378
    },
    {
        "content": "<p>Which almost certainly is irrelevant here, but in general is a curse of doing things through <code>CategoryTheory</code> first</p>",
        "id": 407325381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331413
    },
    {
        "content": "<p>What would have been the natural spelling in Mathlib of my first few auxiliary results? [Edit: imports fixed]</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.DirectSum.Module</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">TensorProduct</span> <span class=\"n\">Function</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">DirectSum</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The natural linear map `⨁̂ⁿ M → ⨁̂ⁿ N` induced on direct sums by a linear map `M → N`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">DirectSum.induced</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">DirectSum.toModule</span> <span class=\"n\">R</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">lof</span> <span class=\"n\">R</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">DirectSum</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- The natural linear map `F : ⨁̂ⁿ M → ⨁̂ⁿ N` induced on direct sums by a linear map `f : M → N`</span>\n<span class=\"sd\">satisfies `(F x) i = f (x i)`, for all `x` in `⨁̂ⁿ M`, for each index `i`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">DirectSum.induced_apply</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">induced</span> <span class=\"n\">R</span> <span class=\"n\">ι</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- The linear map on direct sums induced by an injective linear map is injective. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">DirectSum.induced_injective</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hinjective</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"n\">DirectSum.induced</span> <span class=\"n\">R</span> <span class=\"n\">ι</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 407325446,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702331448
    },
    {
        "content": "<p>the first one is probably called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DirectSum.map#doc\">docs#DirectSum.map</a> ?</p>",
        "id": 407325563,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702331509
    },
    {
        "content": "<p>Yeah, working with categories usually means sacrificing universe polymorphism (for example here the direct limit lies in the max universe of the indexing type's and the modules'), so sometimes you need to use ULifts. Maybe the solution is to add a ULift instance for every algebraic gadget, and maybe UnivLE could help a bit.</p>",
        "id": 407325581,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702331518
    },
    {
        "content": "<p>I think <code>induced</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp.mapRange.linearMap#doc\">docs#DFinsupp.mapRange.linearMap</a></p>",
        "id": 407325643,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331528
    },
    {
        "content": "<p>That is, DirectSum is missing a lot of API because copying the dfinsupp API by hand is a massive waste of time</p>",
        "id": 407325696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407325381\">said</a>:</p>\n<blockquote>\n<p>Which almost certainly is irrelevant here, but in general is a curse of doing things through <code>CategoryTheory</code> first</p>\n</blockquote>\n<p>I think we need to seriously think about this as a community. I hope this \"issue\" can be solved with some metaprogramming.</p>",
        "id": 407325918,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1702331654
    },
    {
        "content": "<p>(to recap: DFinsupp and DirectSum are defeq, and they used to be identically treated. I hijacked the meaning of the latter to mean \"has convolutional multiplication\", leaving the former with (the potential for) pointwise multiplication)</p>",
        "id": 407325998,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702331695
    },
    {
        "content": "<p>Do we really care about making mathlib be as universe polymorphic as the underlying type theory allows us to be? Before 2017 I had never heard of any universes beyond <code>Type</code>, I only put universes in because that seems to be the current fashion. When I'm teaching I only ever use <code>Type</code>.</p>",
        "id": 407326818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702332057
    },
    {
        "content": "<p>I think the problem is we're forced to pick between:</p>\n<ul>\n<li>Use <code>Type</code> everywhere. This breaks  people working with <code>Cardinal</code></li>\n<li>Use <code>Type*</code> everywhere we can. This rules out going via category theory without losing generality</li>\n<li>Use <code>X Y : Type u</code> as much as possible. This means people writing <code>Type*</code> get more confusing universe error messages, and forces us to use <code>ULift</code> more often</li>\n</ul>",
        "id": 407333308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702335066
    },
    {
        "content": "<p>Universes got more annoying in Lean 4 mainly because of <a href=\"https://github.com/leanprover/lean4/pull/2297\">lean4#2297</a></p>\n<p>(UnivLE was designed to bypass the issue, but universe inequalities have been of independent interest.)</p>",
        "id": 407334089,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702335531
    },
    {
        "content": "<p>(and note that if we use <code>Type u</code> everywhere, then we're not even allowed to state things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift.moduleEquiv#doc\">docs#ULift.moduleEquiv</a>, which makes <code>ULift</code> even harder to use)</p>",
        "id": 407334100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702335536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407325643\">said</a>:</p>\n<blockquote>\n<p>I think <code>induced</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp.mapRange.linearMap#doc\">docs#DFinsupp.mapRange.linearMap</a></p>\n</blockquote>\n<p>I cleaned up the branch a little using this. It didn't save a huge number of lines.</p>\n<p><code>DFinsupp.mapRange</code> is a real pain to use! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Is there a short proof of <code>TensorProduct.rid_DirectSum_tmul</code> (below), or do we already have it? If not, do we want it?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.DFinsupp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.DirectSum.TensorProduct</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">DirectSum</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"sd\">/-- If `N` is an `R`-module then `Rⁿ ⊗ N ≃ Nⁿ`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"bp\">!</span> <span class=\"n\">apply</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProduct.rid_DirectSum</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.directSumRight</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≪≫ₗ</span>\n    <span class=\"n\">DFinsupp.mapRange.linearEquiv</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TensorProduct.rid</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Applying the linear equivalence `rid_DirectSum` to a simple element `x ⊗ r` of `N ⊗ Rⁿ`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.rid_DirectSum_tmul</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- It suffices to show the equality holds when `r` is a Kronecker delta.</span>\n  <span class=\"c1\">-- To show this we recast as an equality of linear maps ...</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n        <span class=\"n\">DFinsupp.mapRange.linearMap</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LinearMap.flip</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.lsmul</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"kd\">by</span>\n      <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">]</span>\n      <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange_def</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mk_apply</span><span class=\"o\">]</span>\n      <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span>\n      <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.flip_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.lsmul_apply</span><span class=\"o\">,</span> <span class=\"n\">Subtype.coe_mk</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.not_mem_support_iff.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">],</span>\n    <span class=\"bp\">←</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- ... and apply the default extensionality theorems (explicit here for clarity).</span>\n  <span class=\"n\">refine</span> <span class=\"n\">DirectSum.linearMap_ext</span> <span class=\"n\">R</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LinearMap.ext_ring</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_DirectSum_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">directSumRight_tmul_lof</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_tmul</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.flip_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.lsmul_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 407784538,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702491008
    },
    {
        "content": "<p>I recommend writing the suffices explicitly if you can</p>",
        "id": 407836963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702514425
    },
    {
        "content": "<p>I guess looking at <a href=\"https://github.com/leanprover-community/mathlib4/blob/5973b7110e5745124d413dd9b88c6118668adf4e/Mathlib/RingTheory/Flat.lean#L165-L203\">the proof</a> of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.directSum#doc\">docs#Module.Flat.directSum</a> should help? Indeed the proof is longer than I'd expect ...</p>",
        "id": 407838333,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702515068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407838333\">said</a>:</p>\n<blockquote>\n<p>I guess looking at <a href=\"https://github.com/leanprover-community/mathlib4/blob/5973b7110e5745124d413dd9b88c6118668adf4e/Mathlib/RingTheory/Flat.lean#L165-L203\">the proof</a> of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.directSum#doc\">docs#Module.Flat.directSum</a> should help? Indeed the proof is longer than I'd expect ...</p>\n</blockquote>\n<p>It helps a little! The proof in <code>Flat.directSum</code> doesn't contain the whole of this lemma. That proof's diagram has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>I</mi><mo>⊗</mo><mi>M</mi><msup><mo stretchy=\"false\">)</mo><mi>n</mi></msup><mo>→</mo><mi>I</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><msup><mi>M</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo><mo>→</mo><mi>R</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><msup><mi>M</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>M</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">(I⊗M)ⁿ → I⊗(Mⁿ) → R⊗(Mⁿ) → Mⁿ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> plus some projections and maps between components, but nowhere does it need <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msup><mi>R</mi><mi>n</mi></msup><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">(Rⁿ)⊗M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. Still, part of it is very similar to my proof, and the details might be applicable. I'll give it some thought.</p>",
        "id": 407857419,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702523093
    },
    {
        "content": "<p>It was a fairly recent PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7567\">#7567</a> and the author is <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span></p>",
        "id": 407858300,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702523411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407836963\">said</a>:</p>\n<blockquote>\n<p>I recommend writing the suffices explicitly if you can</p>\n</blockquote>\n<p>I can, and it allows more of the rewriting to be done in the \"complicated → simple\" direction, which is easier to understand. I take it that's one of the motivations for your recommendation? Unfortunately, it so happens that when I do that, I also need to add more workarounds for the fact that the defeq between DirectProduct and DFinsupp is not reducible. That makes the proofs quite slow to elaborate.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407838333\">said</a>:</p>\n<blockquote>\n<p>I guess looking at <a href=\"https://github.com/leanprover-community/mathlib4/blob/5973b7110e5745124d413dd9b88c6118668adf4e/Mathlib/RingTheory/Flat.lean#L165-L203\">the proof</a> of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Flat.directSum#doc\">docs#Module.Flat.directSum</a> should help? Indeed the proof is longer than I'd expect ...</p>\n</blockquote>\n<p>Part of it was unnecessarily long (the <code>split ifs</code> was not needed) and I have golfed it.<br>\nMy lemma is mostly about <code>DFinsupp.mapRange</code> which is not used in <span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span>'s proof, so while the proofs are already have a strong family resemblance, the details of the one aren't really applicable to the other.</p>\n<p>Here are three more versions to illustrate.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct.Prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.DFinsupp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.DirectSum.TensorProduct</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">DirectSum</span> <span class=\"n\">TensorProduct</span> <span class=\"n\">LinearMap</span>\n\n<span class=\"sd\">/-- If `N` is an `R`-module then `Rⁿ ⊗ N ≃ Nⁿ`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"bp\">!</span> <span class=\"n\">apply</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProduct.rid_DirectSum</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.directSumRight</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≪≫ₗ</span>\n    <span class=\"n\">DFinsupp.mapRange.linearEquiv</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">TensorProduct.rid</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"n\">count_heartbeats</span> <span class=\"k\">in</span> <span class=\"c1\">-- 37087</span>\n<span class=\"sd\">/-- Applying the linear equivalence `rid_DirectSum` to a simple element `x ⊗ r` of `N ⊗ Rⁿ`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.rid_DirectSum_tmul</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- It suffices to show the equality holds when `r` is a Kronecker delta.</span>\n  <span class=\"c1\">-- To show this we recast as an equality of linear maps ...</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">DFinsupp.mapRange.linearMap</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">lsmul</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_apply</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span> <span class=\"mi\">2</span>\n  <span class=\"c1\">-- ... and apply the default extensionality theorems (explicit here for clarity).</span>\n  <span class=\"n\">refine</span> <span class=\"n\">DirectSum.linearMap_ext</span> <span class=\"n\">R</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LinearMap.ext_ring</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_DirectSum_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">directSumRight_tmul_lof</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_tmul</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n\n<span class=\"n\">count_heartbeats</span> <span class=\"k\">in</span> <span class=\"c1\">-- 41817</span>\n<span class=\"sd\">/-- Applying the linear equivalence `rid_Finprod` to a simple element `r ⊗ x` of `Rⁿ ⊗ N`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.rid_DirectSum_tmul'</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Recast as an equality of linear maps in order to apply extensionality theorems.</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span>\n      <span class=\"o\">((</span><span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">r</span> <span class=\"bp\">=</span>\n        <span class=\"n\">DFinsupp.mapRange.linearMap</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lsmul</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"k\">from</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_apply</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span> <span class=\"mi\">1</span>\n  <span class=\"n\">refine</span> <span class=\"n\">DirectSum.linearMap_ext</span> <span class=\"n\">R</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LinearMap.ext_ring</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- We need only show the equality holds when `r` is a Kronecker delta.</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_DirectSum_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">directSumRight_tmul_lof</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearEquiv_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span>\n    <span class=\"n\">rid_tmul</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n\n<span class=\"n\">count_heartbeats</span> <span class=\"k\">in</span> <span class=\"c1\">-- 47069</span>\n<span class=\"sd\">/-- Applying the linear equivalence `rid_Finprod` to a simple element `r ⊗ x` of `Rⁿ ⊗ N`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">TensorProduct.rid_DirectSum_tmul''</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n      <span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Recast as an equality of linear maps in order to apply extensionality theorems.</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">h</span> <span class=\"o\">:</span>\n      <span class=\"o\">((</span><span class=\"n\">rid_DirectSum</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"bp\">⨁</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">R</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n        <span class=\"n\">DFinsupp.mapRange.linearMap</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">lsmul</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">from</span> <span class=\"kd\">by</span>\n    <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.ext_iff.mp</span> <span class=\"n\">h</span> <span class=\"n\">r</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">DirectSum</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_apply</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">DirectSum.linearMap_ext</span> <span class=\"n\">R</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">LinearMap.ext_ring</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">-- We need only show the equality holds when `r` is a Kronecker delta.</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">LinearEquiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">rid_DirectSum_apply</span><span class=\"o\">,</span> <span class=\"n\">mk_apply</span><span class=\"o\">,</span> <span class=\"n\">directSumRight_tmul_lof</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.mapRange.linearEquiv_apply</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange.linearMap_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">single_eq_lof</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.mapRange_single</span><span class=\"o\">,</span>\n    <span class=\"n\">rid_tmul</span><span class=\"o\">,</span> <span class=\"n\">flip_apply</span><span class=\"o\">,</span> <span class=\"n\">lsmul_apply</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 408353722,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702740470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Richard Copley</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/407322449\">said</a>:</p>\n<blockquote>\n<p>But it's a short step from this result (the short step is the next part of the Dummit and Foote exercise)</p>\n</blockquote>\n<p>The statement of the exercise is short, but I've finally given up trying to solve it and looked for others' solutions online. The answers to <a href=\"https://math.stackexchange.com/questions/398907/a-flatness-criterion\">this question</a> on Math StackExchange use a certain amount of technology that's a liitle beyond me. I don't think I'll be posting a 3000-line elementary proof any time soon <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 409065874,
        "sender_full_name": "Richard Copley",
        "timestamp": 1703039022
    },
    {
        "content": "<p>All of this is done but not PRed by <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> or possibly <span class=\"user-mention\" data-user-id=\"671216\">@Jujian Zhang</span></p>",
        "id": 409152559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703069858
    }
]