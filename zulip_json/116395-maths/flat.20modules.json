[
    {
        "content": "<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>\n<p>Tagging <span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> since you seem to have asked some related questions before.<br>\nAlso <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> since you are working on cogenerators in abelian categories; this result follows from Baer's criterion if we know that  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(M, X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> is injective iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is flat for <code>X</code> being a (injective?) cogenerator (if I am not mistaken). I'm not sure if this is in your plan.<br>\nAnd also <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> since Baer's criterion is your work.</p>",
        "id": 290078233,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658225786
    },
    {
        "content": "<p>This has been a major todo ever since I added the definition of flat modules. It would be awesome to close it.</p>",
        "id": 290078574,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658226006
    },
    {
        "content": "<p>This is not on my roadmap.</p>",
        "id": 290079460,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1658226583
    },
    {
        "content": "<p>Will your work imply that <code>Module R</code> has an injective cogenerator?</p>",
        "id": 290079847,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658226845
    },
    {
        "content": "<p>Yes, when combined with <a href=\"https://github.com/jjaassoonn/twist/blob/8b12ca696c19c239c2e9deeab51c5dc04e586fed/src/enough_injectives/adjunction_Ab.lean#L183\">Jujian's proof that <code>Module R</code> has enough injectives</a></p>",
        "id": 290080073,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1658227014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/290078233\">said</a>:</p>\n<blockquote>\n<p>Are there people currently developing some API around flat modules? For the first step, having <code>I ⊗ M →ₗ M</code> injective for all <code>I</code>(the definition in mathlib) iff <code>- ⊗ M</code> is exact would be nice.</p>\n</blockquote>\n<p>I have this project on flat modules working towards that: <a href=\"https://github.com/mpenciak/flat_modules\">https://github.com/mpenciak/flat_modules</a></p>\n<p>It's funny you should bring it up because I hadn't touched the project in months, but I just dusted it off last night (bumped mathlib) and intended on trying to make some more progress.</p>",
        "id": 290088150,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232067
    },
    {
        "content": "<p>What a coincidence!<br>\nHave you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>",
        "id": 290088553,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658232306
    },
    {
        "content": "<p>So far I've managed to prove a couple technical things that are used in the Stacks project proof:</p>\n<p>1) Any module is a direct limit of its f.g. submodules. <br>\n2) Tensor product commutes with direct limit (turns out I did more work than needed for this, because it's easy to deduce from some lemmas already in mathlib)</p>\n<p>I got stuck on the next part of the proof because at the time I found the API around short exact sequences in mathlib wasn't quite there to state/prove things like <code>0 → R¹ → Rⁿ⁺¹ → Rⁿ → 0</code>is short exact</p>",
        "id": 290088560,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/290088553\">said</a>:</p>\n<blockquote>\n<p>What a coincidence!<br>\nHave you ever considered the approach I mentioned? I think it might be easier than the proof in stacks since we already have Baer's criterion.</p>\n</blockquote>\n<p>I'd have to look at the proof using Baer's criterion, but it sounds like it should be more do-able!</p>",
        "id": 290088708,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1658232397
    },
    {
        "content": "<p>The proof goes like:<br>\nLet <code>M*</code> denote <code>Hom(M, X)</code>, then by the tensor-hom adjunction, <code>Hom(- , M*)</code> is naturally isomorphic to <code>(_ ⊗ M)*</code>.<br>\nSince <code>-* = Hom(-, X)</code> preserves mono, and reflects mono when it is faithful (<code>X</code> is a cogenerator), <code>M*</code> is injective iff <code>Hom(- , M*)</code> preserves mono iff <code>_ ⊗ M</code> preserves mono iff <code>M</code> is flat.<br>\nBut Baer's criterion tells you that it suffices to check if <code>Hom(- , M*)</code> preserves mono of the form <code>I → R</code>, so we only need to check such morphisms when checking flatness.</p>",
        "id": 290089813,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658233132
    },
    {
        "content": "<p>I would say <code>-* = Hom(-, X)</code> sends epi to mono, and <code>Hom(- , M*)</code> sends mono to epi, but maybe you are implicitly working in the opposite category ...</p>",
        "id": 290110191,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658242312
    },
    {
        "content": "<p>Yeah that's what I meant. <code>-*</code> is contravariant.</p>",
        "id": 290110439,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658242403
    },
    {
        "content": "<p>I am confused, as the argument seems to require <code>-*</code> reflects epi to mono, instead of reflecting mono to epi ...</p>",
        "id": 290114685,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658244042
    },
    {
        "content": "<p>Sorry, I should have made things clearer. I meant <code>-*</code> (and <code>Hom(-, M*)</code>) as the contravariant functor taking <code>R-Mod</code> to <code>R-Mod^op</code>.</p>",
        "id": 290116047,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658244546
    },
    {
        "content": "<p>Yes but I don't see how <code>-*</code> reflects mono.</p>",
        "id": 290119013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658245680
    },
    {
        "content": "<p>Since <code>X</code> is a cogenerator, <code>Hom(-, X)</code> is faithful, and thus reflects mono (and also epi).</p>",
        "id": 290119480,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658245880
    },
    {
        "content": "<p>At <a href=\"https://github.com/jjaassoonn/flat/blob/master/src/flat'.lean\">here</a>, there is a proof that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>R</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">I \\otimes M \\to R \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective for all ideals, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is flat in the sense that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><msup><mi>N</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">N \\otimes M \\to N&#x27; \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8352em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is injective whenever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>→</mo><msup><mi>N</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">N\\to N&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is injective, i.e. <a href=\"https://stacks.math.columbia.edu/tag/00HD\">00HD (3) implies (2)</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">flat'</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">N</span> <span class=\"n\">N'</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">⟶</span> <span class=\"n\">N'</span><span class=\"o\">),</span>\n  <span class=\"n\">function.injective</span> <span class=\"n\">L</span> <span class=\"bp\">→</span>\n  <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.map</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">linear_map.id</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`tensor_embedding M I` is the canonical map `I ⊗ M ⟶ R ⊗ M`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">flat'_of_ideal</span> <span class=\"o\">(</span><span class=\"n\">hIs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">tensor_embedding</span> <span class=\"n\">M</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">flat'</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The only sorry in this repo is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Q / \\mathbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mord\">/</span><span class=\"mord mathbb\">Z</span></span></span></span> is injective as a group which is proved elsewhere</p>\n<p>It basically follows the approach suggested by <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>  with everything de-categorified.</p>",
        "id": 323718734,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1674739798
    }
]