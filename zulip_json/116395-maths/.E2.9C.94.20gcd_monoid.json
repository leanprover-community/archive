[
    {
        "content": "<p>I don't find an instance of <code>gcd_monoid</code> for a <code>principal_ideal_domain</code> (nor of <code>gcd_normalized_monoid</code>). Is it normal?</p>",
        "id": 303478640,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665507008
    },
    {
        "content": "<p>It seems it's not there</p>",
        "id": 303481287,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665507818
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.to_gcd_monoid\">docs#unique_factorization_monoid.to_gcd_monoid</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.to_normalized_gcd_monoid\">docs#unique_factorization_monoid.to_normalized_gcd_monoid</a> are not instances though <a href=\"https://leanprover-community.github.io/mathlib_docs/find/principal_ideal_ring.to_unique_factorization_monoid\">docs#principal_ideal_ring.to_unique_factorization_monoid</a> is.</p>",
        "id": 303481449,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665507859
    },
    {
        "content": "<p>because gcd_monoid carries data</p>",
        "id": 303481541,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665507894
    },
    {
        "content": "<p>Ah sure</p>",
        "id": 303481806,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665507984
    },
    {
        "content": "<p>How the normalization is defined on a general UFD?!</p>",
        "id": 303481862,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508004
    },
    {
        "content": "<p>It takes [normalization_monoid α] as an argument</p>",
        "id": 303482015,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665508065
    },
    {
        "content": "<p>Ah ops</p>",
        "id": 303482037,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508072
    },
    {
        "content": "<p>It makes sense</p>",
        "id": 303482061,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508080
    },
    {
        "content": "<p>Still I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.to_gcd_monoid\">https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.to_gcd_monoid</a> should be an instance</p>",
        "id": 303482433,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508191
    },
    {
        "content": "<p>You need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.normalization_monoid\">docs#unique_factorization_monoid.normalization_monoid</a> to choose a normalization. <del>(It seems this construction can be generalized to any monoid ...)</del></p>",
        "id": 303482543,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665508214
    },
    {
        "content": "<p>Mmm, if it is an instance it risks to conflict with the normalized one</p>",
        "id": 303482981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508370
    },
    {
        "content": "<p>So annoying</p>",
        "id": 303483035,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1665508388
    },
    {
        "content": "<p>I think it doesn't hurt to add <code>unique_factorization_monoid -&gt; nonempty (gcd_monoid / normalization_monoid / normalized_gcd_monoid)</code> instances, and then you can use choice (or just destruct the <code>nonempty</code> when in a proof) to get the desired (normalized)_(gcd)_monoid.</p>",
        "id": 303511190,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665518723
    },
    {
        "content": "<p>Well, but then if you need to use choice, or destruct <code>nonempty</code> in a proof, isn't it the same as doing <code>haveI : blabla</code> and add the local instance? By \"the same\" I mean \"equally annoying\".</p>",
        "id": 303521373,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665522914
    },
    {
        "content": "<p>Maybe some theorems could be changed to use the <code>nonempty gcd_monoid</code> etc. hypothesis, if gcd doesn't appear in the statement? If you want the gcd data you have to make some choice, right? If you're working with explicit types there may already be gcd_monoid instances like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.normalized_gcd_monoid\">docs#polynomial.normalized_gcd_monoid</a>. I don't know about your use case so maybe this is a <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>.</p>",
        "id": 303522649,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665523487
    },
    {
        "content": "<p>Well, my use case is for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> but in general I would like to have <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> 's  proof that the minimal polynomial does not change when passing to the field of fractions for arbitrary PID's. Now we have it for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> and for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>T</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[T]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> but this sounds strange.</p>",
        "id": 303522938,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665523643
    },
    {
        "content": "<p>At any rate, I will use PID-&gt;UFM-&gt;normalized_gcd using <code>haveI</code> for the second step for the time being.</p>",
        "id": 303523103,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665523721
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/minpoly.gcd_domain_eq_field_fractions\">docs#minpoly.gcd_domain_eq_field_fractions</a> is a theorem that could have <code>[normalized_gcd_monoid R]</code> replaced by <code>[nonempty (normalized_gcd_monoid R)]</code> as far as I can see.</p>\n<p>We certainly don't want to end up with two non-defeq instances on the same type. We could use <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#forgetful%20inheritance\">forgetful inheritance</a> and demand that <code>unique_factorization_monoid</code> carries the data of gcd and normalization, but it seems to me there's no good way to normalize in a consistent way in e.g. a number ring of class number one.</p>",
        "id": 303524107,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665524204
    },
    {
        "content": "<p>Yes, I think you are right. Yet I wonder if there is a mathematical reason for these troubles: the theorem should hold for a PID, right? The choice of normalization is only needed to allow the greater generality of <code>gcd_monoids</code> instead of <code>UFD</code>'s, am I wrong?</p>",
        "id": 303524347,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665524322
    },
    {
        "content": "<p>Actually I think this particular theorem could simply be generalized to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_integrally_closed\">docs#is_integrally_closed</a> as I mention in <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Power.20basis.20of.20.60adjoin.20R.20x.60/near/303506914\">another thread</a>, which is a Prop, then typeclass inference through the instances <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.is_integrally_closed\">docs#unique_factorization_monoid.is_integrally_closed</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/principal_ideal_ring.to_unique_factorization_monoid\">docs#principal_ideal_ring.to_unique_factorization_monoid</a> should be automatic.</p>\n<p>Before that happens, PID-&gt;UFM-&gt;normalized_gcd is probably the easiest way to go.</p>\n<p>Actually right now if you want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.minpoly.equiv_adjoin\">docs#adjoin_root.minpoly.equiv_adjoin</a> for R a field you have to go through that ordeal as well.</p>",
        "id": 303524702,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665524507
    },
    {
        "content": "<p>Actually, I tried but I am stuck with <code>normalization_monoid ℤ_[p]</code> which seems to be needed for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.to_normalized_gcd_monoid\">docs#unique_factorization_monoid.to_normalized_gcd_monoid</a> But this cannot be inferred by PID/UFD automatically.</p>",
        "id": 303525197,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665524750
    },
    {
        "content": "<p>But I agree that <code>integrally_closed</code> seems the right generality, I hope it will get PR'd soon.</p>",
        "id": 303525336,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665524808
    },
    {
        "content": "<p>This is what you are missing:<br>\n<span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/gcd_monoid/near/303482543\">said</a>:</p>\n<blockquote>\n<p>You need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.normalization_monoid\">docs#unique_factorization_monoid.normalization_monoid</a> to choose a normalization. <del>(It seems this construction can be generalized to any monoid ...)</del></p>\n</blockquote>",
        "id": 303526185,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665525070
    },
    {
        "content": "<p>Ah, thanks! As a last question: where does this \"normalization\" idea come from? Do we have an example in nature of something having several normalizations? And why is it called a \"normalization\" (the <code>norm_unit</code> gadget in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normalization_monoid\">docs#normalization_monoid</a> looks completely obscure to me, what is it meant to represent?)</p>",
        "id": 303526536,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665525233
    },
    {
        "content": "<p>The first example is multiplying the inverse of the leading coefficient of a polynomial to make it monic (over a field; over a general normalized_monoid you may still normalize the leading coefficient the same way you normalize it in the base monoid), and in the integers you multiply by the sign; the other examples tend to have trivial group of units so the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normalize\">docs#normalize</a> map is just identity.</p>",
        "id": 303527354,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665525609
    },
    {
        "content": "<p>Oh, I see. I think I need to understand this better, I will come back if I have any further questions. But thanks so much!</p>",
        "id": 303527882,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665525831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> has marked this topic as resolved.</p>",
        "id": 303530539,
        "sender_full_name": "Notification Bot",
        "timestamp": 1665527150
    },
    {
        "content": "<p>I think <code>casesI dedicated_lemma</code> is not \"equally annoying\" as <code>haveI := instance_whose_name_was_probably_autogenerated_and_with_not_enough_explicit_arguments</code>.</p>",
        "id": 303535329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665530162
    },
    {
        "content": "<p>This is what we do for <code>finite -&gt; fintype</code>. See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_fintype\">docs#nonempty_fintype</a></p>",
        "id": 303535400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665530194
    },
    {
        "content": "<p>I think the following is easy enough?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">nonempty_fintype</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">casesI</span> <span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"bp\">$</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303536395,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665530884
    },
    {
        "content": "<p>But yes <code>casesI nonempty_fintype α,</code> is indeed shorter, and a lemma probably suffices for our case. I think we just need the lemma <code>[unique_factorization_monoid α] → nonempty (normalized_gcd_monoid α)</code>; once we get the <code>normalized_gcd_monoid α</code>, we would get <code>normalization_monoid α</code> and <code>gcd_monoid α</code> for free. We don't need instances going from <code>nonempty (normalized_gcd_monoid α)</code> to <code>nonempty (gcd_monoid α)</code> etc. and it doesn't seem like we can define a universal <code>nonempty_lift</code> instance that works for all classes.</p>",
        "id": 303537922,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665531893
    },
    {
        "content": "<p>Oh sorry I take that back, it's possible that we already have a <code>normalization_monoid</code> instance but want to put an arbitrary <code>gcd_monoid</code> instance on some type, in which case we don't want an arbitrarily chosen <code>normalized_gcd_monoid</code> instance. And instances from <code>nonempty (normalized_gcd_monoid α)</code> to <code>nonempty (gcd_monoid α)</code> and alike would be necessary if we want theorems with <code>[nonempty (gcd_monoid α)]</code> as an argument to automatically apply to <code>unique_factorization_monoid</code>.</p>",
        "id": 303538310,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665532148
    },
    {
        "content": "<p>So we probably want all of the arrows below to be instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                                       <span class=\"n\">normalized_gcd_monoid</span> <span class=\"bp\">→</span>        <span class=\"n\">gcd_monoid</span>\n                                          <span class=\"bp\">↓</span>                                <span class=\"bp\">↓</span>\n<span class=\"n\">unique_factorization_monoid</span> <span class=\"bp\">→</span> <span class=\"n\">nonempty</span> <span class=\"n\">normalized_gcd_monoid</span> <span class=\"bp\">→</span> <span class=\"n\">nonempty</span> <span class=\"n\">gcd_monoid</span>           <span class=\"bp\">→</span> <span class=\"n\">is_integrally_closed</span>\n                                                             <span class=\"bp\">↘</span> <span class=\"n\">nonempty</span> <span class=\"n\">normalization_monoid</span>\n                                                                           <span class=\"bp\">↑</span>\n                                                                        <span class=\"n\">normalization_monoid</span>\n</code></pre></div>",
        "id": 303539302,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665532911
    },
    {
        "content": "<p>I guess it's impossible to define some meta-instance that generates the following instances automatically; maybe it's doable via automation with a new attribute? Or maybe it should be built into Lean because it won't cause loops?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">--fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 303540838,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665533988
    },
    {
        "content": "<p>Forget what I said above: the following simple instance makes the above two examples work, and the linters are actually happy about it (as long as the priority is set to &lt;1000)!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nonempty_intro</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨‹</span><span class=\"n\">α</span><span class=\"o\">›⟩</span>\n</code></pre></div>",
        "id": 303548927,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665540397
    },
    {
        "content": "<p>Still not sure how we should \"lift\" an instance to <code>nonempty</code> though. If an instance has <code>nonempty ...</code> as the conclusion, then every argument could have a <code>nonempty</code> added and it will still be a valid instance. Maybe during an instance search, if the target is <code>nonempty ...</code>, then every subgoal generated should have a <code>nonempty</code> around it? This sounds like it has to be achieved by modifying Lean itself, but could it be achieved via some meta code?</p>",
        "id": 303550173,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665541669
    }
]