[
    {
        "content": "<p>I'm visiting EPFL. Martin Hairer said he wanted to see how Lean worked in practice, so asked me a challenge question: to prove that for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> naturals, there is a C^infty function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> supported on the closed ball such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∫</mo><mi>ρ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>d</mi><mi>x</mi><mo>=</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\int\\rho(x)P(x)dx=P(0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1111em;vertical-align:-0.3061em;\"></span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">ρ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span> for all polynomials of total degree at most <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>. He sketched some proofs, e.g. \"it's true for the delta function and now just perturb it a bit, you only need to satisfy finitely many criteria\" or \"use integration by parts and the fact that if you differentiate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">N+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> times you get zero\" or \"consider functions supported very close to a point in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span> and now use lots of points and take a linear combination\". But I told him that I couldn't possibly code up any of these in real time because I had no idea what was in the library :-( Are any of these straightforward to push through given what we have?</p>",
        "id": 404836147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701254694
    },
    {
        "content": "<p>Am I right that it follow for purely abstract reasons if we prove that <br>\ndimension(C^infty functions supported on the closed ball) &gt; dimension(polynomials of degree N)?<br>\nIf so, we just need to show that the LHS is infinite.</p>",
        "id": 404842069,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701256619
    },
    {
        "content": "<p>Floris, I think that you need a little more: the space of C-infty functions supported on the unit ball <em>that are also 0 at 0</em> is also infinite-dimensional, but is no good for the conclusion that you want.  This is an affine-linear problem, so you should embed in your statement the fact that there is a solution to the affine version, before you can get the whole \"add a general solution of the associated linear problem\".</p>\n<p>... or am I wrong?  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>EDIT: maybe I am wrong.  This problem is linear in <code>P</code>.</p>",
        "id": 404850990,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701259835
    },
    {
        "content": "<p>Btw, to get infinite dimensionality, you can take any non-zero function supported on the unit ball and show that multiplication by polynomials is injective by arguing that two polynomials multiplying to the same function would be polynomials that agree on the support of the initial function, which is open and non-empty, by the assumption that the function is non-zero.</p>",
        "id": 404851527,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701260053
    },
    {
        "content": "<p><del>But this argument still does not give you an example, I think.</del></p>",
        "id": 404851591,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701260077
    },
    {
        "content": "<p>Somebody once told me you should formalise the statement first if you want help with a proof ;)</p>",
        "id": 404853164,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701260707
    },
    {
        "content": "<p>I think Damiano's right; this was the method I wanted to use but you have a big vector space V and finitely many linear maps from V to the reals, you have the intersection W of their kernels (so W has finite codimension in V so it's huge) and then you have the preimage of {1} under another linear map and you need to check that this preimage of {1} meets W, which is not formal, it probably boils down to an assertion of the form \"the linear map sending rho to integral of rho(x) is not in the span of the linear maps sending rho to integral of rho(x).x^n for 0&lt;n&lt;=d (where n is a vector).</p>",
        "id": 404853552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701260831
    },
    {
        "content": "<p>Ok, I think that my confusion arises from the fact that the problem is linear in <code>P</code> but only affine-linear in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>.  I think that, to use Floris' idea, we would like linearity in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span>.</p>",
        "id": 404853578,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701260838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/404853164\">said</a>:</p>\n<blockquote>\n<p>Somebody once told me you should formalise the statement first if you want help with a proof ;)</p>\n</blockquote>\n<p><span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> My problem was that I know this part of the library so poorly that it would take me forever to even state the question formally :-) I used LaTeX though, what more do you want?!</p>",
        "id": 404853768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701260900
    },
    {
        "content": "<p>I like Floris' point of view, but here is an example to show that you need more work.</p>\n<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> be the vector space of C-infinity functions supported on the unit ball and with integral 0.  We informally know that this vector space is infinite-dimensional.  However, by definition, for all of these functions, the integral with the constant polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> yields <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>=</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">1 = P(0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 404857248,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701262051
    },
    {
        "content": "<p>Given Floris' argument, all that seems to be missing is the following assertion:</p>\n<p>for every finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> of monomials, there is a compactly supported C-infinity function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>F</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> such that, for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>∈</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">m \\in F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, the integral of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>F</mi></msub><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">f_Fm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">m</span></span></span></span> is zero iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> is non-constant.</p>",
        "id": 404861284,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701263101
    },
    {
        "content": "<p>Yes, I think we need more than what I said at the start. And I agree we need something like Damiano's last statement.</p>",
        "id": 404861981,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701263318
    },
    {
        "content": "<p>Here is a statement of the original challenge:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Geometry.Manifold.PartitionOfUnity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.Variables</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">MvPolynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span>  <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 404862075,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701263350
    },
    {
        "content": "<p>(or maybe <code>EuclideanSpace ℝ ι</code> instead of <code>ι → ℝ</code> to have the usual metric)</p>",
        "id": 404862433,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701263466
    },
    {
        "content": "<p>We have <code>BumpFunction</code> for either case.</p>",
        "id": 404862507,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1701263498
    },
    {
        "content": "<p>We can probably reduce to the 1-dimensional case by considering products of 1-variable functions that are solutions, right?</p>",
        "id": 404863085,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701263701
    },
    {
        "content": "<p>So, for <code>n : ℕ</code>, does there exist a <code>BumbFunction</code> <code>f</code> on <code>ℝ</code> such that, for <code>i &lt; n</code>, the integral of <code>f * X ^ i</code> vanishes if and only if <code>i \\ne 0</code>?</p>",
        "id": 404864028,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701264022
    },
    {
        "content": "<p>(the answer is</p>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/404862075\">said</a>:</p>\n<blockquote>\n<p>Here is a statement of the original challenge:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Geometry.Manifold.PartitionOfUnity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.Variables</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">MvPolynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span>  <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is a good <code>proof_wanted</code> example, right?  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 404864411,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701264144
    },
    {
        "content": "<p>And this might be a formalization of the missing step, after Floris' reduction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Polynomial</span> <span class=\"n\">Metric</span>\n\n<span class=\"n\">proof_wanted</span> <span class=\"n\">one_d</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 404865818,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701264575
    },
    {
        "content": "<p>I was thinking of something like this originally, which should be sufficient to prove the challenge, I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Geometry.Manifold.PartitionOfUnity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">|</span> <span class=\"n\">tsupport</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">LinearIndependent</span> <span class=\"n\">ℝ</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The proof sketch of this <code>sorry</code> is: choose countably infinite many disjoint closed balls inside <code>closedBall 0 1</code> and take a bump function on each of these balls.<br>\nAnd the proof sketch of the challenge then is: take an affine combination of the <code>s i</code>.</p>",
        "id": 404868156,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701265257
    },
    {
        "content": "<p>I suspect that there is still something missing to be spelled out: if your functions are all odd, is it a problem?  Is it ruled out by something that I am failing to see?</p>",
        "id": 404869265,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701265599
    },
    {
        "content": "<p>I assume that their integral is 1. <br>\nThe only non-linear condition is for the constant polynomial, which is to say that the integral of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ρ</span></span></span></span> must be nonzero. But an affine combination of bump functions will have integral 1.</p>",
        "id": 404869647,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701265728
    },
    {
        "content": "<p>Ah, I had missed the integral 1 condition!</p>",
        "id": 404869797,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701265780
    },
    {
        "content": "<p>I still need to wrap my head around some thoughts that are bugging me about this.</p>",
        "id": 404870072,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701265864
    },
    {
        "content": "<p>If all functions that you use are non-negative and all contained in the positive orthant, you need negative coefficients.  Affine combination is simply that the sum of the coefficients is 1, not that they are non-negative, right?  I guess that would be convex combination.  Maybe this is what was bugging me!</p>",
        "id": 404871293,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701266226
    },
    {
        "content": "<p>Sorry, have to go, but this is a fun question!</p>",
        "id": 404871326,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701266239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Your statement follows from the following one: if <code>f n</code> is a sequence of functions with strictly decreasing supports, then they are linearly independent.</p>",
        "id": 404874604,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1701267156
    },
    {
        "content": "<p>I don't understand why your statement implies the original one.</p>",
        "id": 404874705,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1701267185
    },
    {
        "content": "<p>I.e., we still need to show that the conditions are linearly independent on our subspace.</p>",
        "id": 404875182,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1701267338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/404874604\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> Your statement follows from the following one: if <code>f n</code> is a sequence of functions with strictly decreasing supports, then they are linearly independent.</p>\n</blockquote>\n<p>I was using disjoint (non-empty) supports, which should also work.</p>",
        "id": 404880799,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701268860
    },
    {
        "content": "<p>But maybe fixing around a single point and only changing the radius is easier...</p>",
        "id": 404880874,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701268882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/404874705\">said</a>:</p>\n<blockquote>\n<p>I don't understand why your statement implies the original one.</p>\n</blockquote>\n<p>Here is the proof sketch I'm imagining.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Geometry.Manifold.PartitionOfUnity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.Variables</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">Set</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">linear</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_affineSpan_zero</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">ι'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">ι'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"bp\">𝕜</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">affineSpan</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">linear</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">normed</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">|</span> <span class=\"n\">tsupport</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">hf.2.add</span> <span class=\"n\">hg.2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">tsupport_eq_empty_iff.mpr</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset.trans</span> <span class=\"o\">(</span><span class=\"n\">empty_subset</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">contDiff_const</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)⟩</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">closure_mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">support_smul_subset_right</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hf.1</span><span class=\"o\">,</span> <span class=\"n\">contDiff_const.smul</span> <span class=\"n\">hf.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">normed</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">MvPolynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">LinearIndependent</span> <span class=\"n\">ℝ</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">h2s</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n    <span class=\"n\">Pairwise</span> <span class=\"o\">(</span><span class=\"n\">Disjoint</span> <span class=\"n\">on</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">closedBall</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">f1</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ContDiffBump</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">half_pos</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">half_lt_self</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">n</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">f1</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">normed</span> <span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f1</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">integral_normed</span><span class=\"o\">⟩</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">f.1</span> <span class=\"n\">x</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">h2f</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">step</span> <span class=\"n\">ι</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">i.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Finite.toFinset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">i.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">})</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">hρ</span><span class=\"o\">,</span> <span class=\"n\">h2ρ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_affineSpan_zero</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">monomial</span> <span class=\"n\">i</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">all_goals</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">real</span>\n</code></pre></div>",
        "id": 404885351,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701269917
    },
    {
        "content": "<p>Or maybe this is a better proof sketch, because it doesn't require us to reduce the general case to monomials:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Geometry.Manifold.PartitionOfUnity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.MvPolynomial.Variables</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">Set</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">linear</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_affineSpan_zero</span> <span class=\"o\">{</span><span class=\"n\">ι'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">ι'</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"bp\">𝕜</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">affineSpan</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">totalDegreeIn</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">totalDegreeIn</span> <span class=\"bp\">𝕜</span> <span class=\"n\">ι</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">linear</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">normed</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">|</span> <span class=\"n\">tsupport</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">hf.2.add</span> <span class=\"n\">hg.2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">tsupport_eq_empty_iff.mpr</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset.trans</span> <span class=\"o\">(</span><span class=\"n\">empty_subset</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">contDiff_const</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)⟩</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">closure_mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">support_smul_subset_right</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hf.1</span><span class=\"o\">,</span> <span class=\"n\">contDiff_const.smul</span> <span class=\"n\">hf.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">normed</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span> <span class=\"n\">real</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">MvPolynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">LinearIndependent</span> <span class=\"n\">ℝ</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">h2s</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span>\n    <span class=\"n\">Pairwise</span> <span class=\"o\">(</span><span class=\"n\">Disjoint</span> <span class=\"n\">on</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">closedBall</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">f1</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ContDiffBump</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">half_pos</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">half_lt_self</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">n</span><span class=\"o\">)⟩</span>\n  <span class=\"k\">let</span> <span class=\"n\">f2</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">f1</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">normed</span> <span class=\"n\">volume</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">f1</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">integral_normed</span><span class=\"o\">⟩</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℝ</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n      <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">f.1</span> <span class=\"n\">x</span>\n        <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n        <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">h2f</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">step</span> <span class=\"n\">ι</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">hρ</span><span class=\"o\">,</span> <span class=\"n\">h2ρ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_affineSpan_zero</span> <span class=\"o\">(</span><span class=\"n\">totalDegreeIn</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">Finset.Icc</span> <span class=\"mi\">1</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"n\">L</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">all_goals</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">real</span>\n</code></pre></div>",
        "id": 404889037,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701270692
    },
    {
        "content": "<p>I should stop spending time on this, but here is the progress I have so far:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/hairer/Mathlib/Hairer.lean\">https://github.com/leanprover-community/mathlib4/blob/hairer/Mathlib/Hairer.lean</a></p>",
        "id": 404902312,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701274554
    },
    {
        "content": "<p>Feel free to push to that branch!</p>",
        "id": 404902400,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701274574
    },
    {
        "content": "<p>Ok, I am missing an additional condition in the lemma <code>exists_affineSpan_zero</code> that I proposed, and that is that the <code>L i</code>must be nonconstant on <code>affineSpan 𝕜 (range x)</code>. I think that is sufficient, but now I'm not sure about that anymore.</p>",
        "id": 404934514,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701285563
    },
    {
        "content": "<p>The integration by parts sound simpler to implement: once you have a smooth bump function, its kth derivative integrates to 0 against any monomial of degree less than k by integration by parts k times. So start with a bump function f of integral 1, this integrates correctly against constants. Then subtract a multiple of f' so it integrates to 0 against x, then a multiple of f'' so it integrates to 0 against x^2, and so on. So in the end \\rho is a rather explicit linear combination of the first derivatives of f. </p>\n<p>It might not be easier to turn into a Lean proof though ...</p>",
        "id": 404949786,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1701291856
    },
    {
        "content": "<p>Hi all, just for a bit of background, the idea behind my question to Kevin was to formalise a proof of the \"reconstruction theorem\" which is the fundamental piece of analysis that makes regularity structures work. One reason for choosing this particular result is that it is a modern piece of analysis that has a proof that is quite short and doesn't rely on much machinery, so the hope was that it wouldn't be too hard to formalise (in particular the version for \"germs\" given by Caravenna and Zambotti). For me, the goal is to figure out how easy it is to actually formalise analysis with the current state of the art...</p>",
        "id": 405064768,
        "sender_full_name": "Martin Hairer",
        "timestamp": 1701332985
    },
    {
        "content": "<p>Regarding the proof of this particular statement, the two strategies I had in mind are either the one sketched by Vincent or the more abstract one that uses the fact that if one has N linearly independent elements y_i of the dual V^* of some real vector space V, then one can always find an element v in V such that y_0(v) = 1 and y_j(v) = 0 for every j&gt;0 (or actually y_i(v) = a_i for any given numbers a_i). I guess there might already be something to that effect in the linear algebra part of mathlib, so maybe that's the cheapest one. Showing that integration against monomials are independent is easy since otherwise one could find a fixed non-zero polynomial that annihilates every test function which is absurd.</p>",
        "id": 405067837,
        "sender_full_name": "Martin Hairer",
        "timestamp": 1701333973
    },
    {
        "content": "<p>I formalized the outline based on what <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">missing_polynomial</span>\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">Submodule</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">totalDegree_le_iff_mem_span</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">totalDegree</span> <span class=\"n\">P</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span>\n    <span class=\"n\">P</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"o\">((</span><span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"n\">monomial</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Is this really missing?? -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">evalAtₗ</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">P</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finite_stuff</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">missing_polynomial</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">missing_linear_algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Module</span> <span class=\"n\">Submodule</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V'</span><span class=\"o\">]</span>\n   <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">V'</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_predual_of_finite</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Dual</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">hμ</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_predual</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Dual</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hμ</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_stuff</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∘</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">exists_predual</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∘</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">stuff</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exists_stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">stuff_eval_self</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exists_stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec.1</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">stuff_eval_other</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec.2</span> <span class=\"n\">j</span> <span class=\"n\">hj</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">V'</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">v'</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">μ</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"n\">v'</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">hs.toFinset</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">•</span> <span class=\"n\">stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span>\n  <span class=\"n\">intro</span> <span class=\"n\">v'</span> <span class=\"n\">hv'</span>\n  <span class=\"n\">apply</span> <span class=\"n\">span_induction</span> <span class=\"n\">hv'</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">v'</span> <span class=\"bp\">↦</span> <span class=\"n\">μ</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"n\">v'</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">hs.toFinset</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">•</span> <span class=\"n\">stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">clear</span> <span class=\"n\">v'</span> <span class=\"n\">hv'</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">hs.toFinset</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">stuff</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">j</span> <span class=\"n\">_</span> <span class=\"n\">hij</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"n\">stuff_eval_other</span> <span class=\"n\">hm</span> <span class=\"n\">hs</span> <span class=\"n\">hi</span> <span class=\"n\">hij.symm</span><span class=\"o\">,</span> <span class=\"n\">smul_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_eq_single_of_mem</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">hs.mem_toFinset.mpr</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">map_smul</span><span class=\"o\">,</span>\n        <span class=\"n\">stuff_eval_self</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">_root_.map_zero</span><span class=\"o\">,</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.zero_apply</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">Finset.sum_const_zero</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Finset.sum_add_distrib</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">v'</span> <span class=\"n\">hv'</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"n\">hv'</span><span class=\"o\">,</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">Finset.mul_sum</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.smul_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">missing_linear_algebra</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Metric</span> <span class=\"n\">Set</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Module</span>\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"kn\">hiding</span> <span class=\"n\">support</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"kn\">hiding</span> <span class=\"n\">eval</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">normed</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"n\">E'</span> <span class=\"n\">F</span>  <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"kd\">def</span> <span class=\"n\">SmoothSupportedOn</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">|</span> <span class=\"n\">tsupport</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"n\">add_mem'</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"n\">hf.2.add</span> <span class=\"n\">hg.2</span><span class=\"o\">⟩</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">tsupport_eq_empty_iff.mpr</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset.trans</span> <span class=\"o\">(</span><span class=\"n\">empty_subset</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">contDiff_const</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)⟩</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">closure_mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">support_smul_subset_right</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hf.1</span><span class=\"o\">,</span> <span class=\"n\">contDiff_const.smul</span> <span class=\"n\">hf.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">FunLike</span> <span class=\"o\">(</span><span class=\"n\">SmoothSupportedOn</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.val</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.coe_injective</span>\n<span class=\"kd\">end</span> <span class=\"n\">normed</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n      <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">↦</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n        <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n        <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">indep</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">∘</span> <span class=\"k\">fun</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"n\">monomial</span> <span class=\"n\">c</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∫</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">supp_φ</span><span class=\"o\">,</span> <span class=\"n\">diff_φ</span><span class=\"o\">⟩,</span> <span class=\"n\">hφ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>  <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">indep</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finite_stuff</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">evalAtₗ</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">supp_φ</span><span class=\"o\">,</span> <span class=\"n\">diff_φ</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">P</span> <span class=\"n\">hP</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">totalDegree_le_iff_mem_span.1</span> <span class=\"n\">hP</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 405195553,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701375890
    },
    {
        "content": "<p>@<strong>algebra people</strong>: what is missing (or at least I couldn't find) is mostly polynomial and linear algebra stuff.</p>",
        "id": 405195627,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701375930
    },
    {
        "content": "<p>The only thing that involves analysis is the <code>indep</code> lemma.</p>",
        "id": 405195941,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701376061
    },
    {
        "content": "<p>I found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial#doc\">docs#MvPolynomial</a>.evalₗ but that doesn't seem to be it</p>",
        "id": 405198650,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701377189
    },
    {
        "content": "<p>I'm sure there's an easier way than this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite_stuff'</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">σ</span> <span class=\"bp\">|</span> <span class=\"n\">Multiset.card</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.ofFinite</span> <span class=\"n\">σ</span>\n  <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">N</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ.val</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.finite_toSet</span> <span class=\"o\">(</span><span class=\"n\">Multiset.toFinset</span> <span class=\"o\">(</span><span class=\"n\">Multiset.powerset</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">subset</span>\n  <span class=\"n\">intro</span> <span class=\"n\">s</span> <span class=\"n\">hs</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_toFinset</span><span class=\"o\">,</span> <span class=\"n\">Multiset.mem_powerset</span><span class=\"o\">,</span> <span class=\"n\">Multiset.le_iff_count</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">Multiset.count_nsmul</span><span class=\"o\">,</span> <span class=\"n\">Multiset.count_univ</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">s.count_le_card</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">hs</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finite_stuff</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">change</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finsupp.card_toMultiset</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Set.Finite.of_finite_image</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Multiset.toFinsupp.symm.injective.injOn</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finite_stuff'</span> <span class=\"n\">N</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">AddEquiv.coe_toEquiv</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 405219123,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701383324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> the final <code>simp</code> doesn't close the goal for me...</p>",
        "id": 405275224,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701406081
    },
    {
        "content": "<p>I pushed Patrick's file + Ruben's lemmas to <code>Archive/Hairer.lean</code> on the branch <code>hairer-challenge</code></p>",
        "id": 405275527,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701406267
    },
    {
        "content": "<p>I closed the sorry about <code>tsupport</code>.</p>",
        "id": 405277141,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701407182
    },
    {
        "content": "<p>I reduced a few more sorries about linearity to sorries about integrability.</p>",
        "id": 405279859,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701409154
    },
    {
        "content": "<p>I solved <code>exists_predual</code> without using <code>exists_predual_of_finite</code>. The idea is similar to <a href=\"#narrow/stream/287929-mathlib4/topic/Projective.20space/near/392642695\">this</a> and makes use of annihilator theory introduced by <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"n\">V'</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">K</span> <span class=\"n\">V'</span><span class=\"o\">]</span>\n   <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">V'</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">Dual</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">surj_of_inj</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">K</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Surjective</span> <span class=\"o\">(</span><span class=\"n\">B.dualMap.comp</span> <span class=\"o\">(</span><span class=\"n\">Module.Dual.eval</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearMap.range_eq_top</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Submodule.eq_top_of_finrank_eq</span>\n  <span class=\"n\">set</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">Subspace</span> <span class=\"n\">K</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.range</span> <span class=\"o\">(</span><span class=\"n\">B.dualMap.comp</span> <span class=\"o\">(</span><span class=\"n\">Module.Dual.eval</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">W.finrank_add_finrank_dualCoannihilator_eq</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subspace.dual_finrank_eq</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">add_right_eq_self</span><span class=\"o\">,</span> <span class=\"n\">finrank_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">eq_bot_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hB</span>\n  <span class=\"n\">ext</span> <span class=\"n\">v</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Submodule.mem_dualCoannihilator</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hx</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mem_range_self</span> <span class=\"n\">_</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_predual</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">Dual</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hμ</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"n\">K</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"n\">i</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">≠</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">μ</span> <span class=\"n\">j</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hμ</span> <span class=\"o\">:=</span> <span class=\"n\">hμ.comp</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">Subtype.val_injective</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">linearIndependent_iff_injective_total</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hμ</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hs.union</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.finite_singleton</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_subtype</span>\n  <span class=\"n\">classical</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">surj_of_inj</span> <span class=\"n\">hμ</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.total</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"bp\">↦</span> <span class=\"k\">if</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">j</span> <span class=\"n\">hjs</span> <span class=\"n\">hji</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">FunLike.congr_fun</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.single</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">if_neg</span> <span class=\"n\">hji</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">FunLike.congr_fun</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.single</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">hjs</span><span class=\"o\">⟩</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 405285213,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701411185
    },
    {
        "content": "<p>Did this in web editor; feel free to put into the branch.</p>",
        "id": 405285377,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701411271
    },
    {
        "content": "<p>Thanks! I'll push it.</p>",
        "id": 405299097,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701416326
    },
    {
        "content": "<p>Several of the remaining sorries are of the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ι</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Fintype</span> <span class=\"n\">ι</span>\n<span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">fg</span><span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">SmoothSupportedOn</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"o\">(</span><span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Integrable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I've never used integration theory in mathlib. How do we close these?</p>",
        "id": 405304550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701417747
    },
    {
        "content": "<p>You probably want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Continuous.integrable_of_hasCompactSupport#doc\">docs#Continuous.integrable_of_hasCompactSupport</a></p>",
        "id": 405310401,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701419510
    },
    {
        "content": "<p>That seems to work assuming</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">MvPolynomial.continuous_eval</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Continuous</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is true</p>",
        "id": 405312408,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701420196
    },
    {
        "content": "<p>And <code>continuity</code> says it is</p>",
        "id": 405312696,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701420298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> are you pushing this? If not, I can copy it into the file.</p>",
        "id": 405315424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701420996
    },
    {
        "content": "<p>Yeah, just pushed</p>",
        "id": 405315640,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701421059
    },
    {
        "content": "<p>Leaving it alone for a while now</p>",
        "id": 405316543,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701421322
    },
    {
        "content": "<p>I've killed a few sorries, in particular completing the main proof. There was a dramatic oversight that the argument was wrong in the case where the indexing space is empty :-) -- but in this case the constant function <code>1</code> will do, so no need to add a further assumption to the statement.</p>",
        "id": 405356494,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701435174
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405356494\">said</a>:</p>\n<blockquote>\n<p>I've killed a few sorries, in particular completing the main proof. There was a dramatic oversight that the argument was wrong in the case where the indexing space is empty :-) -- but in this case the constant function <code>1</code> will do, so no need to add a further assumption to the statement.</p>\n</blockquote>\n<p>Did you push them?</p>",
        "id": 405361776,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701436758
    },
    {
        "content": "<p>Yes.</p>",
        "id": 405361906,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701436797
    },
    {
        "content": "<p>Where?</p>",
        "id": 405361974,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701436806
    },
    {
        "content": "<p>I've just pushed again, in case I did something wrong before.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">PS</span> <span class=\"n\">C</span><span class=\"o\">:</span><span class=\"bp\">\\</span><span class=\"n\">Users</span><span class=\"bp\">\\</span><span class=\"n\">sgouezel_A</span><span class=\"bp\">\\</span><span class=\"n\">Desktop</span><span class=\"bp\">\\</span><span class=\"n\">mathlib4</span><span class=\"bp\">&gt;</span> <span class=\"n\">git</span> <span class=\"n\">push</span>\n<span class=\"n\">Enumerating</span> <span class=\"n\">objects</span><span class=\"o\">:</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"n\">done.</span>\n<span class=\"n\">Counting</span> <span class=\"n\">objects</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"bp\">/</span><span class=\"mi\">7</span><span class=\"o\">),</span> <span class=\"n\">done.</span>\n<span class=\"n\">Delta</span> <span class=\"n\">compression</span> <span class=\"n\">using</span> <span class=\"n\">up</span> <span class=\"n\">to</span> <span class=\"mi\">8</span> <span class=\"n\">threads</span>\n<span class=\"n\">Compressing</span> <span class=\"n\">objects</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">4</span><span class=\"o\">),</span> <span class=\"n\">done.</span>\n<span class=\"n\">Writing</span> <span class=\"n\">objects</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">4</span><span class=\"o\">),</span> <span class=\"mi\">607</span> <span class=\"n\">bytes</span> <span class=\"bp\">|</span> <span class=\"mi\">607</span><span class=\"bp\">.</span><span class=\"mi\">00</span> <span class=\"n\">KiB</span><span class=\"bp\">/</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">done.</span>\n<span class=\"n\">Total</span> <span class=\"mi\">4</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"mi\">3</span><span class=\"o\">),</span> <span class=\"n\">reused</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">pack</span><span class=\"bp\">-</span><span class=\"n\">reused</span> <span class=\"mi\">0</span>\n<span class=\"n\">remote</span><span class=\"o\">:</span> <span class=\"n\">Resolving</span> <span class=\"n\">deltas</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"bp\">/</span><span class=\"mi\">3</span><span class=\"o\">),</span> <span class=\"n\">completed</span> <span class=\"k\">with</span> <span class=\"mi\">3</span> <span class=\"kn\">local</span> <span class=\"n\">objects.</span>\n<span class=\"n\">To</span> <span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">github.com</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"bp\">-</span><span class=\"n\">community</span><span class=\"bp\">/</span><span class=\"n\">mathlib4.git</span>\n   <span class=\"mi\">6</span><span class=\"n\">b874f2421..8686deea3c</span>  <span class=\"n\">hairer</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">hairer</span>\n</code></pre></div>",
        "id": 405362151,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701436864
    },
    {
        "content": "<p>Only thing that went wrong is that there's also <a href=\"https://github.com/leanprover-community/mathlib4/tree/hairer-challenge\">branch#hairer-challenge</a></p>",
        "id": 405362283,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701436909
    },
    {
        "content": "<p>Ah, crap. Which one is the right one?</p>",
        "id": 405362475,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701436956
    },
    {
        "content": "<p>I've merged <code>hairer-challenge</code> into <code>hairer</code>.</p>",
        "id": 405363265,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701437201
    },
    {
        "content": "<p>It was only missing one additional commit by Floris. Can I delete <code>hairer-challenge</code>, to make sure everyone is on the same branch?</p>",
        "id": 405363441,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701437258
    },
    {
        "content": "<p>yes, please go ahead</p>",
        "id": 405363857,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701437390
    },
    {
        "content": "<p><span aria-label=\"warning\" class=\"emoji emoji-26a0\" role=\"img\" title=\"warning\">:warning:</span> the branch name <code>hairer-challenge</code> is going out of business! From now on use <code>hairer</code></p>",
        "id": 405364008,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1701437434
    },
    {
        "content": "<p>I'm completely confused about what <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> is working on.</p>",
        "id": 405368876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439026
    },
    {
        "content": "<p>And what is this story of a missing empty case.</p>",
        "id": 405368929,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439044
    },
    {
        "content": "<p>My main proof was completed already, only algebraic lemmas and the independence proof was missing.</p>",
        "id": 405368985,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439068
    },
    {
        "content": "<p>What's wrong with my</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hairer</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">tsupport</span> <span class=\"n\">ρ</span> <span class=\"bp\">⊆</span> <span class=\"n\">closedBall</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">ρ</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">p.totalDegree</span> <span class=\"bp\">≤</span> <span class=\"n\">N</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∫</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">ρ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">eval</span> <span class=\"mi\">0</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">supp_φ</span><span class=\"o\">,</span> <span class=\"n\">diff_φ</span><span class=\"o\">⟩,</span> <span class=\"n\">hφ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>  <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">indep</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">finite_stuff</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">evalAtₗ</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">supp_φ</span><span class=\"o\">,</span> <span class=\"n\">diff_φ</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">P</span> <span class=\"n\">hP</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">totalDegree_le_iff_mem_span.1</span> <span class=\"n\">hP</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 405369146,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439119
    },
    {
        "content": "<p>This is a full proof of the target statement.</p>",
        "id": 405369178,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439131
    },
    {
        "content": "<p>Why is there a <code>hairer2</code> lemma below it on the branch?</p>",
        "id": 405369219,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439145
    },
    {
        "content": "<p>That one's from <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span></p>",
        "id": 405369364,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701439193
    },
    {
        "content": "<p>Do we now try to get two different proofs?</p>",
        "id": 405369539,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439227
    },
    {
        "content": "<p>My message <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405195553\">here</a> was a complete proof modulo sorries, it did not require any other code from Floris's earlier attempt.</p>",
        "id": 405369758,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439279
    },
    {
        "content": "<p>I hadn't seen the first <code>hairer</code>, I was just closing the sorries in the last theorem in the file, which I thought was the current state of things. This is silly!</p>",
        "id": 405369986,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701439324
    },
    {
        "content": "<p>I'm sorry the situation was confusing. I should have pushed to the branch instead of posting full files here.</p>",
        "id": 405370223,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439369
    },
    {
        "content": "<p>If you want something to do then one of the missing (I think) things to prove is that a polynomial which vanishes on a non-empty open set in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is the zero polynomial. But maybe <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> is already proving it.</p>",
        "id": 405370608,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701439460
    },
    {
        "content": "<p>It looks to me that the point of <code>hairer2</code> is that it avoids <code>indep</code> completely, and instead only uses that you have countably many independent smooth functions with integral 1 (but for this you indeed need the indexing set to be nonempty). This looks easier to prove than <code>indep</code>.</p>",
        "id": 405372994,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701440147
    },
    {
        "content": "<p>(But maybe with something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ae_eq_zero_of_integral_contDiff_smul_eq_zero#doc\">docs#ae_eq_zero_of_integral_contDiff_smul_eq_zero</a> then <code>indep</code> is also easy).</p>",
        "id": 405373560,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701440363
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ae_eq_zero_of_integral_contDiff_smul_eq_zero#doc\">docs#ae_eq_zero_of_integral_contDiff_smul_eq_zero</a> is half the proof of <code>indep</code>, the other half is the lemma I mentioned above (non-empty Zariski opens are dense in Euclidean topology).</p>",
        "id": 405373990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701440538
    },
    {
        "content": "<p>And I think this missing half is something Mathlib should know anyway.</p>",
        "id": 405374047,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701440561
    },
    {
        "content": "<p>I'm sure mathlib should know about this. It's just maybe not the path of least resistance in the current situation.</p>",
        "id": 405374932,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701440890
    },
    {
        "content": "<p>If we wanted to get a proof as fast as possible then the integration path explored by Vincent would probably be faster. I think we should try to get the elegant proof and improve Mathlib along the way. There is no hurry.</p>",
        "id": 405375732,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701441184
    },
    {
        "content": "<p>I'm sure Vincent's approach would be more efficient in dimension 1, but not so sure in higher dimension where multivariate polynomials are a mess. Anyway, completing both paths (I mean, <code>hairer</code> and <code>hairer2</code>) is definitely worthwile, because they will both highlight different gaps in the library that are worth filling.</p>",
        "id": 405376779,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701441555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405376779\">said</a>:</p>\n<blockquote>\n<p>I'm sure Vincent's approach would be more efficient in dimension 1, but not so sure in higher dimension where multivariate polynomials are a mess. Anyway, completing both paths (I mean, <code>hairer</code> and <code>hairer2</code>) is definitely worthwile, because they will both highlight different gaps in the library that are worth filling.</p>\n</blockquote>\n<p>As Damiano Testa pointed out, it actually reduces to the 1D case, but it looks like the current proof is more likely to produce useful stuff for the linear algebra part of <code>matlib</code>. Regarding <code>foo</code>, you currently assume that <code>B m</code> is linearly independent. If I understand the statement correctly though, it would also hold without assuming anything on the linear independence of the <code>m</code>, but assuming instead that <code>B</code> is injective, right? Wouldn't that be a more natural statement to merge into <code>matlib</code>?</p>",
        "id": 405384530,
        "sender_full_name": "Martin Hairer",
        "timestamp": 1701443973
    },
    {
        "content": "<p>Oh, good to know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ae_eq_zero_of_integral_contDiff_smul_eq_zero#doc\">docs#ae_eq_zero_of_integral_contDiff_smul_eq_zero</a>, that makes <code>indep</code> easier.<br>\nHowever, we want a variant of this lemma where the support of <code>g</code> is assumed to lie within some compact set <code>K</code>, and conclude from this that <code>f</code> is a.e. equal to <code>0</code> on (the interior of?) <code>K</code>. This is not super easy to get from the current mathlib version. I currently wrote this version (also on the branch), but I'm not sure if it holds in exactly this form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">IsCompact.ae_eq_zero_of_integral_contDiff_smul_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">LocallyIntegrableOn</span> <span class=\"n\">f</span> <span class=\"n\">K</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"bp\">⊤</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">tsupport</span> <span class=\"n\">g</span> <span class=\"bp\">⊆</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀ᵐ</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 405389104,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1701445346
    },
    {
        "content": "<p>What you can do to prove this is multiply your initial function by a smooth function with compact support in the ball. Then the resulting function will have integral zero against any smooth compactly supported function, so you can apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ae_eq_zero_of_integral_contDiff_smul_eq_zero#doc\">docs#ae_eq_zero_of_integral_contDiff_smul_eq_zero</a> to it and deduce that it vanishes almost everywhere.</p>",
        "id": 405391426,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701446207
    },
    {
        "content": "<p>For this, you probably need your compact set to be the closure of its interior (otherwise, your statement can not be true).</p>",
        "id": 405391638,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701446283
    },
    {
        "content": "<p>You can also use a different measure.</p>",
        "id": 405393423,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701446828
    },
    {
        "content": "<p>Heather just pointed out to me that we know that that analytic functions that coincide on an open set are equal. This could be a way to cheat in the independence proof (although this is really a ridiculously overpowered path).</p>",
        "id": 405393648,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701446900
    },
    {
        "content": "<p>And there is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.funext#doc\">docs#MvPolynomial.funext</a></p>",
        "id": 405393775,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1701446954
    },
    {
        "content": "<p><del>docs#MvPolynomial.funext isn't quite applicable as it requires two polynomials being equal everywhere rather than on a nonempty open set.</del> (Edit: it's applicable once you use the identity principle <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOn.eq_of_eventuallyEq#doc\">docs#AnalyticOn.eq_of_eventuallyEq</a> to show they agree everywhere.) The easiest elementary proof is probably by induction on dimension (for the induction step you'd use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.eq_zero_of_infinite_isRoot#doc\">docs#Polynomial.eq_zero_of_infinite_isRoot</a> and that a MvPolynomial ring over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is a domain). However, you'd need to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.finSuccEquiv#doc\">docs#MvPolynomial.finSuccEquiv</a> like in <a href=\"https://github.com/leanprover-community/mathlib4/blob/42649c4da2724d1aa86b8dab06079db71daf1a84//Mathlib/RingTheory/Polynomial/Basic.lean#L1255-L1265\">this proof</a>, and I expect the proof via analyticity will be simpler. Showing a polynomial is analytic is almost tautology but missing in mathlib apparently. (In the complex case we can combine <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.analyticAt#doc\">docs#Differentiable.analyticAt</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.differentiable#doc\">docs#Polynomial.differentiable</a>, but the former isn't valid in the real case.)</p>",
        "id": 405400603,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701449355
    },
    {
        "content": "<p>I have a bit of time now, I'm trying some of the sorries in the <code>hairer</code> branch.</p>\n<p>...and indeed we have a bunch of missing API for multivariable polynomials :-(</p>",
        "id": 405436053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701463820
    },
    {
        "content": "<p>I made minor progress on finite-dimensional lemmas. I was surprised I couldn't find</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">MvPolynomial.degreeOf_le_totalDegree</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">degreeOf</span> <span class=\"n\">i</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">totalDegree</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 405441248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701466384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671137\">Martin Hairer</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405384530\">said</a>:</p>\n<blockquote>\n<p>Regarding <code>foo</code>, you currently assume that <code>B m</code> is linearly independent. If I understand the statement correctly though, it would also hold without assuming anything on the linear independence of the <code>m</code>, but assuming instead that <code>B</code> is injective, right? Wouldn't that be a more natural statement to merge into <code>matlib</code>?</p>\n</blockquote>\n<p>In my <a href=\"https://github.com/leanprover-community/mathlib4/commit/14a82bb5921d7e795d50c3b8bb970f03669ee092\">latest commit</a> I realized <code>B.dualMap.comp (Module.Dual.eval K V)</code> is otherwise known as <code>B.flip</code> <span aria-label=\"exploding head\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"exploding head\">:exploding_head:</span> and now I directly use my <code>surj_of_inj</code> lemma in the final proof, so that everything from <code>exists_predual</code> to <code>foo</code> in <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>'s original code can now be removed.</p>",
        "id": 405450140,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701471262
    },
    {
        "content": "<p>The final sorry in the first approach (<code>hairer</code>) is moved into <code>IsOpen.ae_eq_zero_of_integral_contDiff_smul_eq_zero</code>, and I'm attempting to use the manifold version <code>ae_eq_zero_of_integral_smooth_smul_eq_zero</code> to prove it, but it's bedtime now ... Not sure it's the quickest approach, maybe it's easier to generalize the manifold version.</p>\n<p>The remaining sorries in the second approach (<code>hairer2</code>) don't seem hard; the FiniteDimensional sorry should follow easily from the existing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">restrictTotalDegree</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>because <code>nonConstantTotalDegreeLE</code> is a smaller submodule.</p>",
        "id": 405503780,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701499798
    },
    {
        "content": "<p>In fact I am not sure I understand the first lemma in Floris' approach. It reads</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_affineSpan_zero</span> <span class=\"o\">{</span><span class=\"n\">ι'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">ι'</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"bp\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">LinearIndependent</span> <span class=\"bp\">𝕜</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">affineSpan</span> <span class=\"bp\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but what if <code>L i</code> is constant equal to <code>1</code> on the affine subspace spanned by the range of <code>x</code>? (I don't see anything in the assumptions of the lemma that excludes this).</p>",
        "id": 405516975,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701509556
    },
    {
        "content": "<p>I killed the final sorry in the <code>hairer</code> approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">printaxioms</span> <span class=\"n\">hairer</span>\n<span class=\"bp\">'</span><span class=\"n\">hairer'</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"kd\">axioms</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">Quot.sound</span><span class=\"o\">,</span> <span class=\"n\">Classical.choice</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 405551661,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701538154
    },
    {
        "content": "<p>(But all the hard work had already been done by <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> , to be fair!)</p>",
        "id": 405552130,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1701538525
    },
    {
        "content": "<p><span aria-label=\"clock\" class=\"emoji emoji-1f557\" role=\"img\" title=\"clock\">:clock:</span> 3 days, 6 hours, 45 minutes</p>",
        "id": 405557972,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701543237
    },
    {
        "content": "<p>Is the final result something that can be decomposed to mathlib PRs + something small enough for a zulip post?</p>",
        "id": 405562812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701547486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405551661\">said</a>:</p>\n<blockquote>\n<p>I killed the final sorry in the <code>hairer</code> approach:</p>\n</blockquote>\n<p>Nice! (just got back from hiking) I read your proof of <code>IsOpen.ae_eq_zero_of_integral_contDiff_smul_eq_zero</code> and pushed a bit of cleanup; to be fair it's quite different from my unfinished approach.</p>",
        "id": 405569768,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701554117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Hairer.20challenge/near/405562812\">said</a>:</p>\n<blockquote>\n<p>Is the final result something that can be decomposed to mathlib PRs + something small enough for a zulip post?</p>\n</blockquote>\n<p>The first (completed) approach takes about <a href=\"https://github.com/leanprover-community/mathlib4/compare/hairer_1st?expand=1\">300 lines</a>. Not sure how many will end up in mathlib proper; maybe 100-200?</p>",
        "id": 405570489,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701554688
    },
    {
        "content": "<p>I would say that we should make this provable within 50 lines and move the rest into mathlib</p>",
        "id": 405570894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701555109
    },
    {
        "content": "<p>or possibly just move the whole thing, I am not the best judge of whether this theorem is itself library material</p>",
        "id": 405570963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701555160
    },
    {
        "content": "<p>Since nothing seems to be moving on this front, I have opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/9138\">#9138</a> as a PR to <code>Archive</code> with the current state of the file. You can have a look to see if there are pieces you would like to move to mathlib.</p>",
        "id": 408560682,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702888562
    },
    {
        "content": "<p>I've got  <a href=\"https://github.com/leanprover-community/mathlib4/pull/9060\">#9060</a> open with a small addition, fwiw</p>",
        "id": 408562423,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702889297
    },
    {
        "content": "<p>Thanks! I've merged master (with <a href=\"https://github.com/leanprover-community/mathlib4/pull/9060\">#9060</a> already in it) into the hairer branch.</p>",
        "id": 408574954,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702893792
    }
]