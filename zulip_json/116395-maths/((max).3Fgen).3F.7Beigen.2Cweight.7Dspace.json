[
    {
        "content": "<p>With eigenspaces, there are various different notions:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=eigenspace#doc\">docs#eigenspace</a>: the kernel of <code>f - algebraMap R (End R M) μ</code></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=genEigenspace#doc\">docs#genEigenspace</a>: for <code>k : ℕ</code> the kernel of <code>(f - algebraMap R (End R M) μ) ^ k</code> (Nb: this decl is implemented as order hom from nats to submodules)</li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=maxGenEigenspace#doc\">docs#maxGenEigenspace</a>: which is <code>⨆ k, f.genEigenspace μ k</code></li>\n</ul>\n<p>And then in Lie theory, there can be similar versions for weight spaces. At the moment we only have the 3rd variant. I recently renamed <code>weightSpace</code> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=genWeightSpace#doc\">docs#genWeightSpace</a>. But it should have been <code>maxGenWeightSpace</code>. <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> </p>\n<p>I am wondering whether we can unify the 3 notions. Certainly <code>eigenspace</code> could be a thin wrapper around <code>genEigenspace 1</code>. But we could also try to unify with <code>maxGenEigenspace</code>. One way to do that is to take a filter as argument, so that <code>genEigenspace k</code> could be <code>filterEigenspace (principal k)</code> and <code>maxGenEigenspace</code> would be <code>filterEigenspace atTop</code>.<br>\n(Note that this would drop the order hom from the type, but of course it is still maths-true.)</p>\n<p>The benefit of this unification would be that it is a lot easier to also have a unified approach to the three versions for weight spaces, instead of developing 3 separate APIs.</p>\n<p><strong>Question</strong>: what is the best design here?</p>\n<p>The only relevant filters are <code>principal k</code> and <code>atTop</code>. Exactly because of the monotonicity of <code>genEigenspace</code>. So it seems like filters are not exactly the right tool for the job. An alternative would be to take an <code>ENat</code> as argument... but it doesn't feel exactly natural to me to do that, even though I don't know why... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 463694025,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724158610
    },
    {
        "content": "<p>Here is a concrete definition using <code>ENat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">unifEigenspace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"n\">add_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">add_mem</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ker_le_ker_of_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_max_left</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ker_le_ker_of_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_max_right</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hb</span>\n<span class=\"w\">  </span><span class=\"n\">zero_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zero_mem</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">smul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hl</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">smul_mem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>",
        "id": 463705019,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724161085
    },
    {
        "content": "<p>More like extendedly natural (sorry)</p>",
        "id": 463749011,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724170656
    },
    {
        "content": "<p>An <code>ENat</code> argument seems like an excellent choice to me informally, but I have zero experience with eigenspaces in mathlib.</p>",
        "id": 463801192,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1724184481
    },
    {
        "content": "<p>I like the ENat idea.</p>",
        "id": 463807644,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1724186184
    },
    {
        "content": "<p>Ok, will try to build an mvp</p>",
        "id": 463919264,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724207441
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16025\">#16025</a> sets up a bunch of basic api, and rewrites the existing api (only for Basic.lean) in terms of the new one.</p>",
        "id": 463996563,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724232962
    },
    {
        "content": "<p>existing definitions became <code>abbrev</code>s, but otherwise no existing decls should've been changed</p>",
        "id": 463996846,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1724233019
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16738\">#16738</a> prepares the library for the refactor by relying less on defeqs</p>",
        "id": 469732639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726160850
    },
    {
        "content": "<p>I wonder whether the ultimate generalization isn't working with some completion of the multiplicative monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>T</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[T]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]</span></span></span></span> (let's pretend we work over a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>), obtained by adding a possible infinite element at each irreducible polynomial.<br>\nIn fact, this would work for any principal ideal ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, and corresponds more or less to the classification of submodules of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">K/R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, where $$K$ is the fraction field of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>.</p>",
        "id": 469744802,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1726163885
    },
    {
        "content": "<p>Hmmz, not sure what an API for that would look like...</p>",
        "id": 469748923,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726164772
    },
    {
        "content": "<blockquote>\n<p>refactor(LinearAlgebra/Eigenspace): unified definition of (max(gen)?)?Eigenspace <a href=\"https://github.com/leanprover-community/mathlib4/pull/16025\">#16025</a></p>\n</blockquote>\n<p>now compiles. I would be happy to get some feedback on whether this is desirable, and how to get this into mathlib as smoothly as possible.</p>",
        "id": 469910599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726219788
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/compare/jmc-eigenspace-filter...jmc-eigenspace-post\">https://github.com/leanprover-community/mathlib4/compare/jmc-eigenspace-filter...jmc-eigenspace-post</a> shows further changes that can be made after the initial refactor.</p>",
        "id": 469910935,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726219870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/.28.28max.29.3Fgen.29.3F.7Beigen.2Cweight.7Dspace/near/469748923\">said</a>:</p>\n<blockquote>\n<p>Hmmz, not sure what an API for that would look like...</p>\n</blockquote>\n<p>It's not clear how to write an API, but this is just duality. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> D(M)=\\operatorname{Hom}(M,K/R) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> (I assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is principal), there is a duality map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> M \\times D(M) \\to K/R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, hence a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M \\to \\operatorname{Hom}(D(M),K/R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> and for a submodule <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">K/R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, the corresponding submodule <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mi>P</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[P]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">]</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is nothing but the kernel of the composition to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>K</mi><mi mathvariant=\"normal\">/</mi><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(D(M), K/R/P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 469957342,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1726231776
    },
    {
        "content": "<p>I don't know this part of the library well, but I need to use it sometimes and the unification of the eigenspaces looks super useful. Is the plan to eventually remove <code>maxGenEigenspace</code> and only talk about <code>unifEigenspace ⊤</code>? Otherwise I worry slightly that we go from having three different notions to four different notions...</p>",
        "id": 474597842,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1727964067
    },
    {
        "content": "<p>Yes. We might still have <code>eigenspace</code> for convenience. At least I want to remove <code>genEigenspace</code> and later rename <code>unifEigenspace</code> to <code>genEigenspace</code>.<br>\nBut I would prefer to do all of that in a follow-up PR.</p>",
        "id": 474598246,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727964173
    },
    {
        "content": "<p>Btw, CI is now happy with the PR. So all feedback is welcome.</p>",
        "id": 474598297,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727964192
    },
    {
        "content": "<p>Okay perfect, I'm fully on board with this generalisation if that's the plan, and fully on board with making those changes in a later PR.</p>",
        "id": 474598687,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1727964303
    }
]