[
    {
        "content": "<p><code>enat</code> is the type <code>nat</code> extended with an element at infinity. As such, it is a <code>canonically_ordered_comm_semiring</code>, and it gets a topology from this. However, this topology is defined by <code>set.Ici</code>, namely intervals closed on the left and unbounded on the right, which means that the element at infinity is isolated. As a consequence, tending to infinity in <code>enat</code> is quite different from tending to infinity in <code>nat</code>‚Ä¶ </p>\n<p>Am I missing a point ? Is this an intended property ?</p>",
        "id": 372958544,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688660904
    },
    {
        "content": "<p>Wait, how does it get a topology from this?</p>",
        "id": 372958705,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1688660941
    },
    {
        "content": "<p>You're right, there's no topology, and I use <code>filter.has_top</code> ‚Äî which precisely is generated by <code>set.Ici</code>.</p>",
        "id": 372959265,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688661050
    },
    {
        "content": "<p>So I should use another filter in this case, generated by <code>set.Ioi</code>, I don't know whether it exists.</p>",
        "id": 372959469,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688661099
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_topology\">docs3#order_topology</a>?</p>",
        "id": 372959889,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1688661193
    },
    {
        "content": "<p>Thanks! That topology is the correct one (obviously, I was missing a point), I will use that one‚Ä¶ (It's not an instance, apparently).</p>",
        "id": 372960985,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688661429
    },
    {
        "content": "<p>It should probably be a global instance, in fact.</p>",
        "id": 372962414,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1688661709
    },
    {
        "content": "<p>Since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ereal.order_topology#doc\">docs#ereal.order_topology</a> is already an instance, that would make sense.</p>\n<p>(But what I need is lighter: just the other version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs3#filter.at_top</a> when the ordered set has a top element. I wonder why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs3#filter.at_top</a> has been defined using closed intervals.)</p>",
        "id": 372970449,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688663601
    },
    {
        "content": "<p>If you use open intervals, then when there is a top element the <code>at_top</code> filter is trivial (i.e., there is no way to tend to top).</p>",
        "id": 372973671,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1688664391
    },
    {
        "content": "<p>What you need is <code>‚®Ö n : ‚Ñï, ùìü(Ioi (n : ‚Ñï‚àû))</code> or, equivalently, <code>‚®Ö (n : ‚Ñï‚àû) (_ : n &lt; ‚ä§), ùìü(Ioi n)</code></p>",
        "id": 372986047,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688667493
    },
    {
        "content": "<p>Exactly, that's how I would naturally define <code>filter.has_top</code>.</p>",
        "id": 373009745,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688674061
    },
    {
        "content": "<p>(Well, up to the precise Lean syntax which I hadn't sorted out yet.)</p>",
        "id": 373009802,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688674081
    },
    {
        "content": "<p>How would you define it if the type has no <code>top</code> element?</p>",
        "id": 373011072,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688674472
    },
    {
        "content": "<p><code>‚®Ö (n : Œ±) (_ : ¬¨(IsTop n)), ùìü(Ioi n)</code>? <code>‚®Ö (n : Œ±) (_ : ¬¨(IsMax n)), ùìü(Ioi n)</code>? Something else?</p>",
        "id": 373011220,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688674532
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsTop#doc\">docs#IsTop</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsMax#doc\">docs#IsMax</a></p>",
        "id": 373011437,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688674596
    },
    {
        "content": "<p>Yes, something  mathematically equivalent to that. (Just because I had expected that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs3#filter.at_top</a>  would have coincided with the filter of neighborhoods at the top element‚Ä¶)</p>",
        "id": 373020500,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688677509
    },
    {
        "content": "<p><code>IsTop</code> or <code>IsMax</code>?</p>",
        "id": 373020939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688677640
    },
    {
        "content": "<p>Anyway, this discussion should wait till after the port.</p>",
        "id": 373021607,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688677863
    },
    {
        "content": "<p>My only concern would be that the inclusion from the the type to its <code>with_top</code> version gives the same notion of limit <code>at _top</code>.</p>",
        "id": 373021645,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688677876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20of.20enat/near/373021607\">said</a>:</p>\n<blockquote>\n<p>Anyway, this discussion should wait till after the port.</p>\n</blockquote>\n<p>I'm not even insisting that some modification be made. It was a genuine question that appeared when I had misinterpreted the function name and people who have implemented <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=filter.at_top#doc\">docs#filter.at_top</a> like it is may have serious reasons for which it's done as it is.</p>",
        "id": 373021911,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688677970
    },
    {
        "content": "<p>If anything, this suggest that we should have more documentation on atTop</p>",
        "id": 373075148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1688703633
    },
    {
        "content": "<p>You see, I <em>had</em> read the doc of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs3#filter.at_top</a>, in particular the parenthesis:</p>\n<blockquote>\n<p>(The preorder need not have a top element for this to be well defined, and indeed is trivial when a top element exists.)</p>\n</blockquote>\n<p>However, when using it later on, I forgot about this and na√Øvely thought that it would be the filter of neighborhoods of <code>‚ä§</code>.</p>\n<p>(This led to a funny error, by the way, because I detected that error when trying to prove the converse of something I had proved: the proof didn't work out exactly because of this problem, which meant my direct proof proved something different from what I had in mind ‚Äî¬†converging to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs3#filter.at_top</a> meant that the function was eventually <code>‚ä§</code>, and I didn't realize I had made a too strong hypothesis.)</p>",
        "id": 373086165,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1688708709
    },
    {
        "content": "<p>I guess this is a great example of \"you're proving theorems about your definitions, so you had better make sure they're right\" (what the computer scientists are always warning us about) plus also \"if the definitions are wrong then you're going to find out pretty quickly\" (which is what the mathematians say to reassure the computer scientists)</p>",
        "id": 373102364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688713776
    },
    {
        "content": "<p><del>This new definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.atTop#doc\">docs#Filter.atTop</a> would mess with our definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasSum#doc\">docs#HasSum</a> right? Because if the index type is finite then <code>Finset \\alpha</code> has a top element. I think that with this new definition, a function would only have its (algebraic) sum as a topological sum if it‚Äôs zero at at least one point, which is very wrong.</del></p>",
        "id": 373123401,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688718951
    },
    {
        "content": "<p>Never mind, this is not true at all.</p>",
        "id": 373125849,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688719460
    },
    {
        "content": "<p>So I guess I‚Äôm in favor of this change then, probably with the <code>IsTop</code> version rather than <code>IsMax</code> because then we make sure to get back our original version in any <code>NoTopOrder</code></p>",
        "id": 373129224,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688720183
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> I think you're still right that this gives the wrong answer sometimes, at least for sums on a domain with 1 point (which under the new definition will always be 0) or 0 points (the sum doesn't exist under the new definition).</p>\n<p>I think we shouldn't redefine <code>Filter.atTop</code>, but make a new definition (or just use the <code>nhds</code> filter in the order topology).</p>",
        "id": 373155165,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1688725301
    },
    {
        "content": "<p>I wonder if <code>Filter.atTop</code> should be the inf over principal filters of order filters rather than over principal filters of <code>Set.Ici</code>? Then that would more directly be the filter at a top in the ideal completion of the type (for example, for <code>Nat</code> that's <code>ENat</code>), and I think it would be equivalent.</p>\n<p>Then the <code>ENat</code>'s infinity filter would be the pushforward of <code>Nat</code>'s <code>Filter.atTop</code></p>",
        "id": 373157040,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688725640
    },
    {
        "content": "<p>This suggests that having two different filters like Floris suggested is the right thing to do: there's the infinity filter on the original order and the infinity filter on the completed order.</p>",
        "id": 373161293,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688726430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20of.20enat/near/373155165\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> I think you're still right that this gives the wrong answer sometimes, at least for sums on a domain with 1 point (which under the new definition will always be 0) or 0 points (the sum doesn't exist under the new definition).</p>\n</blockquote>\n<p>I think it does still work for 1 point domain, but not for zero. Anyways, this does seem like a bad idea <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 373166406,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688727464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> What do you mean by \"principal filters of order filters\" ?</p>",
        "id": 373166581,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688727490
    },
    {
        "content": "<p><code>Filter.atTop = ‚®Ö (f : Order.PFilter Œ±), Filter.principal f</code></p>",
        "id": 373166749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688727534
    },
    {
        "content": "<p>Ooooooh that's interesting</p>",
        "id": 373167216,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688727621
    },
    {
        "content": "<p>For the one point domain, there are two finsets, empty and univ, so I think the new proposal gives you the filter <code>(‚ä§ : Filter (Finset Unit))</code>, not <code>ùìü (Finset.univ)</code></p>",
        "id": 373167586,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1688727697
    },
    {
        "content": "<p>I'm quite sure Kyle's definition is equivalent to the existing one.</p>",
        "id": 373167706,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1688727720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20of.20enat/near/373167586\">said</a>:</p>\n<blockquote>\n<p>For the one point domain, there are two finsets, empty and univ, so I think the new proposal gives you the filter <code>(‚ä§ : Filter (Finset Unit))</code>, not <code>ùìü (Finset.univ)</code></p>\n</blockquote>\n<p>Yes there are two finsets but one of them is top, so you only consider the empty finset which gives you <code>ùìü (Finset.univ)</code>, right?</p>",
        "id": 373168230,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688727824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20of.20enat/near/373167706\">said</a>:</p>\n<blockquote>\n<p>I'm quite sure Kyle's definition is equivalent to the existing one.</p>\n</blockquote>\n<p>For ENat at least yes, that would give the current definition.</p>",
        "id": 373168566,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1688727896
    },
    {
        "content": "<p>One filter that gives the \"right\" notion in all the types I've considered so far (<code>‚Ñù</code>, <code>Finset Œ±</code>, <code>ENat</code>, <code>Nat</code>, finite orders, ...) is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Filter.atTop''</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚®Ö</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">¬¨</span> <span class=\"n\">IsSuccLimit</span> <span class=\"n\">n</span> <span class=\"bp\">‚à®</span> <span class=\"bp\">¬¨</span> <span class=\"n\">IsMax</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"bp\">ùìü</span> <span class=\"o\">(</span><span class=\"n\">Ici</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This should be the current <code>atTop</code> filter in most cases. Only if there is a maximal element that is not the successor of another element then this filter gives you the notion of \"tending to this maximal element\" (or all such maximal elements, if you have multiple).<br>\nHowever, this definition is quite ugly, and I don't propose adopting it as the default definition in mathlib.</p>",
        "id": 373169065,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1688728008
    },
    {
        "content": "<p>Oh wait, Yury's definition uses <code>Ioi</code>, not <code>Ici</code>, I missed that. You're right, Anatole... I think my suggestion in that case is equivalent to Yury's, and has the same defect for 1-element <code>Œ±</code>'s.</p>",
        "id": 373169766,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1688728143
    },
    {
        "content": "<p>Has there been any progress on this? I've just found myself wanting to sum a function <code>f : Œ± ‚Üí ‚Ñï‚àû</code> over <code>Œ±</code> in such a way that the sum is defined for all <code>f</code>, and has  value <code>‚ä§</code> in the infinitely supported case. If I'm not mistaken, this would require <code>tsum</code> with the topology begin talked about here.</p>",
        "id": 377626782,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690039058
    },
    {
        "content": "<p>Do you mean adding a <code>TopologicalSpace</code> instance on <code>ENat</code> (with the order topology)? I think the answer is no, but I can do that quickly if you need it.</p>",
        "id": 377829440,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690117162
    },
    {
        "content": "<p>I guess this would only be useful to me if there were also all the infrastructure would be needed to get <code>tsum</code> working smoothly. If I added the instance myself in <code>Mathlib.Topology.Instances.ENat</code> along with some of this API, would this be well-received?</p>",
        "id": 377836409,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690119072
    },
    {
        "content": "<p>Of course! Which kind of API specific to <code>ENat</code> do you need for <code>tsum</code>, only that it's a topological monoid or do you need more? But don't hesitate to open a PR in any case!</p>",
        "id": 377837296,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690119337
    },
    {
        "content": "<p>As a dyed-in-the-wool combinatorialist, I just want to be able to sum an arbitrary function <code>f : Œ± ‚Üí ‚Ñï‚àû</code>so that it has the 'correct' value (ie. equal to <code>‚ä§</code> iff some summand is <code>‚ä§</code> or the support is infinite). In this case, every function should be <code>Summable</code>, so the API for <code>tsum</code> should be very clean. I'll have a tinker.</p>",
        "id": 377838338,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690119629
    },
    {
        "content": "<p>It's possible that we have to generalize some lemmas about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal#doc\">docs#ENNReal</a> to topological monoids with a top element, but apart from that I would naively guess that you don't need that much more API. Let's see how it goes!</p>",
        "id": 377838747,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690119768
    },
    {
        "content": "<p>I'm having a little trouble getting the right set of instances. For <code>Œ±</code> to have the property that every function <code>f:  Œπ ‚Üí Œ±</code> is summable, it seems I need a lemma like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.InfiniteSum.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Instances.ENNReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">hasSum</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CanonicallyLinearOrderedAddMonoid</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">OrderTopology</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasSum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ü</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Œπ</span><span class=\"o\">,</span> <span class=\"bp\">‚àë</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n  <span class=\"c1\">-- Proof should be</span>\n  <span class=\"c1\">-- exact tendsto_atTop_iSup fun _ _ =&gt; Finset.sum_le_sum_of_subset</span>\n</code></pre></div>\n<p>The canonicality is needed because (for instance) this would fail for the extended reals, and the completeness is needed for the statement to even make sense. But the problem is that the first two instances contain orderings as data, so a mismatch occurs with the obvious proof. Is there a way around this?</p>",
        "id": 377895860,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690135783
    },
    {
        "content": "<p>You could phrase this in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_top.complete_linear_order\">docs3#with_top.complete_linear_order</a>. It probably wouldn't apply directly to ENat or ENNReal, but these lemmas could be proven directly as a consequence of this one.</p>",
        "id": 377899813,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690136745
    },
    {
        "content": "<p>To be clear, you assume alpha is a <code>ConditionallyCompleteLinearOrderBot</code>, and then the lemma is that a function into <code>WithTop alpha</code> is summable. And you get the complete lattice structure for free from the instance mentioned above.</p>",
        "id": 377900745,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690136970
    },
    {
        "content": "<p>Oops, sorry, that doesn't work. There's no additive structure. Sorry!</p>",
        "id": 377901090,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690137059
    },
    {
        "content": "<p>Yeah, it‚Äôs the ‚Äòadditive order‚Äô and the ‚Äòcompleteness order‚Äô that are clashing</p>",
        "id": 377905224,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690138122
    },
    {
        "content": "<p>I don't think the canonicity the right way to avoid problems here, what you really need is the fact that all elements are positive. Actually, I'm surprised we don't have this lemma for any summable and nonnegative f</p>",
        "id": 377905252,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690138135
    },
    {
        "content": "<p>I think what we could have is some <code>ZeroLEClass</code> or <code>ZeroBotClass</code> that would do that, but in the meantime you can (1) prove the general lemma I described above, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum_le_sum_of_subset#doc\">docs#Finset.sum_le_sum_of_subset</a> and (2) specialize it to <code>ENat</code> without the nonnegativity assumption</p>",
        "id": 377905862,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690138300
    },
    {
        "content": "<p>Or maybe the right solution is to say that the nonnegativity argument of the general lemma should be solved by <code>positivity</code>, but I never remember the syntax for that.</p>",
        "id": 377906141,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690138375
    },
    {
        "content": "<p>Summability isn‚Äôt the hypothesis of the lemma above - it‚Äôs a lemma used to prove summability. A lemma needs to hold like that for every function (without hypotheses) to show that every function is summable.</p>",
        "id": 377913030,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690140042
    },
    {
        "content": "<p>Ah right sorry I mixed things up, indeed the first thing to prove is that everything is summable. I'd still say that it would be nice to have a lemma actually computing the sum that would work in any case, but that's orthogonal to what you want.</p>",
        "id": 377918439,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690141398
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasSum_of_isLUB_of_nonneg#doc\">docs#hasSum_of_isLUB_of_nonneg</a> seems like the perfect match here.</p>",
        "id": 377918792,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690141477
    },
    {
        "content": "<p>I'd say the simplest option is to just use this lemma to prove that any <code>ENat</code>-valued family is summable. I'm not sure if we can conveniently state this fact more generally atm.</p>",
        "id": 377921992,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690142354
    },
    {
        "content": "<p>My worry is that that involves duplicating a good amount of <code>tsum</code> API which is identical to the <code>ENNreal</code> case.</p>",
        "id": 377936014,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690148541
    },
    {
        "content": "<p>'Type where summing any function makes sense' feels like a good class to have, and it's a shame if the existing setup can't accommodate that.</p>",
        "id": 377936115,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690148605
    },
    {
        "content": "<p>(The reason the <code>tsum</code> API is so nice for <code>ENNReal</code> is that it none of it needs summability hypotheses.)</p>",
        "id": 377936516,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690148844
    },
    {
        "content": "<p>In what other situations does this come up besides <code>ENNReal</code> and <code>ENat</code>? I guess maybe functions into these types?</p>",
        "id": 377936841,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690149052
    },
    {
        "content": "<p>Yeah, I can't think of any others. Is n = 2 not still a good argument for abstraction?</p>",
        "id": 377936887,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690149077
    },
    {
        "content": "<p>What about a <code>[Summable]</code> typeclass, with instances for <code>ENat</code> and <code>ENNReal</code>? That would probably involve minimal refactoring.</p>",
        "id": 377936999,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690149135
    },
    {
        "content": "<p>It just depends on how much work it is to create a generic API versus duplicating the lemmas.</p>",
        "id": 377937017,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690149150
    },
    {
        "content": "<p><code>WithTop NNRat</code>?</p>",
        "id": 377941175,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690151505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20of.20enat/near/377936014\">said</a>:</p>\n<blockquote>\n<p>My worry is that that involves duplicating a good amount of <code>tsum</code> API which is identical to the <code>ENNreal</code> case.</p>\n</blockquote>\n<p>In an ideal world there should be almost no lemma stated for <code>ENNReal</code> that is not a special case of the general theory (except of course those really specific to <code>ENNReal</code>), so if you have a \"everything is summable\" lemma you could use it to get basically everything you want. <br>\nThen, I get that it's even more convenient if we find a nice way to abstract it, but my claim was that it shouldn't be that annoying to just write <code>ENat.summable</code> wherever you need to provide a proof of summability, at least as a first solution.</p>",
        "id": 377945467,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690154182
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 377945483,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690154205
    },
    {
        "content": "<p>E.g <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENNReal.tsum_le_tsum_comp_of_surjective#doc\">docs#ENNReal.tsum_le_tsum_comp_of_surjective</a> (picked at random) should definitely be generalized in a way that requires summability and nonnegativity assumptions, and then we can discuss about wether we should have \"convenient\" versions in specific settings.</p>",
        "id": 377946767,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690155069
    },
    {
        "content": "<p>Eric, WithTop NNRat doesn't apply. Take a series whose coercion to ENNReal converges to an irrational. Such a series is not summable.</p>",
        "id": 377990981,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1690175175
    },
    {
        "content": "<p>the same property is shared with any closed additive subsemigroup of ENNReal IIRC, but that basically means scaled versions of ENat minus finitely many elements, and ENNReal</p>",
        "id": 377992704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1690175934
    },
    {
        "content": "<p>And products / pi types.</p>",
        "id": 377993045,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690176093
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6159\">#6159</a> is my attempt at defining the appropriate typeclass</p>",
        "id": 378932664,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690402044
    },
    {
        "content": "<p>(A couple of things are still broken)</p>",
        "id": 378937623,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690403327
    },
    {
        "content": "<p>Ok, I believe I'm finished handling all those downstream errors. </p>\n<p>The solution was to define a <code>LEIffExistsMul</code> mixin typeclass that relates an ordering to a monoid structure without extending any classes that contain <code>le</code> or <code>mul</code> as data. This can be used to define a 'complete canonically ordered add monoid', which should be the right structure so that <code>tsum</code>s always exists.  (<code>CanonicallyOrderedMonoid</code> is still a type, and just implements the new typeclass. ) </p>\n<p>More generally, <code>LEIffExistsMul</code> can be used to arbitrarily combine monoid and order structures canonically. I feel that I might not be aware of some of the tradeoffs, but this really feels more convenient, and could also be used to completely remove the need for <code>CanonicallyLinearOrderedMonoid</code> as well.</p>",
        "id": 379789285,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1690634405
    },
    {
        "content": "<p><del>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ExistsMulOfLE#doc\">docs#ExistsMulOfLE</a></del> yours is an iff, sorry!</p>",
        "id": 379801650,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1690637332
    },
    {
        "content": "<p>I think there was a proposed refactor to make <code>CanonicallyOrdered...</code> mixin.</p>",
        "id": 380311323,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1690804610
    },
    {
        "content": "<p>I'm looking at this again, and I'm not sure what to do.</p>\n<p>I don't think that using the existing <code>tsum</code> API for <code>ENat</code> is an easy option. It's not just a matter of invoking<code>Summable</code> in a few places; there are quite a few pieces that don't fit. For instance, none of the existing versions of <code>tsum_mul_left</code>will work, because <code>ENat</code> isn't a topological semiring (at least, I don't think it is). So proving that needs <code>mul_iSup</code>-type lemmas, etc etc. The scope quickly creeps to cover a large chunk of what's in <code>ENNReal</code>. </p>\n<p>But it didn't seem like there was much appetite for <a href=\"https://github.com/leanprover-community/mathlib4/pull/6159\">#6159</a> when I made it as an attempted fix - it eventually became buried and now has merge conflicts. Maybe someone with a better understanding of the tradeoffs in the hierarchy could have another look at this.</p>",
        "id": 404149227,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1700941914
    },
    {
        "content": "<p>Well, I think you could still define <code>CompleteCanonicallyOrderedAddMonoid</code>. I would be happy with that. I was mostly reluctant with the mixin design.</p>",
        "id": 404230926,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1700993145
    },
    {
        "content": "<p>I'm not clear on how <code>extends</code> works here. If I write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CompleteCanonicallyOrderedCommMonoid</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">CanonicallyOrderedCommMonoid</span> <span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>will <code>le</code> be the same for the two structures? Do the two examples below correspond to different sets of assumptions? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CanonicallyOrderedCommMonoid</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CompleteCanonicallyOrderedCommMonoid</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 404260595,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1701006921
    },
    {
        "content": "<p>First question: Yes, that's the entire point of extending.<br>\nSecond question: Yes, the first one has two unrelated orders. The second one does not.</p>",
        "id": 404261698,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701007663
    },
    {
        "content": "<p>Also it's worth considering whether you even need <code>CompleteCanonicallyOrderedCommMonoid</code> and not directly something stronger like <code>CompleteCanonicallyOrderedSemiring</code>.</p>",
        "id": 404261770,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701007738
    },
    {
        "content": "<p>You're reaching a point where there's basically only three examples we could ever care about: extended nonnegative reals, extended natural numbers, extended nonnegative rationals. They all are semirings, so I think we do not care about <code>CompleteCanonicallyOrderedCommMonoid</code>s that are not <code>CompleteCanonicallyOrderedSemiring</code>.</p>",
        "id": 404261892,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701007871
    },
    {
        "content": "<p>Okay that's not quite right. Products and pi types thereof also are examples.</p>",
        "id": 404262038,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701008018
    },
    {
        "content": "<p>But those would also be semirings, so I still think there's no harm in skipping the monoid version.</p>",
        "id": 404262110,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701008052
    },
    {
        "content": "<p>Unrelated remark, but since you mentioned it earlier, the correct generality for <code>mul_iSup</code> is <a href=\"https://en.m.wikipedia.org/wiki/Quantale\">quantales</a>.</p>",
        "id": 404262247,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701008182
    },
    {
        "content": "<p>Annoyingly, there does not seem to be an infimum version of quantales in the literature.</p>",
        "id": 404262298,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701008255
    },
    {
        "content": "<p>Presumably we also care about the semifield version for ennrat/ennreal? Which is perhaps an argument for a mixing typeclass, since we need only one of those, vs two for \"regular\" typeclasses</p>",
        "id": 404271684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701015561
    },
    {
        "content": "<p>Of course, 1 vs 2 isn't very significant; if it were more like 1 vs 5 I would feel more strongly</p>",
        "id": 404271702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701015594
    },
    {
        "content": "<p>Are we likely to want lemmas about the interaction with <code>norm</code>? That would be another point in favor of a mixin.</p>",
        "id": 404271772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701015634
    },
    {
        "content": "<p>Currently, mathlib only talks about norms on <em>groups</em>, so this is mostly irrelevant.</p>",
        "id": 404272187,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701016057
    },
    {
        "content": "<p>The problem I find with algebraic order mixins is that they are too easy to create and too hard to contextualise. I much prefer extending structures as a way to know which concrete structures we care about from the onset.</p>",
        "id": 404272359,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1701016205
    },
    {
        "content": "<p>Just to be clear: is <a href=\"https://github.com/leanprover-community/mathlib4/pull/6159\">#6159</a> sufficient for your goals <span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span>, or are you finding you need more things on top of it?</p>",
        "id": 404273934,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701017872
    },
    {
        "content": "<p>I don't know yet - What I want is a reasonable API for summations in <code>ENat</code>, and the scope of this isn't yet clear. <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> 's suggestion of using a semiring does make sense, though - both <code>ENat</code> and ENNReal<code> are going to want </code>mul_tsum`-type lemmas. </p>\n<p>As <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> commented earlier, <code>ENNRat</code> isn't an example, because of series with irrational sum.  So it really is just two. </p>\n<p>I think that, for summations to exist, one actually needs a <em>linear order</em>.  The following works with <code>Linear</code> but <br>\nfails without, and I think the relevant missing typeclass (<code>SupConvergenceClass Œ±</code>) fails without a linear order. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CompleteCanonicallyLinearOrderedAddCommMonoid</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">CompleteLinearOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">CanonicallyOrderedAddCommMonoid</span> <span class=\"n\">Œ±</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CompleteCanonicallyLinearOrderedAddCommMonoid</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">hasSum'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">HasSum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ü</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Œπ</span><span class=\"o\">),</span> <span class=\"bp\">‚àë</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hn</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">tendsto_atTop_iSup</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"n\">h</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">Finset.sum_le_sum_of_subset</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">hn</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">tsum_eq_iSup'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">‚àë'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ü</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Œπ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">‚àë</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hasSum'</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tsum_eq</span>\n</code></pre></div>\n<p>I'll see how far this goes without additional assumptions being needed.</p>",
        "id": 404279831,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1701022907
    }
]