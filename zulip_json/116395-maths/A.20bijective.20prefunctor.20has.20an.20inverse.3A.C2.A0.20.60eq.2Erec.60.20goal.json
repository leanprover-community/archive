[
    {
        "content": "<p>Hey, I'm trying to define isomorphisms of quivers, and a natural thing to prove here is that a prefunctor that is bijective on objects and arrows is an isomorphism. The problem is that to show that its inverse really is an inverse, I face transport on equalities of vertices, and I¬†see no way to attack those. This is the two <code>sorry</code>s in the code below.<br>\nWhat's the proper way to solve those goals? Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.quiver.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">z</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">quiver</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">iso</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">prefunctor</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv_prefunctor</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">to_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">inv_prefunctor</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">inv_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">to_prefunctor</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">‚âÉ</span><span class=\"n\">q</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"n\">iso</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prefunctor</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">iso.to_prefunctor</span><span class=\"o\">‚ü©</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.refl</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.symm</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">V</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">œÜ.inv_prefunctor</span><span class=\"o\">,</span> <span class=\"n\">œÜ.to_prefunctor</span><span class=\"o\">,</span> <span class=\"n\">œÜ.right_inv</span><span class=\"o\">,</span> <span class=\"n\">œÜ.left_inv</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.trans</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">œà</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œÜ.to_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">œà.to_prefunctor</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œà.inv_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">œÜ.inv_prefunctor</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">prefunctor.comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_assoc</span> <span class=\"n\">œÜ.to_prefunctor</span><span class=\"o\">,</span>\n        <span class=\"n\">œà.left_inv</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_id</span><span class=\"o\">,</span> <span class=\"n\">œÜ.left_inv</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">prefunctor.comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_assoc</span> <span class=\"n\">œà.inv_prefunctor</span><span class=\"o\">,</span>\n        <span class=\"n\">œÜ.right_inv</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_id</span><span class=\"o\">,</span> <span class=\"n\">œà.right_inv</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">iso.of_bijective</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hœÜobj</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"n\">œÜ.obj</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hœÜmap</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"n\">œÜ.map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œÜ</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_prefunctor</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">function.surj_inv</span> <span class=\"n\">hœÜobj.surjective</span><span class=\"o\">,</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">function.right_inverse_surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n          <span class=\"bp\">‚Üê</span><span class=\"n\">function.right_inverse_surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">hœÜmap</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">,</span>  <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">function.surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.left_inverse_surj_inv</span> <span class=\"n\">hœÜobj</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_obj</span><span class=\"o\">,</span>\n                 <span class=\"n\">prefunctor.id_obj</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"n\">fapply</span> <span class=\"n\">prefunctor.ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">generalize</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">function.surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x'</span><span class=\"o\">,</span>\n      <span class=\"n\">generalize</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">function.surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">y'</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">hx'</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">hy'</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">fapply</span> <span class=\"n\">prefunctor.ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.right_inverse_surj_inv</span> <span class=\"n\">hœÜobj.2</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_obj</span><span class=\"o\">,</span>\n                 <span class=\"n\">prefunctor.id_obj</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iso.ext</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"n\">œà</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">œÜ.to_prefunctor</span> <span class=\"bp\">=</span> <span class=\"n\">œà.to_prefunctor</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">œÜ</span> <span class=\"bp\">=</span> <span class=\"n\">œà</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">quiver</span>\n</code></pre></div>",
        "id": 336478897,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677244544
    },
    {
        "content": "<p>Do we have the theorem that a functor is an equivalence if it's bijective on hom sets and essentially surjective on objects? Because you'll see all the same problems there, I should think.</p>",
        "id": 336510678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677252103
    },
    {
        "content": "<p>Good idea, let me see: <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.of_fully_faithfully_ess_surj\">https://leanprover-community.github.io/mathlib_docs/category_theory/equivalence.html#category_theory.equivalence.of_fully_faithfully_ess_surj</a></p>",
        "id": 336510966,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677252158
    },
    {
        "content": "<p>Seems to me that the key difference is that Scott's (presumably it is Scott) definition of <code>full</code> is constructive: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.full\">docs#category_theory.full</a> (see <code>witness</code>)</p>",
        "id": 336517904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677253862
    },
    {
        "content": "<p>It should be doable with some induction on equalities.... I'll give it a go</p>",
        "id": 336518251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677253956
    },
    {
        "content": "<p>yeah it should be messy but doable, but the definition of <code>map</code> in <code>iso.of_bijective</code> is in tactic mode, and Scott can avoid this. I wonder whether it would be easier to prove <code>iso.of_bijective_and_full_in_Scotts_sense</code> first, and then deduce <code>iso.of_bijective</code> from it.</p>",
        "id": 336518971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677254131
    },
    {
        "content": "<p>I had the same problem <a href=\"https://github.com/leanprover-community/mathlib/blob/b2ff9a3d7a15fd5b0f060b135421d6a89a999c2f/src/combinatorics/quiver/push.lean#L62\">here</a> and this got solved by Junyan (iirc). I seem to never be able to close these goals.</p>",
        "id": 336519267,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677254192
    },
    {
        "content": "<p>Basically the same idea: create a little API for the construction which takes a morphism of quivers which is bijective on hom sets and returns the inverse bijection on hom sets, go through the <code>eq.rec</code> pain there, and just use the inverse bijection to make the main proof far less painful (by following Scott's approach, so you don't need the <code>rw</code> in the definition of <code>map</code>)</p>",
        "id": 336519622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677254280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">R√©mi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/A.20bijective.20prefunctor.20has.20an.20inverse.3A.C2.A0.20.60eq.2Erec.60.20goal/near/336519267\">said</a>:</p>\n<blockquote>\n<p>I had the same problem <a href=\"https://github.com/leanprover-community/mathlib/blob/b2ff9a3d7a15fd5b0f060b135421d6a89a999c2f/src/combinatorics/quiver/push.lean#L62\">here</a> and this got solved by Junyan (iirc). I seem to never be able to close these goals.</p>\n</blockquote>\n<p>Yeah, there is an art to these theorems. Back in the day I remember struggling to prove that a bijection gave an equiv, and this is just the same question but hard mode. The reason I'm cautioning against Adam's approach is that it seems to me that using Scott's trick will localise the pain and ultimately decrease it.</p>",
        "id": 336520051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677254389
    },
    {
        "content": "<p>Yeah, I guess it's always about building the right generic api around your equalities and then applying it in the proof, rather than hopelessely trying to bruteforce things when needed.</p>",
        "id": 336521268,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677254659
    },
    {
        "content": "<p>Right, which is why I'm trusting Scott's intuition with <code>full</code> (which he makes an API for).</p>",
        "id": 336522732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1677254946
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.quiver.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.equiv.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">z</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">quiver</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">iso</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">prefunctor</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv_prefunctor</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">to_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">inv_prefunctor</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">inv_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">to_prefunctor</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">‚âÉ</span><span class=\"n\">q</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">60</span> <span class=\"o\">:=</span> <span class=\"n\">iso</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prefunctor</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">iso.to_prefunctor</span><span class=\"o\">‚ü©</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.refl</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">ùü≠</span><span class=\"n\">q</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.symm</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">V</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">œÜ.inv_prefunctor</span><span class=\"o\">,</span> <span class=\"n\">œÜ.to_prefunctor</span><span class=\"o\">,</span> <span class=\"n\">œÜ.right_inv</span><span class=\"o\">,</span> <span class=\"n\">œÜ.left_inv</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">iso.trans</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">œà</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œÜ.to_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">œà.to_prefunctor</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œà.inv_prefunctor</span> <span class=\"bp\">‚ãô</span><span class=\"n\">q</span> <span class=\"n\">œÜ.inv_prefunctor</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">prefunctor.comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_assoc</span> <span class=\"n\">œÜ.to_prefunctor</span><span class=\"o\">,</span>\n        <span class=\"n\">œà.left_inv</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_id</span><span class=\"o\">,</span> <span class=\"n\">œÜ.left_inv</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">prefunctor.comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_assoc</span> <span class=\"n\">œà.inv_prefunctor</span><span class=\"o\">,</span>\n        <span class=\"n\">œÜ.right_inv</span><span class=\"o\">,</span> <span class=\"n\">prefunctor.comp_id</span><span class=\"o\">,</span> <span class=\"n\">œà.right_inv</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">X'</span> <span class=\"n\">Y</span> <span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚âÉ</span> <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">h2</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hom_equiv_of_eq_eq</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">X'</span> <span class=\"n\">Y</span> <span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">X'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">hom_equiv_of_eq</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">iso.of_bijective_inverse_aux</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hœÜobj</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"n\">œÜ.obj</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hœÜmap</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"n\">œÜ.map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">V</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">Eobj</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.of_bijective</span> <span class=\"n\">_</span> <span class=\"n\">hœÜobj</span><span class=\"o\">,</span>\n    <span class=\"n\">Ehom</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">‚âÉ</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">X</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">equiv.of_bijective</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hœÜmap</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"k\">in</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Eobj.symm</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Ehom</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">‚àò</span> <span class=\"n\">hom_equiv_of_eq</span>\n    <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Eobj</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">Eobj.apply_symm_apply</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">Y</span> <span class=\"bp\">=</span> <span class=\"n\">Eobj</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">Eobj.apply_symm_apply</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">iso.of_bijective</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚•§</span><span class=\"n\">q</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hœÜobj</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"n\">œÜ.obj</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hœÜmap</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"n\">œÜ.map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">œÜ.obj</span> <span class=\"n\">x</span> <span class=\"bp\">‚ü∂</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">œÜ</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_prefunctor</span> <span class=\"o\">:=</span> <span class=\"n\">iso.of_bijective_inverse_aux</span> <span class=\"n\">œÜ</span> <span class=\"n\">hœÜobj</span> <span class=\"n\">hœÜmap</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">fapply</span> <span class=\"n\">prefunctor.ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">generalize_proofs</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">induction</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n      <span class=\"n\">induction</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">equiv.of_bijective</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">œÜ.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">fapply</span> <span class=\"n\">prefunctor.ext</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">equiv.of_bijective</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">hœÜobj</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"n\">Eo</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">equiv.of_bijective</span> <span class=\"n\">œÜ.obj</span> <span class=\"n\">hœÜobj</span><span class=\"o\">),</span>\n      <span class=\"k\">let</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.of_bijective</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hœÜmap</span> <span class=\"o\">(</span><span class=\"n\">Eo.symm</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Eo.symm</span> <span class=\"n\">Y</span><span class=\"o\">)),</span>\n      <span class=\"n\">apply</span> <span class=\"n\">E.symm.injective</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">generalize_proofs</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hom_equiv_of_eq_eq</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iso.ext</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"n\">œà</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">œÜ.to_prefunctor</span> <span class=\"bp\">=</span> <span class=\"n\">œà.to_prefunctor</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">œÜ</span> <span class=\"bp\">=</span> <span class=\"n\">œà</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">quiver</span>\n</code></pre></div>",
        "id": 336528646,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677256332
    },
    {
        "content": "<p>Some proofs are sloppy (e.g. I see at least one nonterminal simp)</p>",
        "id": 336528895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677256411
    },
    {
        "content": "<p>Great thanks! I'll try and clean this up and hopefully get the gist of it; Do you reckon <code>iso.ext</code> should be approachable using the same kind of approach ? (I have plenty of similar equalities I¬†need to prove, so hopefully I can base them on your proof here)</p>",
        "id": 336529765,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677256572
    },
    {
        "content": "<p>I haven't tried <code>iso.ext</code> yet...</p>",
        "id": 336529908,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677256609
    },
    {
        "content": "<p>but it should be easier, I think?</p>",
        "id": 336529939,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677256616
    },
    {
        "content": "<p>the rule of thumb with such things is to try to use subst/rcases/induction on the equalities you want to be definitional equalities, and if that doesn't work, pull out an auxiliary lemma which includes these equalities as hypotheses (e.g. I had to do this with <code>hom_equiv_of_eq_eq</code>).</p>",
        "id": 336530160,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1677256678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/A.20bijective.20prefunctor.20has.20an.20inverse.3A.C2.A0.20.60eq.2Erec.60.20goal/near/336529908\">said</a>:</p>\n<blockquote>\n<p>I haven't tried <code>iso.ext</code> yet...</p>\n</blockquote>\n<p>I's a good exercise, I'll try it later on!</p>",
        "id": 336530532,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677256737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/A.20bijective.20prefunctor.20has.20an.20inverse.3A.C2.A0.20.60eq.2Erec.60.20goal/near/336530160\">said</a>:</p>\n<blockquote>\n<p>the rule of thumb with such things is to try to use subst/rcases/induction on the equalities you want to be definitional equalities, and if that doesn't work, pull out an auxiliary lemma which includes these equalities as hypotheses (e.g. I had to do this with <code>hom_equiv_of_eq_eq</code>).</p>\n</blockquote>\n<p>I¬†tried doing the first part, but then lean complained about inducting over non-variables, so I¬†tried <code>generalize</code>, in order to revert the equalities to then be able to induct over them, but I think I was running in circles essentially.<br>\nAnd TIL <code>generalize_proofs</code>, which is something I¬†sorely missed until now.</p>",
        "id": 336531045,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677256862
    },
    {
        "content": "<p>Haha, <a href=\"https://github.com/bottine/mathlib/blob/bottine/combinatorics.quiver/schreier/src/combinatorics/quiver/iso.lean\">finally managed to prove <code>ext</code></a>. I expect it can be golfed to something very much shorter.<br>\nOK, I can't get much shorter than that I¬†guess:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">iso.to_prefunctor_ext</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"n\">œà</span> <span class=\"o\">:</span> <span class=\"n\">iso</span> <span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">œÜ.to_prefunctor</span> <span class=\"bp\">=</span> <span class=\"n\">œà.to_prefunctor</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">œÜ</span> <span class=\"bp\">=</span> <span class=\"n\">œà</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">iso.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">prefunctor.ext</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">œà.to_equiv.injective</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">œà.to_equiv_hom.injective</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">œà.obj_inv_obj_eq</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">œÜ.obj_inv_obj_eq</span> <span class=\"n\">X</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">œà.map</span> <span class=\"o\">(</span><span class=\"n\">œÜ.inv_prefunctor.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">œà.map</span> <span class=\"o\">((</span><span class=\"n\">œà.inv_prefunctor.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prefunctor.map_cast</span><span class=\"o\">,</span> <span class=\"n\">œà.map_inv_map_eq_cast</span><span class=\"o\">,</span> <span class=\"n\">hom.cast_cast</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">prefunctor.map_cast_eq_of_eq</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">œÜ.map_inv_map_eq_cast</span><span class=\"o\">,</span> <span class=\"n\">hom.cast_cast</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 338336964,
        "sender_full_name": "R√©mi Bottinelli",
        "timestamp": 1677507044
    }
]