[
    {
        "content": "<p>Does anyone know how strong axioms are required to prove it? Could it be provable in PA? Has it been proven in Lean yet?</p>",
        "id": 539579761,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1757947687
    },
    {
        "content": "<p>Lean's theory is actually slightly stronger than ZFC, so that probably doesn't give you a good answer.</p>",
        "id": 539590791,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1757950451
    },
    {
        "content": "<p>Lean is not a good tool to answer these questions. The Lean proof of Dirichlet's theorem tells you that Dirichlet's theorem is provable in Lean's type theory. It would be nice to imagine that we could now set some kind of program loose on the proof and this program would come back reporting that the proof actually works in some fragment of PA or whatever, but unfortunately this seems to be far from reality. Yes I am pretty sure that you can prove primes in AP in PA, it wouldn't be much fun, you could just mimic Dirichlet's original proof (which makes extensive use of the real numbers) but then just rewrite everything in terms of sequences of rationals.</p>",
        "id": 539634894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757964979
    },
    {
        "content": "<p>I see, thanks</p>",
        "id": 539659563,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1757977702
    },
    {
        "content": "<p>I agree with Kevin's assessment that there would be no fundamental subtlety with formalizing Dirirchlet's original proof in Peano arithmetic. With the right layer of definitions, it wouldn't even look that different (i.e., you can talk about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-definable real numbers and derivatives and integrals of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-definable functions for a fixed <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> internally in PA.</p>\n<p>For results in number theory, it's really only in proofs that involve large-scale categorical machinery (like certain notions of cohomology) where it becomes unclear how to proceed.</p>",
        "id": 541119477,
        "sender_full_name": "James E Hanson",
        "timestamp": 1758671677
    },
    {
        "content": "<p>I am currently working on formalizing reverse maths in Lean. We can write robust formalizations of proofs in weaker logics. The theories I am interested in are <a href=\"https://www.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf\">Cook and Nguyen's  logics characterizing complexity classes</a>.</p>\n<p>The approach is:</p>\n<ol>\n<li>\n<p>bundle the single axioms you need in a <code>structure</code> or a <code>class</code>: <br>\n<a href=\"/user_uploads/3121/scwru4A3ohn5vL5DhLD2oGD_/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/scwru4A3ohn5vL5DhLD2oGD_/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"692x332\" src=\"/user_uploads/thumbnail/3121/scwru4A3ohn5vL5DhLD2oGD_/image.png/840x560.webp\"></a></div></li>\n<li>\n<p>to add axiom schema of induction, you need a deep embedding of logical formulas to determine that a formula is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Δ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Delta_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> etc. For that you need to use <code>Mathlib.ModelTheory.Syntax</code></p>\n</li>\n<li>you don't deep-embed the deduction system; Lean is your deduction system, and you quantify over every model to prove a theorem. Lean logic leaks into the system; I don't know how to forbid users from using <code>exfalso</code>, but such leakage should be detectable afterwards. What would be bad is weird aspects of Lean type theory allowing you to cheat, but it's not obvious they can when you quantify over every model of just your basic axioms</li>\n</ol>\n<p>Check out <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/013f6dca9b56a5d31fcbf4a828f754e72401b723/BoundedArithmetic/IDelta0.lean#L960\">my proof of 'addition is associative'</a>. It's done in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msub><mi mathvariant=\"normal\">Δ</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">I\\Delta_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, Peano axioms with induction restricted to formulas with bounded quantifiers only. In more interesting theories, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>, pigeonhole is not provable; but it suffices to add an axiom (leading us to a higher complexity class) to make it provable; here's my sketch of <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/013f6dca9b56a5d31fcbf4a828f754e72401b723/BoundedArithmetic/VTC0.lean\">'Pigeonhole Principle is provable in logic corresponding to binary circuit reductions with a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mtext>TC</mtext><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\text{TC}^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8873em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">TC</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8873em;\"><span style=\"top:-3.1362em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>-complete problem added'</a>. The sketch has <code>sorries</code>, but it's not bad; they faithfully transfer lemmas from the original proof in the book: page 292 of draft (310 of the main.dvi pdf file linked above) <br>\n<a href=\"/user_uploads/3121/X5A61GfsU2Dl3acOaFyRLjr1/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/X5A61GfsU2Dl3acOaFyRLjr1/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"803x1017\" src=\"/user_uploads/thumbnail/3121/X5A61GfsU2Dl3acOaFyRLjr1/image.png/840x560.webp\"></a></div>",
        "id": 541186155,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758707040
    },
    {
        "content": "<p>Important: you might be interested in second-order arithmetic. I have only considered first-order theories, although my intuition is that the framework should be very similar. Encoding second-order logic into first-order logic should work for the purpose of proving anything <em>inside</em> of the theory. I might be wrong thought, I haven't tried doing that (but would love to see RCA0 being formalized the same way as my theories) :) </p>\n<p>Btw, check out the recent thread about logical works in Lean: my thread about need for future reviewer of my code :) <a href=\"#narrow/channel/287929-mathlib4/topic/Formalization.20of.20arithmetic.3A.20Reviewer.20needed!/with/540997237\">link</a> and the more general thread created afterwards: <a href=\"#narrow/channel/113488-general/topic/List.20of.20Formalizing.20Mathematical.20Logic.20in.20Lean/with/541045769\">formalizing logic in lean</a></p>",
        "id": 541192982,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758709267
    },
    {
        "content": "<p>Pawel, I’ll check your work out. I’m mainly interested in first order stuff, so I don’t mind the focus on those</p>",
        "id": 541198717,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1758711184
    },
    {
        "content": "<p>I found out more this morning. Jeremy Avigad's paper <em>Number theory and elementary arithmetic</em> <a href=\"https://www.andrew.cmu.edu/user/avigad/Papers/elementary.pdf\">(which can be found here)</a> discusses some of the history of formalizations of Dirichlet's theorem on arithmetic progressions in weak fragments of arithmetic. It seems that Takeuti (in 1978) developed enough complex analysis in Peano arithmetic to make the ordinary proof go through directly. Then Sudac showed in 2001 that Dirichlet's theorem is provable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msub><mi mathvariant=\"normal\">Σ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">I\\Sigma_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (a relatively weak fragment of Peano arithmetic) and then Cornaros and Dimitracopoulos showed that the proof goes through in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msub><mi mathvariant=\"normal\">Δ</mi><mn>0</mn></msub><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">I\\Delta_0 + </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">+</span></span></span></span>\"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span></span></span></span> is a total function\", which is an even weaker fragment.</p>",
        "id": 541282391,
        "sender_full_name": "James E Hanson",
        "timestamp": 1758733355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/116395-maths/topic/Reverse.20mathematics.20and.20Dirichlet's.20theorem.28Arithmetic.20prog.29/near/541192982\">said</a>:</p>\n<blockquote>\n<p>Important: you might be interested in second-order arithmetic. I have only considered first-order theories, although my intuition is that the framework should be very similar. Encoding second-order logic into first-order logic should work for the purpose of proving anything <em>inside</em> of the theory. I might be wrong thought, I haven't tried doing that (but would love to see RCA0 being formalized the same way as my theories) :) </p>\n</blockquote>\n<p>This is maybe an unfortunate aspect of the terminology, but technically second-order arithmetic (and fragments thereof) are treated as two-sorted first-order theories in reverse math, so other than the issue of dealing with many-sorted first-order logic (which I believe has not been done in Lean yet?), it should be possible to approach fragments of second-order arithmetic the same way.</p>",
        "id": 541282952,
        "sender_full_name": "James E Hanson",
        "timestamp": 1758733539
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/116395-maths/topic/Reverse.20mathematics.20and.20Dirichlet's.20theorem.28Arithmetic.20prog.29/near/541282952\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"892220\">Paweł Balawender</span> <a href=\"#narrow/channel/116395-maths/topic/Reverse.20mathematics.20and.20Dirichlet's.20theorem.28Arithmetic.20prog.29/near/541192982\">said</a>:</p>\n<blockquote>\n<p>Important: you might be interested in second-order arithmetic. I have only considered first-order theories, although my intuition is that the framework should be very similar. Encoding second-order logic into first-order logic should work for the purpose of proving anything <em>inside</em> of the theory. I might be wrong thought, I haven't tried doing that (but would love to see RCA0 being formalized the same way as my theories) :) </p>\n</blockquote>\n<p>This is maybe an unfortunate aspect of the terminology, but technically second-order arithmetic (and fragments thereof) are treated as two-sorted first-order theories in reverse math, so other than the issue of dealing with many-sorted first-order logic (which I believe has not been done in Lean yet?), it should be possible to approach fragments of second-order arithmetic the same way.</p>\n</blockquote>\n<p>Wow nice, I didn't know that they treat it as two-sorted first-order. This can be worked with! </p>\n<p>For the details of encoding: section 4.5 <a href=\"https://www.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf\">https://www.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf</a> <br>\nI used this concept to define the 2-sorted, first-order theory <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>V</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">V^0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span> of Cook and Nguyen, having <code>num</code> (representing unary numbers) and <code>str</code> (representing binary numbers / finite sets of integers): <a href=\"https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/79cfe660f91da0133bc9bee5b8e7f528de1f685c/BoundedArithmetic/V0.lean#L121\">https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/79cfe660f91da0133bc9bee5b8e7f528de1f685c/BoundedArithmetic/V0.lean#L121</a></p>\n<p>i am working hard to make the code nice (and it will be nice), but it's a lot of content and takes me days to clean up :) sorry for sending you work in progress</p>",
        "id": 541431189,
        "sender_full_name": "Paweł Balawender",
        "timestamp": 1758798784
    }
]