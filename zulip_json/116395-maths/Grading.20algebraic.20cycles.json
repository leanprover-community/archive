[
    {
        "content": "<p>Hello!</p>\n<p>Following some discussion on the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/26304\">#26304</a>, I'm wondering what peoples' opinions are on the best way to define gradings of algebraic cycles in the right generality. I think we want API which can accommodate grading by dimension and codimension (defined in terms of height and coheight in the specialization order), and by <a href=\"https://stacks.math.columbia.edu/tag/02I8\">dimension function</a>s in the sense of the stacks project. We can't think of a good common generalisation of these kinds of function, and we're also not sure if there are other kinds of gradings on algebraic cycles people might want to consider. </p>\n<p>Currently, things are defined such that <code>Grading X N</code> is just a wrapper around functions <code>X \\to N</code>. For example, using this notion we have the following definition of homogeneous cycles of \"dimension\" d:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Grading</span><span class=\"bp\">.</span><span class=\"n\">homogeneousCycles</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Grading</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddMonoid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">AddSubmonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AlgebraicCycle</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">add_mem'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c₁</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">c₂</span><span class=\"w\"> </span><span class=\"n\">hc₁</span><span class=\"w\"> </span><span class=\"n\">hc₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hc₁</span><span class=\"w\"> </span><span class=\"n\">hc₂</span><span class=\"w\"> </span><span class=\"bp\">⊢</span>\n<span class=\"w\">    </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"n\">zero_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>It feels a little bit strange/like there's not enough structure to just have gradings be a wrapper around plain functions. We would be interested to know if there are any natural properties we should expect these functions to satisfy.</p>\n<p>Thanks,<br>\nRaphael</p>",
        "id": 576112178,
        "sender_full_name": "Raphael Douglas Giles",
        "timestamp": 1772135889
    },
    {
        "content": "<p>For this definition alone, it probably should just take a <code>s : Set X</code> and defined to be <code>{ c | c.support ⊆ s }</code>.</p>",
        "id": 576135771,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1772145298
    },
    {
        "content": "<p>Right, that's true, you can certainly have a grading of cycles be a function <code>N \\to Set X</code> for some indexing type <code>N</code>, and I suppose this allows you the flexibility that the sets of \"homogeneous cycles\" can overlap. Do you think this definition will be as convenient to use as gradings defined by functions <code>X \\to N</code>, and are there cases where we want the increased generality your definition provides?</p>",
        "id": 576286999,
        "sender_full_name": "Raphael Douglas Giles",
        "timestamp": 1772205761
    },
    {
        "content": "<p>Intersection theory on more general schemes than proper varieties over fields sometimes requires different notions of dimension/codimension.  For example, over a discrete valuation ring, Fulton (<em>Intersection theory</em>, chapter 20) considers the relative dimension. In their <em>Non-archimedean Arakelov theory</em>, Bloch, Gillet and Soulé consider the dimension of a proper scheme containing the given scheme. Thorup (1990, <em>Rational equivalence on arbitrary Noetherian schemes</em>) describes various dimension/codimension functions. And all have their interest.</p>",
        "id": 576301609,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1772209616
    }
]