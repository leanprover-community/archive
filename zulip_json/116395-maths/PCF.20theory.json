[
    {
        "content": "<p>I'm finally getting started on PCF theory! The project is hosted on <a href=\"https://github.com/YnirPaz/PCF-Theory\">this</a> git repository, and will follow article 14 in \"Handbook of set theory\" - \"Cardinal Arithmetic\", with the general goal of getting to results about... cardinal arithmetic (a few more details are in the readme). So far I have formalized the existence of club guessing sequences (theorem 2.17), which is basically the only thing we can do before actually defining the basics of PCF.</p>\n<p>A little disclaimer, I don't have plans to get this into mathlib at the moment. I would nevertheless love feedback/help.</p>\n<p>In <code>PCF/Playground.lean</code> I have the definitions I talk up below, but I'm not really sure about any of them. Keep in mind they are not very organized at the moment. The very beginning of PCF has many definitions which are easy to jump between on paper but have no single obvious way to formalize, so it will likely be a minute before they all settle down. Here are some details, and feel free to comment on only a part of it because this is a lot of stuff:</p>\n<p>Let <code>L</code> be a linear order, <code>A</code> any type and <code>I</code> an ideal on <code>A</code> (an ideal here is a family of subsets downwards closed and closed under finite union. Equivalent to <code>Ideal (Set ι)</code>). Then we can define a partial order on <code>(A → L)</code> using the ideal <code>I</code>: for <code>f, g : A → L</code>, define <code>f &lt;I g</code> if <code>{x | g(x) ≤ f(x)} ∈ I</code>. That is, the set of exceptions to <code>f &lt; g</code> is small. <code>≤I</code>, <code>=I</code> etc are defined similarly. Note that <code>f ≤I g</code> is not equivalent to (<code>f &lt;I g</code> or <code>f =I g</code>), so this is not a <code>Preorder</code> in the mathlib sense.</p>\n<p>When <code>h : A → Ordinal</code>, we will look at the collection of functions \"below\" <code>h</code>, the set of <code>f : A → Ordinal</code> which are bounded by <code>h</code> at every coordinate. PCF theory studies the properties of the orders <code>&lt;I</code> on such sets with different ideals <code>I</code>.</p>\n<ul>\n<li>\n<p>First I defined set-ideals,<code>SIdeal α := Order.Ideal (Set α)</code>, because working directly with <code>Order.Ideal</code> is annoying.</p>\n</li>\n<li>\n<p>For a type <code>A</code>, an order <code>L</code> and <code>h : A → L</code>, <code>FunsBelow h</code> is the set of functions from <code>A</code> to <code>L</code> which are smaller than <code>h</code> everywhere.</p>\n</li>\n<li>\n<p>The most common case is where <code>A</code> is a set of ordinals and we look at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∏</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\prod A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, which in the above implementation means <code>h</code> is the identity. This is <code>Ordinal.Prod A</code> (better name?) for <code>A : Set Ordinal</code>. Since this definition is just <code>FunsBelow</code> with specific inputs, this extra layer shouldn't hurt definitional equality between the two.</p>\n</li>\n</ul>\n<p>These definitions have the effect that when talking about an ideal on <code>A : Set Ordinal</code>, its elements will have type <code>Set A</code> and not <code>Set Ordinal</code>. I don't know if this is good or bad.</p>\n<p>A important property is being an \"exact upper bound\" of a set. The definition is in the book for the interested, but importantly it uses both a <code>&lt;</code> and a <code>≤</code> relation, which like I said above don't have to corrospond in the usual way. So the definition must explicitly take them both:</p>\n<ul>\n<li>\n<p><code>Set.ExactUpperBound (le lt : α → α → Prop) (A : Set α) (a : α)</code> means that <code>a</code> is an exact upper bound of <code>A</code> with the relations <code>le</code> and <code>lt</code>. We then define</p>\n</li>\n<li>\n<p><code>Set.ExactUpperBound_SIdeal</code> for the case where the orders are <code>≤I</code> and <code>&lt;I</code>, so it only takes in a set, an element and an ideal.</p>\n</li>\n</ul>\n<p>Some of the results we'll get to soon have the form \"if a set of functions from some <code>A</code> to the ordinals has some order-property with respect an ideal <code>I</code>, then it has an exact upper bound with respect to <code>I</code>\".</p>\n<p>We could also define <code>ExactUpperBound_SIdeal</code> without defining exact upper bounds of general orders not induced by an ideal, but it seems strange not to have it.</p>\n<p>Next we want to talk about cofinalities of such orders induced by an ideal, specifically cofinalities of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∏</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">\\prod A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> for a set of ordinals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and with respect to an ideal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>.</p>\n<p>First we define the more general case of the cofinality of a set of functions given an ideal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SIdeal_cof</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">cof</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then the ordinal case as a definition using this case.</p>\n<p>The main property we will want an order <code>≤I</code> to satisfy is for it to have True Cofinality. This means that it has a linearly ordered cofinal set, or equivalently an increasing cofinal sequence. We call the length of the shortest such sequence, if it exists, the true cofinality of the order. The biggest results of this chapter will say that for many sets of ordinals <code>A</code> there are ideals <code>I</code> so that the product of <code>A</code> has true cofinality with respect to <code>≤I</code>.</p>\n<p>If an order has true cofinality then it is simply equal to its cofinality. Therefore we only need the property of having true cofinality, which we define for a general relation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">hasTCF</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Finally this lets us define the pcf (possible cofinalities) of a set of ordinals as the set of true cofinalities that its product can attain, with any proper ideal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">pcf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">SIdeal_cof_Prod</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">hI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">hTCF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">hasTCF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">))}</span>\n</code></pre></div>\n<p>I think the main reason I ended up defining so many things as just plugging in specific inputs to another definition is because we can't use any typeclasses when dealing with orders induced by ideals, both because we work with many orders at the same time and because there isn't a class for the relationship between <code>≤I</code> and <code>&lt;I</code>.</p>\n<p>NB: To define <code>f &lt;I g</code>,... I first defined <code>≤(g, f)</code> as the set of indices where <code>g ≤ f</code>. Then <code>f &lt;I g := ≤(g, f) ∈ I</code>. I'm not sure if this is useful at all or if it only increases spaghettiness.</p>\n<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>  so you won't be mad at me for not pinging you.</p>",
        "id": 491314407,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735583204
    },
    {
        "content": "<p>I don't know anything about PCF theory, but I'm willing to learn. Count me in!</p>\n<p>I think the decision of working within a separate repo is the correct one. The current ordinal library is a bit tumultuous at the moment (entirely through my fault), and if we want to formalize new mathematics we should focus on moving fast, and then fixing things when we have the time.</p>",
        "id": 491520911,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735757755
    },
    {
        "content": "<p>Question: isn't <code>≤I</code> in fact a preorder? It's reflexive (because every ideal contains <code>univ</code>) and transitive (because of the totality of the order in <code>L</code>).</p>",
        "id": 491521093,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735757926
    },
    {
        "content": "<p><code>x &lt; y ↔ x ≤ y ∨ x = y</code> isn't a necessary condition on a preorder, only on partial orders</p>",
        "id": 491521230,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735758043
    },
    {
        "content": "<p>(Does this same comment apply for <code>ExactUpperBound</code>? If we can avoid unbundled relations, it will make things a lot nicer if not simpler.)</p>",
        "id": 491521406,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735758225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491521230\">said</a>:</p>\n<blockquote>\n<p><code>x &lt; y ↔ x ≤ y ∨ x = y</code> isn't a necessary condition on a preorder, only on partial orders</p>\n</blockquote>\n<p>In mathlib's <code>Preorder</code> the condition is <code>a &lt; b ↔ a ≤ b ∧ ¬b ≤ a</code>, which doesn't necessarily hold. For example if <code>f</code> is always <code>≤</code> to <code>g</code>, but equal to it on a positive set and strictly less than it on a positive set, then <code>f ≤ g</code> and <code>¬ g ≤ f</code>, but <code>f &lt; g</code> doesn't hold.</p>",
        "id": 491521608,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735758422
    },
    {
        "content": "<p>Oh, so the situation is a bit different then. It's not that <code>≤I</code> isn't a preorder, but rather that said preorder doesn't have the correct <code>&lt;I</code> and <code>=I</code> relations.</p>",
        "id": 491521691,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735758488
    },
    {
        "content": "<p>Yes, it is a preorder, just not a <code>Preorder</code> by mathlib's standards.</p>",
        "id": 491521729,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735758536
    },
    {
        "content": "<p>Does the resulting order structure have another name? Can it be characterized somehow?</p>",
        "id": 491521845,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735758650
    },
    {
        "content": "<p>I think the only properties <code>&lt;</code> and <code>≤</code> satisfy with each other are<br>\n<code>a &lt; b → a ≤ b</code> and <code>a &lt; b ≤ c → a &lt; c</code> (and the symmetric case)<br>\nand I don't know of a name for this.</p>",
        "id": 491522025,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735758827
    },
    {
        "content": "<p>By the way a lot of PCF theory is done on the quotient of the function space with <code>=I</code>, and then they are a partial order and a strict order (still not equivalent in the usual sense though), but I think it might be okay to avoid doing that for a while.</p>",
        "id": 491522233,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735758999
    },
    {
        "content": "<p>Thing is, I was working on redefining <code>Order.cof</code> in terms of a preorder, rather than an unbundled relation. I was expecting that this would make things simpler, but that might not be the case here.</p>",
        "id": 491522242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491522025\">said</a>:</p>\n<blockquote>\n<p>I think the only properties <code>&lt;</code> and <code>≤</code> satisfy with each other are<br>\n<code>a &lt; b → a ≤ b</code> and <code>a &lt; b ≤ c → a &lt; c</code> (and the symmetric case)<br>\nand I don't know of a name for this.</p>\n</blockquote>\n<p>All this really says is \"<code>≤</code> is transitive and it's a subrelation of <code>&lt;</code>\"</p>",
        "id": 491522381,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491522242\">said</a>:</p>\n<blockquote>\n<p>Thing is, I was working on redefining <code>Order.cof</code> in terms of a preorder, rather than an unbundled relation. I was expecting that this would make things simpler, but that might not be the case here.</p>\n</blockquote>\n<p>Hmm... with that definition I guess we would need to define the <code>Preorder</code> whose <code>≤</code> is <code>≤I</code> and whose <code>&lt;</code> is <code>¬≤I</code>, and use that for the cofinality, which indeed is less simple. Basically we want it to be easy to take the cofinality of a single preorder.</p>",
        "id": 491522623,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735759420
    },
    {
        "content": "<p>We could define a type alias on <code>A → L</code> which registers a preorder structure such that <code>≤</code> is <code>≤I</code>, but otherwise use <code>≤I</code> and <code>&lt;I</code> everywhere else.</p>",
        "id": 491522833,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759603
    },
    {
        "content": "<p>Thing is, having an unbundled relation takes out a lot of useful functionality, e.g. you can't as easily talk about bounded sets, or suprema/infima, or even <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> sets with the way I implemented them.</p>",
        "id": 491522880,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759662
    },
    {
        "content": "<p>Skimming through the reference you give, it acknowledges that <code>≤I</code> is a quasi-order (a synonym of preorder) and that <code>&lt;I</code> is irreflexive, but doesn't give any explicit structure that relates both of them</p>",
        "id": 491522976,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759736
    },
    {
        "content": "<p>So maybe it's better to treat them as separate relations</p>",
        "id": 491522987,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/PCF.20theory/near/491522880\">said</a>:</p>\n<blockquote>\n<p>Thing is, having an unbundled relation takes out a lot of useful functionality, e.g. you can't as easily talk about bounded sets, or suprema/infima, or even <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> sets with the way I implemented them.</p>\n</blockquote>\n<p>Yea that's a bit of a problem, I ended up defining unbundles versions of <code>Order.Unbounded</code> as <code>Set.Unbounded</code>. I expect if we go down this route there will be some work on this kind of API.</p>\n<p>Thing is, there really isn't a natural <code>Preorder</code> that uses <code>&lt;I</code>, so it would always be awkward to use bundled versions of things.</p>",
        "id": 491523146,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735759893
    },
    {
        "content": "<p>We already have an unbundled version of <code>Order.Unbounded</code>, it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Unbounded#doc\">docs#Set.Unbounded</a>. Except, we've argued in the past that it should be removed...</p>",
        "id": 491523170,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735759922
    },
    {
        "content": "<p>It's a somewhat counterintuitive definition, <code>Unbounded (· ≤ ·) s</code> means <code>¬ BddAbove s</code>, while <code>Unbounded (· &lt; ·) s</code> means <code>Cofinal s</code>... at least if <code>≤</code> and <code>&lt;</code> come from a linear order.</p>",
        "id": 491523291,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735760031
    },
    {
        "content": "<p>Sorry I meant I defined <code>Set.UpperBound</code></p>",
        "id": 491523295,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735760034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491523146\">said</a>:</p>\n<blockquote>\n<p>Thing is, there really isn't a natural <code>Preorder</code> that uses <code>&lt;I</code>, so it would always be awkward to use bundled versions of things.</p>\n</blockquote>\n<p><del>The book says <code>&lt;I</code> is a \"strict partial ordering\". Does that mean that the relation <code>&lt;I</code> or <code>=</code> is a partial order in the Mathlib sense?</del> Sorry, misread</p>",
        "id": 491523456,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735760156
    },
    {
        "content": "<p>Even though <code>upperBounds</code> exists. Although only uses a <code>LE</code> instance so in this case it would be a bit better to use it. But I don't see a a way to do that without explicitly providing the order anyways, since we can't have a <code>LE</code> instance for every ideal...</p>\n<p>I settled on possibly not using any classes for the orders because of thses kinds of stuff.</p>",
        "id": 491523529,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735760199
    },
    {
        "content": "<p>Oh of course, I forgot that you could freely choose an ideal</p>",
        "id": 491523578,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735760256
    },
    {
        "content": "<p>About <code>cof</code>, would it be catastrophical to have 2 definitions? loogle bring up 11 theorems that involve it, we probably need just a few for this project. So maybe you can refactor like you wanted but we can also have a version like the current one?</p>",
        "id": 491523728,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735760383
    },
    {
        "content": "<p>It would not be catastrophical, though it would certainly be annoying</p>",
        "id": 491523784,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735760406
    },
    {
        "content": "<p>I would be fine defining unbundled cofinality in the project (copying what exists right now into some file) and using that without it being in mathlib. It would be easy, quick and dirty, but taking this approach might make the project unfit for mathlib.</p>",
        "id": 491523972,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735760605
    },
    {
        "content": "<p>I think there's two possibilities here. Either<br>\na) We do not do the refactor, and we instead keep <code>Order.cof</code> defined as is. If any theorems are easier to state using <code>@Order.cof α (· ≤ ·)</code> then we just do that.<br>\nb) We do the refactor. We can still define the cofinality in the way that is required for PCF, we can do something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SIdeal_cof</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- temporarily register `≤I` as a preorder</span>\n<span class=\"w\">  </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">cof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then port whatever API is useful so that we don't have to keep explicitly defining the <code>Preorder (A → L)</code> instance</p>",
        "id": 491523973,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735760606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491523973\">said</a>:</p>\n<blockquote>\n<p>I think there's two possibilities here. Either<br>\na) We do not do the refactor, and we instead keep <code>Order.cof</code> defined as is. If any theorems are easier to state using <code>@Order.cof α (· ≤ ·)</code> then we just do that.<br>\nb) We do the refactor. We can still define the cofinality in the way that is required for PCF, we can do something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SIdeal_cof</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- temporarily register `≤I` as a preorder</span>\n<span class=\"w\">  </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">cof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then port whatever API is useful so that we don't have to keep explicitly defining the <code>Preorder (A → L)</code> instance</p>\n</blockquote>\n<p>I'll make a quick test of (b)</p>",
        "id": 491524149,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735760766
    },
    {
        "content": "<p>In fact, there might even be a \"best of two worlds\" approach here. We can define something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">idealPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Then, if it ever becomes useful to use the <code>Preorder</code> structure within a proof, we can simply use <code>have : Preorder (A → L) := idealPreorder I</code>.</p>",
        "id": 491524396,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735761043
    },
    {
        "content": "<p>...although there is a problem with my plan: there is already a preorder structure on <code>A → L</code>! Specifically the one given by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.preorder#doc\">docs#Pi.preorder</a></p>",
        "id": 491524495,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735761132
    },
    {
        "content": "<p>There are ways around this, of course. We could instead register a type alias on <code>A → L</code>, something like <code>WithIdeal A L I = A → L</code> with the order <code>≤I</code>. Or, maybe we can just lower the priority of the <code>Pi.preorder</code> instance?</p>",
        "id": 491524546,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735761214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491524396\">said</a>:</p>\n<blockquote>\n<p>In fact, there might even be a \"best of two worlds\" approach here. We can define something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">idealPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Then, if it ever becomes useful to use the <code>Preorder</code> structure within a proof, we can simply use <code>have : Preorder (A → L) := idealPreorder I</code>.</p>\n</blockquote>\n<p>Honestly I tend to think the <code>Preorder</code> structure won't be useful very often. From the little experimenting I did I always ran into weird defeq and rewrite problems when I had both a bundled and an unbundled version of the relations. And things involving both <code>&lt;I</code> and <code>≤I</code> have to be unbundled, so probably almost all definitions later on will be unbundled.</p>",
        "id": 491525044,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735761714
    },
    {
        "content": "<p>Yeah, that makes sense.</p>\n<p>Does solution (b) seem like it could work? If it does then I think it's by far the cleanest approach.</p>",
        "id": 491526016,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735762714
    },
    {
        "content": "<p>I have my <code>Order.cof</code> refactor in some Mathlib branch, I think it's called something like <code>vi.cofinal</code>. It's basically ready, except I haven't finished porting some currently unused and soon to be deprecated theorems. That might be useful in testing things out.</p>",
        "id": 491526060,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735762790
    },
    {
        "content": "<p>Thanks I was about to quickly write my own definition, I'll copy yours</p>",
        "id": 491526126,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735762832
    },
    {
        "content": "<p>My main motivation for the refactor was that I thought it would make things simpler, and in my opinion, at least the cofinality file itself does become cleaner after the changes I made. But of course, if this refactor makes downstream projects (like this one!) more difficult, then I'm willing to change course.</p>",
        "id": 491526340,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763081
    },
    {
        "content": "<p>...sorry if i'm getting you dragged down into details that aren't ultimately mathematical</p>",
        "id": 491526487,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763263
    },
    {
        "content": "<p>if you want to go the quick and dirty route of just copying the current cofinality file then that's also fine</p>",
        "id": 491526536,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/PCF.20theory/near/491526487\">said</a>:</p>\n<blockquote>\n<p>...sorry if i'm getting you dragged down into details that aren't ultimately mathematical</p>\n</blockquote>\n<p>That's what I was hoping for haha. I'm a bit scared of rushing things and ending up having to redo 3000 lines of code because I didn't think things through.</p>",
        "id": 491526578,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735763346
    },
    {
        "content": "<p>So this is good!</p>",
        "id": 491526588,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735763371
    },
    {
        "content": "<p>Here's the definition with your new cofinality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">cof'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⨅</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">IsCofinal</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instPreorderSIdeal</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">le_refl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">      </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_SIdeal</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ltSet</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lt_self_iff_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">setOf_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">empty_mem</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">lt_iff_le_not_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">SIdeal_cof'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SIdeal</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cardinal</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">cof'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">instPreorderSIdeal</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm seeing if I can prove things about it now. btw I couldn't figure out how to define the preorder instance inside the definition so I did it outside with <code>instPreorderSIdeal</code>. It's probably because I'm doing something stupid with the syntax.</p>",
        "id": 491526709,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735763505
    },
    {
        "content": "<p>Syntax looks fine to me, or at least, as fine as is possible given what we're trying to do</p>",
        "id": 491526796,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763592
    },
    {
        "content": "<p>I mean when I try to put it inside the definition it doesn't work, but it should be able to.</p>",
        "id": 491526877,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735763662
    },
    {
        "content": "<p>Do note that <code>instPreorderSIdeal</code> should be a def rather than an instance, otherwise you're going to get some nasty diamonds</p>",
        "id": 491526902,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763705
    },
    {
        "content": "<p>Wait if the instance takes an explicit argument (the ideal) does it still get automatically synthed?</p>",
        "id": 491526993,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735763787
    },
    {
        "content": "<p>No, but both instances will be found if you ever need to use either one of them on <code>A → I</code> later on, and that might cause problems</p>",
        "id": 491527023,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735763835
    },
    {
        "content": "<p>Well I'm having a little trouble testing the new definition because there isn't a definition for cofinal sets yet. <code>IsCofinal</code> is bundled. The options are to define an <code>SIdeal_cofinal</code> predicate by using <code>IsCofinal</code>, going down the full bundled route, or define a more general unbundled <code>cofinal</code> predicate, and the test of the new def will be to show all the necessary api for it in the case of <code>SIdeal</code>s.</p>\n<p>I'll try the second one tomorrow. Thankfully we have unbundled<code>Set.Bounded</code> and <code>Set.Unbounded</code> already, so the chain stops here for now.</p>",
        "id": 491527938,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735764840
    },
    {
        "content": "<p>Idea, can we perhaps use the same solution of <code>Order.SIdeal_cof</code> for other notions? That is, instead of using <code>Set.Bounded (· ≤I ·) s</code> or whatnot, we define something like <code>Order.SIdeal_bddAbove s I</code> as <code>BddAbove</code> with the <code>≤</code> relation given by <code>≤I</code>. This should hopefully simplify notation, and it also means that if we ever have to port a theorem that exists on <code>BddAbove</code> to our new definition, we can do it more directly.</p>",
        "id": 491529155,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735766033
    },
    {
        "content": "<p>This idea is compatible with both the idea that order relations should be bundled within Mathlib, and that they should be unbundled within the context of PCF, since we can always use the <code>instPreorderSIdeal</code> trick to use a definition expecting a bundled relation with our unbundled <code>≤I</code>.</p>",
        "id": 491529534,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735766431
    },
    {
        "content": "<p>There are really 2 ideas here. First is to have <code>SIdeal_bounded S I</code>, which we could define with either <code>Set.Bounded</code> or <code>BddAbove</code>. The second is to use <code>BddAbove</code> for it.</p>\n<p>I like the first idea in either case, but it's less clear to me which option is better. With <code>cof</code> there is no unbundled version (I'm from the future) so using a preorder makes a lot of sense. But in this case both versions exist. <code>Set.Bounded</code> feels more natural, but <code>BddAbove</code> seems to have significally more API.</p>",
        "id": 491588472,
        "sender_full_name": "Nir Paz",
        "timestamp": 1735812811
    },
    {
        "content": "<p>Yeah, I would avoid <code>Set.Bounded</code>. It will almost surely get deprecated / removed in the near-ish future.</p>\n<p>It's currently only used for a few theorems about ordinals (most of which I've already switched over to <code>BddAbove</code>), and within a single file with API that I wrote back in 2022, before I found out that <code>BddAbove</code> was a thing.</p>",
        "id": 491679101,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735860027
    },
    {
        "content": "<p>(pinging <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> as someone who also had strong opinions on <code>Set.Bounded</code> and <code>Set.Unbounded</code>)</p>",
        "id": 491679158,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1735860056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"565854\">@Nir Paz</span> how are things going? Sorry I haven't been involved with this, I've been much busier this past month than expected.</p>\n<p>I'm still trying to get my cofinality refactor into Mathlib, though this has led to other auxiliary refactors I'm still sorting out. Would it be ok if I temporarily copy over my code into your repo? That could also help us gauge if my plans really do work out as well as I expect.</p>",
        "id": 501675193,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1740440355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> same here, life got in the way hard and I didn't work on this for a while. I'll be back home in a few days and then make some progress.</p>\n<p>So since there isn't much code yet I don't know if it would tell us much to use the new cofinality stuff, and there is actually a lot to do before we have to talk about cofinalities/true cofinalities for pcf, so the definitions we talked about that might get tricky with the refactor will probably just sit there for a while.</p>\n<p>I'm planning on keeping the current old-cofinality defs for now and change them when the refactor happens</p>",
        "id": 502013322,
        "sender_full_name": "Nir Paz",
        "timestamp": 1740566363
    }
]