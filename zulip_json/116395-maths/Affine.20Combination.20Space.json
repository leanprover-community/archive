[
    {
        "content": "<p>I had some thoughts while biking today:</p>\n<p>Define an <em>affine combination space</em> over a field <code>ùïú</code> to be a type <code>P</code> equipped with a partial operation called <em>affine combination</em> with the signature</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">affineCombination</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>This <code>affineCombination</code> must satisfy a distributive law</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚Üí‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">affineCombination</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">mapDomain</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">affineCombination</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">affineCombination</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span>\n</code></pre></div>\n<p>and a unit law</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">affineCombination</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ãØ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>Assuming I've got those axioms correct, it's not hard to see that the nonempty affine combination spaces over a field <code>ùïú</code> are exactly the affine spaces over vector spaces over <code>ùïú</code>. But I've done this without ever explicitly mentioning the vector space, so we can generalize this in a different direction. Nothing in the definition requires <code>ùïú</code> to have division, or even subtraction, so we can consider these over an arbitrary <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Semiring#doc\">docs#Semiring</a>. Contrast this to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddTorsor#doc\">docs#AddTorsor</a> which only makes sense over an <code>AddGroup</code> (with subtraction).<br>\nThe motivation is the figure out a way to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=segment#doc\">docs#segment</a> and friends to affine spaces without losing their use in semirings, which don't have subtraction.<br>\nSome other things I've noticed:</p>\n<ul>\n<li>fixing the semiring gives you a finitary algebraic theory, so abstract nonsense gives you all sorts of results</li>\n<li>a convex set is an affine combination space over the nonnegative part of the scalars</li>\n<li>(semi)modules can be given a similar definition, just without the requirement that the scalars add to one (so with linear combination instead of affine combination), but they also have this nicer presentation with the binary operations of addition and scalar multiplication, however this sort of seems difficult to do with affine combination spaces because of the requirement that the scalars add up to one</li>\n</ul>\n<p>Overall, does this sound like a good idea? I would like to hear your thoughts and opinions on this. Also surely someone else has thought of this before? But I don't see it in mathlib so...</p>",
        "id": 540613425,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758403854
    },
    {
        "content": "<p>This sounds related to <span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span>' past plans to refactor convexity to affine spaces</p>",
        "id": 540619132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758411506
    },
    {
        "content": "<p>Indeed, I have an implementation in LeanCamCombi. It's still on the roadmap, but not my priority</p>",
        "id": 540632400,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1758431582
    },
    {
        "content": "<p>I quite like this idea.</p>\n<p>This means that we can talk about a Euclidean plane without carrying around this awkward real vector space, right? And instead, given such an affine space, there is a way to construct the corresponding vector space (using some choice of an arbitrary base point), right? So to do oriented angles, we would put an orientation on that vector space? And to make sure it is a plane, we require this vector space to be 2 dimensional. (Or we could define rank of such a space to be the rank of its corresponding vector space).</p>",
        "id": 540680902,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758484804
    },
    {
        "content": "<p>Also, I think <code>Finsupp.degree</code> does what you are doing with <code>Finsupp.sum</code>. There was some recent discussion about what <code>Finsupp.degree</code> should be called.</p>",
        "id": 540681191,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758485045
    },
    {
        "content": "<p>Also I think this should be called <code>AffineSpace</code></p>",
        "id": 540682410,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758486314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/540682410\">said</a>:</p>\n<blockquote>\n<p>Also I think this should be called <code>AffineSpace</code></p>\n</blockquote>\n<p>the name is arbitrary and can be whatever you want</p>",
        "id": 540682452,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758486360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/540682410\">said</a>:</p>\n<blockquote>\n<p>Also I think this should be called <code>AffineSpace</code></p>\n</blockquote>\n<p>the problem is that <code>AffineSubspace</code> is already taken</p>",
        "id": 540683535,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758487441
    },
    {
        "content": "<p>My impression is that if we switch to this new definition of <code>AffineSpace</code> for Euclidean geometry, then we also want to switch <code>AffineSubspace</code> to not depend on a vector space.</p>",
        "id": 540684611,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758488684
    },
    {
        "content": "<p>We'll still want some class that is the current <code>AffineSpace</code>, to hold the compatibility between vsub and vadd</p>",
        "id": 540689561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758494932
    },
    {
        "content": "<p>The current thing used for <code>AffineSpace</code> is <code>AddTorsor</code>, which is a more general concept, so that is certainly not getting removed.</p>",
        "id": 540689655,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758495080
    },
    {
        "content": "<p>well it's not more general</p>",
        "id": 540689666,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758495109
    },
    {
        "content": "<p>it's just general in a different direction</p>",
        "id": 540689669,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758495114
    },
    {
        "content": "<p>they are incomparable elements in the type of abstractions partially ordered by generality</p>",
        "id": 540689705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758495177
    },
    {
        "content": "<p>Oh I see, I forgot that <code>AffineSpace</code> doesn't exist and is only notation</p>",
        "id": 540690193,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758495733
    },
    {
        "content": "<p>for example, the set <code>Ico (0 : ‚Ñù) 1</code> is an affine combination space over <code>‚Ñù‚â•0</code> but isn't an <code>AddTorsor</code> in a compatible way, and any nonabelian <code>AddGroup</code> is an <code>AddTorsor</code> over itself without being an affine combination space in a compatible way</p>",
        "id": 540690611,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758496416
    },
    {
        "content": "<p>I was wondering if your definition of <code>AffineSpace</code> could be made without <code>Finsupp</code>, and instead using some version of <code>lineMap</code> as the fundamental operation. But unfortunately it seems like this doesn't work in the generality of a <code>Semiring R</code>.</p>\n<p>Either way, <code>AffineMap.lineMap</code> can be defined in terms of <code>affineCombination</code>. And <code>AffineMap</code> can also be generalized to not have the underlying vector space.</p>",
        "id": 540692144,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758498694
    },
    {
        "content": "<p>I don't think having a real vector space for geometrical uses is awkward; it's used extremely frequently and is much more convenient to have simply as <code>V</code> than requiring use of some other definition to produce a space of vectors from a space of points (even apart from the extra awkwardness of needing to insert lots of extra maps to deal with the space of vectors of an affine subspace not being a submodule of the space of vectors of the whole space if you involve such extra definitions in producing a space of vectors). And I certainly expect that for people using concrete coordinates, it's much better for <code>EuclideanSpace</code> to be its own space of vectors (generally: for a module used as an affine space to be its own space of vectors) than needing to use separate types.</p>\n<p>I'd expect some kind of typeclass for an abstract affine combination space that's also an <code>AddTorsor</code> for a module that asserts that the two ways of calculating affine combinations agree. (Constructing the data for an abstract affine combination space from a torsor is problematic as an instance, at least if you also want an instance to construct the data for a module over a semiring, because of non-defeq diamonds in the case of a module as a torsor for itself.)</p>",
        "id": 540694198,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758501039
    },
    {
        "content": "<p>Removing the existing <code>AffineSpace</code> notation for <code>AddTorsor</code> probably makes sense.</p>",
        "id": 540694439,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758501188
    },
    {
        "content": "<p>What about when there are no vectors?</p>",
        "id": 540694680,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758501428
    },
    {
        "content": "<p>That's a case when you can use only the typeclass for an affine combination space and not the <code>AddTorsor</code> class or the class saying they agree. (Which isn't relevant for doing Euclidean geometry - in the Euclidean case you can freely use all three classes, because using only a subset of them adds no mathematical generality.)</p>",
        "id": 540694788,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758501570
    },
    {
        "content": "<p>In this new design, to have access to a real vector space at any time, I propose defining a single field structure <code>AffineVectorSpace P</code> (or some other name), which has these instances</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AffineVectorSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddTorsor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AffineVectorSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div>\n<p>It's very unfortunate that the <code>AddTorsor</code> cannot be an instance because type class synthesis cannot determine <code>R</code>. So yes, this has the disadvantage or having to add this instance explicitly in the local context.</p>\n<p>You suggest that <code>AffineSubspace</code> will be more awkward to deal with. I don't know if it will, but if so, we should simply not modify its definition, and it should still work fine.</p>\n<p>Indeed we need a type class stating that some <code>AffineSpace</code> instance is compatible with some <code>AddTorsor</code> instance, I hadn't thought of this before. But I'm not sure which instance diamonds you are talking about.</p>",
        "id": 540749712,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758532957
    },
    {
        "content": "<p>There have been various past discussions on this zulip about abstractions of the notion of convexity. Such an algebraic structure should fit into such a formalism.</p>",
        "id": 540849788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1758558239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> do you think a definition like this would make sense? Is <code>Semifield</code> too restrictive?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semifield</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">semiLineMap_zero_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">semiLineMap_symm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"n\">semiLineMap_distrib</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hrt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚â†</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">field_simp</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">semiLineMap</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">field_simp</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>We could also implicitly divide by <code>r + s</code>, so that we only need to require a proof that <code>r + s</code> is nonzero, and then we also don't use division in the definition, which may help to loosed the <code>Semifield</code>. Or we could even have junk values and not take any proof.</p>",
        "id": 540859115,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758561416
    },
    {
        "content": "<p>It's less general I guess</p>",
        "id": 540862668,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758562812
    },
    {
        "content": "<p>but it's not like I have any concrete use cases in mind</p>",
        "id": 540862846,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758562905
    },
    {
        "content": "<p>I don't think <code>ENNReal</code> is a semifield</p>",
        "id": 540862952,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758562942
    },
    {
        "content": "<p>But surely instead of <code>ENNReal</code>, you'd just use <code>NNReal</code>?</p>",
        "id": 540864640,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758563546
    },
    {
        "content": "<p>maybe</p>",
        "id": 540864727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758563578
    },
    {
        "content": "<p>Anything using <code>AffineVectorSpace</code> seems strictly worse for all existing affine and Euclidean geometry uses compared to having independently determined <code>V</code> (note that the group is an <code>outParam</code> for an <code>AddTorsor</code>, meaning that (a) it's implicit in most contexts and (b) there are problems if there are ever two different groups with <code>AddTorsor</code> instances for the same space of points).</p>\n<p>Given <code>s : AffineSubspace R P</code>, <code>s.direction</code> is a <code>Submodule R V</code>, which is clearly desirable so that all the extensive theory of submodules can be applied readily when working with affine subspaces. And there is the obvious instance <code>AddTorsor s.direction s</code> which is also clearly desirable. But <code>AffineVectorSpace s</code> is not the same as <code>s.direction</code> (coerced to a Sort) and in particular is not a submodule of <code>AffineVectorSpace P</code>.</p>\n<p>The diamond for affine combinations is: affine combinations for <code>AddTorsor</code> for a module should be defined something like they are at present, while affine combinations for a module (possibly over a semiring, so no subtraction, so no torsor) look something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.linearCombination#doc\">docs#Finsupp.linearCombination</a> but it's unlikely these could be made defeq in the case of a module as a torsor over itself, so at least one of these constructions of an affine combination space should not be an instance.</p>",
        "id": 540913004,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1758588839
    },
    {
        "content": "<p>I don't like <code>AffineVectorSpace</code> anymore</p>",
        "id": 540913197,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758588948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/540862846\">said</a>:</p>\n<blockquote>\n<p>but it's not like I have any concrete use cases in mind</p>\n</blockquote>\n<p>Not that concrete, but instantiating with <code>R = Int</code> seems vaguely useful</p>",
        "id": 540961286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758617692
    },
    {
        "content": "<p>Is the <code>AffineVectorSpace</code> you now dislike different from Jovan's <code>AffineSpace</code> above?</p>",
        "id": 540961445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758617739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/540749712\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AffineVectorSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AffineSpace</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddTorsor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AffineVectorSpace</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> is referring to the vector space that we would construct from a given <code>AffineSpace</code> (I couldn't come up with a better name)</p>",
        "id": 540968433,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1758619798
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/31984\">#31984</a></p>",
        "id": 558862522,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763869409
    },
    {
        "content": "<p>The difference seems to be that in that PR, defining the ConvexSpace, they only allow the weights to be non-negative. So it wouldn't work as an affine combination space we were discussing here.</p>",
        "id": 559049590,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763992223
    },
    {
        "content": "<p>yes that's correct</p>",
        "id": 559053312,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763993139
    },
    {
        "content": "<p>Maybe I should make a PR generalizing it</p>",
        "id": 559053530,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763993188
    },
    {
        "content": "<p>I think it should get a different name, but the model should be the same</p>",
        "id": 559053711,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1763993225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/559053530\">said</a>:</p>\n<blockquote>\n<p>Maybe I should make a PR generalizing it</p>\n</blockquote>\n<p>How would you do this? I don't think it is straightforward to do so without making it more awkward to use in the convex case.</p>",
        "id": 559056457,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1763993789
    },
    {
        "content": "<p>I think it should be similar to <code>Ideal</code> and <code>Submodule</code>, where we define all these things for <code>Submodule</code> and then <code>Ideal R</code> is just <code>Submodule R R</code> and we define things for <code>Ideal</code> too</p>",
        "id": 559081130,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763998909
    },
    {
        "content": "<p>I'd expect an affine combination space (no restrictions on the signs of weights in combinations) to be fine for convexity in most cases - you simply just use combinations where all weights are nonnegative even if the underlying semiring also includes negative values. The main issue would be that you couldn't then use spans for convex hulls if the semiring includes negative values.</p>\n<p>Note incidentally that there's a design question of how spans / convex hulls / subspaces work over the trivial ring in affine combination spaces / convex combination spaces. <code>AffineSubspace</code> for torsors always has ‚ä• empty as the closure property is always true for an empty carrier set. But if your closure property is for n-way combinations then the empty combination is a thing when 0=1.</p>",
        "id": 560043830,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1764028705
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/560043830\">said</a>:</p>\n<blockquote>\n<p>Note incidentally that there's a design question of how spans / convex hulls / subspaces work over the trivial ring in affine combination spaces / convex combination spaces. <code>AffineSubspace</code> for torsors always has ‚ä• empty as the closure property is always true for an empty carrier set. But if your closure property is for n-way combinations then the empty combination is a thing when 0=1.</p>\n</blockquote>\n<p>Unfolding all the definitions, we get that any affine combination space over the trivial ring is a single point which is equal to the empty combination.</p>",
        "id": 560044091,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764028885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/channel/116395-maths/topic/Affine.20Combination.20Space/near/560043830\">said</a>:</p>\n<blockquote>\n<p>I'd expect an affine combination space (no restrictions on the signs of weights in combinations) to be fine for convexity in most cases - you simply just use combinations where all weights are nonnegative even if the underlying semiring also includes negative values. The main issue would be that you couldn't then use spans for convex hulls if the semiring includes negative values.</p>\n</blockquote>\n<p>I'm saying just take the combination over the nonnegative part of your ring, and then you'll only be able to use nonnegative weights</p>",
        "id": 560044500,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764029084
    }
]