[
    {
        "content": "<p>It seems that I've missed this thread in 2022. I suggest that we redefine <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fderiv\">docs#fderiv</a> in similar terms. What do you think?</p>",
        "id": 359284921,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684368869
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 359287421,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684370124
    },
    {
        "content": "<p>We can redefine <code>has_fderiv_at f f' a</code> as <code>‚àÄ (U ‚àà ùìù 0) (r' ‚â† 0) s, is_vonN_bounded ùïú s ‚Üí ‚àÄ·∂† r : ùïú in ùìù[‚â†] 0, maps_to (Œª x, f (a + x) - f a - f' x) (r ‚Ä¢ s) (r' ‚Ä¢ r ‚Ä¢ U)</code> (not tested, may contain typos)</p>",
        "id": 359288092,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684370440
    },
    {
        "content": "<p>BTW, we can redefine topology on multilinear forms in a similar way.</p>",
        "id": 359290094,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684371471
    },
    {
        "content": "<p>Then many facts will work without norms.</p>",
        "id": 359290167,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684371487
    },
    {
        "content": "<p>(though proofs will be harder)</p>",
        "id": 359290197,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684371505
    },
    {
        "content": "<p>I think we had a similar discussion before. I am generally in favor of this, however there might be subtleties when it comes to higher derivatives. The only reference for something like this I know is Hamilton's 1982 paper on Nash-Moser theory and he uses directional derivatives and I don't know whether his smoothness is the same as your proposed smoothness (which would make mathlib's smooth Fr√©chet manifolds weaker).</p>",
        "id": 359290465,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1684371628
    },
    {
        "content": "<p>I suggest that the following plan (each step is 1 or more PRs):</p>\n<ol>\n<li>Drop <code>has_fderiv_at_filter</code>, leave only <code>has_fderiv_within_at</code> and <code>has_fderiv_at</code> (defined as <code>has_fderiv_within_at ... univ</code>).</li>\n<li>Redefine <code>has_fderiv_within_at</code> for topological vector spaces. Prove equivalence to the old definition, leave all theorems as is.</li>\n<li>Gradually migrate theorems to topological vector spaces.</li>\n</ol>",
        "id": 359291284,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684372190
    },
    {
        "content": "<p>Do you have an application in mind? I have no objection in theory, but I am not sure I see the point yet.</p>",
        "id": 359325631,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684396367
    },
    {
        "content": "<p>I have one; I can't talk about derivatives of matrix functions because to even state the results I have to choose a norm</p>",
        "id": 359326930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396822
    },
    {
        "content": "<p>This <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> and some other finite dimensional spaces.</p>",
        "id": 359326984,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684396850
    },
    {
        "content": "<p>So right now if I wanted to write down how derivatives (by a scalar) distribute across a matrix product, I need to repeat the lemma for every currently-available norm on matrices (I think we have 3 right now via <code>local attribute [instance]</code> and nothing globally)</p>",
        "id": 359327042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684396869
    },
    {
        "content": "<p>Your lemmas should be true for any norm on matrices, so why not write them right away in this generality?</p>",
        "id": 359327700,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684397150
    },
    {
        "content": "<p>What other examples of \"canonical topology, no canonical norm\" do we have?</p>",
        "id": 359328190,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684397300
    },
    {
        "content": "<p>This came up in a discussion with <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> about tensor products of vector bundles. But in that case there is no canonical topology either.</p>",
        "id": 359329167,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684397660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm/near/359327700\">said</a>:</p>\n<blockquote>\n<p>Your lemmas should be true for any norm on matrices, so why not write them right away in this generality?</p>\n</blockquote>\n<p>How do you suggest I state something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">has_deriv_at.matrix_mul</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">X</span> <span class=\"n\">X'</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">Y</span> <span class=\"n\">Y'</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_deriv_at</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">‚¨ù</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"bp\">‚¨ù</span> <span class=\"n\">Y</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"n\">r</span> <span class=\"bp\">‚¨ù</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n</code></pre></div>",
        "id": 359331146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684398342
    },
    {
        "content": "<p>Can you add some typeclasses here? You need some topology somewhere.</p>",
        "id": 359331312,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684398413
    },
    {
        "content": "<p>Sure, here's the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, extracted from <a href=\"https://github.com/eric-wieser/lean-matrix-cookbook/blob/096e48ea7226daf02d62f2d65adb5fe3611a7a0f/src/matrix_cookbook/for_mathlib/analysis/matrix.lean#L32-L41\">lean-matrix-cookbook</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.matrix</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">matrix</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">matrix</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">matrix.normed_add_comm_group</span> <span class=\"n\">matrix.normed_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_deriv_at_matrix</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_deriv_at</span> <span class=\"n\">f</span> <span class=\"n\">f'</span> <span class=\"n\">r</span> <span class=\"bp\">‚Üî</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">has_deriv_at</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"n\">has_deriv_at_pi</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_deriv_at.matrix_mul</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">X</span> <span class=\"n\">X'</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">has_deriv_at</span> <span class=\"n\">Y</span> <span class=\"n\">Y'</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_deriv_at</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">‚¨ù</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">X'</span> <span class=\"bp\">‚¨ù</span> <span class=\"n\">Y</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">X</span> <span class=\"n\">r</span> <span class=\"bp\">‚¨ù</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">has_deriv_at_matrix</span> <span class=\"n\">at</span> <span class=\"bp\">‚ä¢</span> <span class=\"n\">hX</span> <span class=\"n\">hY</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_apply</span><span class=\"o\">,</span> <span class=\"n\">pi.add_apply</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">finset.sum_add_distrib</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">has_deriv_at.sum</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">k</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 359331411,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684398460
    },
    {
        "content": "<p>But I cheated, this is only about <code>matrix.normed_space</code> and not the other norms</p>",
        "id": 359331479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684398482
    },
    {
        "content": "<p>I‚Äôve spent some time a year ago thinking about how to get meaningful differentiability (which really means a good notion of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_o\">docs#is_o</a>) without any norm, specifically for the case of finite dimensional vector spaces where we don‚Äôt want to impose the norm, but I didn‚Äôt think about using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_vonN_bounded\">docs#is_vonN_bounded</a> for that. This is interesting, do you have any reference ? (Or maybe this is well known and I‚Äôm just not aware of it)</p>",
        "id": 359331565,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684398504
    },
    {
        "content": "<p>I can't write <code>[normed_add_comm_group (matrix m n R)] [normed_space R (matrix m n R)]</code> because then I get a nonsense addition on the matrices that might not be elementwise</p>",
        "id": 359331610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684398520
    },
    {
        "content": "<p>In this generality, it's definitely not true for all norms (since norms are not all equivalent as you're  not assuming your field is complete).</p>",
        "id": 359331901,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684398612
    },
    {
        "content": "<p>But I agree I don't see a neat way to write it for all norms even if your field is nice, because <code>normed_add_comm_group</code> can't be expressed with a mixin.</p>",
        "id": 359332103,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684398717
    },
    {
        "content": "<p><del>However, I wouldn't see a way to write it for all topologies either, for the same reason.</del></p>",
        "id": 359332264,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684398759
    },
    {
        "content": "<p>One case I‚Äôve heard about a few weeks ago is when you have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_seminorms\">docs#with_seminorms</a>, then it makes perfect sense to say that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_o\">docs#is_o</a> means \"<code>is_o</code> with respect to each seminorm\" and then I think that agrees with the version Yury gave</p>",
        "id": 359332332,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684398788
    },
    {
        "content": "<p>Scratch that, for topologies we can definitely use mixins.</p>",
        "id": 359332348,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1684398795
    },
    {
        "content": "<p>For matrices that‚Äôs no problem anyway, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.topological_space\">docs#matrix.topological_space</a></p>",
        "id": 359332499,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1684398844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm/near/359331565\">said</a>:</p>\n<blockquote>\n<p>I‚Äôve spent some time a year ago thinking about how to get meaningful differentiability (which really means a good notion of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_o\">docs#is_o</a>) without any norm, specifically for the case of finite dimensional vector spaces where we don‚Äôt want to impose the norm, but I didn‚Äôt think about using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_vonN_bounded\">docs#is_vonN_bounded</a> for that. This is interesting, do you have any reference ? (Or maybe this is well known and I‚Äôm just not aware of it)</p>\n</blockquote>\n<p>I don't know about references. I just made it up.</p>",
        "id": 359334182,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684399456
    },
    {
        "content": "<p>Possibly, there are better ways to generalize it to topological vector spaces - I don't know.</p>",
        "id": 359334283,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684399487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm/near/359332103\">said</a>:</p>\n<blockquote>\n<p>But I agree I don't see a neat way to write it for all norms even if your field is nice, because <code>normed_add_comm_group</code> can't be expressed with a mixin.</p>\n</blockquote>\n<p>I attempted to change it to be a mixin in <a href=\"https://github.com/leanprover-community/mathlib/pull/18462\">#18462</a>, but that's lost to the porting tide now (and wasn't looking promising performance-wise)</p>",
        "id": 359335635,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684399908
    },
    {
        "content": "<p>I've occasionally mused about generalising <code>fderiv</code> in another direction, where we weaken the <code>module</code> structure on the domain so that the axioms <code>smul_add</code> and <code>add_smul</code> are only required to hold for sufficiently small scalars. The motivation is that the circle (or tori) possess such scalar actions so we could speak of smooth functions on them without having to regard them as manifolds.</p>",
        "id": 359337490,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1684400461
    },
    {
        "content": "<p>(I'm not seriously suggesting we actually do this.)</p>",
        "id": 359337539,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1684400479
    },
    {
        "content": "<p>Why is <code>deriv</code> defined from a normed field to a <strong>normed</strong> vector space? For example this <a href=\"https://en.wikipedia.org/wiki/Differentiable_vector%E2%80%93valued_functions_from_Euclidean_space\">wiki article</a> talks about well defined and well behaved derivative from finite dimensional spaces to a general topological vector space. Is this because <code>deriv</code> is defined through <code>fderiv</code>?</p>\n<hr>\n<p><strong>edit</strong>: this was originally the first post in this thread but earlier discussion from a different thread was moved here. Also those two threads got interleaved so it is a bit incoherent right now ...</p>",
        "id": 364340755,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686156742
    },
    {
        "content": "<p>I think there was a recent discussion about generalizing both, but I'm on mobile so I can't find it now.</p>",
        "id": 364350680,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686159116
    },
    {
        "content": "<p>A link to such discussion would be appreciated, I did some searching but I couldn't find any relevant discussions.</p>",
        "id": 364352602,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686159561
    },
    {
        "content": "<p>Maybe <a href=\"#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm/near/359326930\">this thread</a>?</p>",
        "id": 364355924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686160419
    },
    {
        "content": "<p>Probably, we should generalize it but this can't be done before the port is over.</p>",
        "id": 364366939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686163147
    },
    {
        "content": "<p>Waiting for the port to be done makes total sense. I was curious what are the thoughts on this topic as I need the generalization for my project.</p>",
        "id": 364385108,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686168366
    },
    {
        "content": "<p>Since this thread has been linked from somewhere else, I just want to add that the second part of this discussions is not really related to the original topic: unless I‚Äôm missing something obvious, the topology on continuous linear maps does not matter here</p>",
        "id": 364389474,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686169880
    },
    {
        "content": "<p>I initialized the other thread and my motivation for generalizing derivative and differentiability is to allow for isomorphism: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><msup><mi mathvariant=\"double-struck\">R</mi><mn>2</mn></msup><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo><mo>‚âÖ</mo><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C^\\infty(\\mathbb{R}^2, \\mathbb{R}) \\cong C^\\infty(\\mathbb{R}, C^\\infty(\\mathbb{R}, \\mathbb{R})) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚âÖ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">))</span></span></span></span> which requires to define suitable topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C^\\infty(\\mathbb{R}, \\mathbb{R})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>After this is done, I want to do some variational calculus calculations.</p>",
        "id": 364391946,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686170770
    },
    {
        "content": "<p>What topology are you proposing to put on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">R</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C^\\infty(\\R,\\R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span></span></span></span> to make that assertion true?</p>",
        "id": 364392418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686170948
    },
    {
        "content": "<p>The topology of uniform convergence on compact sets of each derivative separately, see <a href=\"https://en.wikipedia.org/wiki/Convenient_vector_space#Main_properties_of_smooth_calculus\">wiki on convenient vector spaces</a>.</p>",
        "id": 364393642,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686171397
    },
    {
        "content": "<p>You can define such topology for any locally convex TVS with some mild completeness condition and you have a general isomoprhism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi>X</mi><mo>√ó</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo>‚âÖ</mo><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi>Z</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">C^\\infty(X\\times Y,  Z) \\cong C^\\infty(X, C^\\infty(Y, Z))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚âÖ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mclose\">))</span></span></span></span></p>",
        "id": 364394020,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686171535
    },
    {
        "content": "<p>Oh nice! I could see that it would have to be subtle but I didn't know the answer.</p>",
        "id": 364394623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686171727
    },
    {
        "content": "<p>It is kind of messed up because you end up with functions that are differentiable but not continuous.</p>",
        "id": 364394763,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686171785
    },
    {
        "content": "<p>What are your applications?</p>",
        "id": 364394923,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686171844
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 364394994,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686171875
    },
    {
        "content": "<p>Let me move the second part of this thread to the new one.</p>",
        "id": 364395071,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686171912
    },
    {
        "content": "<p>I'm working on symbolic and automatic differentiation for SciLean and if I hope to have it verified I need this generalization of derivative.</p>",
        "id": 364395115,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686171931
    },
    {
        "content": "<p>40 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm\">#maths &gt; Topology on continuous_maps without a norm</a> by <span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span>.</p>",
        "id": 364395175,
        "sender_full_name": "Notification Bot",
        "timestamp": 1686171957
    },
    {
        "content": "<p>Now the history looks a bit strange ;)</p>",
        "id": 364395492,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686172049
    },
    {
        "content": "<p>ohh well <span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span> I added a small explanation to my first post at least.</p>",
        "id": 364395797,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686172194
    },
    {
        "content": "<p>To get back to your original question, I think the reason we don't have this easy generalization (talking about <code>deriv</code> here, not <code>fderiv</code>) is indeed because we tend to see <code>deriv</code> as the one-dimensional Fr√©chet derivative instead of the one-dimensional G√¢teaux d√©rivative. Of course they give the same notion, but because we want the APIs of <code>fderiv</code> and <code>deriv</code> to be similar we probably miss some easy generalizations of <code>deriv</code>.</p>",
        "id": 364400543,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686174146
    },
    {
        "content": "<p>But we can generalize <code>fderiv</code> too (see above)</p>",
        "id": 364408017,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686177591
    },
    {
        "content": "<p>So, the answer is: at the time derivatives were added to <code>mathlib</code> (~4 years ago), nobody cared about this generality.</p>",
        "id": 364408159,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686177644
    },
    {
        "content": "<p>I agree, my point (and I think Tomas' original message too) was about the fact that the generalization to TVS of <code>deriv</code> is way easier: you can just take the usual limit of <code>(f (x + h) - f x) / h</code> and you don't need any more machinery. But if we make the generalization you suggest (and check that it is indeed a strict generalization of this) then that's even better.</p>",
        "id": 364408937,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686178040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> I'm not familiar with von Neumann bounded sets. Do you know the relationship between your suggested generalization and differentiability between convenient vector spaces?</p>",
        "id": 364409036,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686178085
    },
    {
        "content": "<p>What definition are you talking about? I don't know any references on the subject. I made up the definition above in some conversation.</p>",
        "id": 364410072,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686178611
    },
    {
        "content": "<p>Wikipedia says that it is possible to generalize derivatives to TVS \"in muliple ways\" but doesn't give references.</p>",
        "id": 364410164,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686178659
    },
    {
        "content": "<p>I think that my definition should be equivalent to <a href=\"https://en.wikipedia.org/wiki/Fr%C3%A9chet_derivative#Generalization_to_topological_vector_spaces\">https://en.wikipedia.org/wiki/Fr%C3%A9chet_derivative#Generalization_to_topological_vector_spaces</a></p>",
        "id": 364410952,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179070
    },
    {
        "content": "<p>UPD: my definition is a bit different but should be equivalent for \"nice\" TVS domains (probably, locally bounded).</p>",
        "id": 364411280,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179272
    },
    {
        "content": "<p>I guess, we should use the one from Wikipedia instead. UPD: but we need to generalize it to any normed field instead of real numbers.</p>",
        "id": 364411446,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179363
    },
    {
        "content": "<p>Should we add a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsLittleO#doc\">docs4#Asymptotics.IsLittleO</a> for TVS?</p>",
        "id": 364411662,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179485
    },
    {
        "content": "<p>We can't generalize this definition becase it doesn't require a vector space structure; some properties work for a normed group.</p>",
        "id": 364411777,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179532
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lf_dRC-2zqtSC8P9AnpUmVJa/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/lf_dRC-2zqtSC8P9AnpUmVJa/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/lf_dRC-2zqtSC8P9AnpUmVJa/image.png\"></a></div><p><span aria-label=\"angry\" class=\"emoji emoji-1f620\" role=\"img\" title=\"angry\">:angry:</span></p>",
        "id": 364411795,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686179539
    },
    {
        "content": "<p>What would the TVS version look like?</p>",
        "id": 364411926,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686179627
    },
    {
        "content": "<p>We need special support for <code>irreducible_def</code> in doc-gen4</p>",
        "id": 364411944,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/364411926\">said</a>:</p>\n<blockquote>\n<p>What would the TVS version look like?</p>\n</blockquote>\n<p>Probably it would look the same</p>",
        "id": 364412004,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686179664
    },
    {
        "content": "<p>I meant, what would the lean definition look like, not the docs!</p>",
        "id": 364412021,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686179690
    },
    {
        "content": "<p>/me is thinking</p>",
        "id": 364412137,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686179763
    },
    {
        "content": "<p>Not tested:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Asymptotics.Asymptotics</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Topology</span> <span class=\"n\">Pointwise</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsLittleOTVS</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">‚àÄ</span> <span class=\"n\">V</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">‚àÉ</span> <span class=\"o\">(</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span><span class=\"o\">),</span> <span class=\"n\">Tendsto</span> <span class=\"n\">œÜ</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">‚àß</span>\n      <span class=\"bp\">‚àÄ·∂†</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span><span class=\"o\">,</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">a</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚â§</span> <span class=\"n\">œÜ</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">b</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">b</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">V</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">a</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">U</span>\n</code></pre></div>",
        "id": 364413320,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686180567
    },
    {
        "content": "<p>Trying to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">isLittleOTVS_iff_isLittleO</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsLittleOTVS</span> <span class=\"bp\">ùïú</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 364413666,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686180778
    },
    {
        "content": "<p>This <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> definition is wrong. Thinking.</p>",
        "id": 364414318,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686181262
    },
    {
        "content": "<p>You can always take <code>U = univ</code></p>",
        "id": 364414345,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686181279
    },
    {
        "content": "<p>(no, you can almost always take <code>a = 0</code> to fail the definition)</p>",
        "id": 364414368,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686181319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/364410072\">said</a>:</p>\n<blockquote>\n<p>What definition are you talking about? I don't know any references on the subject. I made up the definition above in some conversation.</p>\n</blockquote>\n<p>I would say that <code>f : E ‚Üí F</code> is differentiable at <code>x</code> if for every curve <code>Œ≥ : ùïú ‚Üí E</code> differentiable at <code>0</code> and <code>Œ≥ 0 = x</code> the curve <code>f ‚àò Œ≥ : ùïú ‚Üí F</code> is differentiable at <code>0</code>.</p>\n<p>Is that reasonable generalization? If you require smoothness in the definition then based on <a href=\"https://en.wikipedia.org/wiki/Convenient_vector_space#Main_properties_of_smooth_calculus\">wiki</a> this should recover any reasonable definition of smoothness for Frechet spaces.</p>",
        "id": 364415524,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686182166
    },
    {
        "content": "<p>This is not a generalization of Frechet derivative.</p>",
        "id": 364416427,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686182786
    },
    {
        "content": "<p>For a normed vector space, it is not equivalent to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAt#doc\">docs4#HasFDerivAt</a></p>",
        "id": 364416517,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686182864
    },
    {
        "content": "<p>I see, then I do not understand these things properly. Why is not equivalent? Is there a counter example?</p>",
        "id": 364416800,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686183042
    },
    {
        "content": "<p>The problem is with \"if you require smoothness\"</p>",
        "id": 364417337,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686183435
    },
    {
        "content": "<p>First of all, your definition does not involve any continuous linear map.</p>",
        "id": 364417362,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686183457
    },
    {
        "content": "<p>I think that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">f(x, y)=\\frac{x^3}{x^2+y^2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.499em;vertical-align:-0.4811em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0179em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7463em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8913em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4811em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> is differentiable at zero in the sense of curves but it is not Frechet differentiable.</p>",
        "id": 364417731,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686183698
    },
    {
        "content": "<p>Ahh right, it is mentioned here <a href=\"https://ncatlab.org/nlab/show/Boman%27s+theorem\">https://ncatlab.org/nlab/show/Boman%27s+theorem</a></p>\n<p>My final suggestion would be:<br>\n<code>f : E ‚Üí F</code> is differentiable at <code>x</code> if for every <code>Œ≥ : ùïú√óùïú ‚Üí E</code> differentiable at 0 and Œ≥ 0 = x the <code>f ‚àò Œ≥ : ùïú√óùïú ‚Üí F</code> is differentiable at 0.</p>\n<p>but I really do not understand these things in depth, so I should stop suggesting anything further :)</p>",
        "id": 364418226,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686184037
    },
    {
        "content": "<p>I proved that the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Asymptotics.Asymptotics</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecificLimits.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Topology</span> <span class=\"n\">Pointwise</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">Metric</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">TVS</span>\n\n<span class=\"kd\">variable</span>  <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsLittleOTVS</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">V</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">‚Üí</span>\n    <span class=\"bp\">‚àÄ·∂†</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">b</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">V</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span><span class=\"o\">,</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">a</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚â§</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">b</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚àß</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">a</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">U</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">TVS</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isLittleOTVS_iff_isLittleO</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsLittleOTVS</span> <span class=\"bp\">ùïú</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">f</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">_</span>\n</code></pre></div>\n<p>The proof is in branch4#YK-isO-TVS</p>",
        "id": 364444748,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686201795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> We will definitely need to have different higher-dimensional-domain derivatives at some point (or rather of differentiability I guess, since when they are defined they all agree) anyway, the key point being that <code>fderiv</code> should keep being the usual one in the case of normed spaces. That said, I would guess and hope that we can stay with only one version in the case of one dimensional domain.</p>",
        "id": 364534081,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686225029
    },
    {
        "content": "<p>One thing I do not understand is what is the motivation to have Frechet derivative as the base definition? If a function has Frechet derivative then it has Gateaux derivative. Why not have Gateaux derivative as the basic definition and have theorem that on nice spaces and under nice differentiability conditions it is Frechet derivative.</p>",
        "id": 364541088,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686226570
    },
    {
        "content": "<p>You want a notion that has nice properties, in the sense that it makes it possible to prove nice theorems. For instance the local inverse theorem, which says that if the derivative is invertible then the map is locally invertible. Or the implicit function theorem. These are true for the Fr√©chet derivative, but not for the Gateaux derivative. In a sense, Gateaux derivative is a nice gadget, but not useful to prove theorems. While Fr√©chet derivative is the fundamental notion.</p>",
        "id": 364542784,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686226935
    },
    {
        "content": "<p>Wikipedia says:</p>\n<blockquote>\n<p>If F is Fr√©chet differentiable, then it is also Gateaux differentiable, and its Fr√©chet and Gateaux derivatives agree</p>\n</blockquote>\n<p>If this is actually true in general and not just for the cases wikipedia cares about, then presumably the answer to \"Why not have Gateaux derivative as the basic definition\" is \"it's convenient to have the derivative <code>fderiv</code> bundled as a multilinear map\"?</p>",
        "id": 364547065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686227877
    },
    {
        "content": "<p>You could have a definition of a derivative as \"if there is a continuous linear map which gives the directional derivative in every direction, then use it, and otherwise take <code>0</code>\". This would be the Gateaux derivative in mathlib conventions. And it would be essentially useless because it doesn't have nice properties without further assumptions which amount to saying that the function is in fact Fr√©chet-differentiable. For instance, a function which is Gateaux-differentiable at a point doesn't have to be continuous there. Or, the composition of two Gateaux-differentiable maps is not in general Gateaux-differentiable. It's just a bad notion from the mathematical point of view.</p>",
        "id": 364550766,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686228564
    },
    {
        "content": "<p>Inverse theorem needs strict differentiability, not only Fr√©chet.</p>",
        "id": 364557484,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686229902
    },
    {
        "content": "<p>You can define Gateaux derivative using Fr√©chet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">HasDirDerivAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasDerivAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚àò</span> <span class=\"n\">lineMap</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">f'</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dirDeriv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">deriv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚àò</span> <span class=\"n\">lineMap</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">GateauxDifferentiableAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">DifferentiableAt</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">‚àò</span> <span class=\"n\">lineMap</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 364558285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686230057
    },
    {
        "content": "<p>I think the only thing I'm suggesting is to have <code>deriv</code> and it's bundled version <code>fderiv</code> as general as possible and then of course have theorems about them with different notions of differentiability. </p>\n<p>I would like to formalize Convenient Vector spaces, define a new notion of differentiability and reuse mathlib's <code>deriv</code> but I can't do that as it is restricted to normed spaces.</p>",
        "id": 364561297,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686230694
    },
    {
        "content": "<p>This is a very niche and exotic notion. Are you sure you really need that for your formalization, instead of sticking with more mainstream and established mathematics?</p>",
        "id": 364563493,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1686231154
    },
    {
        "content": "<p>I want to formalize computations in variational calculus, in particular calculations commonly done by physicists in mechanics or thermodynamics.</p>\n<p>Using lebesgue/sobolev spaces is annoying as you have to deal with integrability which is completely unrelated to why you would do those computations.</p>\n<p>I really want to work with smooth functions, but they do not behave well w.r.t. standard notions of vector spaces.</p>\n<p>That is why I want to use convenient vector spaces, I get smooth functions and cartesian closed category which simplifies lot of arguments.</p>",
        "id": 364581914,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1686234554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> Once we generalize Fr√©chet derivatives, you can define Gateaux derivatives as above, if you need them.</p>",
        "id": 364592820,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686236491
    },
    {
        "content": "<p>What do we need to assume about topology on the (co)domain to have <code>IsLittleOTVS.add</code>? The problem is that we can choose different <code>a</code>s.</p>",
        "id": 364611247,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686239967
    },
    {
        "content": "<p>If <code>ùïú</code> were <code>‚Ñù</code> there would be no problem right? Because then if you get <code>a‚ÇÅ</code> and <code>a‚ÇÇ</code> for the individuals, you can take <code>a := ‚à•a‚ÇÅ‚à• + ‚à•a‚ÇÇ‚à•</code> for the sum. Just trying to make sure I understand the issue. (In my head the problem isn't that you have two <code>a</code>s, it's that you don't know how to make them \"point in the same direction\")</p>",
        "id": 364615661,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686240929
    },
    {
        "content": "<p>Yes.</p>",
        "id": 364628758,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686244061
    },
    {
        "content": "<p>Probably, we should require that nhds of zero has a basis of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Balanced#doc\">docs4#Balanced</a> sets.</p>",
        "id": 364630622,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686244536
    },
    {
        "content": "<p>It's still not clear how to pick <code>a</code> though.</p>",
        "id": 364631933,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686244867
    },
    {
        "content": "<p>Because you could have say <code>a‚ÇÅ = (1 : ‚ÑÇ)</code> and <code>a‚ÇÇ = Complex.I</code>.</p>",
        "id": 364632200,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686244937
    },
    {
        "content": "<p>I think that <code>Balanced</code> should fix this but I don't have time now. Maybe, tomorrow.</p>",
        "id": 364669071,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686255184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/364630622\">said</a>:</p>\n<blockquote>\n<p>Probably, we should require that nhds of zero has a basis of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Balanced#doc\">docs4#Balanced</a> sets.</p>\n</blockquote>\n<p>This is always true, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nhds_basis_balanced#doc\">docs4#nhds_basis_balanced</a></p>",
        "id": 364692024,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686263962
    },
    {
        "content": "<p>I haven't spent enough times thinking about this to be sure about what I say, but I think that another reasonable definition would be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Asymptotics.Asymptotics</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecificLimits.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Convex.Gauge</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Topology</span> <span class=\"n\">Pointwise</span> <span class=\"n\">Asymptotics</span> <span class=\"n\">Metric</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">TVS</span>\n\n<span class=\"kd\">variable</span>  <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- I would argue this should be the general replacement for `gauge`, but I could be wrong</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">gauge'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span> <span class=\"o\">:=</span> <span class=\"n\">sInf</span> <span class=\"o\">((</span><span class=\"bp\">‚Üë‚Äñ¬∑‚Äñ‚Çä</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">k</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">s</span><span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">IsLittleOTVS</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">V</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÄ·∂†</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">gauge'</span> <span class=\"bp\">ùïú</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">‚â§</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">gauge'</span> <span class=\"bp\">ùïú</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I am pretty confident that this gives the usual version in normed spaces, but not sure that it's the same notion as Wikipedia's or Yury's. The reason this feels natural is that, if topologies on E and F are generated by seminorms, I think you get a nice-looking characterization, but it's getting too late to even state it...</p>",
        "id": 364699204,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686267999
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge#doc\">docs4#gauge</a> and the whole file around it. In particular, the gauge (or gauge‚Äô) of the unit ball of a normed space is exactly the norm</p>",
        "id": 364699498,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686268189
    },
    {
        "content": "<ol>\n<li>I think that your <code>gauge'</code> should be added as <code>egauge</code> to the library, similar to <code>edist</code>. <code>gauge</code> should be redefined as <code>(egauge _ _).toReal</code>.</li>\n<li>I think that our definitions are equivalent. I didn't use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/gauge\">docs#gauge</a> in mine because it's not <code>egauge</code>.</li>\n</ol>",
        "id": 364702350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686270038
    },
    {
        "content": "<p>So you lose the fact that the gauge returns a scalar?</p>",
        "id": 364731835,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1686287444
    },
    {
        "content": "<p>In the p-adic theory Frechet spaces are topological vector spaces whose topology is defined by a family of seminorms and they play a big role in the p-adic Langlands program. I'm assuming this is material that we stole from the real analysts...</p>",
        "id": 364743627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686292187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/364731835\">said</a>:</p>\n<blockquote>\n<p>So you lose the fact that the gauge returns a scalar?</p>\n</blockquote>\n<p>Currently, <code>gauge</code> is only defined for a real vector space.</p>",
        "id": 364847343,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686315367
    },
    {
        "content": "<p>I‚Äôm on mobile right now so I won‚Äôt develop all of my thoughts, but there are two distinct deviations from <code>gauge</code> at play.</p>\n<ul>\n<li>The first one is indeed just a matter of taking values in <code>ENNReal</code> instead of <code>Real</code>. I would say we should definitely keep both</li>\n<li>The other one is that, even where both the infimum is well defined, it‚Äôs not clear that the two agree for a non-symmetric set. On the other hand, I see no way to generalize <code>gauge</code> to arbitrary field that would preserve this property. This reminds me of the \"real polar\" VS \"absolute polar\" design choice, and iirc we chose the latter precisely because it works over other fields</li>\n</ul>",
        "id": 364852467,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686316331
    },
    {
        "content": "<p>Hence I have a question for people more familiar with convex analysis: do you care about the value of the gauge for non absorbent and balanced sets ?</p>",
        "id": 364852823,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1686316406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110401\">@Brendan Seamas Murphy</span> does to construct a homeomorphism with a ball.</p>",
        "id": 364864483,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686318870
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12852\">#12852</a> is a step towards derivatives for functions between TVS</p>",
        "id": 439081877,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715885500
    },
    {
        "content": "<p>Just to check, are there any open PRs currently on the path to this?</p>",
        "id": 473445628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727613700
    },
    {
        "content": "<p>There is a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/9675\">#9675</a> which defines <code>IsLittleOTVS</code> and proves both equivalences we care about (to <code>IsLittleO</code> for normed spaces and to \"tends to zero\" for domain = field).</p>",
        "id": 473949672,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727762342
    },
    {
        "content": "<p>The main issue with this PR is it has low priority for me. If you want to take over it, then you're welcome.</p>",
        "id": 473949747,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727762388
    },
    {
        "content": "<p>Once we have it, we can define <code>HasFDerivAtFilter</code> for a topological vector space, but prove everything for normed spaces.</p>",
        "id": 473949924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727762425
    },
    {
        "content": "<p>Of course, later we may decide to generalize some proofs to TVS.</p>",
        "id": 473949997,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727762445
    },
    {
        "content": "<p>Also, <a href=\"https://github.com/leanprover-community/mathlib4/pull/15217\">#15217</a> is a bit related (it's used in WIP <a href=\"https://github.com/leanprover-community/mathlib4/pull/13648\">#13648</a> which generalized <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.compSL#doc\">docs#ContinuousLinearMap.compSL</a> to TVS, not 100% sure that we'll need it, but seems relevant).</p>",
        "id": 473950746,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727762621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/473949747\">said</a>:</p>\n<blockquote>\n<p>The main issue with this PR is it has low priority for me. If you want to take over it, then you're welcome.</p>\n</blockquote>\n<p>I've fixed the conflicts and new lint warnings, but it seems there is a gap in the proof</p>",
        "id": 474003852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727778725
    },
    {
        "content": "<p>I'll fix it today. AFAIR, I wrote the proof w/o <code>egauge</code>, then partially migrated to <code>egauge</code>.</p>",
        "id": 474040674,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727789926
    },
    {
        "content": "<p>Fixed, pushed</p>",
        "id": 474042884,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1727790518
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9675\">#9675</a> is ready for review!</p>",
        "id": 477843932,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729377634
    },
    {
        "content": "<p>The details are slightly above my paygrade, but this seems clearly useful for generalizing <code>HasDerivAt</code> etc. Does anyone else more qualified (<span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>, <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span>?) want to review, or should we just put this in?</p>",
        "id": 479791761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730340026
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/19104\">#19104</a> is the next piece towards generalizing the definitions</p>",
        "id": 482681484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731698951
    },
    {
        "content": "<p>And now the very trivial <a href=\"https://github.com/leanprover-community/mathlib4/pull/19114\">#19114</a></p>",
        "id": 482704566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731709613
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/19108\">#19108</a> is the main change, <del>though bizarrely this fails because the elaborator now thinks it has to find <code>NormedAddCommGroup (List ùî∏)</code></del></p>",
        "id": 482705911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731710364
    },
    {
        "content": "<p>Any more thoughts on <a href=\"https://github.com/leanprover-community/mathlib4/pull/19108\">#19108</a>?</p>",
        "id": 489850219,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734560213
    },
    {
        "content": "<p>My thoughts are \"golly, lots of files are now slower\"</p>",
        "id": 490489971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734948664
    },
    {
        "content": "<p>Yes, this is really worrying. Do we know how much time this actually represents? Are those big files?</p>",
        "id": 490492876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1734949770
    },
    {
        "content": "<p>If you look at the <a href=\"https://speed.lean-lang.org/mathlib4/compare/adc89be7-8c79-4ecc-8572-8127ae0f5ea3/to/c933702c-c70b-4bca-857d-8a0c98db0ef7\">bench results</a> (unfortunately the bench summary bot is dead now), you see that build is 0.359% slower, which is equivalent to adding 20.6 files or 6k lines to mathlib. Lint is 0.394% slower but only costs ~5% instructions compared to build.</p>",
        "id": 490496983,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734951325
    },
    {
        "content": "<p>I see that Mathlib.Analysis.Calculus.Deriv.Prod got 102% slower though. Probably worth investigating ...</p>",
        "id": 490497470,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734951512
    },
    {
        "content": "<p>By wall clock, the total build is 0.6% or 6s slower, where the current build time is 17 minutes and 15 seconds</p>",
        "id": 490504076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734954237
    },
    {
        "content": "<p>I investigated the file with the largest absolute slowdown using the firefox profiler; my takeaway is that statements like <code>HasDerivAt f f'</code> take longer to elaborate because before the process was:</p>\n<ul>\n<li>I need <code>NormedAddCommGroup F</code></li>\n<li>Oh, it's in the context</li>\n</ul>\n<p>and now its:</p>\n<ul>\n<li>I need <code>AddCommGroup F</code></li>\n<li>I will do a typeclass search</li>\n<li>Goose chasing ensues</li>\n<li>Oh, it's <code>NormedAddCommGroup.toAddCommGroup</code></li>\n</ul>\n<p>and this happens for every single reference to these definitions.</p>",
        "id": 490504962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734954604
    },
    {
        "content": "<p>I see! And we definitely don't want to increase the priority of <code>NormedAddCommGroup.toAddCommGroup</code> because 99% of the time this is a disastrous thing to try (leading us on a wild goose chase) and the right answer is probably <code>Ring.toAddCommGroup</code>.</p>",
        "id": 490505584,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734954866
    },
    {
        "content": "<p>A reasonable stance to hold would be \"pick any priorities you  like if mathlib becomes faster as a result\" but this of course has unpredictable impact on code that hasn't been written yet</p>",
        "id": 490505704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734954921
    },
    {
        "content": "<p>I think the performance hit for <code>Prod</code> specfically can be greatly reduced in future by generalizing the lemmas to also not need <code>NormedAddCommGroup</code> at all</p>",
        "id": 490505865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734954977
    },
    {
        "content": "<p>But this a) is a massive scope creep, and b) probably just shifts the performance drop to the callers, where the game can maybe be repeated in exchange for even further scope creep</p>",
        "id": 490505995,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734955031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/490489971\">said</a>:</p>\n<blockquote>\n<p>golly, lots of files are now slower\"</p>\n</blockquote>\n<p>Perhaps also worth considering that the push for file splits / the overall growth of mathlib is going to mean that performance issues increasingly impact \"lots\" of files</p>",
        "id": 490507584,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734955703
    },
    {
        "content": "<p>Maybe refreshing the <code>NormedAddCommGroup.toAddCommGroup</code> instance locally would help. I've noticed that once you import Nat.card etc. into the algebraic hierarchy (e.g. in Ideal/Quotient/Operations), the trace for synthesizing CommRing.toRing becomes this:</p>\n<blockquote>\n<p>[Meta.synthInstance] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> Ring R ‚ñº<br>\n  [] new goal Ring R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @StrictOrderedRing.toRing to Ring R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @LinearOrderedRing.toStrictOrderedRing to StrictOrderedRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @LinearOrderedCommRing.toLinearOrderedRing to LinearOrderedRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @LinearOrderedField.toLinearOrderedCommRing to LinearOrderedCommRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @StrictOrderedCommRing.toStrictOrderedRing to StrictOrderedRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @LinearOrderedCommRing.toStrictOrderedCommRing to StrictOrderedCommRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @OrderedRing.toRing to Ring R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @OrderedCommRing.toOrderedRing to OrderedRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @StrictOrderedCommRing.toOrderedCommRing to OrderedCommRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @StrictOrderedRing.toOrderedRing to OrderedRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @DivisionRing.toRing to Ring R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @Field.toDivisionRing to DivisionRing R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @LinearOrderedField.toField to Field R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply @CommRing.toRing to Ring R ‚ñ∂<br>\n  [] <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> apply inst‚úù¬π to CommRing R ‚ñ∂<br>\n  [resume] propagating CommRing R to subgoal CommRing R of Ring R ‚ñ∂<br>\n  [] result CommRing.toRing </p>\n</blockquote>\n<p>However, refreshing the CommRing.toRing instance has a mixed effect: it makes some decls in the file faster and some slower.</p>",
        "id": 490546237,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734971357
    },
    {
        "content": "<p>As you may well know, unfolding the <code>new goal Ring R ‚ñ∂</code> line in your trace shows the list of instances which Lean is about to apply in reverse order in order to try and solve <code>Ring R</code>. The list is ordered by priority, with things of equal priority being ordered by when Lean found them, so in particular out of all of the things with default priority, it tries the one it learnt last, first.</p>",
        "id": 490548872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734972330
    },
    {
        "content": "<p>I'll use this as an opportunity to suggest people upvote <a href=\"https://github.com/leanprover/lean4/pull/6389\">lean4#6389</a>, since without that the infoview doesn't reveal that <code>LinearOrderedField.toField</code> is a subgoal generated by <code>DivisionRing.toRing</code></p>",
        "id": 490549371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734972548
    },
    {
        "content": "<p>(I noticed that this had changed in the infoview, and just assumed that it was intentional because I barely ever look at the command line output)</p>",
        "id": 490549851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734972731
    },
    {
        "content": "<blockquote>\n<p>so in particular out of all of the things with default priority, it tries the one it learnt last, first.</p>\n</blockquote>\n<p>Yes I'm aware, and by \"refreshing\" I mean just reiterate an existing instance again to ensure it's fresh in Lean's memory (as if it just learnt it).</p>",
        "id": 490558232,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734976303
    },
    {
        "content": "<p>I also tried to lower the priority of <code>StrictOrderedRing.toRing</code> etc. <a href=\"https://github.com/leanprover-community/mathlib4/pull/20185/files\">here</a> but then something in Mathlib/Tactic/Positivity/Core.lean <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/12457513719/job/34772138881?pr=20185\">times out</a>.</p>",
        "id": 490558656,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734976475
    },
    {
        "content": "<p>Yes it seems to me that the moment you start globally goofing around, you break random unrelated files. One hack might be to locally fudge priorities in the files which are currently slower?</p>",
        "id": 490567781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734980470
    },
    {
        "content": "<p>This is likely related to the order+algebra type class problem that I was trying to mitigate in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12778\">#12778</a> ...</p>",
        "id": 490567879,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1734980521
    },
    {
        "content": "<p>Yes, I guess this is the related norm+algebra typeclass problem :-/</p>",
        "id": 490568780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734980925
    },
    {
        "content": "<p>The norm+algebra one is arguably worse because we inherited a weird mix of new- and old- style classes from Lean 3</p>",
        "id": 490569102,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734981064
    },
    {
        "content": "<p>But I'd rather that we not gate the titular generalization in <a href=\"https://github.com/leanprover-community/mathlib4/pull/19108\">#19108</a> that costs a 6s global slow down on a multi-month refactor!</p>",
        "id": 490569295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734981110
    },
    {
        "content": "<p>BTW, we use very different approaches to topological groups and normed groups. For topological groups, it's <code>[AddCommGroup G] [TopologicalGroup G]</code>, while normed groups are bundled.</p>",
        "id": 490572656,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734982692
    },
    {
        "content": "<p>Are pros and cons of these approaches described somewhere?</p>",
        "id": 490572693,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734982715
    },
    {
        "content": "<p>Also, we use <code>NormedSpace K E</code>, if <code>K</code> is a field but module+mixins in case <code>K</code> is a normed (division) ring.</p>",
        "id": 490572764,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734982761
    },
    {
        "content": "<p>Yes, I think that part of the library deserves some technical decisions to be re-evaluated</p>",
        "id": 490572876,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1734982808
    },
    {
        "content": "<p>There was a relevant refactor <a href=\"https://github.com/leanprover-community/mathlib/pull/18462\">!3#18462</a>. But it was abandoned for porting.</p>",
        "id": 490579158,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1734985876
    },
    {
        "content": "<p>I'm trying to make some sense of the slowdowns. The first thing to say is that this is nothing like the algebra slowdowns we've seen in the past, where Module \\u A B is incredibly slow and you have to bump up max heartbeats to 400,000. These \"30% slower files\" are still compiling in just a few seconds, it's just that apparently they were compiling in one or two fewer seconds before. Having looked at a random sample of these files I am now far less concerned about merging this PR. </p>\n<p>One thing I noticed when experimenting is that whilst it's difficult to put your finger on what is causing the slowdowns (everything is just a bit slower), a random typeclass instance trace in one file has this on master</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.000128</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">üí•Ô∏è</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">340822</span>\n</code></pre></div>\n<p>and this (for the same search) on the branch</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mf\">0.000128</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">üí•Ô∏è</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">420469</span>\n</code></pre></div>\n<p>So (looking at the numbers) Lean is is using 25% more metavariables in the branch. I have no idea if this is significant. But what I do know is that these huge percentage increases seem to be completely insignificant in terms of wall clock time so, as I said, I'm very happy to merge. Are there any dissenting voices?</p>",
        "id": 490582586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734987507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/490492876\">said</a>:</p>\n<blockquote>\n<p>Yes, this is really worrying. Do we know how much time this actually represents? Are those big files?</p>\n</blockquote>\n<p>These are fast files and they're still fast after this PR. There seems to be little to worry about here.</p>",
        "id": 490583105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734987765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/490579158\">said</a>:</p>\n<blockquote>\n<p>There was a relevant refactor <a href=\"https://github.com/leanprover-community/mathlib/pull/18462\">!3#18462</a>. But it was abandoned for porting.</p>\n</blockquote>\n<p>What's known about pros and cons of each approach?</p>",
        "id": 490599172,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1734995727
    },
    {
        "content": "<p>The slowdown from <a href=\"https://github.com/leanprover-community/mathlib4/pull/19046\">#19046</a> and my <a href=\"https://github.com/leanprover-community/mathlib4/pull/17930\">#17930</a> are of a similar order (several seconds).</p>\n<p>Any one knows why lint uses ~5% instructions as build but ~1/3 wall-clock time? Less parallelization?</p>",
        "id": 490604802,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1734998791
    },
    {
        "content": "<p>I think lint has basically no parallelization?</p>",
        "id": 490605042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734998936
    },
    {
        "content": "<p>Why linter can't run itself on all defs/theorems in parallel?</p>",
        "id": 490621342,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735008860
    },
    {
        "content": "<p>Is it \"because nobody added this functionality\" or there are some obstacles?</p>",
        "id": 490621401,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735008906
    },
    {
        "content": "<p>I think that if <a href=\"https://github.com/leanprover-community/mathlib4/pull/17930\">#17930</a> now has a slowdown in the range of several seconds, then that is a very acceptable price to pay for generalizing a bunch of stuff to two-sided ideals.</p>",
        "id": 490634055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1735018788
    },
    {
        "content": "<p>Thanks! Apparently the slowdown from <a href=\"https://github.com/leanprover-community/mathlib4/pull/17930\">#17930</a> is 6.562s (in this run), a bit higher than 5.861s for Eric's <a href=\"https://github.com/leanprover-community/mathlib4/pull/19108\">#19108</a>, even though in terms of instructions it's 0.178% vs. 0.359%. I guess parallelization and fluctuation are playing a role here.<br>\n<a href=\"/user_uploads/3121/PG1emtG9HtxL5fD8Hpv5B6Ho/image.png\">image.png</a><br>\n<a href=\"/user_uploads/3121/qBFsEdGb0pilzm_qFZ6lDrHo/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PG1emtG9HtxL5fD8Hpv5B6Ho/image.png\" title=\"image.png\"><img data-original-dimensions=\"1267x50\" src=\"/user_uploads/thumbnail/3121/PG1emtG9HtxL5fD8Hpv5B6Ho/image.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/qBFsEdGb0pilzm_qFZ6lDrHo/image.png\" title=\"image.png\"><img data-original-dimensions=\"1268x48\" src=\"/user_uploads/thumbnail/3121/qBFsEdGb0pilzm_qFZ6lDrHo/image.png/840x560.webp\"></a></div>",
        "id": 490674452,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1735045390
    },
    {
        "content": "<p>On the topic of the original thread, <a href=\"https://github.com/leanprover-community/mathlib4/pull/20220\">#20220</a> (edit: now depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/20305\">#20305</a>) is a step towards generalizing more results to TVSs</p>",
        "id": 490680327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735049219
    },
    {
        "content": "<p>Beyond that, I think the key missing piece is <code>IsLittleOTVS.add</code>, which I think will require something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- probably needs `Convex _ s` and `Absorbent _ s`</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">egauge_add_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">egauge</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">egauge</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">egauge</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=gauge_add_le#doc\">docs#gauge_add_le</a>. From there, I can prove (in <a href=\"https://github.com/leanprover-community/mathlib4/pull/20250\">#20250</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">IsLittleOTVS</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LocallyConvexSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">TopologicalAddGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LocallyConvexSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hf‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLittleOTVS</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLittleOTVS</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsLittleOTVS</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>though having to assume that <code>E</code> is both a <code>ùïú</code>-vector space and an <code>‚Ñù</code>-vector space is a little annoying</p>",
        "id": 490823754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735177126
    },
    {
        "content": "<p>We definitely want <code>HasDerivAt.add</code> to work for fields that aren't <code>RCLike</code>.</p>",
        "id": 490829529,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1735183220
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/34127\">#34127</a> generalizes most of the theory about <code>tangentConeAt</code> and <code>UniqueDiffOn</code> to topological vector spaces, changing the definition to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">TangentConeAt</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The set of all tangent directions to the set `s` at the point `x`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tangentConeAt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ClusterPt</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">‚ä§</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">ùìù</span><span class=\"o\">[(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Åª¬π'</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)}</span>\n</code></pre></div>\n<p>As a side effect, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=posTangentConeAt#doc\">docs#posTangentConeAt</a> becomes a special case of <code>tangentConeAt</code>. Suggestions are welcome. E.g., I'm not sure about <code>ùìù[(x + ¬∑) ‚Åª¬π' s] 0</code> vs <code>(ùìù[s] x).comap (x + ¬∑)</code> vs <code>(ùìù[s] x).map (¬∑ - x)</code>. All three are equivalent in a topological group, so this only affects <code>[ContinuousAdd E]</code> assumptions here and there. Also, should I use <code>[AddCommMonoid E]</code> in the definition and in lemmas that work with this assumption, or stick to at least <code>AddCommGroup E</code> everywhere?</p>",
        "id": 569173249,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768972262
    },
    {
        "content": "<p>I'm reviving an old thread. For those who didn't follow this refactor, we've already generalized <code>HasFDerivAt</code> etc to topological vector spaces, but lots of lemmas still assume <code>NormedSpace</code>.</p>",
        "id": 569173320,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768972322
    },
    {
        "content": "<p>Unless we're certain the generality is correct for <code>AddCommMonoid</code>, I'd be inclined to stick with groups for now; that is, focus on just one part of the generalization at a time</p>",
        "id": 569175539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768973902
    },
    {
        "content": "<p>Which of the three spellings look more natural to you?</p>",
        "id": 569177419,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1768975295
    },
    {
        "content": "<p><code>ùìù[(x + ¬∑) ‚Åª¬π' s] 0</code> has the advantage that when you unfold to it, you don't duplicate <code>x</code></p>",
        "id": 569179043,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768976417
    },
    {
        "content": "<p>I'd like to let <span class=\"user-mention\" data-user-id=\"110050\">@S√©bastien Gou√´zel</span> have one more look at <a href=\"https://github.com/leanprover-community/mathlib4/pull/34127\">#34127</a>, but I think it's pretty much ready to go.</p>",
        "id": 569807306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769204567
    },
    {
        "content": "<p>What's the next step after this; is it just mindless typeclass generalization, or is there more mathematical work to do?</p>",
        "id": 569807333,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769204584
    },
    {
        "content": "<p>I think that for <code>fderiv</code>, it's mostly typeclass generalization. If we want to generalize stuff like <code>fderiv_mul</code> to topological algebras over a normed field, then we should replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBoundedBilinearMap#doc\">docs#IsBoundedBilinearMap</a> with a version for topological spaces (a bilinear map that is continuous as a function on the product).</p>",
        "id": 569813519,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208124
    },
    {
        "content": "<p>For iterated derivatives, the situation is more complicated, because uncurrying only works for normed spaces. Probably, we can generalize to the <em>codomain</em> being a TVS, but not for the <em>domain</em>.</p>",
        "id": 569813642,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208211
    },
    {
        "content": "<p>Do you have a branch already with those generalizations (say, for <code>add</code> and <code>sum</code>), or do you want me to have a go once the above lands?</p>",
        "id": 569813709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769208262
    },
    {
        "content": "<p>I would wait with this until we generalize enough of theorems about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=fderiv#doc\">docs#fderiv</a>.</p>",
        "id": 569813710,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208263
    },
    {
        "content": "<p>I don't have a branch yet.</p>",
        "id": 569813780,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208312
    },
    {
        "content": "<p>I've recently found out about <a href=\"https://projecteuclid.org/journalArticle/Download?urlId=10.36045%2Fbbms%2F1197908901\">this</a> approach to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span>. I don't know how exactly it relates to our definition in case of real normed spaces.</p>",
        "id": 569813947,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208417
    },
    {
        "content": "<p>Pros of this approach is that (a) it works for functions on topological vector fields over topological fields (do people really need topological fields w/o a norm? idk); (b) it gives, e.g., symmetry of derivatives over other fields.</p>",
        "id": 569814080,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208506
    },
    {
        "content": "<p>(c) it looks similar to Whitney differentiability, not sure if it's exactly the same for, e.g., closed sets in finite dimensional spaces.</p>",
        "id": 569814148,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208550
    },
    {
        "content": "<p>BTW, do you have any idea about why do we see so much red in the benchmark?</p>",
        "id": 569814298,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208632
    },
    {
        "content": "<p>E.g., would it be better if I assume a stronger typeclass about the coefficients type everywhere? I doubt that we'll need it for anything less than a <code>DivisionSemiring</code>.</p>",
        "id": 569814825,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208925
    },
    {
        "content": "<p>This will shorten the path in instance searches, but add more fields for defeq calls.</p>",
        "id": 569814929,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769208984
    },
    {
        "content": "<p>BTW, I would appreciate reviews of <a href=\"https://github.com/leanprover-community/mathlib4/pull/34033\">#34033</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/34074\">#34074</a> (more API about asymptotics in TVS).</p>",
        "id": 569815038,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209049
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAtFilter.tendsto_nhds#doc\">docs#HasFDerivAtFilter.tendsto_nhds</a> generalize without much work?</p>",
        "id": 569815041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769209051
    },
    {
        "content": "<p>I might have it in a branch.</p>",
        "id": 569815068,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209073
    },
    {
        "content": "<p>Let me have a look later today.</p>",
        "id": 569815080,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209080
    },
    {
        "content": "<p>As for the next few lemmas, I think that we should introduce <code>IsEquivalentTVS</code>. Before doing this, I would prefer to merge the two PRs above, then split the file while moving it to <code>Topology/Algebra/Module/Asymptotics/*</code>.</p>",
        "id": 569815424,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209233
    },
    {
        "content": "<p>Then I would deprecate the <code>*BigO_*_rev</code> lemmas and replace them with more precise <code>IsEquivalent</code> + <code>IsTheta</code> lemmas.</p>",
        "id": 569816061,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209534
    },
    {
        "content": "<p>One more unrelated generalization I was thinking about is to make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAtFilter#doc\">docs#HasFDerivAtFilter</a> take a filter on the product as an argument, so that it works for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasStrictFDerivAt#doc\">docs#HasStrictFDerivAt</a> too.</p>",
        "id": 569816245,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769209643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569813709\">said</a>:</p>\n<blockquote>\n<p>Do you have a branch already with those generalizations (say, for <code>add</code> and <code>sum</code>), or do you want me to have a go once the above lands?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/34345\">#34345</a> makes a start on basic; I've just commented things out for now to make conflicts easier to resolve</p>",
        "id": 569816399,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769209720
    },
    {
        "content": "<p>My guess would be that we should relocate all the commented out code to a new section or file, since the statements actually need a norm in their assumptions or conclusions</p>",
        "id": 569816574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769209843
    },
    {
        "content": "<p>I can have a look tomorrow.</p>",
        "id": 569819398,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769212187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569814080\">said</a>:</p>\n<blockquote>\n<p>Pros of this approach is that (a) it works for functions on topological vector fields over topological fields (do people really need topological fields w/o a norm? idk); (b) it gives, e.g., symmetry of derivatives over other fields.</p>\n</blockquote>\n<p>I don't think I know any application of talking about merely C^k functions over fields other than R or C. The only regularity class for functions over Q_p I see people work with is analytic functions, where things like symmetry of partials is completely obvious anyway.</p>",
        "id": 569822610,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1769214499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569815041\">said</a>:</p>\n<blockquote>\n<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAtFilter.tendsto_nhds#doc\">docs#HasFDerivAtFilter.tendsto_nhds</a> generalize without much work?</p>\n</blockquote>\n<p>I worked this one out (edit: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34347\">#34347</a>)</p>",
        "id": 569823779,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769215482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569822610\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569814080\">said</a>:</p>\n<blockquote>\n<p>Pros of this approach is that (a) it works for functions on topological vector fields over topological fields (do people really need topological fields w/o a norm? idk); (b) it gives, e.g., symmetry of derivatives over other fields.</p>\n</blockquote>\n<p>I don't think I know any application of talking about merely C^k functions over fields other than R or C. The only regularity class for functions over Q_p I see people work with is analytic functions, where things like symmetry of partials is completely obvious anyway.</p>\n</blockquote>\n<p>The paper I've linked shows that at least some people care about ways to define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb Q_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> to get meaningful results. I have no idea how common is it. If this definition is equivalent to Whitney differentiability for closed subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, then I would introduce it. Otherwise, I would wait until one of the people who care about this comes to us.</p>",
        "id": 569824290,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769215900
    },
    {
        "content": "<p>Sure some people will study it just because they find it intrinsically interesting. I'm just saying that from what I know, there isn't really any use for the C^k-differentiable p-adic functions in mainstream number theory. So if there are some complications with the definition because what if it doesn't work over some crazy fields, I would personally vote for restricting the theory to R or C over doing something very complicated.</p>",
        "id": 569825204,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1769216926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569813642\">said</a>:</p>\n<blockquote>\n<p>For iterated derivatives, the situation is more complicated, because uncurrying only works for normed spaces. Probably, we can generalize to the <em>codomain</em> being a TVS, but not for the <em>domain</em>.</p>\n</blockquote>\n<p>The iterated Frechet derivative for the codomain being a TVS would be amazing to have! I have a bunch of results that I could probably prove very easily, but not state because that is missing.</p>",
        "id": 569830410,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1769223039
    },
    {
        "content": "<p><del>Do you know what definition is the right one in this context?</del> I've misread \"codomain\" as \"domain\" <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 569830526,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769223230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569816574\">said</a>:</p>\n<blockquote>\n<p>My guess would be that we should relocate all the commented out code to a new section or file, since the statements actually need a norm in their assumptions or conclusions</p>\n</blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34348\">#34348</a>.</p>",
        "id": 569834145,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769228277
    },
    {
        "content": "<p>I'm someone who would care about \"fields other than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>\"! Specifically I care about (continuous, nonanalytic but presumably smooth functions on) the field of unitary operators <em>on</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>‚Üí</mo><mi mathvariant=\"normal\">‚àû</mi></mrow><annotation encoding=\"application/x-tex\">n \\to \\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">‚àû</span></span></span></span>; I'm interested in TVS's because they show up in some approaches to algebraic quantum field theory. I have no idea if that meaningfully changes your constraints any, but since it came up...</p>",
        "id": 569835798,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1769230196
    },
    {
        "content": "<p>Are you interested in this field as a field of coefficients or as the domain/codomain of functions?</p>",
        "id": 569836566,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769230970
    },
    {
        "content": "<p>I know there are people here who do analysis with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb Q_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> as the field of scalars. I don't know if people are interested in other fields as fields of scalars. Also, I don't know if there are people here who care about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> functions, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>œâ</mi></mrow><annotation encoding=\"application/x-tex\">k&lt;\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œâ</span></span></span></span>, in case of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic analysis.</p>",
        "id": 569836681,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769231090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569836566\">said</a>:</p>\n<blockquote>\n<p>Are you interested in this field as a field of coefficients or as the domain/codomain of functions?</p>\n</blockquote>\n<p>Both, but particularly the latter.</p>",
        "id": 569837120,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1769231621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569830526\">said</a>:</p>\n<blockquote>\n<p><del>Do you know what definition is the right one in this context?</del> I've misread \"codomain\" as \"domain\" <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>\n</blockquote>\n<p>There is something with derivatives in \"tame\" Fr√©chet spaces (grading of the seminorms and some additional condition)- it is some paper by Hamilton. It defines only directional derivatives and C^1 is all directional derivatives exist and the derivative built from the directional derivatives is continuous. I think there is something that the definition does not match up with the one for Banach spaces, so it might be very hard to generalize beyond Banach spaces as the domain and keep a useful derivative.</p>",
        "id": 569846579,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1769242020
    },
    {
        "content": "<p>But the thing that I would like to have is way more simple (and IMO way more relevant): I would like to say that a function is smooth from the reals (or non-negative reals) to Schwartz functions, to be able to state regularity of something like the propagator of the wave/Schr√∂dinger equation (or heat) and having all of the calculus library for codomain being a TVS is the main obstacle.</p>",
        "id": 569850175,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1769245343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569813947\">said</a>:</p>\n<blockquote>\n<p>I've recently found out about <a href=\"https://projecteuclid.org/journalArticle/Download?urlId=10.36045%2Fbbms%2F1197908901\">this</a> approach to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">C^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span>. I don't know how exactly it relates to our definition in case of real normed spaces.</p>\n</blockquote>\n<p>I was aware of this approach when I developed <code>C^k</code> in Mathlib. The book by Schikhof (Ultrametric calculus) is a very nice reference for that. It is a little bit alien to what we usually do on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> because it is not written in terms of a sequence of iterated derivatives all of a similar nature. It turns out to be equivalent to the usual definition on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>, but the definitions and results are sufficiently different that it would be much harder to use in the usual situations. In fact, to me the main point of calculus, and the reason for its power, it that you can deduce properties of the function from properties of the derivative, and this doesn't really hold in this generalized context because there is no real notion of derivative. So, for practicality of use, I decided to go for a more classically-flavored definition.</p>\n<p>If anyone has a use for the more exotic definition, I think it should be defined as a parallel hierarchy in Mathlib, not replacing the one we already have. But I don't know of applications beyond the theory itself, so I'm not sure there is a huge pressure or need for that in Mathlib.</p>",
        "id": 569857583,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1769253305
    },
    {
        "content": "<p>I think that sometimes it is wise to bifurcate in the archimedean/nonarchimedean case even if it's strictly speaking possible to formalise everything in a universal way. For example, it's possible to define the adeles of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> as a restricted product of the completions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>, but we have an essentially completely disjoint API for archimedean and nonarchimedean completions, so in mathlib the adeles of a number field is defined as the product of (the restricted product of the nonarchimedean completions) and (the product of the archimedean completions) and we severely stress-tested this design decision in the FLT project throughout 2025 and I was very happy with it. </p>\n<p>The first section of the fundamental book by Jacquet and Langlands (which we'll need for FLT) talks about Schwarz functions on a completion of a number field, so this is either <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> or a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic field, and I absolutely did <em>not</em> start screaming about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic fields when people started developing the classical theory of Schwarz functions, because even though I knew that in theory one could develop the theory in such a way that a small part of it applied to the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic case, in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic case it's just locally constant functions with compact support, and I could see absolutely no point at all in arguing that the theory should apply in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic case when it was simply far easier to just make the (far simpler) relevant definitions in the nonarchimedean case by hand.</p>\n<p>There is an art to formalization -- you want your definitions to hold not in \"the most generality\" but in \"the right generality\". If we always went for the most generality then probably the bottom of our algebra hierarchy would be statements about objects of categories or something! We wouldn't have <code>Zero</code> and <code>One</code>, we'd have <code>Element</code> which unifies the two theories in a totally unhelpful way.</p>",
        "id": 569865013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1769259588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/generalizing.20deriv.20to.20TVS/near/569834145\">said</a>:</p>\n<blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34348\">#34348</a>.</p>\n</blockquote>\n<p>This should now be ready to go, which unblocks <a href=\"https://github.com/leanprover-community/mathlib4/pull/34345\">#34345</a> which generalizes <code>Basic.lean</code> to TVS. I had a quick go at generalizing <code>Const.lean</code>, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasFDerivWithinAt_singleton#doc\">docs#hasFDerivWithinAt_singleton</a> doesn't work without some thought</p>",
        "id": 569970208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769363275
    },
    {
        "content": "<p>I will have some time tonight to review this and <a href=\"https://github.com/leanprover-community/mathlib4/pull/34402\">#34402</a> (unrelated)</p>",
        "id": 569976127,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769368792
    },
    {
        "content": "<p>Sent <a href=\"https://github.com/leanprover-community/mathlib4/pull/34348\">#34348</a> to bors. Please tell me when <a href=\"https://github.com/leanprover-community/mathlib4/pull/34345\">#34345</a> is ready for review.</p>",
        "id": 570012186,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769404778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/34345\">#34345</a> is ready</p>",
        "id": 570020171,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1769410666
    },
    {
        "content": "<p>While thinking about generalizing more lemmas, I've found out that I don't know how to prove this lemma (and if it's true in a general TVS):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Asymptotics</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsTopologicalAddGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ContinuousSMul</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"n\">O</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It's a part of <code>IsEquivalentTVS.isThetaTVS</code>, where <code>IsEquivalentTVS</code> is defined in the same way as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsEquivalent#doc\">docs#Asymptotics.IsEquivalent</a>, but for TVS.</p>",
        "id": 571311153,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769975356
    },
    {
        "content": "<p>A version of this lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsLittleO.right_isBigO_add#doc\">docs#Asymptotics.IsLittleO.right_isBigO_add</a> for normed spaces is used in the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAtFilter.isBigO_sub_rev#doc\">docs#HasFDerivAtFilter.isBigO_sub_rev</a></p>",
        "id": 571311270,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769975484
    },
    {
        "content": "<p>I think this should at least be true in the locally convex settings, using the results of <a href=\"https://github.com/leanprover-community/mathlib4/pull/34472\">#34472</a></p>",
        "id": 571313769,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769977814
    },
    {
        "content": "<p>This is not something that we can require for any field <code>K</code>.</p>",
        "id": 571314063,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769978094
    },
    {
        "content": "<p>We can thanks to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PolynormableSpace#doc\">docs#PolynormableSpace</a>, which encompasses all normed spaces</p>",
        "id": 571314098,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769978130
    },
    {
        "content": "<p>But it would be nicer to not have this assumption I agree</p>",
        "id": 571314131,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769978161
    },
    {
        "content": "<p>Wait actually I retract my claim: even in the locally convex it's not clear if it's true</p>",
        "id": 571315191,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769979170
    },
    {
        "content": "<p>Am I right that, in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi mathvariant=\"double-struck\">N</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span></span></span> with the product topology, the function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>‚Üí</mo><msup><mi mathvariant=\"double-struck\">R</mi><mi mathvariant=\"double-struck\">N</mi></msup><mo separator=\"true\">,</mo><mi>n</mi><mo>‚Ü¶</mo><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mi>k</mi></msup><msub><mo stretchy=\"false\">)</mo><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">f : \\mathbb{N} \\to \\mathbb{R}^\\mathbb{N}, n \\mapsto (n^k)_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0397em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Ü¶</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> satisfies <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = o(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> at infinity? Because each coordinate is negligible compared to the next one. But then of course <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo mathvariant=\"normal\">‚â†</mo><mi>O</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo>‚àí</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f \\neq O(f - f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\">ÓÄ†</span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> so your lemma would be false?</p>",
        "id": 571315657,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769979623
    },
    {
        "content": "<p>Does it mean that our definition of <code>f = o(g)</code> in a TVS is bad?</p>",
        "id": 571315698,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769979671
    },
    {
        "content": "<p>I'm not sure to be honest. My guess (purely based on the locally convex/polynormable setting) is it's the only sensible thing, and it should give some interesting generalization (typically, we could upgrade <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasFDerivAt_pi#doc\">docs#hasFDerivAt_pi</a> to arbitrary products, which would allow stating things in a convenient way), but probably there's too many pathologies to generalize everything.</p>",
        "id": 571316701,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769980672
    },
    {
        "content": "<p>For anyone following along: in the locally convex setting, the criterion for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = o(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> is: for any continuous seminorm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, there exists a continuous seminorm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>‚àò</mo><mi>f</mi><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi>q</mi><mo>‚àò</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p\\circ f = o(q\\circ g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àò</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àò</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span>. The issue, IIUC, comes from this forall/exists asymmetry.</p>",
        "id": 571316863,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769980880
    },
    {
        "content": "<p>Aha, in fact this suggests a probably better behaved definition of asymptotic equivalents : for all continuous seminorm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo>‚àí</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p(f - g) = o(p(g))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">))</span></span></span></span> (and in general you replace the \"forall seminorm\" by \"for any gauge of a neighborhood of zero\").</p>\n<p>I haven‚Äôt thought about the details though, so take this with a grain of salt.</p>",
        "id": 571327257,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1769991959
    },
    {
        "content": "<p>This won't be helpful for derivatives, since we can't get it from <code>f=o(g)</code>.</p>",
        "id": 571327837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1769992493
    },
    {
        "content": "<p>Is this generalisation for its own sake or are people really using little-o notation in the wild in situations where there isn't a canonical fixed norm?</p>",
        "id": 571362310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1770017584
    },
    {
        "content": "<p>People use derivatives without a canonical fixed norm. E.g.,</p>\n<ul>\n<li>derivative of a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext>‚Äâ‚Å£</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi mathvariant=\"double-struck\">R</mi><mo>‚Üí</mo><msup><mi>C</mi><mi mathvariant=\"normal\">‚àû</mi></msup><mo stretchy=\"false\">(</mo><mi>E</mi><mo separator=\"true\">,</mo><mi>F</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f\\colon\\mathbb R\\to C^\\infty(E, F)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">‚àû</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">)</span></span></span></span>;</li>\n<li>matrix spaces have no canonical norm in Mathlib.</li>\n</ul>",
        "id": 571459566,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770045655
    },
    {
        "content": "<p>For growth estimates, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsLittleO#doc\">docs#Asymptotics.IsLittleO</a> etc are more convenient, as they have more API. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Asymptotics.IsLittleOTVS#doc\">docs#Asymptotics.IsLittleOTVS</a> was introduced to generalize the derivatives.</p>",
        "id": 571477392,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1770050201
    },
    {
        "content": "<p>Sorry for being late to this discussion, but would it be easier if we restrict to the co-domain of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> being a normed space? then there is no seminorm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> to choose. For the derivatives that is all we need, right?</p>",
        "id": 575195635,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1771797693
    },
    {
        "content": "<p>That's what we have now in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFDerivAt.isEquivalent_sub#doc\">docs#HasFDerivAt.isEquivalent_sub</a> now.</p>",
        "id": 575199396,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771800827
    },
    {
        "content": "<p>UPD: sorry, I've misread what you were answering. I'll look into this later today.</p>",
        "id": 575199422,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771800868
    },
    {
        "content": "<p>What I would expect the definition for <code>IsLittleOTVS</code> to be is: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f = o(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span> if for every continuous seminorm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>, we have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>o</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚à•</mi><mi>g</mi><mi mathvariant=\"normal\">‚à•</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p(f) = o(\\|g\\|)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mopen\">(</span><span class=\"mord\">‚à•</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\">‚à•</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 575199480,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1771800917
    },
    {
        "content": "<p>I don't think that we should restrict this in the definition.</p>",
        "id": 575199528,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771800957
    },
    {
        "content": "<p>We have a definition that works for a function between two TVS, and it gives the right result for (semi)normed spaces. Why change it?</p>",
        "id": 575199572,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1771800997
    },
    {
        "content": "<p>There is no need to change it, but maybe we want a characterisation in terms of the co-domain of <code>f</code> being polynormable and the co-domain of <code>g</code> being normable? And then it should be easy to prove the statement above. Or do you have a case where <code>g</code> maps into a locally convex space?</p>",
        "id": 575202337,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1771803366
    }
]