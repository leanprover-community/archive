[
    {
        "content": "<p>I would really like to see the monoidal structure on chain complexes, which will unlock many interesting bits of maths.</p>\n<p>Unfortunately it seems hard to implement. In fact, even forgetting about differentials and just defining it on graded objects, where </p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊗</mo><mi>Y</mi><msub><mo stretchy=\"false\">)</mo><mi>i</mi></msub><mo>=</mo><msub><mo>⊕</mo><mrow><mi>i</mi><mo>=</mo><mi>j</mi><mo>+</mo><mi>k</mi></mrow></msub><msub><mi>X</mi><mi>j</mi></msub><mo>⊗</mo><msub><mi>Y</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">(X ⊗ Y)_i = ⊕_{i=j+k} X_j ⊗ Y_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mbin\">⊕</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>seems quite difficult. I'm happy to restrict to <code>ℕ</code>-graded objects, as I think the additional difficulties for bounded complexes are of a different sort. (Note that graded objects are a helpful stepping stone to chain complexes, as the forgetful functor is faithful, so if you can check the pentagon equation for graded objects you'll get it for free for chain complexes.)</p>\n<p>So the first question is just: is there some abstract nonsense way of thinking about this tensor product that I am missing? Something that magically combines the additive monoidal structures on the ambient category, the fact that <code>ℕ</code> is a discrete monoidal category under additional, and naturally makes use of the direct sums?</p>\n<p>Doing things directly, the tensor product itself is not difficult. I can then define the associator for tensor product of graded objects, although it is a somewhat grungy combination of six maps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"n\">_i</span> <span class=\"bp\">=</span> <span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"bp\">=</span><span class=\"n\">ab</span><span class=\"bp\">+</span><span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{</span><span class=\"n\">ab</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y_b</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span> <span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y_b</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span>                                <span class=\"o\">:=</span> <span class=\"n\">distributivity</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{((</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"n\">c</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y_b</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span>                      <span class=\"o\">:=</span> <span class=\"n\">iterated</span> <span class=\"n\">biproducts</span> <span class=\"n\">are</span> <span class=\"n\">biproducts</span> <span class=\"n\">over</span> <span class=\"n\">a</span> <span class=\"n\">sigma</span> <span class=\"n\">type</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">))}</span> <span class=\"o\">(</span><span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y_b</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span>                      <span class=\"o\">:=</span> <span class=\"n\">reindexing</span> <span class=\"n\">use</span> <span class=\"n\">associativity</span> <span class=\"n\">of</span> <span class=\"n\">antidiagonal</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{(</span><span class=\"n\">a</span><span class=\"o\">,(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">))}</span> <span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y_b</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span><span class=\"o\">)</span>                      <span class=\"o\">:=</span> <span class=\"n\">the</span> <span class=\"n\">associator</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">ambient</span> <span class=\"n\">category</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span> <span class=\"bp\">⊕</span> <span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y_b</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z_c</span><span class=\"o\">)</span>                                <span class=\"o\">:=</span> <span class=\"n\">iterated</span> <span class=\"n\">biproducts</span> <span class=\"n\">are</span> <span class=\"n\">biproducts</span> <span class=\"n\">over</span> <span class=\"n\">a</span> <span class=\"n\">sigma</span> <span class=\"n\">type</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"bp\">=</span><span class=\"n\">a</span><span class=\"bp\">+</span><span class=\"n\">bc</span><span class=\"o\">}</span> <span class=\"n\">X_a</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"bp\">⊕</span><span class=\"n\">_</span><span class=\"o\">{</span><span class=\"n\">bc</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"bp\">+</span><span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"n\">Y_b</span> <span class=\"n\">Z_c</span><span class=\"o\">)</span>                <span class=\"o\">:=</span> <span class=\"n\">distributivity</span>\n  <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">⊗</span> <span class=\"n\">Z</span><span class=\"o\">))</span><span class=\"n\">_i</span>                                      <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>However with this definition checking the pentagon equation seems intractable (it's an equation involving 30 morphisms, and a lot of rewriting, and <code>simp</code> only gets you so far). I've made a few recent PRs that make this a bit easier, but it still looks too hard.</p>",
        "id": 380876112,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690939394
    },
    {
        "content": "<p>The second question is if anyone has advice for tackling the pentagon equation if this is the best we can do for the associator.</p>\n<p>The third question is if anyone is interested in working on this. :-) I won't be doing more on this in the near future, but I think it is important for lots of homological algebra.</p>",
        "id": 380876470,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690939584
    },
    {
        "content": "<p>I had a branch somewhere that worked with (the ring structure implied by) graded tensor products in <code>ZMod 2</code>, defined with</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊗</mo><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">deg</mi><mo>⁡</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">deg</mi><mo>⁡</mo><msup><mi>a</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo></mrow></msup><mi>a</mi><msup><mi>a</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊗</mo><mi>b</mi><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">(a\\otimes b)(a^{\\prime}\\otimes b^{\\prime})=(-1)^{(\\operatorname{deg}b)(\\operatorname{deg}a^{\\prime})}aa^{\\prime}\\otimes bb^{\\prime}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1925em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9425em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mop mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">deg</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\">b</span><span class=\"mclose mtight\">)</span><span class=\"mopen mtight\">(</span><span class=\"mop mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">deg</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8278em;\"><span style=\"top:-2.931em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>but I don't remember how far I got with it, or whether the definition coincides with yours</p>",
        "id": 380876932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690939810
    },
    {
        "content": "<p>What about an inductive construction where you induct on the length of the complex(es)? Or maybe this is what you have already?</p>",
        "id": 380877059,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690939880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span>, I'm not even sure what this would mean. The definition of the tensor product on objects and morphisms is straightforward:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The tensor product of graded objects `X` and `Y` is, in each degree `i`,</span>\n<span class=\"sd\">the biproduct over `a + b = i` of `X a ⊗ Y b`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">tensorObj</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">GradedObject</span> <span class=\"n\">ℕ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">biproduct</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Finset.Nat.antidiagonal</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">p.1.1</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">p.1.2</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- The tensor product of morphisms between graded objects is the diagonal map</span>\n<span class=\"sd\">consisting of tensor products of components. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">tensorHom</span> <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">GradedObject</span> <span class=\"n\">ℕ</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">tensorObj</span> <span class=\"n\">W</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">tensorObj</span> <span class=\"n\">X</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">biproduct.map</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">p.1.1</span> <span class=\"bp\">⊗</span> <span class=\"n\">g</span> <span class=\"n\">p.1.2</span>\n</code></pre></div>\n<p>The associator I can at least write down (see <a href=\"https://github.com/leanprover-community/mathlib4/tree/monoidal_complex\">branch#monoidal_complex</a>, in <code>Mathlib.CategoryTheory.GradedObject.Monoidal</code>) but then the pentagon equation seems nightmarish.</p>",
        "id": 380886821,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690943788
    },
    {
        "content": "<p>I guess I'm hoping to summon a sealed horror from nlab that will tell me a cheap way to do this, at the price of some nonsense about extensions or coends or ... :-)</p>",
        "id": 380886977,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690943868
    },
    {
        "content": "<p>I did not manage to compile the <code>monoidal_complex</code> branch, but my guess is that we would need suitable ext lemmas (but it seems that the <code>MonoidalPreadditive</code> API provides these) so that it should reduce to a computation on each indivual term <code>W p ⊗ X q ⊗ Y r ⊗ Z s</code>, and then we would need suitable lemmas which would identity the restriction of the associator maps on these, and for that the most annoying thing is that we may have to use arithmetical identities, like the associativity of the addition in the natural numbers. (I have encountered related issues when I studied the cochain complex of abelian groups of morphisms from a cochain complex to another.)</p>",
        "id": 380923962,
        "sender_full_name": "Joël Riou",
        "timestamp": 1690959660
    },
    {
        "content": "<p>I will try to get the branch working for you, sorry!</p>",
        "id": 380933247,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690962084
    },
    {
        "content": "<p>The necessary <code>ext</code> lemmas are there, but I could not convince <code>simp</code> to actually deal with all the resulting <code>biproduct.ι</code> and <code>biproduct.π</code>s that appear. The naturality of <code>biproduct.lift/desc</code> seems to get in the way of having a simp normal form that goes all the way --- although I'm certainly not saying this is impossible, just intimidating. :-)</p>",
        "id": 380933640,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690962177
    },
    {
        "content": "<p>I had to prove some lemmas about biproducts when I was translating the LFTCM20 category theory exercises into Lean 4 for the students in Copenhagen, and it struck me that they have this same property as cohomology of a complex -- they're both a limit and a colimit, which makes them interesting to work with :-)</p>",
        "id": 380934289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690962338
    },
    {
        "content": "<p>I fixed the badly botched merge on <a href=\"https://github.com/leanprover-community/mathlib4/tree/monoidal_complex\">branch#monoidal_complex</a>, and it is compiling again now.</p>",
        "id": 380939846,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690963637
    },
    {
        "content": "<p>I thought for too long about speeding up mathlib and now I have to spend a week or so doing real life things like reading PhD theses so I can examine them, but my naive thoughts on this matter say that the right ext lemma just reduces you to checking everything on pure tensors a x b x c x d where it is hopefully rfl. What is wrong with my thought experiment?</p>",
        "id": 380955414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690966810
    },
    {
        "content": "<p>By themselves all the ext lemmas do is make things more complicated: they introduce lots of \"inclusion into this summand\" and \"projection onto this summand\" morphisms at either either of the big composite of morphisms.</p>\n<p>We then need <code>simp</code> to actually combine those with the structural maps (e.g. distributors, biproduct reindexing maps, etc) so that we actually get down to something about pure tensors. This is far from working at the moment.</p>\n<p>Possibly we also need \"ext lemmas on the inside\", i.e. to locate places in the middle of the composition where we \"visit\" a large direct sum, and insert that fact that the identity is the sum over of the index set of the <code>biproduct.π _ j ≫ biproduct.ι _ j</code> maps, which will hopefully then induce further simplification as these maps hit the structural morphisms on the inside. But this hopefully isn't essentially: naturality should hopefully propagate the <code>biproduct.ι</code>s inwards from the left and the <code>biproduct.π</code>s inwards from the right until they actually meet in the middle and annihilate. </p>\n<p>However with ~18 morphisms on the LHS of the pentagon, and ~12 on the RHS, we are asking a lot of simp normal form to successfully push the extra morphisms introduced by <code>ext</code> all the way through. Apparently asking too much at present!</p>",
        "id": 380963966,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690968631
    },
    {
        "content": "<p>A typical place where the current simp set gets stuck is something that looks schematically like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">biproduct.ι</span> <span class=\"n\">_</span> <span class=\"n\">j</span> <span class=\"bp\">≫</span> <span class=\"n\">biproduct.lift</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">biproduct.π</span> <span class=\"n\">_</span> <span class=\"n\">k</span> <span class=\"bp\">≫</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If <code>k</code> did not depend on <code>i</code>, then by \"naturality\" we could pull the <code>biproduct.π</code> out of the <code>biproduct.lift</code>, after which it would annihilate with the <code>biproduct.ι</code> via <code>biproduct.ι_π_assoc</code>. However it does depend, so the only choice seems to be to push the <code>biproduct.ι</code> inside the the <code>biproduct.lift</code>, which seems slightly scary. Perhaps it is okay to always do this? Or should we only do it when we can see that there is a <code>biproduct.π</code> already inside the <code>biproduct.lift</code> for it to collide with?</p>\n<p>(Sorry, writing this without the branch open, may be nonsensical. :-)</p>",
        "id": 380965401,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690968903
    },
    {
        "content": "<p>As a general principal, lemmas \"pushing <code>biproduct.ι</code> to the right\" (and dually pushing <code>biproduct.π</code> to the left) are pretty easy to justify, so maybe we should just be braver.</p>",
        "id": 380965842,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690968982
    },
    {
        "content": "<p>Sorry what I meant boils down the following. I rarely need much more than </p>\n<ul>\n<li>we know this construction on whatever objects we are building chain complexes with</li>\n<li>it commutes with colimits </li>\n<li>it takes cones to cones</li>\n</ul>\n<p>Usually statements I care about are closed under those operations so you get a reduction quickly. </p>\n<p>What can you say about the full subcategory where the pentagon equality holds?</p>",
        "id": 381226636,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1690994644
    },
    {
        "content": "<p>Using the strategy I had suggested above (where I would like to stress the importance of the arithmetical identities, here the associativity in the natural numbers), I have reduced the pentagon identity to a very basic equational lemma for the associator. Then, in principle, it should not be too hard to complete the proof. See <a href=\"https://github.com/leanprover-community/mathlib4/tree/monoidal_complex_jriou\">branch#monoidal_complex_jriou</a> <a href=\"https://github.com/leanprover-community/mathlib4/blob/monoidal_complex_jriou/Mathlib/CategoryTheory/GradedObject/Monoidal.lean\">https://github.com/leanprover-community/mathlib4/blob/monoidal_complex_jriou/Mathlib/CategoryTheory/GradedObject/Monoidal.lean</a></p>\n<p>(It is certainly better for me not to work more on this anytime soon: I am in Chennai working on a non-math project...)</p>",
        "id": 381427723,
        "sender_full_name": "Joël Riou",
        "timestamp": 1691057716
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span>, that made it much more manageable. I needed to add quite a bit of further API for <code>biproduct</code>, but I've now finished the proof of the pentagon equation.</p>",
        "id": 381659226,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691119276
    },
    {
        "content": "<p>For now I've just pushed to your branch, and left it in a fairly messy state, but hopefully soon I will do the unitors as well (hopefully much much easier!) and clean up.</p>",
        "id": 381659257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691119307
    },
    {
        "content": "<p>Oh -- and the abstract nonsense words I was probably looking for earlier are \"<a href=\"https://ncatlab.org/nlab/show/Day+convolution\">Day convolution</a>\", although I'm not sure you actually get any savings on the monoidal structure by generalizing in that direction.</p>",
        "id": 381692319,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691130831
    },
    {
        "content": "<p>I have refactored <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/6379\">#6379</a> as <a href=\"https://github.com/leanprover-community/mathlib4/pull/7389\">#7389</a>, which is still a draft, but the first PR out of it <a href=\"https://github.com/leanprover-community/mathlib4/pull/7425\">#7425</a> is ready. In order to construct the tensor product on graded objects by an additive monoid <code>I</code> in a category <code>C</code>, I extend the tensor product on <code>C</code> to a functor <code>GradedObject I C ⥤ GradedObject I C ⥤ GradedObject (I × I) C</code> and then I use the \"pushforward\" by the addition <code>I × I → I</code> which is a functor <code>GradedObject (I × I) C ⥤ GradedObject I C</code>. Eventually, if <code>X₁ X₂ : GradedObject I C</code>, <code>(X₁ ⊗ X₂) j</code> is the coproduct of the <code>X₁ i₁ ⊗ X₂ i₂</code> for <code>i₁ + i₂ = j</code>. The associator <code>(X₁ ⊗ X₂) ⊗ X₃ ≅ X₁ ⊗ (X₂ ⊗ X₃)</code> is obtained by showing that in degree <code>j</code>, both sides identifies to a coproduct indexed by triples <code>(i₁, i₂, i₃)</code> such that <code>i₁ + i₂ + i₃ = j</code> (this is the most technical part of the construction <a href=\"https://github.com/leanprover-community/mathlib4/blob/graded-monoidal/Mathlib/CategoryTheory/GradedObject/Trifunctor.lean#L245-L246\">https://github.com/leanprover-community/mathlib4/blob/graded-monoidal/Mathlib/CategoryTheory/GradedObject/Trifunctor.lean#L245-L246</a> which is done more generally for trifunctors obtained by composing bifunctors). The pentagon relation is now obtained in a much cleaner way than I initially did: <a href=\"https://github.com/leanprover-community/mathlib4/blob/graded-monoidal/Mathlib/CategoryTheory/GradedObject/Monoidal.lean#L577-L611\">https://github.com/leanprover-community/mathlib4/blob/graded-monoidal/Mathlib/CategoryTheory/GradedObject/Monoidal.lean#L577-L611</a> (the proof is now mostly a sequence of <code>rw</code>, and no longer a series of lemmas in a random order).</p>\n<p>Using <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>'s <a href=\"https://github.com/leanprover-community/mathlib4/pull/7237\">#7237</a> it should be relatively easy to deduce the monoidal structure on chain complexes in an additive monoidal category. I have made as little assumptions as possible so that eventually this could also be used to get a monoidal structure on unbounded complexes.</p>",
        "id": 393807746,
        "sender_full_name": "Joël Riou",
        "timestamp": 1695936617
    },
    {
        "content": "<p>I'm consistently impressed by how often someone else ends up needing something I only just worked on</p>",
        "id": 393808730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695937106
    },
    {
        "content": "<p>(and vice versa!)</p>",
        "id": 393808749,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1695937120
    },
    {
        "content": "<p>This was first flagged in the class group paper several years ago; it is a surprisingly common phenomenon.</p>\n<p><a href=\"/user_uploads/3121/i7nN0MK4DLQjX5iix0KoSD-v/Screenshot-from-2023-09-29-08-52-25.png\">Screenshot-from-2023-09-29-08-52-25.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/i7nN0MK4DLQjX5iix0KoSD-v/Screenshot-from-2023-09-29-08-52-25.png\" title=\"Screenshot-from-2023-09-29-08-52-25.png\"><img src=\"/user_uploads/3121/i7nN0MK4DLQjX5iix0KoSD-v/Screenshot-from-2023-09-29-08-52-25.png\"></a></div><p>This is precisely the big edge that mathlib has over things like AFP.</p>",
        "id": 393879347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695973979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Tensor.20products.20of.20graded.20objects.20.2F.20chain.20complexes/near/380876932\">said</a>:</p>\n<blockquote>\n<p>I had a branch somewhere that worked with (the ring structure implied by) graded tensor products in <code>ZMod 2</code> [snip] but I don't remember how far I got with it, or whether the definition coincides with yours</p>\n</blockquote>\n<p>This is now sorry-free in <a href=\"https://github.com/leanprover-community/mathlib4/pull/7394\">#7394</a></p>",
        "id": 396497523,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697200624
    },
    {
        "content": "<p>Can one apply this work on the categorical part of mathlib to the type theoretic part? use graded objects in categories to redefine/handle <code>GradedModule</code>, etc.?</p>",
        "id": 396666401,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697304104
    },
    {
        "content": "<p>If nothing else it would be good to show a link between the two approaches</p>",
        "id": 396679993,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697320567
    },
    {
        "content": "<p>The questions is whether we do need to have two approaches.</p>\n<ol>\n<li>\n<p>Many typeclasses in mathlib give rise naturally to categories, in the mathematical sense. <br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoid#doc\">docs#AddMonoid</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidHom#doc\">docs#AddMonoidHom</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module#doc\">docs#Module</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap#doc\">docs#LinearMap</a> (the latter category being parameterized by a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Semiring#doc\">docs#Semiring</a>), etc.<br>\nIt is certainly important to define systematically as such the categories that already exist in mathlib.</p>\n</li>\n<li>\n<p>Probably, very generic type classes (such as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidHomClass#doc\">docs#AddMonoidHomClass</a>) will imply that some category is of an important type (additive, monoidal, etc.) and here as well, some relation has to be stated.</p>\n</li>\n<li>\n<p>Some constructions can be stated at a categorical level (graded objects, for example), and certainly the relation should be done, but it would also be important to be able to inherit automatically from the categorical results. </p>\n</li>\n<li>\n<p>Maybe this can be incorporated in a general <a href=\"https://inria.hal.science/hal-02478907v4/document\">hierarchy builder</a> such as the one that <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span>  and his coauthors proposed for Coq. I believe it would be great to incorporate that effort into mathlib.</p>\n</li>\n</ol>",
        "id": 396856038,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697447123
    },
    {
        "content": "<p>Note that right now, inheriting in <em>full</em> generality from category theoretic results is impossible; the category-theoretic results are less universe-polymorphic than the <code>Type</code> counterparts (you can't build a morphism between modules in different universes)</p>",
        "id": 396858401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697447996
    },
    {
        "content": "<p>Of course, you could fairly argue that the polymorphism is (mostly) worthless, and those who need it should just suffer through some extra <code>ULift</code>s</p>",
        "id": 396858515,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697448031
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> might remember from <code>slim_check</code>, I'd prefer we don't let desiring more universe polymorphism get in the way of ... well, anything.</p>",
        "id": 396862075,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1697449233
    },
    {
        "content": "<p>I think a more realistic example of why we can't use the category theory library for everything is that AFAIK there's no direct analog to <code>is_scalar_tower</code>, because the things we'd want to quantify over are bundled</p>",
        "id": 396862483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697449363
    },
    {
        "content": "<p><code>IsScalarTower R A M</code> is not very far from what mathematicians do implicitly when they consider modules M over an R-algebra A</p>",
        "id": 396869570,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697451506
    },
    {
        "content": "<p>And I'm not arguing that everything should be done automatically. <br>\nOne could imagine a system that gives you what it can do, and asks you about the rest.</p>",
        "id": 396869872,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1697451577
    }
]