[
    {
        "content": "<p>I have been working on <a href=\"https://github.com/sinhp/groupoid_model_in_lean4\">a formalization project</a> involving lots of universal properties expressed as natural equivalences between hom-types in categories.</p>\n<p>Let me give you three examples, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’(X,Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> denotes the hom-type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>âŸ¶</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X âŸ¶ Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6943em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âŸ¶</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo>:</mo><mi>ğ’</mi></mrow><annotation encoding=\"application/x-tex\">X,Y : ğ’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span>.</p>\n<ul>\n<li>For adjunctions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>âŠ£</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">F âŠ£ G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">âŠ£</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>, we have the usual correspondence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’Ÿ</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>â‰ƒ</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’Ÿ(F(X), Y) â‰ƒ ğ’(X, G(Y))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.09371em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰ƒ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span></span></span></span>.</li>\n<li>For products (in fact any limit), we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>Z</mi><mo separator=\"true\">,</mo><mi>X</mi><mo>Ã—</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>â‰ƒ</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>Z</mi><mo separator=\"true\">,</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>Ã—</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>Z</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’(Z, XÃ—Y) â‰ƒ ğ’(Z, X) Ã— ğ’(Z, Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰ƒ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>.</li>\n<li>For <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>:</mo><mi>ğ’</mi><mtext>â¥¤</mtext><mi>ğ’</mi></mrow><annotation encoding=\"application/x-tex\">P: ğ’ â¥¤ ğ’</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mord\">â¥¤</span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span> a polynomial functor on a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p : ğ’(E,B)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span></span></span></span> (whatever that means), <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>â‰ƒ</mo><mo stretchy=\"false\">(</mo><mi>b</mi><mo>:</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>Ã—</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><msup><mi>b</mi><mo>âˆ—</mo></msup><mi>p</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ğ’(X, P(Y)) â‰ƒ (b : ğ’(X, B)) Ã— ğ’(b^*p, Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰ƒ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">Ã—</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">âˆ—</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> (dependent pair on the right, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>b</mi><mo>âˆ—</mo></msup><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">b^*p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">âˆ—</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">p</span></span></span></span> means the corner of the pullback of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>).</li>\n</ul>\n<p>In <code>mathlib</code>, bijections of this kind seem to usually be formalized as <code>Equiv</code>s, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.homEquiv#doc\">docs#CategoryTheory.Adjunction.homEquiv</a>.</p>\n<p>However, there is more to this than an <code>Equiv</code>: the bijections are also natural, meaning they behave well on compositions. For example, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><mi>ğ’Ÿ</mi><mo stretchy=\"false\">(</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>â‰ƒ</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i : ğ’Ÿ(F(X), Y) â‰ƒ ğ’(X, G(Y))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.09371em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰ƒ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span></span></span></span> for an adjunction, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo>â‰«</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>i</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>â‰«</mo><mi>G</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(f â‰« g) = i(f) â‰« G(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰«</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â‰«</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span>; this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Adjunction.homEquiv_naturality_right#doc\">docs#CategoryTheory.Adjunction.homEquiv_naturality_right</a>.</p>\n<p>Now, one sometimes build up larger equivalences by composing smaller ones. The example I have in mind is the equivalence for polynomial functors; it can be obtained (e.g. <a href=\"https://topos.institute/blog/2024-12-10-polynomial-universes-natural-models/\">here</a>) as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">ğ’</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"n\">ğ’</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"bp\">âˆ‘_</span><span class=\"o\">{</span><span class=\"bp\">!_</span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"bp\">âˆ_</span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"bp\">!^*_</span><span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"bp\">âˆ‘_</span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"bp\">âŸ¶</span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"n\">ğ’</span><span class=\"bp\">/</span><span class=\"n\">B</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">âˆ_</span><span class=\"n\">p</span><span class=\"o\">(</span><span class=\"bp\">!^*_</span><span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"bp\">âˆ‘_</span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"bp\">âŸ¶</span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"n\">ğ’</span><span class=\"bp\">/</span><span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^*</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"bp\">!^*_</span><span class=\"n\">E</span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"bp\">âˆ‘_</span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">X</span><span class=\"bp\">âŸ¶</span><span class=\"n\">B</span><span class=\"o\">}</span><span class=\"n\">ğ’</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">^*</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">Y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>We may now ask: why is this natural? On paper, the answer is 'obviously, because it's a composition of natural bijections'. In Lean, however, with the current approach we'd have to state <code>naturality_left</code>, <code>naturality_right</code>, etc., and prove all of these one-by-one by applying naturality laws for the smaller equivalences used as building blocks. This gets a bit painful for sufficiently complex equivalences, and is also very repetitive: <a href=\"https://github.com/sinhp/Poly/commit/b0e1b7a7795facf75b751f7b89e61529ac8fcee3\">here</a> is one such proof I did last year.</p>\n<p>In order to avoid doing more of these, I have been testing out an approach to formalizing the 'obviously' proof. The idea is that a natural equivalence is actually a natural isomorphism of functors into the category of types. For these, naturality is built-in as one of the fields, and crucially we get it for free when isomorphisms are composed. <a href=\"https://github.com/sinhp/Poly/blob/47193337ff0d63f7d86287335675a9ce8b1d2bb3/Poly/UvPoly/UPIso.lean#L39-L69\">Here</a> is that polynomial functor equivalence, now using the functor approach. Recovering mathlib-style naturality laws <a href=\"https://github.com/sinhp/Poly/blob/47193337ff0d63f7d86287335675a9ce8b1d2bb3/Poly/UvPoly/UPIso.lean#L79-L85\">takes two lines</a>.</p>\n<p>Unfortunately, this approach has serious performance issues. The problem is that to even state the two sides of the equivalence, we need to write down what functors they are given by; e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>â†¦</mo><mi>ğ’</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(X,Y) â†¦ ğ’(X,P(Y))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†¦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">))</span></span></span></span> is <code>P â‹™â‚‚ coyoneda</code>, and the RHS is a complicated thing involving <code>Functor.Sigma</code> (which I defined for this purpose).</p>\n<p>In order to recover an ordinary <code>Equiv</code> from the isomorphism, Lean has to see through the action of this functor on objects and compute the original hom-type; this may fall under 'defeq abuse'.</p>\n<p>For example, in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">P.functor.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â‰ƒ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pullback</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">P.p</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Iso.toEquiv</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P.iso_Sigma.app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">equiv_app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"bp\">âŸ¶</span><span class=\"w\"> </span><span class=\"n\">P.functor.obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">P.equiv</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P.iso_Sigma.hom.app</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">Î“</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">equiv</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>the expected type of <code>be</code> appearing as an argument to <code>(P.iso_Sigma.hom.app &lt;| .op Î“).app X</code> is <code>((P.functor â‹™â‚‚ coyoneda).obj (op Î“)).obj X</code>, which indeed computes down to <code>Î“ âŸ¶ P.functor.obj X</code>. The RHS is analogous, except more computation is involved. The end result is that I have theorems which take ~0.3s to prove by <code>simp</code> (so they are fast with <code>set_option debug.skipKernelTC true</code>), but for which kernel typechecking takes ~10s, and in one pathological case upwards of a minute (!).</p>\n<p>I like being able to skip bunch of gnarly proofs, but I have been unable to make this approach work at reasonable speeds.</p>\n<p>I am wondering if anybody else has thought about:</p>\n<ul>\n<li>different ways of stating natural equivalences/universal properties that make 'trivial' naturality proofs trivial in Lean; or</li>\n<li>improving performance in similar situations that seem to rely on defeq abuse; or</li>\n<li>anything else related to this topic and my issue.</li>\n</ul>",
        "id": 513971849,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1745445825
    }
]