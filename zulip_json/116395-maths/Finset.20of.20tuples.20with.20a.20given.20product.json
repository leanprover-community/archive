[
    {
        "content": "<p>I've gradually been working to extract out results from my work on the Selberg sieve to be added to mathlib. For one important bound I use the fact that the number of ways to write a squarefree natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> as a product of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> naturals is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mrow><mi>ω</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\"> k^{\\omega(n)} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span>. </p>\n<p>The proof is currently far too long, and I think cleaning it up would be a good excuse to develop some API around the <code>Finset</code> of k-tuples with a fixed product, as a generalisation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisors#doc\">docs#Nat.divisors</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisorsAntidiagonal#doc\">docs#Nat.divisorsAntidiagonal</a>. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tuplesWithProd</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">Fintype.piFinset</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d.divisors</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∏</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>There's also a connection to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ArithmeticFunction#doc\">docs#Nat.ArithmeticFunction</a>, since the Dirichlet convolution of multiple functions can be expressed as a sum over this set.</p>\n<p>Does this sound reasonable? And does anyone have a better name than <code>tuplesWithProd </code>?</p>",
        "id": 375071409,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689285752
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Nat.antidiagonalTuple#doc\">docs#Finset.Nat.antidiagonalTuple</a> is close, but for sums instead of products</p>",
        "id": 375073240,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689286436
    },
    {
        "content": "<p>I would guess you can implement it in very similar way</p>",
        "id": 375075209,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689287175
    },
    {
        "content": "<p>That definition does look like it's written with computational performance in mind. I doubt that part would transfer over very well since 'number of prime factors' is much slower to recurse on,  but the API is probably a good reference.</p>",
        "id": 375077768,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689288232
    },
    {
        "content": "<p>Yes, computational performance was certainly a consideration there, as powersets blow up very quickly!</p>",
        "id": 375078413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689288391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"585783\">@Arend Mellendijk</span>, we have a very similar construction in <a href=\"https://github.com/YaelDillies/LeanAPAP/blob/master/src/prereqs/cut.lean\">https://github.com/YaelDillies/LeanAPAP/blob/master/src/prereqs/cut.lean</a></p>",
        "id": 375222996,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1689334673
    },
    {
        "content": "<p>Your <code>cut</code> should follow by composing <code>finset.nat.antidiagonal_tuple</code> with <code>trunc_equiv_fin</code>, right?</p>",
        "id": 375225467,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689335247
    },
    {
        "content": "<p>This week, I also extended <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> 's initial definition of tuples to arbitrary <code>canonically_ordered_add_monoid</code>, because we needed it for <code>finsupp</code> Types, but — unfortunately — this does not take multiplicative monoids into account.</p>",
        "id": 375230676,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1689336336
    },
    {
        "content": "<p>Might it be feasible to make a (generalised) definition along Antoine's line for <code>canonically_ordered_monoid</code>, which would be appropriately multiplicative (I think?), then to_additive to recover the Antoine's version and the version in archive and LeanAPAP</p>",
        "id": 375232909,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1689336772
    },
    {
        "content": "<p>I don't think <code>nat</code> is a <code>canonically_ordered_monoid</code> though? Because of <code>0</code>.</p>",
        "id": 375233296,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689336862
    },
    {
        "content": "<p>Maybe <code>nat</code> under divisibility would work, but you'd still have to worry about finiteness surrounding 0</p>",
        "id": 375235094,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689337255
    },
    {
        "content": "<p>The problem is that it is not locally finite. <code>Set.Iic 0</code> is infinite, but all <code>set.Iio n</code> are finite…</p>",
        "id": 375246579,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1689339287
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat#doc\">docs#PNat</a> ?</p>",
        "id": 375247499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1689339431
    },
    {
        "content": "<p>That might make the generalisation work, but I imagine we'd still want some specific API phrased around <code>Nat</code> just so it interacts nicely with the rest of the library.</p>",
        "id": 375252694,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689340072
    },
    {
        "content": "<p>Probably, <code>antidiagonal n</code> (or for tuples) would work on the subtype <code>{ n // Set.Iic n }</code> is finite.</p>",
        "id": 375259876,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1689341023
    },
    {
        "content": "<p>What if you just do what <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.divisorsAntidiagonal#doc\">docs#Nat.divisorsAntidiagonal</a> does and set <code>antidiagonal n</code>to be empty if <code>Set.Iic n</code> is infinite?</p>",
        "id": 375263056,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689341437
    },
    {
        "content": "<p>I'd be worried that's too annoying to work with in general only works out for Nat because there's only one exception</p>",
        "id": 375263517,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1689341498
    },
    {
        "content": "<p>That would be equally fine — and consistent with Lean's philosophy that we want complete functions, with a perfectly reasonable output, actually consistent with <code>Nat.card</code>.</p>",
        "id": 375264810,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1689341660
    }
]