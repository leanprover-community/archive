[
    {
        "content": "<p>I have a question for people who love orders. It was initially a complicated question but then I realized I don’t even know how to answer a baby version. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> be a type and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">φ : Filter(X) → Filter(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">lt</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">lt</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>. Assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> is monotone and is the identity on principal filters. Is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> the identity? The more complicated version is: assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is complete lattice (or more generally a poset where directed sets have an infimum) and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">f : Set(X) → Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> is monotone. Does any monotone extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>F</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">φ : Filter(X) → Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">lt</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> automatically preserve infimums of directed sets?</p>",
        "id": 455930097,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722604231
    },
    {
        "content": "<p>I am pretty sure <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> doesn't need to be the identity</p>",
        "id": 455931134,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722604645
    },
    {
        "content": "<p>Actually, here is a fully explicit counterexample: <code>φ f := generate f.ker</code>. This is the identity on filters with a basis and nowhere else</p>",
        "id": 455931545,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722604809
    },
    {
        "content": "<p>The picture is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> somehow \"completes\" the filter to force it to be based</p>",
        "id": 455931678,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722604856
    },
    {
        "content": "<p>Nice, thanks. I couldn’t see any reason why <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">φ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> would miraculously behave nicely but I didn’t get the right idea to build a counter-example.</p>",
        "id": 455933178,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605418
    },
    {
        "content": "<p>Where does your weird vocabulary comes from? Is it from the theory of pfilters on posets other than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Set(X)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 455933363,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605480
    },
    {
        "content": "<p>What part is the weird vocabulary? I was never officially taught about filters so I'm making the nomenclature up</p>",
        "id": 455933925,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722605666
    },
    {
        "content": "<p>Weird here means non-mathlib.</p>",
        "id": 455933966,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605684
    },
    {
        "content": "<p>If I understand correctly, your <code>generate</code> is called <code>principal</code> in mathlib and what you call based filters are called principal filters.</p>",
        "id": 455934086,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605729
    },
    {
        "content": "<p>But it may be that the mathlib vocabulary is weird. There are definitely people who seem to use the word principal only in the case of singletons.</p>",
        "id": 455934323,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605800
    },
    {
        "content": "<p>No, I mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.generate#doc\">docs#Filter.generate</a></p>",
        "id": 455934377,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722605814
    },
    {
        "content": "<p>Then your formula does not type-check.</p>",
        "id": 455934453,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605844
    },
    {
        "content": "<p>And I am pretty sure I interpret your example in the way you intend it.</p>",
        "id": 455934523,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605864
    },
    {
        "content": "<p>Oh yes you are right, I mean <code>principal f.ker</code></p>",
        "id": 455934542,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722605872
    },
    {
        "content": "<p>Do you know any property of the order on <code>Filter X</code> that is special and can be explained without referring to <code>principal</code>?</p>",
        "id": 455934915,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722605984
    },
    {
        "content": "<p>I’m sorry this is a vague question. What I try to understand better is whether the free completion going from <code>Set X</code> to <code>Filter X</code> by freely adding directed infimums makes <code>Filter X</code> intrinsically better than <code>Set X</code>.</p>",
        "id": 455935245,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722606086
    },
    {
        "content": "<p>The confusing thing compared to other free constructions is that other constructions usually start with a less structured object. For instance building a free group on a set starts with a set and builds a group, and same with free module etc. Here we already have a complete lattice but we are somehow dissatisfied with its (directed) infimums and add new ones.</p>",
        "id": 455935635,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722606176
    },
    {
        "content": "<p>I want to say that the generalisation of principal filters to arbitrary orders is something like compact, prime or irreducible elements, but I haven't checked the details</p>",
        "id": 455935690,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722606188
    },
    {
        "content": "<p>I mean, Kyle would say something something pro-objects, but I am not sure I have a good general intuition for why filters are better than sets.</p>",
        "id": 455936015,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722606260
    },
    {
        "content": "<p>The clear part is this story of directed infimums. Those suck in <code>Set X</code>. For instance the infimum of neighborhoods of <code>x</code> in a nice topological space is <code>{x}</code> and we want to change that. Going to <code>Filter X</code> changes this infimum to <code>nhds x</code> which is larger than <code>{x}</code>. And this is done in a way that any monotone function from <code>Set X</code> to a complete lattice (or even a poset with directed infimum) extends uniquely to a function that preserves directed infs. But I have a hard time seeing whether the infimums in <code>Filter X</code> have a nice property by themselves. A very nice one would be that any monotone function between filters automatically preserved directed infs, but this was fishy and indeed you provided a counter-example.</p>",
        "id": 455936918,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722606495
    },
    {
        "content": "<p>In relation with <code>Set X</code> this is clearer. There is the universal property I mentioned and also the related fact that a directed infimum is less than a principal filter if and only if one element of the set is less than this principal filter.</p>",
        "id": 455937432,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722606615
    },
    {
        "content": "<p>The later statement being <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Filter/Basic.html#Filter.mem_iInf_of_directed\">Filter.mem_iInf_of_directed</a></p>",
        "id": 455937764,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1722606703
    },
    {
        "content": "<p>I interpret the theorem “A filter is the intersection of the ultrafilters it contains” as the fact that the set of filters on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> identifies with the set of subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span>, the Stone-Cech compactification of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>.  Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span> is best viewed as a topological space, my intuition is that the set of filters should also be considered in regard with this topology, but I don't know whether this will help to answer your question.</p>",
        "id": 459588255,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723242706
    },
    {
        "content": "<p>I don’t think this helps me, but thanks anyway.</p>",
        "id": 459666578,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723283473
    },
    {
        "content": "<p>I suspect that <span class=\"user-mention\" data-user-id=\"411579\">@Sam van G</span> would have some idea about your question.</p>",
        "id": 459700175,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723298251
    },
    {
        "content": "<p>Have you seen this? <a href=\"https://mathoverflow.net/questions/139608/a-characterization-of-the-poset-of-filters-on-a-set\">https://mathoverflow.net/questions/139608/a-characterization-of-the-poset-of-filters-on-a-set</a></p>",
        "id": 459700451,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1723298385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/Universal.20property.20of.20inclusion.20of.20principal.20filters/near/459700175\">said</a>:</p>\n<blockquote>\n<p>I suspect that <span class=\"user-mention silent\" data-user-id=\"411579\">Sam van G</span> would have some idea about your question.</p>\n</blockquote>\n<p>I’m not sure what the question is exactly. Section 2 of <a href=\"https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=90a01094111de1b2a52d70f71671a353af02aac4\">this article by Gehrke and Priestley 2008</a> studies the abstract properties of the filter completion of a poset (they focus on adding directed joins but mathematically it’s of course the same, modulo adding a few “op”s in the right places).</p>",
        "id": 459766218,
        "sender_full_name": "Sam van G",
        "timestamp": 1723326379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/Universal.20property.20of.20inclusion.20of.20principal.20filters/near/455937432\">said</a>:</p>\n<blockquote>\n<p>In relation with <code>Set X</code> this is clearer. There is the universal property I mentioned and also the related fact that a directed infimum is less than a principal filter if and only if one element of the set is less than this principal filter.</p>\n</blockquote>\n<p>The second property is a special case of what is called “compact completion” in that section. It is indeed closely related to topological compactness.</p>",
        "id": 459768394,
        "sender_full_name": "Sam van G",
        "timestamp": 1723327072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/Universal.20property.20of.20inclusion.20of.20principal.20filters/near/455934915\">said</a>:</p>\n<blockquote>\n<p>Do you know any property of the order on <code>Filter X</code> that is special and can be explained without referring to <code>principal</code>?</p>\n</blockquote>\n<p>The comparison with free groups is indeed a useful one to think about: As you know, the construction that sends Set(X) to Filter(X) is a special case of the construction that sends a poset P to a the poset F(P) of filters in (not “on”!) P. So when doing this construction, you actually first “forget” almost all the complete lattice (even complete atomic Boolean algebra) structure that you have on Set(X), except for the fact that it’s a poset.<br>\nNow one can ask the interesting question: If P is a “special” poset and I look at its filter poset F(P), how can the “specialness” of P be felt on F(P)? One such property is for example stated as Prop 2.3 of the cited paper (I just reverse the statement here wrt the paper to better fit your filter intuitions): If P had finite sups to begin with, then so does F(P).  In Lemma 2.4, some extension properties for functions are given.</p>",
        "id": 459769582,
        "sender_full_name": "Sam van G",
        "timestamp": 1723327686
    },
    {
        "content": "<p>As is also shown there, the embedding e : P -&gt; F(P) can be characterized abstractly as the unique completion of P which has directed meets, is generated by P under directed meets, and which satisfies the property that, whenever a meet of a directed set D is below an element e(p) where p in P, then at least one of the elements of D is below e(p).<br>\nTo state this property, though, one must refer to the elements of the “generating” poset P. But this is analogous to the fact that when you say a set X freely generates the free group FG(X), you need to refer to X when you state that there are no relations between the generators.</p>",
        "id": 459770704,
        "sender_full_name": "Sam van G",
        "timestamp": 1723328721
    },
    {
        "content": "<p>Is there anything else to say beyond the pro objects point of view? For example the characterization of principal filters discussed above is analogous to the notion of a compact object as described here <a href=\"https://ncatlab.org/nlab/show/compact+object\">https://ncatlab.org/nlab/show/compact+object</a> (or rather its dual since compact objects would be the analogue for ind-objects). And in terms of the universal property of the lattice of filters, it should correspond exactly to the universal property of the pro-category, which should translate to saying that any monotone map from <code>Set X</code> to <code>T</code>, where <code>T</code> has directed infs, extends uniquely to a monotone map from <code>Filter X</code> to <code>T</code> which preserves all directed infs.</p>",
        "id": 459834897,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1723357645
    },
    {
        "content": "<p>Thanks Sam, this is all useful. I’ll read that paper. I like the confirmation of the characterization I was hoping for, but I still don’t have a good story about how <code>F(P)</code> is better than <code>P</code> when <code>P</code> was already a complete lattice. I think the best summary of what bothers me is: “if I start with something that is already complete then anything called a completion should not change it up to isomorphism”.</p>",
        "id": 459876876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723373367
    },
    {
        "content": "<p>Since we are here, does anyone know whether <code>F(P)</code> can be seen as a category of sheaves on <code>P</code> (with <code>e</code> being the Yoneda embedding)?</p>",
        "id": 459877073,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1723373409
    },
    {
        "content": "<p>Patrick you may want to look at <a href=\"https://ncatlab.org/nlab/show/ind-object#the_case_that__already_admits_filtered_colimits\">https://ncatlab.org/nlab/show/ind-object#the_case_that__already_admits_filtered_colimits</a> (again, this is in the categorical context and for ind-objects, but something analogous can be said in you context as well)</p>",
        "id": 459894522,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1723387142
    },
    {
        "content": "<p>In other words, it’s not just about completeness in the sense that directed infs exist, but also that the lattice is generated under directed infs by “cocompact” objects. This generation condition will not hold true in general even if directed infs exist, and <code>Set X</code> is an example.</p>",
        "id": 459937287,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1723406708
    },
    {
        "content": "<p>I have a few comments to add to what Sam said. This does reiterate part of both what he and Adam Topaz have already said. Sorry about that. </p>\n<p>When going from Powerset(X) to Filt(X), which from the point of view of ordered sets should really rather be called Filt(Powerset(X)), the first step is to FORGET — at least — the infinitary meets structure of Powerset(X) (you can keep just the order, the finite joins, the arbitrary joins structure, and/or the finite meets structure), THEN you freely add down-directed (=filtering) meets.</p>\n<p>To follow the analogy with groups, if you take a group G, forget its structure and just keep the underlying set, then take the free group over that, there is not much you can say about the relation to the original group structure. Of course, this is not that bad because in the case of Powerset(X)\\mapsto Filt(Powerset(X)), we do keep the order (so a weak part of the structure of Powerset(X)).</p>\n<p>The good news is, for very general reasons, as Sam said:</p>\n<ul>\n<li>the poset Powerset(X) has finite meets, and therefore Filt(Powerset(X)) does also ! (and the embedding preserves these). In fact, as a consequence Filt(Powerset(X)) has all meets and is in fact a complete lattice. </li>\n<li>Powerset(X) has arbitrary joins and the embedding preserves these.</li>\n</ul>\n<p>However, the embedding DESTROYS ALL non-trivial directed meets (that is, the embedding destroys meets of any filtering set, which doesn’t have a minimum)!<br>\nIn fact, when one does the construction P\\mapsto Filt(P) to a poset which already has filtering meets this is usually precisely what one is seeking: the existing filtering meets give faulty information about the limit behaviour of the finitary order/meet structure of the poset. Sorry that this last part is a bit vague, but I think it gets at what you, Patrick, are asking in your last post</p>\n<blockquote>\n<p>good story about how <code>F(P)</code> is better than <code>P</code> when <code>P</code> was already a complete lattice</p>\n</blockquote>\n<p>It is better precisely in that we have destroyed the nontrivial filtering meets!!!</p>\n<p>If we take the free filtering meets completion in the category of posets enriched with \"partially existing filtering meets\" (this corresponds to taking filters closed under existing filtering meets), then from Powerset(X) we indeed just get Powerset(X), but I suspect, in whatever capacity you are using Powerset(X)\\mapsto Filt(Powerset(X)), you probably want to encode \"downward limit behaviour\" of the finitary meet structure of Powerset(X). This is the point of (co-)compactness. This is also what Adam Topaz is talking about, I think.</p>\n<p>Just to finish up the round of nice complete lattice properties possessed by Powerset(X):</p>\n<ul>\n<li>It is meet generated by its co-atoms and is a co-frame. This all remains true for Filt(Powerset(X));</li>\n<li>It is join generated by its atoms and is a frame. This is NOT true for Filt(Powerset(X)). It is atomic as every filter is an intersection of ultrafilters (assuming these exist), but it is not a frame as every atomic frame is isomorphic to the powerset of its atoms. This is not true for Filt(Powerset(X)), e.g.  it isn't Boolean.</li>\n<li>It is completely distributive. This is not true for Filt(Powerset(X)) since it isn't even a frame.<br>\n(Here \"frame\" means complete lattice in which arbitrary joins distribute over finite meets)</li>\n</ul>",
        "id": 462960458,
        "sender_full_name": "Mai Gehrke",
        "timestamp": 1723887963
    }
]