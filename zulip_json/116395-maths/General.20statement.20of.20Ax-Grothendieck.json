[
    {
        "content": "<p>Wikipedia and Terry Tao say that the general statement of the Ax-Grothendieck is that it's true for any map from an algebraic variety to itself. I understand how to use model theory to prove the statement for the zero-set of a finite set of polynomials, but I don't understand straight away how to do it for infinite sets of polynomials? Does this follow from the finite case?</p>",
        "id": 385724883,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692294777
    },
    {
        "content": "<p>Variety usually means finite type</p>",
        "id": 385725363,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1692295024
    },
    {
        "content": "<p>The zero set of an infinite set of polynomials (in finitely many variables) is the zero set of a finite subset of these polynomials, because the ring of polynomials (over a field) is noetherian.</p>",
        "id": 385767229,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1692314302
    },
    {
        "content": "<p>\"Finite type\" means in finitely many variables, finite presentation means finite type + defined by finitely many polynomials. Over a noetherian ring (e.g. a field) they are equivalent <a href=\"https://stacks.math.columbia.edu/tag/00FP\">stacks#00FP</a>, because the ring of polynomials over a noetherian ring is also noetherian (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.isNoetherianRing#doc\">docs#MvPolynomial.isNoetherianRing</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.isNoetherianRing#doc\">docs#Polynomial.isNoetherianRing</a>).</p>",
        "id": 385811078,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692330738
    },
    {
        "content": "<p>Okay, Thanks everyone. The statement I went for was this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsAlgClosed</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ax_grothendieck_zeroLocus</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">zeroLocus</span> <span class=\"n\">I</span>\n    <span class=\"n\">S.MapsTo</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.InjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.SurjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 385911422,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692364819
    },
    {
        "content": "<p>I tried several spellings using Lean 4's succinct function notation and not all them work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">p</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">works</span>\n<span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">·</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">doesn't</span> <span class=\"n\">work</span>\n<span class=\"o\">(</span><span class=\"n\">MvPolynomial.eval</span> <span class=\"bp\">·</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">p</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">works</span><span class=\"o\">,</span> <span class=\"n\">preferred</span> <span class=\"n\">spelling</span><span class=\"bp\">?</span>\n<span class=\"o\">(</span><span class=\"n\">MvPolynomial.eval</span> <span class=\"bp\">·</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">doesn't</span> <span class=\"n\">work</span>\n<span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"bp\">·</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">works</span>\n<span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"bp\">·</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">works</span>\n<span class=\"n\">replacing</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"bp\">$</span> <span class=\"n\">also</span> <span class=\"n\">works</span>\n</code></pre></div>\n<p>By the way, is it easy to make a pretty printer for such function notation? Not that it help much in this case, but it would make the co(ntra)variance assumptions in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=add_eq_add_iff_eq_and_eq#doc\">docs#add_eq_add_iff_eq_and_eq</a> etc. much more readable.</p>",
        "id": 385941500,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692372231
    },
    {
        "content": "<p><code>(MvPolynomial.eval · &lt;| p ·)</code> seems absolutely unreadable</p>",
        "id": 385946221,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1692374073
    },
    {
        "content": "<p>I think Ax-Grothendieck is fairly easily generalizable to rational functions, or even I guess functions definable in the language of fields. I don't know if people are interested in these generalizations</p>",
        "id": 386109140,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692454596
    },
    {
        "content": "<p>What is the version of injectivity you want to allow if you're allowing infinity as a value?</p>",
        "id": 386376533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692620550
    },
    {
        "content": "<p>Grothendieck himself already formulated a very general statement in EGA, see  10.4.11 in <a href=\"http://www.numdam.org/article/PMIHES_1966__28__5_0.pdf\">http://www.numdam.org/article/PMIHES_1966__28__5_0.pdf</a> . Note that preschemes there are nowadays just called schemes.<br>\nTranslation into modern english that statement reads:</p>\n<p>Let S be a scheme, and X be a scheme over S of finite type. Then every S endomorphism of X that is <a href=\"https://en.wikipedia.org/wiki/Radicial_morphism\">radical</a> is surjective (and hence bijective).</p>\n<p>It think it would be awesome if you could prove it in this generality just because it means we have enough scheme theory in Mathlib to reduce the statement for arbitrary <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to the case where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is itself of finite type over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>",
        "id": 386456246,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692644588
    },
    {
        "content": "<p>I'm not really very good at algebraic geometry. Can it be proven with similar methods in model theory, or is it completely different?</p>",
        "id": 386458048,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692645368
    },
    {
        "content": "<p>It is a completely different proof. Theorem 3.1 of <a href=\"https://arxiv.org/pdf/0903.0517.pdf\">https://arxiv.org/pdf/0903.0517.pdf</a> has a good short overview of how Grothendiecks proof goes, in a slightly less general setting that proof sketch is really short and understandable.</p>",
        "id": 386463047,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692647693
    },
    {
        "content": "<p>I'm not sure we do have enough scheme theory and it would take me quite a bit of time to understand that stuff. I guess realistically I won't be doing the general version unless someone writes me a clear explanation of how and it turns out to be easier than it sounds. I think it might have to wait.</p>",
        "id": 386682578,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692733867
    },
    {
        "content": "<p>Chris you could just restrict to the affine case over an alg closed field (which covers C^n but also all Zariski-closed subspaces of C^n, i.e. subspaces defined by polynomial equations). Then it really is just ring theory and at the end of the day the proof in Lean would be much simpler than the model theory one.</p>",
        "id": 386684057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692734507
    },
    {
        "content": "<p>Isn't that what I did prove? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ax_grothendieck_zeroLocus</span>\n    <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">Ideal</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">zeroLocus</span> <span class=\"n\">I</span>\n    <span class=\"n\">S.MapsTo</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.InjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.SurjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">MvPolynomial.eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>",
        "id": 386689307,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692736870
    },
    {
        "content": "<p>Or maybe you need the slightly more general one </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ax_grothendieck_of_definable</span> <span class=\"o\">[</span><span class=\"n\">CompatibleRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">c.Definable</span> <span class=\"n\">Language.ring</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">S.MapsTo</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.InjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"n\">S.SurjOn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eval</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">ps</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p><code>CompatibleRing</code> just means that it's a mode-theoretic ring structure and a ring in a way that's compatible.</p>",
        "id": 386689542,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692736992
    },
    {
        "content": "<p>My initial impression is that these non-model theoretic proofs are more or less the same as the model-theoretic proof. The model theoretic proof works basically by exhibiting an alg-closed field of char zero as an ultraproduct of <span class=\"tex-error\">$$\\overline{\\mathbb{F}_p$$</span>, and it seems maybe these other proofs do the same thing, and then more or less prove a special case of Łoś's Ultraproduct theorem, by proving for a simple formula what Łoś proved for all formulas. I'm just guessing about what's going on here, I could be completely wrong.</p>",
        "id": 386698258,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692739785
    },
    {
        "content": "<blockquote>\n<p>Isn't that what I did prove?</p>\n</blockquote>\n<p>Probably. I don't think I understand the statement. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.zeroLocus#doc\">docs#MvPolynomial.zeroLocus</a></p>",
        "id": 386700294,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692740825
    },
    {
        "content": "<p>Yes, you've already done the affine case over an alg closed base. My understanding is that Grothendieck generalised this in three ways: he weakens the alg closed field base first to an arbitrary commutative ring (where now you have to look at prime ideals rather than just closed points) and then to a scheme, and he generalised the variety over the base from an affine one to a general one, so all the next steps are schemey except that you could change K to a commring and use PrimeSpectrum instead of iota -&gt; K.</p>",
        "id": 386701046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692741227
    },
    {
        "content": "<p>Is that easy?</p>",
        "id": 386702634,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692741835
    },
    {
        "content": "<p>And I guess I'm just curious, is what I've proved useful for proving the most general case, or do you have to start over and do something totally different?</p>",
        "id": 386702874,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692741963
    },
    {
        "content": "<p>I should imagine that what you have is already useful. I haven't looked at the Grothendieck proof but results in algebraic geometry are often proved by reducing them to simpler cases such as the one you've already proved.</p>",
        "id": 386703871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692742367
    },
    {
        "content": "<p>Yes, Grothendieck reduces from a general base to a field, although unfortunately he doesn't reduce to the affine case.</p>",
        "id": 386704303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692742614
    },
    {
        "content": "<p>A field or an Algebrically Closed field?</p>",
        "id": 386704354,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692742653
    },
    {
        "content": "<p>I'm seeing the French word \"Or\" which has no translation in English so I'm told.</p>",
        "id": 386704631,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692742807
    },
    {
        "content": "<p>So I guess we're using the fact that any subfield of C is an ultraproduct of subfields of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><msub><mi mathvariant=\"double-struck\">F</mi><mi>p</mi></msub><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{F}_p}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.175em;vertical-align:-0.2861em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span> or something like that. Which is a little more general than what the model theory stuff uses.</p>",
        "id": 386704925,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692742958
    },
    {
        "content": "<p>Yeah he reduces to a field and then to a finitely generated ring and then he appeals to a general result about the image being constructible. You have to understand \"injective\" in terms of the scheme points though. I wonder if the HoTT people can prove it? The hard part might be stating it.</p>",
        "id": 386705132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692743070
    },
    {
        "content": "<p>What is HoTTy about this theorem? I don't understand why HoTT is relevant. It should be constructively provable if you can constructively prove completeness of ACF_p, by doing the quantifier elimination algorithm</p>",
        "id": 386706404,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692743576
    },
    {
        "content": "<p>The image being constructible sound a bit like quantifier elimination</p>",
        "id": 386707340,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692744208
    },
    {
        "content": "<p>Grothendieck's version of the theorem states that a map is surjective, by which he means \"surjective on scheme-theoretic points\". At least one HoTT construction of schemes which I have seen did not have an API for the scheme-theoretic points with its topological space structure, but \"surjective\" is a statement about this structure.</p>",
        "id": 386708770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692745182
    },
    {
        "content": "<p>\"scheme-theoretic points\" is different to \"functor of points\".</p>",
        "id": 386708876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692745228
    },
    {
        "content": "<p>I kind of think this discussion is useless unless I know exactly what's going on. You say reduce to a field, but clearly x^3 : Q-&gt;Q is injective and not surjective. I don't think it can be explained by halves.</p>",
        "id": 386709533,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1692745590
    },
    {
        "content": "<p>Q is not the scheme-theoretic points of affine 1-space over Q. The scheme-theoretic points biject with the monic irreducible polynomials and there are a lot more of these than those of the form <code>X - q</code>. The point <code>X^2+X+1</code> gets mapped to <code>X - 1</code> by cubing, as does <code>X - 1</code>.</p>",
        "id": 386711340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692746803
    },
    {
        "content": "<p>Over an alg closed field, the field bijects with the monic irreducible polynomials over the field because they're all degree 1. But for a general field they become different concepts. It's really important to use this more abstract one rather than the \"solutions to the equation over the field\" one (the one used by Weil and all the classical people) because for a field like the rationals most equations have no solutions at all, so how are you going to tell x^7+y^7=z^7 and x^11+y^11=z^11 apart -- their solution set is the same. But the prime ideals of Q[x,y,z] containing x^7+y^7-z^7 are very different to those containing x^11+y^11-z^11.</p>",
        "id": 386711841,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692747139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/116395-maths/topic/General.20statement.20of.20Ax-Grothendieck/near/386704631\">said</a>:</p>\n<blockquote>\n<p>I'm seeing the French word \"Or\" which has no translation in English so I'm told.</p>\n</blockquote>\n<p>I would usually translate it by \"but indeed\". If you give me more context, I can be more precise.</p>",
        "id": 386781938,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1692775989
    },
    {
        "content": "<p>I'm a little bit late in replying here, but there is at least no obvious use of ultraproducts in Grothendieks proof. The key idea from Grothendieck  restricted to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb C^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> for simplicity is that if you have a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant=\"double-struck\">C</mi><mi>n</mi></msup><mo>→</mo><msup><mi mathvariant=\"double-struck\">C</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">f: \\mathbb C^n \\to \\mathbb C^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> described by multivariate polynomials  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_1, \\ldots, f_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then there  is a finite set  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊂</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">S \\subset \\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> that contains all coefficients of these polynomials. So in fact f can be defined over the finitely generated subring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo><mo>⊂</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z[S] \\subset \\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>, and now suddenly you know that since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is finite there will be infinitely many primes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> for which  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mi>p</mi><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z[S]/ p \\mathbb Z[S]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> is not the zero ring. So suddenly you can relate geoemetry in characteristic 0 to geometry in characteristic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>.</p>",
        "id": 387030301,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692869480
    },
    {
        "content": "<p>Although I wouldn't be surprised if some parts of the proof would be translatable. For example Grothendieck uses the fact that being radical is a constructible property and being surjecitive is one as well. Which allows him to deduce that f is radical if an only if there is a finite subset <span class=\"tex-error\">$$S\\subset \\C$$</span> such that f \"restricted\" to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z[S]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> is radical. And the same for surjectiveness  (however for surjectiveness it is the scheme theoretic sense of surjectiveness meaning $f : \\mathbb A^n_{\\matbb Z[S]} \\to \\mathbb A^n_{\\matbb Z[S]}$ is surjective. And a lot of the reduction steps in the proof that reduce it to finitely generated rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb Z[S]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> feel like a kind of compactness theorem from model theory. However it is not clear to me if this is just something that looks the same on first sight or wether there is a deeper connection.</p>",
        "id": 387043587,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692873977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"637200\">@Maarten Derickx</span> note that we have a ton of stuff about Jacobson rings in mathlib, but I don't think we have that the image of a constructible set is construcible</p>",
        "id": 387044923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692874457
    },
    {
        "content": "<p>Does mathlib even have the definition of constructible sets?</p>",
        "id": 387046251,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1692874927
    },
    {
        "content": "<p>This is all topology rather than alg geom but not as far as I know.</p>",
        "id": 387046404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692874989
    },
    {
        "content": "<p>A proof of Chevalley's theorem was my first dream when I started with mathlib.  I think that I got to formalizing that the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Spec</mtext><mtext> </mtext><mi>k</mi><mo stretchy=\"false\">[</mo><mi>t</mi><mo stretchy=\"false\">]</mo><mo>→</mo><mtext>Spec</mtext><mtext> </mtext><mi>k</mi></mrow><annotation encoding=\"application/x-tex\"> {\\textrm{Spec}} \\, k[t] \\to {\\textrm{Spec}} \\, k </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord textrm\">Spec</span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord textrm\">Spec</span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is open: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.Polynomial.isOpenMap_comap_C#doc\">docs#AlgebraicGeometry.Polynomial.isOpenMap_comap_C</a>.</p>",
        "id": 387051195,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692876686
    }
]