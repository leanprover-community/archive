[
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/3965\">!4#3965</a>, a new tactic (written with <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>) for \"relational congruence\" reasoning:  reducing a relational goal between a LHS and RHS matching the same pattern to relational subgoals between the differing inputs to the pattern.  For a quick sense of the style of argument facilitated by the tactic, <a href=\"https://github.com/leanprover-community/mathlib4/commit/9a5e0ce9f9b714fd5383610a12746cded21f030f\">this commit</a> (which will be PR'd separately) gives &gt;100 examples of use cases in the existing library.  Common themes: inequalities, calc blocks, \"hard\" (as opposed to \"soft\") analysis.</p>\n<p>A typical example is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">x</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">‚â§</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">‚â§</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rel_congr</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">linarith</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>This example has the goal of proving the relation <code>‚â§</code> between a LHS and RHS both of the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>\n<p>(with inputs <code>a</code>, <code>c</code> on the left and <code>b</code>, <code>d</code> on the right).  After the use of <code>rel_congr</code>, we have the simpler goals <code>a ‚â§ b</code> and <code>c ‚â§ d</code>.</p>",
        "id": 358182177,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684024215
    },
    {
        "content": "<p>The tactic has various convenience features:</p>\n<ul>\n<li>a pattern can be provided explicitly (same syntax as the mathlib3 <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#congrm\"><code>congrm</code> tactic</a>), which is convenient if a non-maximal match is desired</li>\n<li>an extensible discharger (currently just wrapping <code>positivity</code>) is run to try to resolve goals identified as \"side goals\" (for example, the fact <code>0 ‚â§ x ^ 4</code> in the example above)</li>\n</ul>",
        "id": 358182812,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684024495
    },
    {
        "content": "<p>FAQ:</p>\n<p><strong>Couldn't Aesop do this?</strong></p>\n<p>Aesop is optimized for writing finishing tactics, whereas the crucial use case of this tactic is as a \"mid-proof\" tactic: cleaning up the goal before the \"real proof\".  An important situation where this matters is when there are several lemmas which match the goal.  For example, consider the following two lemmas which both deal with <code>‚â§</code> comparisons between products in <code>‚Ñö</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">mul_le_mul</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a1</span> <span class=\"bp\">*</span> <span class=\"n\">b1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a2</span> <span class=\"bp\">*</span> <span class=\"n\">b2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">b2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b1</span> <span class=\"bp\">‚â§</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b2</span>\n</code></pre></div>\n<p>The latter lemma only applies to left-constant products (<code>a * b1 ‚â§ a * b2</code>), but it is strictly more useful in this situation, requiring fewer side conditions.  One wants the tactic to prefer the latter lemma in that situation.  A finishing tactic doesn't necessarily need a preference: it can just try both and backtrack as needed.</p>\n<p>Aesop <em>can</em> support this preference, by assigning a higher priority to the latter lemma (and <code>solve_by_elim</code>, which I used in the prototype implementation, can achieve this by the back door if you tag the lemmas in the right order!), but <code>rel_congr</code> does this in a more principled way:  it has a pre-built array of which arguments to the head function <code>*</code> vary between the two sides in the conclusion of the lemmas (so, neglecting implicit arguments, <code>#[true, true]</code> for the first and <code>#[true, false]</code> for the second), and only tries to apply lemmas with the correct array.</p>\n<p>The pattern feature <code>rel_congr x ^ 4 * ?_ + _</code>, allowing the user to specify the degree of matching desired, is also an important facet of the tactic's usability as a mid-proof tactic, and it would not be possible to get this from an Aesop implementation.</p>",
        "id": 358184501,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684025112
    },
    {
        "content": "<p><strong>Isn't this just <code>mono</code>?</strong></p>\n<p>Yes and no.  Both tactics build a tagged family of library lemmas whose conclusions are of the form <code>f [args‚ÇÅ] ‚àº f [args‚ÇÇ]</code>, and operate by throwing these lemmas at the goal. The closest comparison to <code>rel_congr</code> is actually <code>mono*</code>, the iterating version of <code>mono</code>.</p>\n<ol>\n<li>\n<p><code>rel_congr</code> improves on <code>mono*</code> by including a discharger which attempts to resolve side conditions (whereas the recursion is only run on the main conditions).  The mechanism identifying which lemma preconditions are \"side\" rather than \"main\" is rather fundamental, and it would require some work to backport this to <code>mono</code>: the \"main\" antecedents to the lemma are those which are relations between a pair of free variables which occur in matching positions on the LHS and RHS of the conclusion of the lemma.</p>\n</li>\n<li>\n<p>For the issue described above (re: <code>aesop</code>) when a more general and a more specific lemma apply, both <code>rel_congr</code> and <code>mono*</code> are clever enough to prefer the more specific lemma, but their mechanisms are different.  The <code>mono*</code> tactic will try to apply both lemmas, and prefer the second by noticing that they both succeed but that the second generates fewer new goals.  This is potentially less efficient, as well as less predictable, than the mechanism in <code>rel_congr</code>.</p>\n</li>\n<li>\n<p>The pattern feature <code>rel_congr x ^ 4 * ?_ + _</code> is new.</p>\n</li>\n<li>\n<p>The philosophy for tagging congruence lemmas is different between <code>@[rel_congr]</code> and <code>@[mono]</code>.  For example, both of these lemmas are tagged <code>@[mono]</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem mul_le_mul_of_nonneg_left (hb : b1 ‚â§ b2) (ha_pos : 0 ‚â§ a) : a * b1 ‚â§ a * b2\n\ntheorem mul_le_mul_of_nonpos_left (hb : b2 ‚â§ b1) (ha_neg : a ‚â§ 0) : a * b1 ‚â§ a * b2\n</code></pre></div>\n\n<p>In practice, this causes <code>mono*</code> to fail often, printing a message asking for more input from the user (the user then provides syntax such as <code>mono* with b1 ‚â§ b2</code>).  By contrast, <code>rel_congr</code> will run with the first lemma which works, so fewer lemmas should be tagged <code>@[rel_congr]</code> -- the heuristic is to tag only the most likely one for a given situation.</p>\n</li>\n</ol>",
        "id": 358186090,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684025638
    },
    {
        "content": "<p>This is a really interesting development! I guess it's going to be slower than just writing the term, but is it still fast?</p>",
        "id": 358186405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684025744
    },
    {
        "content": "<p>I'll let <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> comment.  It's pretty fast.</p>",
        "id": 358186524,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684025775
    },
    {
        "content": "<p>well, things take time, I'm not sure if it's the things we wrote</p>",
        "id": 358186680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684025837
    },
    {
        "content": "<p>I don't think it should be a very slow tactic. It should be roughly on par with <code>rw</code></p>",
        "id": 358186863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684025893
    },
    {
        "content": "<p>I will point out that in addition to being convenient for the <em>author</em> of the code (I hope no one will ever need to memorize the lemma name <code>mul_le_mul_of_nonneg_left</code> again), this tactic should produce proofs which are more comprehensible for the <em>readers</em> of the code, automating a certain class of boilerplate so that the actual ideas stand out better.</p>\n<p>Analogy: once you are used to calling the tactic <code>ext</code>, how often have you cared about exactly which extensionality lemmas it is applying?</p>",
        "id": 358189026,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684026648
    },
    {
        "content": "<blockquote>\n<p>for example, both of these lemmas are tagged <code>@[mono]</code></p>\n</blockquote>\n<p>Which of these lemmas does your new tactic use?</p>",
        "id": 358215441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684051099
    },
    {
        "content": "<p>(and can it be persuaded to use the other one that it doesn't use by default?)</p>",
        "id": 358215504,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684051146
    },
    {
        "content": "<p>This looks like a great tactic. I hope it can replace my idea of having generalised rewrite.</p>",
        "id": 358218620,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1684053105
    },
    {
        "content": "<p>I agree! I can see how it can make pen and paper style <code>calc</code> proofs much nicer in some cases.</p>",
        "id": 358219501,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684053517
    },
    {
        "content": "<p>This looks really nice! I think this has especially great potential if we could combine it with interface improvements to type calc blocks. On Thursday I ran an intro to Lean afternoon based on a compressed version of the tutorials project but participants were extremely slow to formalize computations, in particular because they had such a hard time getting the calc syntax right. I don't really understand why, but it seems Lean 4 makes this harder, maybe because the underscore leading calc lines is so hard to spot.</p>",
        "id": 358224927,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1684056391
    },
    {
        "content": "<p>10 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Autogenerating.20parts.20of.20.02klzzwxh.3A0000.03s\">#maths &gt; Autogenerating parts of <code>calc</code>s</a> by <span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span>.</p>",
        "id": 358280339,
        "sender_full_name": "Notification Bot",
        "timestamp": 1684079368
    },
    {
        "content": "<p>One issue I had with <code>mono</code> (don't remember Lean version): it was unable to prefer <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul%27\">docs#mul_le_mul'</a> (not tagged <code>mono</code> because of this bug) over <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_le_mul\">docs#mul_le_mul</a> for natural numbers.</p>",
        "id": 358286008,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684081707
    },
    {
        "content": "<p>Can your tactic do this?</p>",
        "id": 358286030,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1684081717
    },
    {
        "content": "<p>It does by a fluke of tagging order, but it also doesn't matter, because <code>positivity</code> (the discharger) resolves those side goals even if they are created.</p>",
        "id": 358286151,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684081760
    },
    {
        "content": "<p>I also want to bikeshed a bit about tactic naming.  I would like this tactic to be called <code>rcongr</code>, placing the emphasis on the <code>congr</code> part, and saving a few characters for something which I hope will be used often (already &gt;100 times if my <a href=\"https://github.com/leanprover-community/mathlib4/commit/9a5e0ce9f9b714fd5383610a12746cded21f030f\">golfing commit</a> goes through).  Currently that name is taken by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.rcongr#doc\">docs4#Std.Tactic.rcongr</a>, which is used once in the library.</p>",
        "id": 358301044,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684088250
    },
    {
        "content": "<p>/poll Which tactic should get the name <code>rcongr</code>?<br>\nStatus quo: \"repeatedly apply <code>congr</code> and <code>ext</code>\"<br>\nProposed change: \"relational <code>congr</code>\"</p>",
        "id": 358301061,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684088262
    },
    {
        "content": "<p>Current <code>rcongr</code> could be renamed to <code>ext_congr</code>, maybe?</p>",
        "id": 358303192,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1684089174
    },
    {
        "content": "<p>Does <code>congr_rel</code> relate to <code>congr</code> the same way as <code>rintro</code> to <code>intro</code> and <code>rcases</code> to <code>cases</code>?<br>\nIf not, I assume there is some confusion that can be avoid by sticking to <code>congr_rel</code> or <code>rel_congr</code>.</p>",
        "id": 358315266,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684095224
    },
    {
        "content": "<p>Neither the status-quo <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.rcongr#doc\">docs4#Std.Tactic.rcongr</a> nor our \"relational <code>congr</code>\" have the <code>r</code> meaning from <code>rintro</code>/<code>rcases</code>.  So maybe you want a third option, \"neither\"!</p>",
        "id": 358315392,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684095308
    },
    {
        "content": "<p>I was actually tempted to add that. Maybe I should. Did it :-)</p>",
        "id": 358315409,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684095328
    },
    {
        "content": "<p>How does this fit in with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.interactive.congrm\">docs#tactic.interactive.congrm</a>?</p>",
        "id": 358320271,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684098677
    },
    {
        "content": "<p>That name would suggest <code>congrr</code></p>",
        "id": 358320299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684098702
    },
    {
        "content": "<p>In some sense this tactic is doing <code>congrmr</code>, in that it implements the pattern feature from <code>congrm</code> as well as the relation-handling functionality.</p>",
        "id": 358322788,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684100792
    },
    {
        "content": "<p>Would it make sense to just merge it with <code>congrm</code>?</p>",
        "id": 358323068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684101042
    },
    {
        "content": "<p>Which is to say; does <code>rel_congr</code> know how to deal with the <code>=</code> relation by looking at regular <code>congr</code> lemmas?</p>",
        "id": 358323109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684101082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/New.20tactic.20for.20.22relational.20congruence.22/near/358323109\">said</a>:</p>\n<blockquote>\n<p>does <code>rel_congr</code> know how to deal with the <code>=</code> relation by looking at regular <code>congr</code> lemmas?</p>\n</blockquote>\n<p>I'd like that, but it doesn't yet (and nobody ported <code>congrm</code> yet).  I don't really know how you get your hands on all the autogenerated <code>congr</code> lemmas.</p>",
        "id": 358323187,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684101132
    },
    {
        "content": "<p>Perhaps the compromise for now is to have <code>congrm</code> be essentially:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"n\">head_symbol</span> <span class=\"bp\">==</span> <span class=\"n\">Eq</span> <span class=\"k\">then</span>\n   <span class=\"n\">do_the_old_congrm</span>\n<span class=\"k\">else</span>\n   <span class=\"n\">do_the_new_rel_congr</span>\n</code></pre></div>",
        "id": 358323469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684101391
    },
    {
        "content": "<p>Recursing back and forth between the two modes might be useful, but certainly isn't necessary in the short term</p>",
        "id": 358323533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684101436
    },
    {
        "content": "<p>I'd prefer to combine them in that way but under the name <code>rcongr</code>!  Because in my opinion the \"relational\" part is more fundamental than the \"match\" syntax option.  However, let's wait for more opinions.</p>",
        "id": 358324417,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684102192
    },
    {
        "content": "<p>It's also possible we could just call them all <code>congr</code></p>",
        "id": 358324573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684102324
    },
    {
        "content": "<p>I like that idea, but there are some delicate things that might need to get ironed out.  For example, one thing I've really found convenient about <code>congrm</code> is that you can use the pattern-match to force Lean to unfold something it doesn't unfold with <code>congr</code>.  I guess it's a difference in the transparency of a certain step in the implementation.  Our <code>rel_congr</code> doesn't currently make a transparency distinction according to whether a pattern is present but maybe it should.</p>",
        "id": 358324846,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1684102624
    },
    {
        "content": "<p>I have some memory that <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> made <code>congr</code> more powerful in mathlib4 than it was in mathlib3, though perhaps I'm getting confused with <code>convert</code></p>",
        "id": 358325142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684102927
    },
    {
        "content": "<p>I added <code>congr!</code> to be more careful and more powerful than the built-in <code>congr</code> tactic (and <code>congr</code> is a bit less powerful than Lean 3's <code>congr</code>, for example it doesn't know about <code>Subsingleton</code>).</p>\n<p><code>congr!</code> aims to do congruence: equating the things on both sides of an equality that correspond to each other. It avoids unfolding definitions to do this since this can be rather unpredictable (though there are some configuration options to make it unfold things in a <code>congr</code>-like way).</p>\n<p>I think the way <code>congr</code> unfolds things is sort of accidental. The way it works is it takes the LHS of an equality, generates a congruence lemma, and then applies it to the target. As a consequence, this can make the RHS unfold.</p>\n<p>The way <code>congrm</code> takes a pattern that directs how to unfold things is more principled. I suppose it's like a 3-way diff, and the resulting goals are the merge conflicts.</p>",
        "id": 358330639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684108019
    },
    {
        "content": "<p>I changed <code>convert</code> and <code>convert_to</code> to use <code>congr!</code> under the hood, which made it more powerful and (hopefully) a bit easier to predict what it will do.</p>",
        "id": 358330669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684108053
    },
    {
        "content": "<p>As someone who uses lean only every few months and keeps forgetting everything in between I'd certainly be most happy if there is simply a single <code>congr</code> tactic that I have to know about, and can handle all the cases. If configurable variants on behavior, when they are unavoidable (unfolding or not maybe, if that's unavoidable) are then discoverable from the tooltip, I'm in UX heaven.</p>",
        "id": 358363585,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1684130254
    },
    {
        "content": "<p>We really need to figure something out re: forward references to mathlib from core. While it is possible to override tactics, there is no clear single owner for the docstring when an overridden tactic mixes together implementations from several sources.</p>",
        "id": 358367688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684132041
    },
    {
        "content": "<p>Is the quest for a name for this tactic still going?<br>\nYou could build on Coq's terminology, call it ‚Äúgeneralized congruence‚Äù, short <code>gcongr</code>, and start a naming scheme that nicely extends to <code>grewrite</code> and <code>grw</code> and maybe other related tactics that generalize from equality to arbitrary relations, without invading the <code>r‚Ä¶</code> prefix space.</p>",
        "id": 361710388,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685265410
    },
    {
        "content": "<p>I'm ok with <code>gcongr</code> (as the name for the tactic whose working title was <code>rel_congr</code> and whose requested name was, controversially, <code>rcongr</code>). Are there any objections?  Perhaps particularly asking <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, who is the tactic's coauthor :)</p>",
        "id": 363583575,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685922838
    },
    {
        "content": "<p>I have no opinion on this</p>",
        "id": 363586585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685925366
    },
    {
        "content": "<p>I have a slight preference for <code>rel_congr</code> because it is a bit more descriptive of the tactic than <code>gcongr</code>.</p>",
        "id": 363592578,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685929878
    },
    {
        "content": "<p>OK, let's do this again ....</p>",
        "id": 363592666,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685929964
    },
    {
        "content": "<p>/poll What shall we name the relational congruence tactic?<br>\nrel_congr<br>\nrcongr<br>\ngcongr</p>",
        "id": 363592729,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685930038
    },
    {
        "content": "<p>Noting that if we choose <code>rcongr</code>,<br>\n(1) it requires evicting the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Tactic/Congr.html#Std.Tactic.rcongr\">current occupant of the name</a>, and <br>\n(2) it does not fit the <code>rintros</code>/<code>rcases</code> pattern for the r-prefix.</p>",
        "id": 363592851,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685930130
    },
    {
        "content": "<p>(oops, sorry Heather, somehow I missed that there was already a poll)</p>",
        "id": 363594142,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685931166
    },
    {
        "content": "<p>There was a poll before, but <code>gcongr</code> hadn't been proposed at that time.</p>",
        "id": 363594281,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685931288
    },
    {
        "content": "<p>I think that merging would be more productive than restarting the naming debate.</p>",
        "id": 363594840,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1685931730
    },
    {
        "content": "<p>I don't like the current name, so I'm motivated to push for a rename before merge!</p>",
        "id": 363594885,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685931786
    },
    {
        "content": "<p>Do you have a favorite name? I would go with that one.</p>",
        "id": 363595177,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1685932037
    },
    {
        "content": "<p>OK, I'm going with <code>gcongr</code>, since it's short and the objections raised to it were only aesthetic.</p>",
        "id": 363614434,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685944337
    },
    {
        "content": "<p>Let's live with it for a couple of months and then I don't mind discussing renaming.</p>",
        "id": 363614481,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685944356
    },
    {
        "content": "<p>Hopefully-mature version is awaiting CI at <a href=\"https://github.com/leanprover-community/mathlib4/pull/3965\">!4#3965</a>.</p>",
        "id": 363614839,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685944500
    },
    {
        "content": "<p>Maybe one day I‚Äôll make meaningful contributions, until then I‚Äôll help with naming  :-D</p>",
        "id": 363744513,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685975433
    },
    {
        "content": "<p>I just pulled <code>mathlib</code> into a project of mine and <a href=\"https://github.com/nomeata/rerolling-sixes/commit/df0d997ea453638c2087d3d509103fa10e406515\">started using <code>gcongr</code></a>. Works great so far!</p>\n<p>I had to add</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">gcongr</span><span class=\"o\">]</span> <span class=\"n\">sub_lt_sub_right</span> <span class=\"n\">add_lt_add_right</span> <span class=\"n\">mul_lt_mul_of_pos_left</span>\n</code></pre></div>\n<p>first. Is it the case that attributes on relevant lemmas are going to be added to <code>mathlib</code> separately, so in a while I would not have to add these attributes?</p>",
        "id": 363747212,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685975928
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span></p>",
        "id": 363748081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1685976117
    },
    {
        "content": "<p>Heather has a separate branch which tags a bunch of stuff and golfs proofs in mathlib using it</p>",
        "id": 363748922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1685976276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>  Awesome! Did you import <code>Mathlib.Tactic.GCongr</code>?  That should have all these lemmas tagged:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/GCongr.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/GCongr.lean</a></p>",
        "id": 363766953,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685979652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/New.20tactic.20for.20.22relational.20congruence.22/near/363748922\">said</a>:</p>\n<blockquote>\n<p>Heather has a separate branch which tags a bunch of stuff and golfs proofs in mathlib using it</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/4702\">!4#4702</a></p>",
        "id": 363787464,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1685984230
    },
    {
        "content": "<p>No, I did not; I naively assumed that if the tactic<code>gcongr</code> is known, then I would not have to import additional files.<br>\nSo if I import this file, I don‚Äôt have to tag any attribute; in one of my proofs I have to give an explicit pattern (expected), and in another <code>gcongr</code> suddenly used a hypothesis where it didn‚Äôt do it before:<br>\n<a href=\"https://github.com/nomeata/rerolling-sixes/commit/29e33411090ca7f6b6ef777a56f6d4715f8b2ac5\">https://github.com/nomeata/rerolling-sixes/commit/29e33411090ca7f6b6ef777a56f6d4715f8b2ac5</a></p>",
        "id": 363801891,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1685987829
    },
    {
        "content": "<p>This new tactic is great! I just started using it, and I already have some feature requests :-) Is there any chance that the following use case could be supported?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Asymptotics.Asymptotics</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Asymptotics</span>\n\n<span class=\"kd\">@[gcongr]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">IsLittleO.mul_left</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IsBigO.mul_isLittleO</span> <span class=\"o\">(</span><span class=\"n\">isBigO_refl</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Here I get an error on the <code>gcongr</code> attribute, saying that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[gcongr]</span> <span class=\"kn\">attribute</span> <span class=\"n\">only</span> <span class=\"n\">applies</span> <span class=\"n\">to</span> <span class=\"n\">lemmas</span> <span class=\"n\">proving</span> <span class=\"n\">x‚ÇÅ</span> <span class=\"bp\">~‚ÇÅ</span> <span class=\"n\">x‚ÇÅ'</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">...</span> <span class=\"n\">x‚Çô</span> <span class=\"bp\">~‚Çô</span> <span class=\"n\">x‚Çô'</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">f</span> <span class=\"n\">x‚ÇÅ</span> <span class=\"bp\">...</span> <span class=\"n\">x‚Çô</span> <span class=\"bp\">‚àº</span> <span class=\"n\">f</span> <span class=\"n\">x‚ÇÅ'</span> <span class=\"bp\">...</span> <span class=\"n\">x‚Çô'</span><span class=\"o\">,</span> <span class=\"n\">got</span> <span class=\"bp\">‚àÄ</span>\n  <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">NormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">},</span>\n  <span class=\"n\">g‚ÇÅ</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I'm guessing this is because <code>fun x =&gt; f x * g x</code> is not an <code>Expr.app</code> but rather an <code>Expr.lam</code>, or something like that, but it would be great to support this if it's not too hard.</p>",
        "id": 364157668,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1686111130
    },
    {
        "content": "<p>What if you write a defeq variant of the lemma which is in the relational form, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[gcongr]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">IsLittleO.mul_left</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>This is what we did for big operators and it works pretty well:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/8842682b35b93cd754f489edc823eba1e9b6dc0c/Mathlib/Algebra/BigOperators/Order.lean#L131\">https://github.com/leanprover-community/mathlib4/blob/8842682b35b93cd754f489edc823eba1e9b6dc0c/Mathlib/Algebra/BigOperators/Order.lean#L131</a></p>",
        "id": 364163775,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1686114514
    },
    {
        "content": "<p>If I do this, it lets me tag the lemma, but then if I try to prove the original lemma by gcongr it doesn't make any progress.</p>",
        "id": 364278954,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1686144434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I absolutely love this tactic! Thanks!</p>",
        "id": 364418886,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686184487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> I see the issue.  The head symbols of <code>Finset.sum s f</code> and <code>‚àë x in s, f x</code> (which stands for <code>Finset.sum s (fun x ‚Ü¶ f x)</code>) are the same, whereas the head symbols of <code>f * g</code> and <code>fun x ‚Ü¶ f x * g x</code> are different.</p>",
        "id": 364632002,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1686244888
    },
    {
        "content": "<p>Right. It works if we first transform it into <code>f * g</code> using <code>show</code>, but then this is usually more work than solving the goal manually :-(</p>",
        "id": 364632483,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1686245038
    },
    {
        "content": "<p>Just as a test in what it would take to not use <code>show</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[gcongr]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">IsLittleO.mul_left</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÅ</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">IsBigO.mul_isLittleO</span> <span class=\"o\">(</span><span class=\"n\">isBigO_refl</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Function.eta</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≥</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≥</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">IsLittleO.mul_left'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">g‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÅ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span><span class=\"n\">o</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">g‚ÇÇ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">mul_apply</span><span class=\"o\">,</span> <span class=\"n\">Function.eta</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n  <span class=\"n\">gcongr</span>\n</code></pre></div>\n<p>I'm not saying this is a solution.</p>",
        "id": 364639249,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686246864
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 364642511,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1686247716
    },
    {
        "content": "<p>I'm going to add <code>@[gcongr]</code> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.rpow_lt_rpow#doc\">docs4#Real.rpow_lt_rpow</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.rpow_le_rpow#doc\">docs4#Real.rpow_le_rpow</a>. Should I also add it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.rpow_le_rpow_of_exponent_le#doc\">docs4#Real.rpow_le_rpow_of_exponent_le</a> or we don't want to have opinion about <code>x &lt; 1</code> vs <code>1 &lt; x</code>?</p>",
        "id": 365439843,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686546327
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 365439847,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686546333
    },
    {
        "content": "<p>Thanks!  I agree with all three.  I think it's better for it to be opinionated, since the template syntax makes it easy to partial-match.</p>",
        "id": 365440130,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1686546437
    },
    {
        "content": "<p>OK.</p>",
        "id": 365440283,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686546516
    },
    {
        "content": "<p>You can see in<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/GCongr.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/GCongr.lean</a><br>\nthat I tagged <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=pow_le_pow%27#doc\">docs4#pow_le_pow'</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=zpow_le_of_le#doc\">docs4#zpow_le_of_le</a> with <code>gcongr</code>, which are the <code>pow</code> and <code>zpow</code> analogues of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.rpow_le_rpow_of_exponent_le#doc\">docs4#Real.rpow_le_rpow_of_exponent_le</a> .</p>",
        "id": 365440360,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1686546551
    }
]