[
    {
        "content": "<p>I've added a lot of junk to PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a> to move from a proof that a functor preserves terminal objects at universe level zero to conclude the same at all universe levels. Eg, in the test code below I have a much easier construction of the <code>given</code> but had to add a lot to generalize this to a proof of the <code>goal</code>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">AlgebraicTopology</span><span class=\"bp\">.</span><span class=\"n\">SimplicialSet</span><span class=\"bp\">.</span><span class=\"n\">HomotopyCat</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Preserves</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Monoidal</span><span class=\"bp\">.</span><span class=\"n\">Cartesian</span><span class=\"bp\">.</span><span class=\"n\">Cat</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"w\"> </span><span class=\"n\">SSet</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"sd\">/-- In the PR there is a relatively easy proof of this. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">given</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- It takes a lot more work to prove this. But can I conclude it somehow from `given`? -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hoFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">SSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">given</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>\n<p>I'm wondering if there is a way to move from the given to the goal directly?</p>",
        "id": 522368096,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749045832
    },
    {
        "content": "<p>In case anyone cares, I'll give more details about the current construction in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25010\">#25010</a>. Golfing advice would be very welcome!</p>\n<p>Essentially the proof chains together five isomorphisms:<br>\n<code>(hoFunctor.obj (‚ä§_ SSet)) ‚âÖ hoFunctor.obj Œî[0] ‚âÖ hoFunctor.obj (nerve (ULiftFin 1)) ‚âÖ ULiftFin 1  ‚âÖ Cat.of (Discrete PUnit) ‚âÖ (‚ä§_ Cat)</code></p>",
        "id": 522368682,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749045969
    },
    {
        "content": "<p>We start by lifting the finite ordinal categories to arbitrary universe levels:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- An alias for the underlying type of the category `Fin n` lifted to an object of `Cat.{v, u}`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ULiftFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftHom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 522368752,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749045986
    },
    {
        "content": "<p>The first is obtained by proving that the 0-simplex is terminal.</p>\n<p>The second requires a generalization of a recent result of <span class=\"user-mention\" data-user-id=\"548935\">@Thomas Murrills</span> to arbitrary universes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The Yoneda embedding from the `SimplexCategory` into simplicial sets is naturally</span>\n<span class=\"sd\">isomorphic to `SimplexCategory.toCat ‚ãô nerveFunctor` with component isomorphisms</span>\n<span class=\"sd\">`Œî[n] ‚âÖ nerve (Fin (n + 1))`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">NatIso</span><span class=\"bp\">.</span><span class=\"n\">ofComponents</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span>\n<span class=\"w\">    </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">toIso</span><span class=\"w\"> </span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">objEquiv</span><span class=\"w\"> </span><span class=\"bp\">‚â™‚â´</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">homIsoFunctor</span>\n\n<span class=\"c1\">-- TODO: generalize from universe level 0 to arbitrary universes.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simplexIsNerve'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">nerve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The third iso is something in mathlib (phew).</p>\n<p>The final two isomorphisms connect the abstract defined terminal object in Cat to an explicitly described unit category at any universe level. Then we connect this explicit categorty to <code>ULiftFin 1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">ofUniqueHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">star</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">punit_ext'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- As a terminal object, `Discrete PUnit` is isomorphic to the terminal object in `Cat.` -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TerminalCatDiscretePUnitIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">terminalIsoIsTerminal</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span>\n\n<span class=\"sd\">/-- An isomorphism between `ULiftFin 1` and `Discrete PUnit`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ULiftFinDiscretePUnitIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toCatHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">star</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULiftFin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">toCatHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fromPUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">hom_inv_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">RightInverse</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"n\">ULiftFin</span><span class=\"bp\">.</span><span class=\"n\">of_toComposableArrows</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ComposableArrows</span><span class=\"bp\">.</span><span class=\"n\">ext‚ÇÄ</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">inv_hom_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 522369351,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749046128
    },
    {
        "content": "<p>I am not sure if this helps directly for this, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.Types.isTerminalEquivUnique#doc\">docs#CategoryTheory.Limits.Types.isTerminalEquivUnique</a> says an object in <code>Type u</code>  is terminal iff it has a <code>Unique</code> structure. Perhaps it would be good to introduce a similar thing for <code>Cat</code>, saying that an object is terminal iff the underlying type has a <code>Unique</code> structure and the category has a <code>IsDiscrete</code> instance?</p>",
        "id": 522371436,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749046644
    },
    {
        "content": "<p>Then you‚Äôd \"just\" need to prove that <code>hoFunctor.obj (‚ä§_ SSet)</code> has a single object (should be \"easy\", as this is a quotient of a one-object type?) and, only one morphisms between those.</p>",
        "id": 522371897,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749046758
    },
    {
        "content": "<p>Interesting idea. The single object would be clear enough but I'm scared to attempt a proof that requires getting into the details of the construction of <code>hoFunctor</code>. Though in this case perhaps it wouldn't be too terrible...</p>",
        "id": 522372501,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749046912
    },
    {
        "content": "<p>In any cases, I believe a characterization of terminal object in <code>Cat</code> as \"Unique + IsDiscrete\" would be nice to have on its own.</p>",
        "id": 522372776,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749046981
    },
    {
        "content": "<p>We have a file <code>CategoryTheory.Category.Cat.Limit</code> (constructing limits in <code>Cat</code>) so could this go in <code>CategoryTheory.Category.Cat.Terminal</code>?</p>",
        "id": 522372888,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749047014
    },
    {
        "content": "<p>I‚Äôll leave it to a maintainer to give a definite answer, but for <code>Type</code>, it‚Äôs in a file <code>CategoryTheory.Limits.Types.Shapes</code>, that records \"explicit\" constructions for co/limits of types, so I guess <code>CategoryTheory.Limits.Cat.Shapes</code> or <code>CategoryTheory.Category.Cat.Limit.Shape</code> might be appropriate? <br>\n(Though <code>....Terminal</code> is perhaps best suited if the file only deal with terminal objects...)</p>",
        "id": 522373453,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749047157
    },
    {
        "content": "<p>I need to run for today, so I apologize for the unfinished stuff, but if you add things like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">full_functor</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_surjective</span><span class=\"bp\">.</span><span class=\"n\">subsingleton</span>\n</code></pre></div>\n<p>around line 129 in <code>CategoryTheory.Quotient</code>, and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">FreeRefl</span><span class=\"bp\">.</span><span class=\"n\">quotientFunctor_id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ReflQuiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">FreeRefl</span><span class=\"bp\">.</span><span class=\"n\">quotientFunctor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ReflQuiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeRefl</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ReflQuiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeRefl</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeRefl</span><span class=\"bp\">.</span><span class=\"n\">quotientFunctor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Paths</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">uniq</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Paths</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n<span class=\"w\">      </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">        </span><span class=\"n\">equals</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">ùüô</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">hrec</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"n\">rq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subsingleton</span>\n<span class=\"w\">        </span><span class=\"c1\">-- rw below can be avoided if you turn FreeRefl.quotientFunctor into an abbrev.</span>\n<span class=\"w\">        </span><span class=\"c1\">-- and then also the simp call works better</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">FreeRefl</span><span class=\"bp\">.</span><span class=\"n\">quotientFunctor</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Paths</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‚Üì</span><span class=\"n\">hrec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Paths</span><span class=\"bp\">.</span><span class=\"n\">of_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"n\">FreeRefl</span><span class=\"bp\">.</span><span class=\"n\">quotientFunctor_id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>in <code>Mathlib.CategoryTheory.ReflQuiv</code>, after line 142,  (the last proof is certainly golfable...), then with just the right amount of unfolding on <code>hoFunctor</code> it should be doable to prove that <code>hoFunctor.obj (‚ä§_ SSet.{u})</code> has a single object and a unique morphism between that single object, provided that you give <code>Unique _</code> and <code>[‚àÄ (x y : _), Unique (x ‚ü∂ y)]</code> instances on <code>oneTruncation‚ÇÇ ((truncation 2).obj ‚ä§_ SSet.{u})</code>, which should hopefully be doable. Then, the thing I mentionned about terminal objects in Cat should finish the thing.<br>\nPerhaps for better defeq properties, it might be better to show this for <code>hoFunctor.obj (ùüô_ SSet.{u})</code> first, and then use an abstract isomorphism with <code>‚ä§_ SSet.{u}</code> though.</p>",
        "id": 522397602,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749053283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> is this the sort of thing you had in mind?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">Limit</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">Terminal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">PUnit</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"n\">u'</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"w\"> </span><span class=\"n\">Functor</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Cat</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The unique functor to the discrete category on a unique object. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">toDiscreteUnique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">default</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"mi\">ùüô</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"sd\">/-- Any two functors to a discrete category on a unique object are *equal*. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">toDiscreteUnique_ext</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚•§</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Functor</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_iff_true_of_subsingleton</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isDiscreteUnique</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">ofUniqueHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">toDiscreteUnique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">toDiscreteUnique_ext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 522419136,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749059691
    },
    {
        "content": "<p>I also built some isomorphisms (continuing the above):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Any `T : Cat.{u, u}` with a unique object and discrete homs is isomorphic to `‚ä§_ Cat.{u, u}.` -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">terminalDiscreteUniqueIso</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDiscrete</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ä§_</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">terminalIsoIsTerminal</span><span class=\"w\"> </span><span class=\"n\">isDiscreteUnique</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span>\n\n<span class=\"sd\">/-- The discrete category on `PUnit` is terminal. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isDiscreteUnique</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- Any terminal object `T : Cat.{u, u}` is isomorphic to `Cat.of (Discrete PUnit)`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isTerminalDiscretePUnitIso</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">‚âÖ</span><span class=\"w\"> </span><span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Discrete</span><span class=\"w\"> </span><span class=\"n\">PUnit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsTerminal</span><span class=\"bp\">.</span><span class=\"n\">uniqueUpToIso</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">DiscretePUnit</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Cat</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>",
        "id": 522419337,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749059753
    },
    {
        "content": "<p>The code above (your suggestions and my work in progress) is now in a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25459\">#25459</a>. I accidentally merged in the other approach (manually constructing a bunch of isomorphisms, without using an abstract characterization of terminal objects). I could prune this or leave it there for reference. </p>\n<p>I got stuck on a lot of basic things when constructing the two instances of uniqueness involving one-truncations. Morally these are just types of maps into the terminal object in the simplex category but Lean doesn't agree... :(</p>",
        "id": 522455853,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749072960
    },
    {
        "content": "<p>Yes, these kind of lemmas about Cat are what I had in mind.<br>\nI took the liberty to push sorry-free versions of the <code>Unique</code> instances on <code>OneTruncation‚ÇÇ</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/25459\">#25459</a>, which basically works by forcing Lean to see these are \"just\" maps to a terminal object,  feel free to rework it if you want!</p>",
        "id": 522533096,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749112826
    },
    {
        "content": "<p>Thanks! Really appreciated. This would have taken me ages (if ever) to sort out. </p>\n<p>I've cleaned up the rest of the PR so hopefully it will be ready to review soon. Feel free to make improvements/golf if you are so inspired but if you're ready to move onto other things, please accept my thanks now.</p>",
        "id": 522592158,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749130117
    },
    {
        "content": "<p>My inclination would be to prove that the various functors involved preserve limits of the appropriate shape.</p>",
        "id": 522603192,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1749133022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"286014\">@Robin Carlier</span> the PR you helped me with is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/25781\">#25781</a> on my fork. I had trouble with a few of the suggested changes, one of which I'm hoping you can help me with.</p>\n<p>Jo√´l suggested changing <code>abbrev FreeRefl.quotientFunctor</code> back to a def, but this breaks the instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ReflQuiver</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeRefl</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>in a way I don't understand. Supposedly the issue can be fixed by adding simp lemmas but I don't know how to figure out what statements would help.</p>",
        "id": 524051983,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749892460
    },
    {
        "content": "<p>I think the simp lemmas that we'd want from this def are already here (there‚Äôs just one and it‚Äôs <code>FreeRefl.quotientFunctor_id</code>).</p>\n<p>I think the issue here is that we‚Äôre calling <code>Quotient.induction</code>, which creates goal using <code>Quotient.functor ...</code>. I suggested making <code>FreeRefl.quotientFunctor</code> and abbrev so that it unifies with <code>Quotient.functor</code>.</p>\n<p>So either we need a special induction principle for <code>FreeReflQuiver</code> (really, just a restatement/translation of the one for quotients), or, alternatively, immediately after calling <code>Quotient.induction</code> we can get everything back in the <code>FreeRefl.quotientFunctor</code>language via a rewrite.<br>\nThis diff should be working (works on my end at least).</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/Mathlib/CategoryTheory/Category/ReflQuiv.lean b/Mathlib/CategoryTheory/Category/ReflQuiv.lean</span>\n<span class=\"gh\">index 36935d8b291..0d8582630f2 100644</span>\n<span class=\"gd\">--- a/Mathlib/CategoryTheory/Category/ReflQuiv.lean</span>\n<span class=\"gi\">+++ b/Mathlib/CategoryTheory/Category/ReflQuiv.lean</span>\n<span class=\"gu\">@@ -129,7 +129,7 @@ instance (V) [ReflQuiver V] : Category (FreeRefl V) :=</span>\n\n<span class=\"w\"> </span>/-- The quotient functor associated to a quotient category defines a natural map from the free\n<span class=\"w\"> </span>category on the underlying quiver of a refl quiver to the free category on the reflexive quiver. -/\n<span class=\"gd\">-abbrev FreeRefl.quotientFunctor (V) [ReflQuiver V] : Paths V ‚•§ FreeRefl V :=</span>\n<span class=\"gi\">+def FreeRefl.quotientFunctor (V) [ReflQuiver V] : Paths V ‚•§ FreeRefl V :=</span>\n<span class=\"w\"> </span>  Quotient.functor (C := Paths V) (FreeReflRel (V := V))\n\n<span class=\"w\"> </span>/-- This is a specialization of `Quotient.lift_unique'` rather than `Quotient.lift_unique`, hence\n<span class=\"gu\">@@ -156,6 +156,7 @@ instance (V : Type*) [ReflQuiver V] [Unique V]</span>\n<span class=\"w\"> </span>  uniq f := by\n<span class=\"w\"> </span>    letI : Unique (Paths V) := inferInstanceAs (Unique V)\n<span class=\"w\"> </span>    induction f using Quotient.induction with | @h x y f =&gt;\n<span class=\"gi\">+    rw [‚Üê FreeRefl.quotientFunctor]</span>\n<span class=\"w\"> </span>    symm\n<span class=\"w\"> </span>    induction f using Paths.induction with\n<span class=\"w\"> </span>    | id =&gt;\n</code></pre></div>",
        "id": 524052657,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749893296
    },
    {
        "content": "<p>Writing an induction principle specially for <code>FreeRefl</code> (combining <code>Paths.Induction</code> and <code>Quotient.Induction</code>) is probably the more principled approach though, it‚Äôs a bit longer but it‚Äôs what you want to go for if you intend to prove more stuff about <code>FreeRefl</code>.</p>",
        "id": 524053011,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749893682
    },
    {
        "content": "<p>I‚Äôm noticing that we also don‚Äôt have special induction principles for HomotopyCategory (at least I did not see any around the definition), <code>FreeRefl</code> is a bit of an intermediary construction but I think we definitely want some quality of life principles around <code>HomotopyCategory</code>. I‚Äôll try writing one this weekend if I find the time.</p>",
        "id": 524053482,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1749894275
    },
    {
        "content": "<p>Thanks both for the solution and for the explanation. </p>\n<p>I'm about to go offline for a few days so I opted for the less principled more efficient solution. But I agree that having some quality of life principles for homotopy category would be great. We're about to have a strict bicategory of quasi-categories whose hom-categories are homotopy categories. I'd like to some day be able to calculate the 1-cells and 2-cells!</p>",
        "id": 524058499,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1749900264
    }
]