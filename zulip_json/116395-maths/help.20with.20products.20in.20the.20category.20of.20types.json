[
    {
        "content": "<p>I'd like to define (or be able to use a function like the following)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"n\">hyp</span>\n</code></pre></div>\n<p>but where the <code>×</code> is the product in the category of types rather than the product type. I have two things I can't figure out how to do.</p>\n<p>(1)  Given a term <code>q : X × Y</code> I can't figure out how to extract its projections to <code>X</code> and <code>Y</code>; <code>q.1</code> does not appear to be defined here and I'm also having trouble applying the function <code>prod.fst q</code> maybe because of failure to find implicit arguments, or maybe because Lean won't coerce <code>prod.fst</code>, a morphism in the category of types, to a function which can be applied to a term.</p>\n<p>(2) Given an equality between two such terms extracting the equality between the corresponding projections.</p>",
        "id": 511011387,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1744140823
    },
    {
        "content": "<ol>\n<li>Do you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ChosenFiniteProducts.fst#doc\">docs#CategoryTheory.ChosenFiniteProducts.fst</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ChosenFiniteProducts.snd#doc\">docs#CategoryTheory.ChosenFiniteProducts.snd</a> ?</li>\n<li>If the answer to 1. is \"Yes\", then given <code>hpq : p = q</code> you can do <code>congr(CategoryTheory.ChosenFiniteProducts.fst $hpq)</code></li>\n</ol>",
        "id": 511011780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744140976
    },
    {
        "content": "<p>What does the $ mean in your code?</p>",
        "id": 511012570,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1744141309
    },
    {
        "content": "<p>I just found</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hyp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">hyp</span>\n</code></pre></div>",
        "id": 511012590,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1744141314
    },
    {
        "content": "<p>If <code>hab : a = b</code>, then <code>congr(f $hab) : f a = f b</code> (and similarly for more complicated expressions). It's a very handy macro!</p>",
        "id": 511012960,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744141450
    },
    {
        "content": "<p>In this case you should be able to just write <code>congrArg _ hyp</code> and let unification do its job.</p>",
        "id": 511013142,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744141535
    },
    {
        "content": "<p>And indeed if you use chosen finite products, then things are even better: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">MonoidalCategory</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Prod.fst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 511013335,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744141609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/channel/116395-maths/topic/help.20with.20products.20in.20the.20category.20of.20types/near/511013142\">said</a>:</p>\n<blockquote>\n<p>In this case you should be able to just write <code>congrArg _ hyp</code> and let unification do its job.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hxy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"c1\">-- fails</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hxy</span>\n</code></pre></div>",
        "id": 511013500,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744141677
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⨯</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">prod.fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">prod.fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 511013669,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744141741
    },
    {
        "content": "<p>I guess need to learn how to use chosen finite products (and what exactly this means). I'm really struggling to do something very basic. Essentially I need to prove that some morphism in the category of types valued in a product is a monomorphism, which I'm doing by proving that the function is injective, which is obvious except I can't seem to mix the category theory and the types stuff.</p>",
        "id": 511013770,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1744141783
    },
    {
        "content": "<p>The chosen finite products class merely bundles in a specific choice of a binary product and terminal object. If you have such an instance, then typeclass synthesis will find a monoidal category structure (the cartesian one, where the tensor product is your chosen binary product and the unit is the chosen terminal object). In the case of types, the chosen binary product is the type-theoretic product and the terminal object is <code>PUnit</code>.</p>",
        "id": 511014050,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744141882
    },
    {
        "content": "<p>But I get the bigger point here. It's painful when category theory and the surface type theory have to mix because it's confusing (to both Lean and humans) when something should be considered as a morphism and when it should be considered as a function. There is a whole refactor going on by <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> around concrete categories trying to address some of these pain points.</p>",
        "id": 511014552,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744142057
    },
    {
        "content": "<p>Did that refactor finish already?</p>",
        "id": 511014765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744142155
    },
    {
        "content": "<p>Yes, as far as I am aware everything should be completely switched over already.</p>",
        "id": 511019769,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1744143985
    },
    {
        "content": "<p>The category of types is not much better to work with though, because plain functions are not really <code>FunLike</code>s. So you have to enable <code>attribute [local instance] Types.instFunLike Types.instConcreteCategory</code> and then every so often hint to tactics that <code>FunLike.coe</code> really is the identity map.</p>",
        "id": 511020489,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1744144268
    }
]