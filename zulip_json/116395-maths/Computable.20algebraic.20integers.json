[
    {
        "content": "<p>The following is just for my personal curiosity, I have no intention of doing or using any of the following results:</p>\n<h1>How difficult is it (maybe in theory) to implement a computable type of algebraic integers?</h1>\n<p>By which I mean:</p>\n<ol>\n<li>There should be a bijection from this type <code>A</code> to the IntegralClosure of ℤ in ℂ (the inverse would be noncomputable)</li>\n<li>All the ring operations (0, 1, +, x) on <code>A</code> should be computable, and equality should be decidable.</li>\n<li>There should also be a computable function <code>A → ℤ[X]</code> that gives you the minimal polynomial of a given algebraic integer (so we would first need to make ℤ[X] computable <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span> )</li>\n<li>maybe other properties that don't come to mind yet.</li>\n</ol>\n<p>I've only ever heard about it in theory, where you basically well-order every monic integer polynomial, and for each one you can computably find approximations to its roots in ℂ, which allows you to pick an order on the roots as well (in terms of what they get sent to in ℂ), but then the details will undoubtedly get very messy very  quickly, so I'm just wondering if anyone has actually done anything like this.</p>\n<p>I guess if we compare it to existing computer algebra systems (CAS), they only take one finite extension at a time, which I guess could also be good enough.</p>",
        "id": 525814029,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750904491
    },
    {
        "content": "<p>This sounds greatly difficult</p>",
        "id": 525814263,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750904751
    },
    {
        "content": "<p>I guess it depends on how computable you want it to be</p>",
        "id": 525814303,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750904791
    },
    {
        "content": "<p>Do you want it to be computable or efficiently computable</p>",
        "id": 525814324,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750904817
    },
    {
        "content": "<p>Just Computable I think should be pretty easy (if insanely tedious)</p>",
        "id": 525814369,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750904849
    },
    {
        "content": "<p>I think firstly you need to compute an integral basis</p>\n<p>Maybe you want to check out Cohen's Computational Algebraic Number Theory GTM books</p>",
        "id": 525829697,
        "sender_full_name": "Jz Pan",
        "timestamp": 1750918273
    },
    {
        "content": "<p>What did the odd order people do in Rocq for the character theory part of the proof? I thought they had (and solved) a problem very close to this.</p>\n<p>I thought that the conclusion of the discussion about computable polynomials was not \"polynomials need to be made computable\" but \"computable polynomials need to be written as a separate thing\"</p>",
        "id": 525835812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750921523
    },
    {
        "content": "<p>And as Aaron said, are you going for \"computable in theory\" or \"actually useful\" because these are two very different things. Existing CASs tend to go for \"actually useful\" which involves not doing what you're suggesting at all but instead working with a good model of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}[X]/(f).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 525836105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750921633
    },
    {
        "content": "<p>Have a look at the work by <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> and <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> on real algebraic geometry:<br>\n<a href=\"https://inria.hal.science/inria-00593738v4\">https://inria.hal.science/inria-00593738v4</a></p>",
        "id": 526409363,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1751292031
    },
    {
        "content": "<p>I think that's a little different - that's the decision procedure for arithmetical statements about real closed fields</p>",
        "id": 526431233,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1751297999
    },
    {
        "content": "<p>So good for eg solving real polynomial inequalities</p>",
        "id": 526431453,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1751298083
    },
    {
        "content": "<p>I think computational ANT uses quite different methods?</p>",
        "id": 526431712,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1751298163
    },
    {
        "content": "<p>Indeed the paper of mine which is closest to this topic is rather <a href=\"https://inria.hal.science/hal-00671809v2/\">https://inria.hal.science/hal-00671809v2/</a><br>\nBut the I/we reused many of the methods in the QE paper.</p>",
        "id": 526432752,
        "sender_full_name": "Cyril Cohen",
        "timestamp": 1751298471
    }
]