[
    {
        "content": "<p>I'm trying - and in some cases succeeding - to prove results about the relationships between various well known topologies on a lattice:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/mans0954/lawson-topology/Mathlib/Topology/Order/LawsonTopology.lean#L168\">https://github.com/leanprover-community/mathlib4/blob/mans0954/lawson-topology/Mathlib/Topology/Order/LawsonTopology.lean#L168</a></p>\n<p>However, it's all starting to look a bit weird and unlike other things I've seen in Mathlib e.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">ScottTopology</span> <span class=\"n\">α</span> <span class=\"n\">S</span> <span class=\"n\">_</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">LawsonTopology</span> <span class=\"n\">α</span> <span class=\"n\">L</span> <span class=\"n\">_</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">LowerTopology</span> <span class=\"n\">α</span> <span class=\"n\">l</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Scott open iff UpperSet and STopology open</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">LawsonOpen_iff_ScottOpen</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsUpperSet</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsOpen</span><span class=\"o\">[</span><span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">IsOpen</span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">hs</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">ScottTopology.isOpen_iff_upper_and_Scott_Hausdorff_Open</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">h</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">d</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LawsonOpen_implies_ScottHausdorffOpen'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">l</span> <span class=\"n\">S</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n        <span class=\"n\">hs</span> <span class=\"n\">d</span> <span class=\"n\">d₁</span> <span class=\"n\">d₂</span> <span class=\"n\">d₃</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">TopologicalSpace.le_def.mp</span> <span class=\"o\">(</span><span class=\"n\">Scott_le_Lawson</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Before I go much further down this route, it would be useful to know if I'm going about this the right way or not?</p>\n<p>Thanks!</p>\n<p>CC <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 362578797,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1685569396
    },
    {
        "content": "<p>Sorry, am unavailable for the next week. But you know what I'm going to say: use type synonyms and translation functions.</p>",
        "id": 362580466,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685569951
    },
    {
        "content": "<p>I think there might be precedent for this kind of thing in our topology files</p>",
        "id": 362595787,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685576601
    },
    {
        "content": "<p>Okay, but I'm still wondering what to do about ordering topologies? Which of the following is \"correct\" or should I provide both?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">Scott_Hausdorff_le_Lower'</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ScottHausdorffTopology</span> <span class=\"n\">α</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">LowerTopology'</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ScottHausdorffTopology.Lower_IsOpen</span> <span class=\"n\">s</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">LowerTopology.isLowerSet_of_isOpen</span> <span class=\"o\">(</span><span class=\"n\">WithLowerTopology</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"n\">_</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Scott_Hausdorff_le_Lower</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LowerTopology</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">ScottHausdorffTopology</span> <span class=\"bp\">≤</span>  <span class=\"o\">‹</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">›</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ScottHausdorffTopology.Lower_IsOpen</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">LowerTopology.isLowerSet_of_isOpen</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I don't see a way of formulating this statement using <code>WithLowerTopology α </code> since the topology is of type <code>TopologicalSpace (WithLowerTopology α )</code> and therefore not directly comparable with an element of <code>TopologicalSpace α</code>?</p>\n<p>Christopher</p>",
        "id": 362924206,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1685677782
    },
    {
        "content": "<p>I would state it as <code>continuous (toScottHausdorff \\comp toLower\\-1)</code></p>",
        "id": 362944120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685688141
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 362944363,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685688222
    },
    {
        "content": "<p>If you can't figure it out, I can do it all in a week from now.</p>",
        "id": 362944371,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1685688226
    },
    {
        "content": "<p>Another option is to consider two distinct types with an <code>OrderIso</code> between them.</p>",
        "id": 363098223,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1685721980
    },
    {
        "content": "<p>Lean looks happy with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ScottLawsonCont'</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">WithScottTopology.toScott</span> <span class=\"bp\">∘</span> <span class=\"n\">WithLawsonTopology.ofLawson</span> <span class=\"o\">:</span> <span class=\"n\">WithLawsonTopology</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Ultimately I want to get to a position where I can figure these things out by myself, so I don't have to keep bothering other people.</p>\n<p>Thanks for the suggestions.</p>",
        "id": 363151587,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1685735647
    },
    {
        "content": "<p>So the rule is, if the result is a property intrinsic to the topology (e.g. a separation property) use the mixin class, and if it's about the relationship between multiple topologies, use the type synonyms?</p>",
        "id": 365445999,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1686548849
    },
    {
        "content": "<p>You can formulate your result without type synonyms using something like (not sure about names)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">IsLawsonTopology</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsScottTopology</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">OrderIso</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 365453301,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686551330
    },
    {
        "content": "<p>The rule is: if you want more than 1 topology on the same space, then most of the time it's better to use type synonyms.</p>",
        "id": 365453400,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686551369
    },
    {
        "content": "<p>What's good about the way of formulating the lemma with two separate spaces: if (I didn't check for these two topologies) the statement holds with weaker assumptions on <code>e</code> (e.g., an order embedding, or even a monotone map), then you can prove this more precise statement, then get the version with type synonyms for free.</p>",
        "id": 365453810,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1686551500
    },
    {
        "content": "<p>Sorry for the long delay in replying - I've been trying to figure this out when I have a moment.</p>\n<p>I've been wondering what to do when the statement of a result uses only one topology, but the proof depends on a stronger or weaker topology?</p>\n<p>This is what I've come up with: <a href=\"https://github.com/leanprover-community/mathlib4/pull/2508/files#diff-983e16dd03108ad09234625f776ad94cfb58b1f6ee4762bf7519306fd90a2b46R293-R313\">https://github.com/leanprover-community/mathlib4/pull/2508/files#diff-983e16dd03108ad09234625f776ad94cfb58b1f6ee4762bf7519306fd90a2b46R293-R313</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">closure_singleton</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">Iic</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_antisymm_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"n\">closure_minimal</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">singleton_subset_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_Iic</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isClosed_iff_lower_and_subset_implies_LUB_mem</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">isLowerSet_Iic</span> <span class=\"n\">a</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intros</span> <span class=\"n\">d</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">d₃</span> <span class=\"n\">d₄</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">isLUB_le_iff</span> <span class=\"n\">d₃</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">d₄</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">OrderIso.apply_symm_apply</span> <span class=\"n\">WithUpperSetTopology.ofUpperSetOrderIso</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">OrderIso.image_Iic</span> <span class=\"n\">WithUpperSetTopology.ofUpperSetOrderIso</span><span class=\"o\">),</span>\n      <span class=\"bp\">←</span> <span class=\"n\">UpperSetTopology.closure_singleton</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">image_singleton</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">WithUpperSetTopology.ofUpperSetOrderIso</span> <span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">image_closure_subset_closure_image</span>\n      <span class=\"o\">(</span><span class=\"n\">Monotone_continuous</span> <span class=\"n\">WithUpperSetTopology.ofUpperSetOrderIso.monotone</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Is this the right sort of idea?</p>\n<p>Thanks.</p>",
        "id": 370524573,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1687975015
    },
    {
        "content": "<p>I haven't looked closely at your code, but if you have two topologies on the same type, we have some results for this kind of thing (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed.mono#doc\">docs#IsClosed.mono</a>, although I couldn't find an analogous one for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=closure#doc\">docs#closure</a>, but you could prove it and add it, as it follows easily from <code>IsClosed.mono</code>; <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=closure_mono#doc\">docs#closure_mono</a> is different).  That would allow you to show that if you had two topologies <code>t₁ ≤ t₂</code> and <code>Iic a ⊆ closure {a}</code> in <code>t₁</code>, then the same is true in <code>t₂</code>.</p>",
        "id": 370529950,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1687976055
    },
    {
        "content": "<p>Should we introduce a type tag <code>WithOrderTopology</code> such that <code>WithOrderTopology X</code> has order topology?</p>",
        "id": 370537899,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1687977366
    },
    {
        "content": "<p>Then one can talk about continuity of the identity function to/from <code>WithOrderTopology X</code> if <code>X</code> has other topology.</p>",
        "id": 370538069,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1687977402
    },
    {
        "content": "<p>Yeah that's what we've been doing with the other order topologies.</p>",
        "id": 370583906,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1687989132
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Thanks - I was able to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Closure.mono</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t₁</span> <span class=\"bp\">≤</span> <span class=\"n\">t₂</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">closure</span> <span class=\"n\">_</span> <span class=\"n\">t₁</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"bp\">@</span><span class=\"n\">closure</span> <span class=\"n\">_</span> <span class=\"n\">t₂</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">closure_minimal</span> <span class=\"n\">_</span> <span class=\"n\">t₁</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">closure</span> <span class=\"n\">_</span> <span class=\"n\">t₂</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">subset_closure</span> <span class=\"o\">(</span><span class=\"n\">IsClosed.mono</span> <span class=\"n\">isClosed_closure</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I then try to use this in the last step of the proof of <code>closure_singleton</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">convert</span> <span class=\"n\">Closure.mono</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">upper_le_Scott</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which leaves me with two goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">h.e'_1</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.10323</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">ScottTopology</span> <span class=\"n\">α</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Iic</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span>\n<span class=\"n\">case</span> <span class=\"n\">h.e'_2.h.e'_2</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.10323</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝²</span><span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">ScottTopology</span> <span class=\"n\">α</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"bp\">=</span> <span class=\"n\">ScottTopology'</span>\n</code></pre></div>\n<p>The second goal can be closed with: <code>exact topology_eq α</code>. The first goal looks like it is exactly the statement of <code>UpperSetTopology.closure_singleton</code>. However, a rewrite results in the <code>failed to synthesize instance  UpperSetTopology α</code> error.</p>\n<p>So, it seems I still need a way to \"put\" the <code>UpperSetTopology</code> on α?</p>\n<p>Thanks,</p>\n<p>Christopher</p>",
        "id": 370881200,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688062540
    },
    {
        "content": "<p>Can you provide a full <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> so I don't have to paste it together?</p>",
        "id": 370881805,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688062643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I've pushed where I've got to onto this branch: <a href=\"https://github.com/leanprover-community/mathlib4/tree/mans0954/scott-topology\">https://github.com/leanprover-community/mathlib4/tree/mans0954/scott-topology</a></p>\n<p>If you want a genuine MWE that it might take me a little while to filter that out as there's quite a lot of gubbins associated with each topology.</p>",
        "id": 370883544,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688062957
    },
    {
        "content": "<p>the branch is fine</p>",
        "id": 370883632,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688062976
    },
    {
        "content": "<p>Thank you :) Specifically: <a href=\"https://github.com/leanprover-community/mathlib4/blob/mans0954/scott-topology/Mathlib/Topology/Order/ScottTopology.lean#L302\">https://github.com/leanprover-community/mathlib4/blob/mans0954/scott-topology/Mathlib/Topology/Order/ScottTopology.lean#L302</a></p>",
        "id": 370883878,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688063031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span>  I looked at this for just a few minutes, but I'm fairly certain that your issue is that you haven't told Lean that the <code>upperSetTopology'</code> is an <code>UpperSetTopology</code>. This fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>and this succeeds (in the spot you linked on your branch) except for the <code>infer_instance</code> line, which means it's correct except it can't find the instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">.</span> <span class=\"n\">convert</span> <span class=\"n\">Closure.mono</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">upper_le_Scott</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">swap</span>\n    <span class=\"n\">exact</span> <span class=\"n\">topology_eq</span> <span class=\"n\">α</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">UpperSetTopology.closure_singleton</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 370898385,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688065997
    },
    {
        "content": "<p>Note: I just used tunnel vision to work on this problem, I did not look wider at your design choices in this branch.</p>",
        "id": 370898820,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688066090
    },
    {
        "content": "<blockquote>\n<p>I did not look wider at your design choices in this branch.</p>\n</blockquote>\n<p>I don't know enough to make design choices. I rely on the advice of whoever was kind enough to answer my most recent query. </p>\n<p>Naively I tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">UpperSetTopology</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But that gives me a type mismatch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.2929</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.2938</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">u.2938</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 370906731,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688067925
    },
    {
        "content": "<p>Right, that's because <code>UpperSetTopology</code> takes a term of type <code>Type u</code>, but you gave it <code>upperSetTopology' α : TopologicalSpace α</code>. You need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 370912185,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688069233
    },
    {
        "content": "<p>As for design, I would probably echo the suggestion above to make a type synonym (maybe with different naming to what I have below), and maybe even a <code>structure</code> so you can get nice functions back and forth easily.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">WithUpperSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">toWithUpperSet</span> <span class=\"o\">::</span> <span class=\"n\">ofWithUpperSet</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- pull the instance back through `toWithUpperSet`</span>\n\n<span class=\"sd\">/-- `toWithUpperSet` as an order isomorphism. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">WithUpperSet.orderIso</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">WithUpperSet</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">upperSetTopology'</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSet</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">UpperSetTopology</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSet</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">continuous_toWithUpperSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSet.OrderIso</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 370917030,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688070440
    },
    {
        "content": "<p>I thought I already had a type synonym with <code>WithUpperSetTopology</code>?</p>\n<p>So, for each topology we have:</p>\n<p>i) the element of <code>TopologicalSpace α</code> itself;<br>\nii)  the mixin class;<br>\niii) the  type synonym;<br>\niv) the structure;<br>\nv) a set of maps and results connecting them all? </p>\n<p>It's all getting a bit baffling for the non-specialist.</p>\n<p>Is any of this documented as best practice for topologies anywhere?</p>",
        "id": 370919433,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688071141
    },
    {
        "content": "<p>Sorry, I didn't see <code>WithUpperSetTopology</code>, that plays the role of my <code>WithUpperSet</code></p>",
        "id": 370920217,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688071378
    },
    {
        "content": "<p>Regarding \"best practice\". I would say just use the following general rule of thumb: if you have a type <code>α</code> with and instance <code>inst₁ : C</code> and <em>very rarely</em> you want to equip <code>α</code> with a different <code>inst₂ : C</code>, then just go through the pain of switch the instances out manually on the same type <code>α</code>. However, if with any regularity you want to equip <code>α</code> with <code>inst₂</code> instead of <code>inst₁</code>, then create a type synonym (or a one-field structure). This is generic to any type class, and not specific to topologies.</p>\n<p>As for mixins, that depends on the specific situation, but as mentioned, we seem to have <code>Prop</code>-valued mixins for how a topology interacts with the order structure. Recently, <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> and <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> were running into a few issues related to order topologies and the extreme value theorem. So perhaps they have some insight to share here.</p>",
        "id": 370923467,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688072294
    },
    {
        "content": "<p>Thanks. I got stuck trying to remove the <code>sorry</code> in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But perhaps that will be clearer in the morning.</p>",
        "id": 370962818,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688087902
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/leanprover-community/mathlib/pull/19224\">https://github.com/leanprover-community/mathlib/pull/19224</a></p>",
        "id": 371028813,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688109883
    },
    {
        "content": "<p>You should just PR that to mathlib 4 directly.</p>",
        "id": 371179431,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688134487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> The last time I made a change to a file that was in both mathlib and mathlib4, it was mandatory to make the change in mathlib first and then forward port to mathlib4 to keep things in sync. Has that now changed?</p>",
        "id": 371180292,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688134636
    },
    {
        "content": "<p>It has, yeah</p>",
        "id": 371181199,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1688134799
    },
    {
        "content": "<p>And also you are only adding new material, not refactoring existing material. We've been accepting PRs like that to mathlib4 for a while now.</p>",
        "id": 371247618,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688145858
    },
    {
        "content": "<p>Thanks. Mathlib4 PR here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/5631\">https://github.com/leanprover-community/mathlib4/pull/5631</a></p>",
        "id": 371278303,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688152553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>isn't quite right, because:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>gives me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>What is true is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSetTopology</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>With this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">.</span> <span class=\"n\">convert</span> <span class=\"n\">Closure.mono</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">upper_le_Scott</span> <span class=\"n\">α</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"bp\">@</span><span class=\"n\">UpperSetTopology.closure_singleton</span> <span class=\"o\">(</span><span class=\"n\">WithUpperSetTopology</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">)]</span>\n    <span class=\"n\">infer_instance</span>\n    <span class=\"n\">exact</span> <span class=\"n\">topology_eq</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>completes the second part of the proof.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/2508/files#diff-983e16dd03108ad09234625f776ad94cfb58b1f6ee4762bf7519306fd90a2b46R311\">https://github.com/leanprover-community/mathlib4/pull/2508/files#diff-983e16dd03108ad09234625f776ad94cfb58b1f6ee4762bf7519306fd90a2b46R311</a></p>\n<p>Still a bit clunky, but perhaps that's unavoidable?</p>",
        "id": 371385828,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1688196908
    },
    {
        "content": "<p>This fixes your first problem, and so should avoid the <code>convert</code> (which is a hack in this case). In Lean 4 I've seen that when you manually specify an instance in a declaration you need to re-specify it in the body. The <code>letI</code> makes it inline the instance in the body. Actually, come to think of it, is this (re-specifying required) a bug, or an intended feature (maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  knows)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">UpperSetTopology</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">upperSetTopology'</span> <span class=\"n\">α</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 371500476,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1688222190
    },
    {
        "content": "<p>I haven't followed this discussion carefully, but I've written a summary of my approach on the matter (hoping that would help <span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> with <a href=\"https://github.com/leanprover-community/mathlib4/pull/5672\">#5672</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/2508\">#2508</a>). Of course this is only my opinion on the subject so feel free to let me know if you disagree with something. Maybe once we have a version that everyone agrees on it would deserve to become a library note?<br>\nBtw, all of the following applies also to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace#doc\">docs#UniformSpace</a>, and I will use that as an example sometimes.</p>",
        "id": 374577669,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689160039
    },
    {
        "content": "<p>There are three main ways to work with topologies on a type <code>α</code> that can't be declared as an instance (typically because they will disagree with the \"canonical\" options which are declared as instances). </p>\n<ol>\n<li>Working with a bare term of type <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace#doc\">docs#TopologicalSpace</a></li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">myTopology</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Defining a type alias and declaring the desired topology on it as an instance</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MyAlias</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">MyAlias</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>Defining a typeclass predicate expressing that \"the canonical topology on this type is equal to some topology\"</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MyTopologyClass</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">topology_eq</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 374577890,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689160086
    },
    {
        "content": "<p>The important thing to understand is that these are mutually compatible, but also some of them may be useless depending on the situation (examples below).</p>\n<p>Generally speaking, here are the use case for the three options.</p>\n<ol>\n<li>Working with a concrete term of type <code>TopologicalSpace _</code> should almost <em>never</em> be the preferred way of using a theory, because it can get quite annoying and lengthy due to the <code>@</code>s and <code>_</code>s everywhere (althoug Lean4's named arguments can make that slightly better). That said, actually working with these terms is often a convenient way to <em>build up</em> the API, by using the order structure and other operations on topologies, but this should almost be an implementation detail.</li>\n<li>Type aliases are really useful when you want to endow a type with a topology that is <em>really not</em> (e.g propositionally) the default one. In some cases this is even what we do in pen-and-paper mathematics (e.g Bourbaki uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">F</mi><mi>u</mi></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}_u(X, Y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0993em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> for the functions endowed with the uniform convergence topology, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>E</mi><mi>s</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msubsup></mrow><annotation encoding=\"application/x-tex\">E_s&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9989em;vertical-align:-0.247em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-2.453em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span> for the weak-* dual of a TVS <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>). </li>\n<li>The predicate class is most useful if you have examples of types whose default topology happens to be the one you want, just not definitionally. Then stating results using a predicate typeclass allows you to use the results seemlessly, without needing to rewrite an equality of topologies back and forth in your goal and hypotheses. Note also that this combines nicely with 1 and 2, because if you give the right instances then results about <code>MyTopologyClass</code> will automatically apply to <code>MyAlias</code> as well as <code>myTopology</code>.</li>\n</ol>",
        "id": 374578295,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689160176
    },
    {
        "content": "<p>To illustrate this, here are three examples currently in the library:</p>\n<ul>\n<li>For the order topology, we have 1 (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder.topology#doc\">docs#Preorder.topology</a>) and 3 (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderTopology#doc\">docs#OrderTopology</a>). It is very important to have 3 in this case because a lot of topologies naturally happen to coincide with the order topology, e.g the usual topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> (which is not <em>defined</em> from the order). We use 1 for various things, but one use I want to highlight is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrictMono.induced_topology_eq_preorder#doc\">docs#StrictMono.induced_topology_eq_preorder</a> where we want to use topological operations (in this case <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.induced#doc\">docs#TopologicalSpace.induced</a>) on it. Note however that this lemma is then immediately re-stated in terms of 3</li>\n<li>For the weak topology on a TVS induced by a pairing, we have only 2 (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeakBilin.instTOpologicalSpace#doc\">docs#WeakBilin.instTOpologicalSpace</a>). Here 3 wouldn't make sense since there aren't a lot of spaces where the weak topology would be the default one (except maybe finite dimensional spaces). We also never had to use 1 so far, mostly thanks to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeakBilin.embedding#doc\">docs#WeakBilin.embedding</a> which completely characterizes the topology without resorting to actual equality of <code>TopologicalSpace</code>s.</li>\n<li>For the uniform convergence topology, we have 1 (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun.uniformSpace#doc\">docs#UniformOnFun.uniformSpace</a>) and 2 (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun#doc\">docs#UniformOnFun</a>). Again, 3 would mostly not make sense (see note below) because the type of functions always comes with the product topology by default. Most of the theorems are proven about 2 and its canonical uniformity, but some of them actually follow from a statement about 1 (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun.comap_eq#doc\">docs#UniformOnFun.comap_eq</a> which becomes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun.postcomp_uniformInducing#doc\">docs#UniformOnFun.postcomp_uniformInducing</a>). </li>\n</ul>\n<p>Note: thinking about it, it may make sense to have a <code>UniformConvergenceTopology</code> for <code>FunLike</code> types, expressing e.g that the usual topology on continuous linear maps is that of bounded convergence in a nicer way than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.strongUniformity.uniformEmbedding_coeFn#doc\">docs#ContinuousLinearMap.strongUniformity.uniformEmbedding_coeFn</a></p>",
        "id": 374578518,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689160219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Multiple.20topologies.3F/near/374578295\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Working with a concrete term of type <code>TopologicalSpace _</code> should almost <em>never</em> be the preferred way of using a theory, because it can get quite annoying and lengthy due to the <code>@</code>s and <code>_</code>s everywhere (althoug Lean4's named arguments can make that slightly better). That said, actually working with these terms is often a convenient way to <em>build up</em> the API, by using the order structure and other operations on topologies, but this should almost be an implementation detail.</li>\n</ol>\n</blockquote>\n<p>I think it would be very worthwhile to add named topology arguments and then see whether this approach is actually more useful in some of the API building parts that are more on the 'abstract nonsense' side (like polar topologies or S-topologies) where synonyms are a bit annoying because you might want to use mainly one topology but state some things in a different topology.</p>",
        "id": 374611018,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1689166799
    },
    {
        "content": "<p>the only remaining downside I see is that the docs might be harder to read (is this fixable for named implicit arguments?)</p>",
        "id": 374611838,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1689166930
    },
    {
        "content": "<p>Yes I agree. Note that we already have some nice notations like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology#doc\">docs#Topology</a>.«termUniformContinuous[_,_]» too.</p>",
        "id": 374629187,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689170282
    },
    {
        "content": "<p>Oh also there's one important caveat to \"1 should never be the main entry point of the API\", which is that sometimes you don't really want an API (maybe that covers Moritz's examples? I don't know enough to tell) because it's more of a gadget than an interesting definition in itself. This kind of definitions are typically here just to simplify a proof or to formulate a more interesting definition, but they may not have a lot of interest by themselves.</p>",
        "id": 374634400,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689171143
    },
    {
        "content": "<p>That said, adding 3 on top of 1 is never going to be a problem since everything stated for 3 will apply to 1. The type alias setup is a bit heavier.</p>",
        "id": 374635355,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689171305
    }
]