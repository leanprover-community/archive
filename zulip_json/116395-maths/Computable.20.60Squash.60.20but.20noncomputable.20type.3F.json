[
    {
        "content": "<p>Is there any type <code>α</code> such that we have a computable <code>def a : Squash α</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Squash#doc\">docs#Squash</a>) but no computable <code>def b : α</code>?</p>",
        "id": 490190849,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711019
    },
    {
        "content": "<p>With any constraints on <code>a</code> and <code>b</code>?</p>",
        "id": 490191031,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734711100
    },
    {
        "content": "<p>What do you mean? They need to be computable and use the standard axiom set (<code>propext</code>, <code>Quot.sound</code>, <code>Classical.choice</code>)</p>",
        "id": 490191142,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711134
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Squash</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">√</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"c1\">-- can't remove `noncomputable`</span>\n</code></pre></div>",
        "id": 490191247,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734711176
    },
    {
        "content": "<p>But <code>Squash</code> is a distraction in that example, hence my question</p>",
        "id": 490191428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734711246
    },
    {
        "content": "<p>I meant no computable value, which isn't true for <code>ℝ</code> - you can have <code>def b : ℝ := 0</code></p>",
        "id": 490192167,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734711548
    },
    {
        "content": "<p>I don't think it's possible; you can compute the <code>Squash</code> value exactly when you can compute <em>some</em> value of the original type... I believe the reason for this is that lean treats <code>Squash.mk</code> as <code>id</code> when computing</p>",
        "id": 490197215,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734713305
    },
    {
        "content": "<p>And in general lean does this for quotients</p>",
        "id": 490197400,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734713380
    },
    {
        "content": "<p>(I may be confused with <code>Trunc</code> tho)</p>",
        "id": 490197520,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734713410
    },
    {
        "content": "<p>Looking into it, these are effectively the same type (and possibly even defeq? Don't treat them as such tho)</p>",
        "id": 490198352,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734713742
    },
    {
        "content": "<p>(<a href=\"#narrow/channel/116395-maths/topic/Strength.20of.20Nonempty.20.CE.B1.20.E2.86.92.20Squash.20.CE.B1/near/450507842\">previous thread</a>)</p>",
        "id": 490202880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1734715561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/116395-maths/topic/Computable.20.60Squash.60.20but.20noncomputable.20type.3F/near/490197215\">said</a>:</p>\n<blockquote>\n<p>I don't think it's possible; you can compute the <code>Squash</code> value exactly when you can compute <em>some</em> value of the original type... I believe the reason for this is that lean treats <code>Sqaush.mk</code> as <code>id</code> when computing</p>\n</blockquote>\n<p>Yes, but maybe there's some difference between \"computable\" in the compiler sense and \"computable\" in the theoretical sense? I'm not sure</p>",
        "id": 490206985,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1734717450
    },
    {
        "content": "<p>if we care about computable in the theoretical sense, i suspect that any nonempty type has a computable element using choice?</p>",
        "id": 490229997,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734728449
    },
    {
        "content": "<p>you can choose a partial encoding of the type, in such a way that <code>0</code> is the encoding of the first element, at which point decoding <code>0</code> is a computable definition of an element of the type.</p>",
        "id": 490230310,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734728641
    },
    {
        "content": "<p>of course, this is kind of cheating, since the encoding we're using is not (necessarily) canonical, or even total for that matter.</p>",
        "id": 490230492,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1734728734
    }
]