[
    {
        "content": "<p>If <code>V</code> is a topological vector space over a normed field <code>ğ•œ</code>, how can I construct the canonical map from V to its double dual? That is, I'm looking for a construction of a map <code>R : V â†’L[ğ•œ] ((V â†’L[ğ•œ] ğ•œ) â†’L[ğ•œ] ğ•œ)</code> such that <code>R v e = e v</code> for all <code>(v : V) (e : V â†’L[ğ•œ] ğ•œ)</code>.</p>\n<p>If we forget the topologies and just ask for a plain linear map, this is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map\">docs#linear_map</a>.applyâ‚—. If we put a normed-space structure (not just a topological-vector-space structure) on <code>V</code>, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map.apply\">docs#continuous_linear_map.apply</a>; but I don't want to force a choice of norm on <code>V</code>. It looks like mathlib does know how to topologize <code>V â†’L[ğ•œ] ğ•œ</code>for any TVS, so the question makes sense, but I can't seem to find an answer to it in the library.</p>",
        "id": 350042017,
        "sender_full_name": "David Loeffler",
        "timestamp": 1681504657
    },
    {
        "content": "<p>do we have something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/weak_dual.apply\">docs#weak_dual.apply</a> ?</p>",
        "id": 350042531,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1681504869
    },
    {
        "content": "<p>well, it should be quite easy using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/weak_dual.eval_continuous\">docs#weak_dual.eval_continuous</a></p>",
        "id": 350042621,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1681504912
    },
    {
        "content": "<p>Are you using the weak topology?</p>",
        "id": 350042676,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1681504923
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/top_dual_pairing\">docs#top_dual_pairing</a> also seems useful</p>",
        "id": 350043628,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1681505284
    },
    {
        "content": "<blockquote>\n<p>It looks like mathlib does know how to topologize <code>V â†’L[ğ•œ] ğ•œ</code> for any TVS</p>\n</blockquote>\n<p>I seem to remember that <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> had made quite a lot of progress on this, but it either didn't make it to a PR, or the PR was diverted into a refactor elsewhere and then forgotten</p>",
        "id": 350047594,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681506818
    },
    {
        "content": "<p>(referred to <a href=\"#narrow/stream/116395-maths/topic/Distribution.20theory/near/292318478\">here</a>)</p>",
        "id": 350047724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681506864
    },
    {
        "content": "<p>Aha, <a href=\"#narrow/stream/116395-maths/topic/Topology.20on.20continuous_maps.20without.20a.20norm\">this is the thread</a> I'm thinking of</p>",
        "id": 350048025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681506978
    },
    {
        "content": "<p>I think we don't have the construction but it should be very easy, the key lemma being <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_on_fun.uniform_continuous_eval_of_mem\">docs#uniform_on_fun.uniform_continuous_eval_of_mem</a>. At some point it would be nice to go systematically through the basic operator norm files and generalize as much as possible, but this should probably wait for the port</p>",
        "id": 350050116,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1681507992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/116395-maths/topic/Map.20vector.20space.20to.20its.20double.20dual/near/350042017\">said</a>:</p>\n<blockquote>\n<p>If we forget the topologies and just ask for a plain linear map, this is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map\">docs#linear_map</a>.applyâ‚—.</p>\n</blockquote>\n<p>Just so you know (or in case it's useful to anyone who finds this thread later), the pure algebra version is wrapped up as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.dual.eval\">docs#module.dual.eval</a></p>",
        "id": 350052056,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681509026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Map.20vector.20space.20to.20its.20double.20dual/near/350050116\">said</a>:</p>\n<blockquote>\n<p>I think we don't have the construction but it should be very easy, the key lemma being <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_on_fun.uniform_continuous_eval_of_mem\">docs#uniform_on_fun.uniform_continuous_eval_of_mem</a>. At some point it would be nice to go systematically through the basic operator norm files and generalize as much as possible, but this should probably wait for the port</p>\n</blockquote>\n<p>Actually that's not quite right. What can easily be proved is that each evaluation is continuous (i.e we can get <code>V â†’â‚—[ğ•œ] ((V â†’L[ğ•œ] ğ•œ) â†’L[ğ•œ] ğ•œ)</code>), but it is not clear at all that the last continuity is true in general (and Bourbaki seems to indicate otherwise, but I will have another look to be sure). Of course it is true for normed space and we could give topological conditions to make it work without invoking extra data (typically \"bornological\" or \"barreled\", but unfortunately we don't have these in mathlib yet).<br>\nJust to be clear, let me mention that this is all way easier if you work with weak topologies, but since you want to generalize the normed case I figured this is probably not what you want.</p>",
        "id": 350058243,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1681512022
    },
    {
        "content": "<p>Ah, so the reason I couldn't find the result I wanted in mathlib is because it's false, which is a pretty good reason. Thanks for enlightening me on that!</p>\n<p>(Ironically, the case I want this for is actually when V is finite-dimensional. In this case the mathematical issues are all trivial, but the problem is getting mathlib to recognise that <code>V â†’L[ğ•œ] ((V â†’L[ğ•œ] ğ•œ) â†’L[ğ•œ] ğ•œ)</code> and <code>V â†’â‚—[ğ•œ] ((V â†’â‚—[ğ•œ] ğ•œ) â†’â‚—[ğ•œ] ğ•œ)</code> are the same thing.)</p>",
        "id": 350079678,
        "sender_full_name": "David Loeffler",
        "timestamp": 1681524647
    },
    {
        "content": "<p>Surely we have an equiv for that, right?</p>",
        "id": 350079725,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1681524690
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.to_continuous_linear_map\">docs#linear_map.to_continuous_linear_map</a></p>",
        "id": 350079835,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1681524758
    },
    {
        "content": "<p>You can probably use that to beef it up to the version needed here (I guess it's not <em>super</em> trivial though).</p>",
        "id": 350079888,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1681524807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/Map.20vector.20space.20to.20its.20double.20dual/near/350079888\">said</a>:</p>\n<blockquote>\n<p>You can probably use that to beef it up to the version needed here (I guess it's not <em>super</em> trivial though).</p>\n</blockquote>\n<p>Unfortunately, it seems it is not only not super-trivial, but possibly even strictly sub-trivial. Using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.to_continuous_linear_map\">docs#linear_map.to_continuous_linear_map</a> you can get a linear equivalence between <code>V â†’L[ğ•œ] ğ•œ</code> and <code>V â†’â‚—[ğ•œ] ğ•œ</code>. But you can't get a continuous linear equivalence; indeed the latter space doesn't have a topology at all, as far as mathlib is concerned. So I don't see how to use the same trick a second time to get an isomorphism between the algebraic and topological double duals.</p>",
        "id": 350092357,
        "sender_full_name": "David Loeffler",
        "timestamp": 1681535898
    },
    {
        "content": "<p>I don't think you were interpreting what I said the same way I intended it. You can get a linear equivalence between <code>V â†’L[ğ•œ] ((V â†’L[ğ•œ] ğ•œ) â†’L[ğ•œ] ğ•œ)</code> and <code>V â†’â‚—[ğ•œ] ((V â†’â‚—[ğ•œ] ğ•œ) â†’â‚—[ğ•œ] ğ•œ)</code> by constructing the equivalence piece by piece using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.to_continuous_linear_map\">docs#linear_map.to_continuous_linear_map</a> to upgrade with continuity, and using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.arrow_congr\">docs#linear_equiv.arrow_congr</a> to paste things together. Like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.module.finite_dimension</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.module.strong_topology</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_add_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_smul</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span> <span class=\"bp\">â‰ƒâ‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">linear_equiv.refl</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">arrow_congr</span> <span class=\"bp\">$</span>\n  <span class=\"o\">((</span><span class=\"n\">linear_map.to_continuous_linear_map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â‰ƒâ‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">arrow_congr</span>\n  <span class=\"o\">(</span><span class=\"n\">linear_equiv.refl</span> <span class=\"bp\">ğ•œ</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"n\">linear_map.to_continuous_linear_map</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"n\">linear_map.to_continuous_linear_map</span>\n</code></pre></div>\n<p>In a calc-style block, this looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span> <span class=\"bp\">â‰ƒâ‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span>\n<span class=\"bp\">...</span>                             <span class=\"bp\">â‰ƒâ‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span>\n<span class=\"bp\">...</span>                             <span class=\"bp\">â‰ƒâ‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 350114589,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1681549063
    },
    {
        "content": "<p>Great, thank you very much for your help! I hadn't come across <code>linear_map.arrow_congr</code> before, I'll have to remember that one.</p>\n<p>For my application, I eventually realised I could get away with something a little weaker:  I only need an element of <code>V â†’â‚—[ğ•œ] ((V â†’L[ğ•œ] ğ•œ) â†’â‚—[ğ•œ] ğ•œ)</code> (with two <code>â†’â‚—</code>s and one <code>â†’L</code>) and this can be constructed as <code>(top_dual_pairing ğ•œ V).flip</code>.</p>",
        "id": 350200642,
        "sender_full_name": "David Loeffler",
        "timestamp": 1681582014
    }
]