[
    {
        "content": "<p>I'm trying to formalize ordinals as transitive sets based on ZF axioms (no choice, I'm polyfilling Classical logic via axiom of excluded middle directly without going through Classical.choice).</p>\n<p>I'm having trouble formalizing <code>a ⊂ b -&gt;  a ∈ b</code> given two ordinals <code>a</code> and <code>b</code>. I think this is required or very helpful to prove membership trichotomy, which I haven't done yet. I've linked this below.</p>\n<p>The strategy I'm using is based off of this document: <a href=\"https://www.ucl.ac.uk/~ucahcjm/ast/ast_notes_2.pdf\">https://www.ucl.ac.uk/~ucahcjm/ast/ast_notes_2.pdf</a>, and <a href=\"https://proofwiki.org/wiki/Transitive_Set_is_Proper_Subset_of_Ordinal_iff_Element_of_Ordinal\">ProokWiki</a>. But I just realized both proofs seem to be using properties of ordinals that haven't been established yet. And ProofWiki seems to be using circular proofs.</p>\n<p>So I'm stuck. My strategy so far is to show that since <code>b \\ a</code> is nonempty (since a is a proper subset of b), there exists a minimal element (let's call it <code>s</code>). Then prove <code>s = a</code>, and since <code>s ∈ b \\ a</code>, it follows that <code>a ∈ b</code>.  This is taken from ast_notes_2.pdf. I can prove that <code>s ⊆ a</code>, but the converse <code>a ⊆ s</code> is proving challenging. This step in ProofWiki appeals to membership trichotomy (which  in turn appeals back to this very proof no matter what path is taken through ProofWiki), and in ast_notes_2.pdf it appeals to the well ordering of set membership.</p>\n<blockquote>\n<p>Also, because ∈ is a l.o. of β, γ ∈ α implies that γ ∈ s, thus α ⊆ s</p>\n</blockquote>\n<p>Where <code>l.o.</code> is linear order, but this also seems to depend on trichotomy which is only established later. So I'm not sure how to translate this proof to Lean.</p>\n<p><a href=\"https://github.com/RustyYato/zfc/blob/5900e67043afda4b4ab51611885fa0dd6d451fff/Zfc/Ordinal.lean#L121-L154\">https://github.com/RustyYato/zfc/blob/5900e67043afda4b4ab51611885fa0dd6d451fff/Zfc/Ordinal.lean#L121-L154</a></p>\n<p>I've defined Ordinals as <code>def Zf.IsOrdinal (a: α): Prop := ∀x ∈ a, x ∩ a = x</code>. Which I think is correct, since it is equivalent to Definition 3 in Proof Wiki, if we take set membership to be the relation. <a href=\"https://proofwiki.org/wiki/Definition:Ordinal\">https://proofwiki.org/wiki/Definition:Ordinal</a>. However I'm not sure if this enforces that set membership well orders <code>a</code>.  It was able to prove that <code>ω</code> and all <code>Nat</code> are ordinals, so it not obviously wrong,  but that isn't proof that this definition is correct.</p>\n<p>I have also proven that this definition is equivalent to <code>def Zf.IsTransitive (a: α): Prop := ∀x ∈ a, x ⊆ a</code>, so that seems like strong proof that it is correct.</p>\n<p>tldr: I'm having trouble formalizing <code>a ⊂ b -&gt;  a ∈ b</code> given two ordinals <code>a</code> and <code>b</code>, and any pointers would be very helpful.</p>",
        "id": 463187154,
        "sender_full_name": "RustyYato",
        "timestamp": 1723993964
    },
    {
        "content": "<p>Your definition of ordinal has a bug: an ordinal is a transitive set of transitive sets, not a transitive set. For instance, {0, {0}, {{0}}} is considered an ordinal by your program.</p>",
        "id": 463193182,
        "sender_full_name": "Sky Wilshaw",
        "timestamp": 1723996020
    },
    {
        "content": "<p>Oh wow that would do it. Thanks! I'll see how I can fix that</p>",
        "id": 463199718,
        "sender_full_name": "RustyYato",
        "timestamp": 1723998258
    },
    {
        "content": "<p>I guess using Definition two from ProofWiki would be easiest</p>\n<p><a href=\"https://proofwiki.org/wiki/Definition:Ordinal/Definition_2\">https://proofwiki.org/wiki/Definition:Ordinal/Definition_2</a></p>\n<p>Looks like that is a promising direction, thanks!</p>",
        "id": 463205332,
        "sender_full_name": "RustyYato",
        "timestamp": 1724000704
    },
    {
        "content": "<p>I've been able to find a very minimal definition of ordinals in the past:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A transitive set is one where every element is a subset. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsTransitive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- A set `x` is a von Neumann ordinal when it's a transitive set, that's transitive under `∈`. We</span>\n<span class=\"sd\">prove that this further implies that `x` is well-ordered under `∈`.</span>\n\n<span class=\"sd\">The transitivity condition is written in an even weaker form, where `a ∈ b` and `b ∈ c` imply</span>\n<span class=\"sd\">`a ∈ c` when only `c ∈ x` and not `a ∈ x` or `b ∈ x` are known a priori. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsOrdinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">IsTransitive</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>",
        "id": 463276836,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724034046
    },
    {
        "content": "<p>See my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/15793\">#15793</a></p>",
        "id": 463276865,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724034061
    },
    {
        "content": "<p>This is a much weaker definition than any of the ones in ProofWiki. I've proven that it's equivalent to being a transitive well-ordered set in a Lean 3 branch I'm currently working on porting.</p>",
        "id": 463277078,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724034217
    },
    {
        "content": "<p>Cool, actually your PR was why I started this! Since this seems like a step up from my last adventure in Lean (proving things about the Naturals, and defining the Reals). I'm still wrapping my head around that definition. </p>\n<p>I'm curious, what's the benefit of a weaker definition if it is equivalent to the standard definition?</p>\n<p>Currently I'm using this definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Zf</span><span class=\"bp\">.</span><span class=\"n\">IsTransitive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Zf</span><span class=\"bp\">.</span><span class=\"n\">IsTotalOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Zf</span><span class=\"bp\">.</span><span class=\"n\">IsOrdinal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">IsTransitive</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTransitive</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">IsTotalOrder</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Zf</span><span class=\"bp\">.</span><span class=\"n\">IsTotalOrder</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>and am currently working on addition, and am having some trouble there, but I think I can figure it out.</p>",
        "id": 463452557,
        "sender_full_name": "RustyYato",
        "timestamp": 1724085336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> I presume that your definition makes use of the axiom of regularity/foundation. Set theorists usually find it interesting to have a definition of ordinals that avoids this axiom because if you don't add it, and take the class of sets which are “regular” (there is no chain of element containing an element containing…), then it gives you a model of Set theory that satisfies the regularity axiom, hence indicates some independence of that axiom with respect to the other ones.</p>",
        "id": 464410804,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1724340753
    },
    {
        "content": "<p>I hadn't noticed that, but yes. A quine atom would be an ordinal under this definition.</p>",
        "id": 464485820,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724363096
    },
    {
        "content": "<p>\"A well-ordered set under <code>∈</code>\" is probably the correct definition under such generality</p>",
        "id": 464485882,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724363143
    }
]