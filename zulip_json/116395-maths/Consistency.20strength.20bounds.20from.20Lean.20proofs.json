[
    {
        "content": "<p>As is old news at this point, Sky Wilshaw recently formalized Randall Holmes's proof of the consistency of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">N</mi><mi mathvariant=\"sans-serif\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{NF}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">NF</span></span></span></span></span> in Lean. If I recall correctly, Holmes has stated that he believes the proof should go through in something as weak as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> without replacement + \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℶ</mi><msub><mi>ω</mi><mn>1</mn></msub></msub></mrow><annotation encoding=\"application/x-tex\">\\beth_{\\omega_1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.939em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">ℶ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> exists\", and this is plausible to me given my extremely broad understanding of the proof. But I'm also under the impression (and please correct me if I'm wrong) that, while you can ask Lean to report the axioms used in a proof, this is really in the sense of the word 'axiom' used in type theory, rather than in classical mathematical logic, and as such doesn't necessarily represent the full strength used in a proof. (For instance, a fully constructive proof of the consistency of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{PA}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">PA</span></span></span></span></span> would be reported as using no axioms.) </p>\n<p>It's relatively clear to me that one could read off the number of universe levels used in a fully compiled proof term, but a priori it seems like this wouldn't allow you to get below something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> + \"there exists approximately <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> inaccessible cardinal\", which is well above Holmes's intuition about how much strength his proof really needs. Has there been any work that would allow one to extract a tighter bound automatically? I think this would be nice to see even if it can't get as low as Holmes's estimate.</p>\n<p>I'd also be curious about this in the context of the proof of Fermat's Last Theorem, since the original proof famously uses some inaccessible cardinals (i.e., Grothendieck universes) <a href=\"https://arxiv.org/abs/1102.1773v4\">but it's known that the relevant machinery needs much less</a> and it's widely suspected that the theorem should be provable in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{PA}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">PA</span></span></span></span></span>.</p>",
        "id": 515826143,
        "sender_full_name": "James E Hanson",
        "timestamp": 1746235374
    },
    {
        "content": "<p>This PA.SX question addresses a bit of this with links back to Zulip: <a href=\"https://proofassistants.stackexchange.com/questions/2728/lean-and-inaccessible-cardinals/2755#2755\">https://proofassistants.stackexchange.com/questions/2728/lean-and-inaccessible-cardinals/2755#2755</a></p>",
        "id": 515830437,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746238009
    },
    {
        "content": "<p>But Lean isn’t probably ever suited for measuring below the strength of ZFC.</p>",
        "id": 515830594,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746238098
    },
    {
        "content": "<p>Here is a direct link to a Zulip thread also talking  about related stuff: <a href=\"#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes\">https://leanprover.zulipchat.com/#narrow/stream/236446-Type-theory/topic/Theory.20of.20Lean.20with.20n.20universes</a></p>",
        "id": 515830781,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746238227
    },
    {
        "content": "<blockquote>\n<p>I'd also be curious about this in the context of the proof of Fermat's Last Theorem, since the original proof famously uses some inaccessible cardinals (i.e., Grothendieck universes)</p>\n</blockquote>\n<p>Just pushing back on this -- it was a completely incorrect rumour at the time that the original proof \"famously\" used inaccessible cardinals. The proof used nothing beyond SGA4.5 which needs no inaccessible cardinals, and it was just a bunch of misguided logicians making a lot of noise. The facts that results from SGA4 appear in the FLT paper and that parts of SGA4 use inaccessible cardinals cannot be used to deduce that FLT uses inaccessible cardinals (this was the error made by the people who just looked at the references and didn't understand the proof).</p>",
        "id": 515885686,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746272091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/515885686\">said</a>:</p>\n<blockquote>\n<p>and it was just a bunch of misguided logicians making a lot of noise.</p>\n</blockquote>\n<p>Professor Buzzard, I must confess that as a logician myself I find the way you phrase these things a little unwelcoming.</p>\n<p>I would presume that after you finish formalizing FLT, you'd like to be able to point to some computer verification of the additional mathematical fact that the proof of FLT does not need any inaccessible cardinals (otherwise how could you be so certain that it actually doesn't?). At the end of the day, that is what I'm thinking about. To what extent can we automate the fairly common 'obvious' process of looking at a proof and deciding that it doesn't depend on strong assumptions in the background theory?</p>\n<p>From what I'm gathering, though, this might be hard to do automatically from a proof formalized in Lean, as dependent type theory tends to use inaccessible cardinals a little bit liberally. I guess I need to spend some time thinking about when and how you can systematically replace something like Grothendieck or type-theoretic universes with smaller 'approximate universes' (like how the Stacks project operates to stay inside <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span>). This is pretty interesting to me because we know that you can't actually do it in full generality, since, for instance, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> + \"there exists an inaccessible cardinal\" proves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Π</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Pi^0_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span> facts that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{ZFC}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span></span></span></span> alone does not. This makes it a challenge to delineate, say, a Lean proof of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">n</mi></mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"sans-serif\">Z</mi><mi mathvariant=\"sans-serif\">F</mi><mi mathvariant=\"sans-serif\">C</mi></mrow><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Con}(\\mathsf{ZFC})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Con</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathsf\">ZFC</span></span><span class=\"mclose\">)</span></span></span></span> from a Lean proof of FLT, since these are both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi mathvariant=\"normal\">Π</mi><mn>1</mn><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\Pi^0_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0622em;vertical-align:-0.2481em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.4519em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2481em;\"><span></span></span></span></span></span></span></span></span></span> statements.</p>",
        "id": 515945050,
        "sender_full_name": "James E Hanson",
        "timestamp": 1746302104
    },
    {
        "content": "<p>Yes my proof of FLT will use inaccessibles, because of the nature of the software I'm using. Wiles' proof did not and that's a fact, and I apologise if I explained this in an unwelcoming way but it makes me angry that this lie is still being perpetrated.</p>",
        "id": 516001450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746342748
    },
    {
        "content": "<p>To be more precise, my proof will be a proof in Lean's type theory, which is equiconsistent with ZFC + a statement about inaccessibles</p>",
        "id": 516001588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746342866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> has thought about the idea of post-processing lean proofs to demonstrate that they \"could have been done without inaccessibles\" but apparently this is hard to do in practice because universes are everywhere in the theory.</p>",
        "id": 516001864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746343135
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Just so I’m clear, you are saying that if one looks at the original proof of Wiles’ theorem and all the specific theorems that it references from other sources, then none of this used large cardinals?  And if someone bothered to check that, it would have been clear?  (And of course to be fair to McLarty, going through FLT’s proof in detail just to work this out may have been a research level task on its own. <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>)</p>",
        "id": 516020878,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746359224
    },
    {
        "content": "<p>(Maybe I shouldn’t defend McLarty.  I’ve never read his paper and I don’t know if he was right or not on his points, especially about FLT, at least on the surface, using universes.)</p>",
        "id": 516021350,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746359664
    },
    {
        "content": "<p>McLarty proved much more because he showed that one needed far less than ZFC. But yes, Wiles never uses universes and nor does anything he relies on. </p>\n<p>Wiles does use etale cohomology. The very first references for etale cohomology were Grothendieck's SGA4 and SGA5 which famously use universes because they develop a hugely general machine using topoi which could be used to construct all sorts of exotic cohomology theories, for example fpqc cohomology which does have foundational subtleties. However etale cohomology was then used to prove the Weil conjectures and in order to demonstrate to the mathematical community that universes were not used in the proof of the Weil conjectures, Deligne wrote SGA4.5, which developed etale cohomology without all the topos-theoretic framework and demonstrated that the proof of the Weil conjectures did indeed work fine in ZFC. The situation then stayed like this for 20 years, and several other books were written developing etale cohomology in ZFC for example Milne's book and Freitag-Kiehl.</p>\n<p>Then suddenly when FLT was proved someone claimed on the internet that the proof used etale cohomology and hence universes, and despite the attempts of several number theorists to try and explain that this was not at all the case, the claim still seems to have some traction.</p>",
        "id": 516032657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746368344
    },
    {
        "content": "<p>well this sounds like a rather disappointing end to the project to show that the lean proof of FLT doesn't use universes</p>",
        "id": 516033245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746368760
    },
    {
        "content": "<p>Yes it's just the opposite! I'm putting them back in!</p>\n<p>We talked about this sort of thing in about 2019. My memory of the conversation was that I said \"presumably I can just use universes left right and centre in any proof, and then you can write a program checking that the proof works fine in ZFC\" and you said \"hmm it might not be that simple\". And then later on you did write a simpler program which counted the number of universes used in proofs, and the answers were far higher than I was expecting, e.g. there was some trivial assertion about finite sets which you claimed used <code>Type 4</code> at some point (and I was incredulous but it was what your code said). This was all in Lean 3 and then when Lean 4 happened I encouraged you to port the code but you had plenty of other things to worry about (e.g. porting mathlib) so as far as I know we still don't have it. But that code (just counting the number of universes actually used) isn't what would be needed here, what would be needed here is far more nontrivial and probably we're not ready for it yet. <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> has been thinking about this sort of thing carefully in some of his recent PRs in category theory. The general phenomenon that you want to take care of is when you want to define a cohomology theory by taking some kind of limit over covers but that limit is not a set. In SGA4 Grothendieck just took the limit anyway, and his cohomology group was defined one universe level up. In SGA4.5 Deligne showed how you could take the limit over a set and still get the same answer (that's the basic idea but it's more complicated than this, you also have to show that everything you want to do with the cohomology theory also descends, but this is the basic idea). Joel has been proving general results of the form \"if hom types in a category descend to a smaller universe then various constructions which you make using this category also descend\". But if you want to get a proof of FLT into ZFC then you need to show that these techniques apply. Set theorists understand this problem well; a reference for how it works in algebraic geometry is in the Stacks project: the set-theoretic input is <a href=\"https://stacks.math.columbia.edu/tag/000F\">here</a> and the application to schemes is <a href=\"https://stacks.math.columbia.edu/tag/000H\">here</a>. In particular it's not something which you get \"for free\", there is content here. </p>\n<p>I suppose the last thing to add is that ironically the work I'm formalizing (the modern version of the Wiles paper) will avoid etale cohomology completely. However I will be assuming the existence of Galois representations attached to Hilbert modular forms and the only known construction of these in the generality I require uses etale cohomology.</p>",
        "id": 516036671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746370808
    },
    {
        "content": "<p>Just to clarify, the project I'm talking about is an extension of that discussion we had (and also some discussions we had last summer at the hausdorff institute). The basic idea is that yes, you can count up the <code>Type</code> levels directly used in the proof and you will get a number like 4 or something and this can indeed be used to prove that you can establish the theorem using 4 universes, but that's a boring upper bound. It's possible to do better than that, even without changing the actual proof. <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> hints at this already in his first post, it is possible to interpret <code>Type u</code> as being less than a full universe and thereby avoid needing an inaccessible cardinal.</p>\n<p>But if FLT itself (the original proof) doesn't use universes, then this is a much less interesting headline (\"formalizing the proof in lean solved an open question about whether FLT can be done without universes\") and instead is \"formalizing the proof proved a weaker result and wasted a bunch of peoples' time\"</p>",
        "id": 516037113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746371117
    },
    {
        "content": "<p>In case it is useful to anyone, here is a 14 years old discussion of the same issue on mathoverflow: <a href=\"https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof\">https://mathoverflow.net/questions/35746/inaccessible-cardinals-and-andrew-wiless-proof</a>.</p>",
        "id": 516037478,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1746371355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/516001450\">said</a>:</p>\n<blockquote>\n<p>but it makes me angry that this lie is still being perpetrated.</p>\n</blockquote>\n<p>I apologize for spreading a misconception, but, again, the word 'lie' is pretty strong and accusatory. It suggests malicious intent.</p>\n<p>Given the prevalence of people who seem to think that set theory 'isn't really mathematics' or something to that effect, I don't see what's wrong with set theorists being excited about the potential relevance of concepts in their field to big famous results. I've met people who work with Grothendieck universes and don't even realize they're directly related to the large cardinals set theorists talk about.</p>",
        "id": 517169051,
        "sender_full_name": "James E Hanson",
        "timestamp": 1746816038
    },
    {
        "content": "<p>Thanks for coming back James. As you can see I clearly have very strong opinions about this (I remember it all unfolding at the time and being extremely frustrated about how incorrect claims were being circulated) but I think the mathoverflow post summarises the facts accurately. </p>\n<p>Regarding the far more interesting question of how lean fits into all of this, my initial naive model of how things could work would be that we could just work in Lean's type theory and get on with it and then try and shoehorn it all into ZFC later on. But this is more subtle than it looks. I don't claim to understand all the subtleties but here is I think one, which I'll illustrate by example. </p>\n<p>The concept of finiteness in ZFC is represented by a predicate on sets which can be captured by a formula. The concept of finiteness in lean is simply a function from a type universe to Prop. In ZFC you can do certain things with functions and you can do different things with predicates on sets, they're different objects and satisfy different rules. A class in ZFC can't be defined as just \"any old collection of sets\", it must somehow be defined by a rule. But you can say \"let f be any old function\". My worries about translating a proof of FLT in lean directly into a ZFC proof is that at some point I will use the language of categories and will do things which, to check they're ok in ZFC, one will have to take various definitions apart to check that they can be translated into predicates which can be expressed in an appropriate first order language and that I didn't do \"functiony\" things which can't be translated into \"predicatey\" things. For example I can say \"choose a well-ordering of the reals\" in ZFC but in lean I can say \"choose a well-ordering of <code>Type</code>\" because it's no different.</p>",
        "id": 517179260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746820547
    },
    {
        "content": "<p>The point is that \"choose a well-ordering of Type\" is <em>also</em> something you can do in ZFC, because Type is just another set. It's definitely got to be interpreted as a set, interpreting it as V doesn't work. Either you say that the set is a grothendieck universe and now you need an inaccessible cardinal (this is the easy way), or you interpret it as an almost-universe and check that the proof doesn't do any concrete construction that violates the almostness of the universe. I believe this is a more sophisticated version of your point about translating the proof into functiony things and predicatey things. But I am quite confident in asserting that the upshot for you is that should just \"get on with it and then try and shoehorn it all into ZFC later on\".</p>",
        "id": 517227725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746856541
    },
    {
        "content": "<p>I do think that this leads to an interesting problem for set theorists, namely to figure out what kind of almostness one needs to cover a significant fraction of lean in practice. As you know, I've been trying to figure that out myself, and I have some possible answers but they aren't great. Perhaps I can interest some other people in this problem.</p>",
        "id": 517227945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746856787
    },
    {
        "content": "<p>Yes my model was \"Type is the universe\"</p>",
        "id": 517230955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859470
    },
    {
        "content": "<p>That doesn't work because as you hint at, lean is able to do higher order things with Type that go beyond what ZFC can support</p>",
        "id": 517230993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859507
    },
    {
        "content": "<p>even without using Type 1</p>",
        "id": 517231001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859516
    },
    {
        "content": "<p>I'm just not convinced that I do any of them</p>",
        "id": 517231043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859549
    },
    {
        "content": "<p>But this might be hard to check</p>",
        "id": 517231052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859560
    },
    {
        "content": "<p>You certainly do. Just writing down <code>Group</code> requires defining a function into Type</p>",
        "id": 517231107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859574
    },
    {
        "content": "<p>But my point is that set theorists can talk about groups so I'm not <em>really</em> doing it</p>",
        "id": 517231139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859606
    },
    {
        "content": "<p>Just like how Wiles' proof doesn't <em>really</em> use universes</p>",
        "id": 517231169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746859633
    },
    {
        "content": "<p>I certainly agree with this, but that's basically what this almostness is about</p>",
        "id": 517231184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859647
    },
    {
        "content": "<p>the challenge is to take that general intuition and make a coherent system out of it which isn't foiled every time you make a function type</p>",
        "id": 517231264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859699
    },
    {
        "content": "<p>because lean really likes making function types</p>",
        "id": 517231275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859714
    },
    {
        "content": "<p>and I'd like to try to reach a bit further and also handle \"benign\" uses of things like the category of sets, which are also not really fundamentally different from this idea that using <code>Group</code> doesn't mean any more than fancy notation for predicates</p>",
        "id": 517231339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746859798
    },
    {
        "content": "<p>When discussing the ZFC question in the 90s it was clear that all the representable functor stuff in the deformation theory part of Wiles' argument could be shoehorned into an exposition which never said the word \"category\" at all, but the price you paid was a loss of readability which nobody wanted to pay.</p>",
        "id": 517231667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1746860112
    },
    {
        "content": "<p>I think the approach I'm advocating will do much better than that, I think it won't require eliminating categories at all from the lean proof</p>",
        "id": 517231698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746860150
    },
    {
        "content": "<p>in effect, all of that elimination work is turned into an automated check and a metatheorem</p>",
        "id": 517231772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746860190
    },
    {
        "content": "<p>and if it works I think it will be a great advert for the advantage of having formal proof objects to begin with</p>",
        "id": 517231807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746860235
    },
    {
        "content": "<p>I wonder if this question translates to the existence of a metaprogram which maps definitions into <code>ZFSet</code> and predicates on them, in a \"faithful\" way</p>",
        "id": 517244174,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746870333
    },
    {
        "content": "<p>Maybe this is implicit in the thread, but in his lectures at Collège de France, Thierry Coquand insisted that the basic Martin-Löf type theory, with universes, is weaker than second order Peano arithmetic. I understand from this that universes in type theory and Grothendieck universes in set theory are not strict analogues,  so that eliminating Grothendieck universes from Wiles's proof shouldn't require to eliminate type theoretical universes from its formalization in Lean.</p>",
        "id": 517251295,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1746876974
    },
    {
        "content": "<p>But I assume that quote is referring to MLTT without axioms.  The choice axiom makes a large difference.</p>",
        "id": 517251464,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746877177
    },
    {
        "content": "<p>MLTT is predicative, so it's much weaker than CIC used in Lean.</p>",
        "id": 517252673,
        "sender_full_name": "suhr",
        "timestamp": 1746878314
    },
    {
        "content": "<p>I should know this, but what does predicative mean again?  Is it basically that CIC has <code>Prop</code> and <code>\\forall X : Type, p X</code> is in <code>Prop</code> for <code>p : Prop</code>?  (I’m having trouble following <a href=\"https://proofassistants.stackexchange.com/questions/326/what-is-predicativity\">https://proofassistants.stackexchange.com/questions/326/what-is-predicativity</a> .)</p>",
        "id": 517253188,
        "sender_full_name": "Jason Rute",
        "timestamp": 1746878738
    },
    {
        "content": "<p>You have this rule:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mstyle mathcolor=\"red\"><mi>σ</mi></mstyle><mo>:</mo><msub><mi mathvariant=\"script\">U</mi><mi>i</mi></msub><mspace width=\"2em\"/><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mstyle mathcolor=\"red\"><mi>x</mi></mstyle><mo>:</mo><mstyle mathcolor=\"red\"><mi>σ</mi></mstyle><mo stretchy=\"false\">)</mo><mo>⊢</mo><mstyle mathcolor=\"red\"><mi>τ</mi></mstyle><mo>:</mo><msub><mi mathvariant=\"script\">U</mi><mi>j</mi></msub></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mstyle mathcolor=\"red\"><mi>x</mi></mstyle><mo>:</mo><mstyle mathcolor=\"red\"><mi>σ</mi></mstyle><mi mathvariant=\"normal\">.</mi><mtext>  </mtext><mstyle mathcolor=\"red\"><mi>τ</mi></mstyle><mo stretchy=\"false\">)</mo><mo>:</mo><msub><mi mathvariant=\"script\">U</mi><mi>k</mi></msub></mrow></mfrac><mo separator=\"true\">,</mo><mspace width=\"1em\"/><mi>k</mi><mo>=</mo><mi>i</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\frac{\n  Γ ⊢ {\\color{red}σ}: \\mathcal U_i \\qquad\n  Γ,({\\color{red}x}: {\\color{red}σ}) ⊢ {\\color{red}τ}: \\mathcal U_j\n}{Γ ⊢ (∀{\\color{red}x}:{\\color{red}σ}.\\; {\\color{red}τ}): \\mathcal U_k},\\quad k = imax(i,j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.363em;vertical-align:-0.936em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.427em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"color:red;\">x</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;color:red;\">σ</span></span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;color:red;\">τ</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0993em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;color:red;\">σ</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0993em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:2em;\"></span><span class=\"mord\">Γ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"color:red;\">x</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;color:red;\">σ</span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;color:red;\">τ</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0993em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.936em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>In MLTT <code>imax</code> is simply <code>max</code>. In Lean it's different: <a href=\"https://lean-lang.org/doc/reference/latest//The-Type-System/Universes/#level-expressions\">https://lean-lang.org/doc/reference/latest//The-Type-System/Universes/#level-expressions</a></p>",
        "id": 517253735,
        "sender_full_name": "suhr",
        "timestamp": 1746879301
    },
    {
        "content": "<p>(outside of type theory predicativity might mean something completely different)</p>",
        "id": 517254009,
        "sender_full_name": "suhr",
        "timestamp": 1746879550
    },
    {
        "content": "<p>I find it rather less likely that one can automatically remove uses of impredicative Prop from a proof of FLT in lean</p>",
        "id": 517357932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746967089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517179260\">said</a>:</p>\n<blockquote>\n<p>Thanks for coming back James. As you can see I clearly have very strong opinions about this (I remember it all unfolding at the time and being extremely frustrated about how incorrect claims were being circulated) but I think the mathoverflow post summarises the facts accurately.</p>\n</blockquote>\n<p>Rather than just brushing off what I said, would you be willing to actually <em>retract</em> your insinuation that the statements in question were 'lies'?</p>",
        "id": 517936966,
        "sender_full_name": "James E Hanson",
        "timestamp": 1747176945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517254009\">said</a>:</p>\n<blockquote>\n<p>(outside of type theory predicativity might mean something completely different)</p>\n</blockquote>\n<p>I wouldn't go so far as to say they're <em>completely</em> different. They all trace their roots to Russell's analysis of the paradoxes of naive set theory. But the senses of the word used in type theory and in classical mathematical logic are different enough to be somewhat incompatible, though, and it can be confusing.</p>",
        "id": 517937038,
        "sender_full_name": "James E Hanson",
        "timestamp": 1747176978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517227725\">said</a>:</p>\n<blockquote>\n<p>It's definitely got to be interpreted as a set, interpreting it as V doesn't work.</p>\n</blockquote>\n<p>If the operations being performed on Type are sufficiently predicative, could it not be possible to interpret it as something like the class of canonical codes for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">Σ</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-definable classes?</p>",
        "id": 517937243,
        "sender_full_name": "James E Hanson",
        "timestamp": 1747177107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> I'm sorry I used the word \"lie\"and I'm sorry I upset you. The claim that Wiles' proof used large cardinals is an incorrect statement but I'm sure you made the statement without the intent to mislead. I'm happy to take any further discussion of this to DMs.</p>",
        "id": 517975135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747201587
    },
    {
        "content": "<p>I may be mistaken but it was my understanding that if one can prove a statement in (ZFC + n inaccessible cardinals) that don't mention the inaccessible cardinals, then you can also prove this in ZFC (<a href=\"https://mathoverflow.net/questions/382270/reflection-principle-vs-universes\">source</a>). So if the Lean proof of FLT only uses n inaccessible cardinals, then this gives a true statement in ZFC+, which gives a true statement in ZFC with no extra cardinals, right?</p>",
        "id": 518038950,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1747221932
    },
    {
        "content": "<p>No, this is not true, ZFC + n inaccessibles is strictly stronger in consistency strength</p>",
        "id": 518039106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747221970
    },
    {
        "content": "<p>Even for statements not involving the inaccessibles? Is the theorem mentioned in the link wrong, or is my understanding of it wrong?</p>",
        "id": 518039296,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1747222030
    },
    {
        "content": "<p>the consistency of ZFC does not make reference to inaccessibles but it's provable in ZFC + 1 inaccessible because you can construct a model of ZFC in the first inaccessible</p>",
        "id": 518039496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747222085
    },
    {
        "content": "<p>and ditto for each inaccessible after that, it demonstrates the consistency of the theory with one less inaccessible</p>",
        "id": 518039629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747222127
    },
    {
        "content": "<p>Increases in consistency strength can be used to prove new theorems in the natural numbers.  These theorems don’t have to mention explicitly anything about the objects used in the new axioms used to increase consistency strength.</p>",
        "id": 518039801,
        "sender_full_name": "Jason Rute",
        "timestamp": 1747222173
    },
    {
        "content": "<p>right, thanks for clearing up my confusion (for those interested, I understood the theorem quoted in a wrong manner; the point there is that this new system \"looks\" and \"feels\" like using inaccessible cardinals but it really isn't doing that)</p>",
        "id": 518040139,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1747222255
    },
    {
        "content": "<p>I hope it's not bad form to post to an old conversation that petered out a long time ago, but I have some comments to make that I think this community would find interesting and might not be fully aware of.</p>\n<p>Avoiding universes and staying strictly within ZFC is something that some people care about. The number of such people is pretty small, I think, but it includes Peter Scholze. See this MathOverflow discussion: <a href=\"https://mathoverflow.net/q/382270/\">https://mathoverflow.net/q/382270/</a></p>\n<p>As already discussed earlier in this conversation, universes are irrelevant to Fermat's Last Theorem, but there is another question that quite a few people seem to be interested in, which is whether FLT is provable in first-order Peano arithmetic (PA for short). I personally believe that many people who ask this question are making the mistake of conflating \"Is FLT is provable in PA?\" with \"Does FLT have an elementary proof?\" and they're asking the former question when they're really interested in the latter. Angus Macintyre's appendix to Chapter 1 (\"The Impact of Gödel's Incompleteness Theorems on Mathematics\") of <em>Kurt Gödel and the Foundations of Mathematics: Horizons of Truth</em> gives a pretty convincing heuristic argument that one can take the existing proof of FLT and replace all the fancy machinery (which makes liberal use of infinite sets) with \"finitary approximations\"; the result would be a PA-proof, but not a proof that most people would call \"elementary.\" Regardless, as I said, some people do seem to be interested in whether FLT is provable in PA, and this is a nontrivial question.</p>\n<p>More generally, \"reverse mathematics\" is a growing field, and aims to find the weakest possible axioms needed to prove a theorem. The usual framework for reverse mathematics is second-order arithmetic, in the sense of Steve Simpson's book <em>Subsystems of Second-Order Arithmetic</em> (SOSOA). The phrase \"second-order arithmetic\" is somewhat confusing, because it's really a two-sorted first-order system, but the terminology is too entrenched to change at this point in time.</p>\n<p>I gather that Lean is not designed to answer these kinds of reverse-mathematical questions, and at least at the moment, the Lean community has much bigger fish to fry. But I think it's good to be aware that eliminating universes is not the only reverse-mathematical question that people are interested in.</p>\n<p>Here's a related question. I have a vague and quite possibly incorrect impression that HOL Light is based on simple type theory and therefore equiconsistent with bounded Zermelo set theory. If so, then what are the prospects for semi-automatically translating portions of mathlib into HOL Light? Would doing so help us answer provability-in-ZFC questions?</p>",
        "id": 544077023,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1760063628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517251295\">said</a>:</p>\n<blockquote>\n<p>Maybe this is implicit in the thread, but in his lectures at Collège de France, Thierry Coquand insisted that the basic Martin-Löf type theory, with universes, is weaker than second order Peano arithmetic.</p>\n</blockquote>\n<p>Do you have a link to Coquand's lectures or write-ups of them?</p>",
        "id": 544081353,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1760067612
    },
    {
        "content": "<p>Videos of the lectures: <a href=\"https://www.college-de-france.fr/fr/enseignements/audios-videos?f%5B0%5D=chair%3A83777\">https://www.college-de-france.fr/fr/enseignements/audios-videos?f%5B0%5D=chair%3A83777</a></p>",
        "id": 544081809,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1760068019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> thanks, but that's nine videos, in a language I know the bare basics of, if that. Which one should I look at?</p>",
        "id": 544082024,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1760068201
    },
    {
        "content": "<p>I think I saw the passage Antoine is referring to, so it is probably in one of the first three videos. I can't be more precise than that.</p>",
        "id": 544082173,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1760068347
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 544084741,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1760070591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130272\">David Michael Roberts</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/544081353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517251295\">said</a>:</p>\n<blockquote>\n<p>Maybe this is implicit in the thread, but in his lectures at Collège de France, Thierry Coquand insisted that the basic Martin-Löf type theory, with universes, is weaker than second order Peano arithmetic.</p>\n</blockquote>\n<p>Do you have a link to Coquand's lectures or write-ups of them?</p>\n</blockquote>\n<p>I recently had cause to track down the sources for this claim (that MLTT embeds in second order arithmetic). I found the following:</p>\n<ol>\n<li><a href=\"https://www2.math.uu.se/~palmgren/universe.pdf\">https://www2.math.uu.se/~palmgren/universe.pdf</a></li>\n<li><a href=\"https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2024.44\">https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2024.44</a></li>\n<li><a href=\"https://www.sciencedirect.com/science/article/pii/S0049237X08713648\">https://www.sciencedirect.com/science/article/pii/S0049237X08713648</a></li>\n<li><a href=\"https://link.springer.com/chapter/10.1007/978-3-319-63334-3_14\">https://link.springer.com/chapter/10.1007/978-3-319-63334-3_14</a></li>\n<li><a href=\"https://www.researchgate.net/publication/247365747_Recursive_models_for_constructive_set_theories\">https://www.researchgate.net/publication/247365747_Recursive_models_for_constructive_set_theories</a></li>\n</ol>\n<p>I believe (3) is the original reference, (4) is an overview of related results, and (5) was the easiest for me to understand the full construction</p>",
        "id": 545020215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760548334
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478409\">Timothy Chow</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/544077023\">said</a>:</p>\n<blockquote>\n<p>Here's a related question. I have a vague and quite possibly incorrect impression that HOL Light is based on simple type theory and therefore equiconsistent with bounded Zermelo set theory. If so, then what are the prospects for semi-automatically translating portions of mathlib into HOL Light? Would doing so help us answer provability-in-ZFC questions?</p>\n</blockquote>\n<p>Mario and I had a conversation a while ago about the prospects of (semi-)automatically removing universes from Lean proofs. My best attempt at this would be something like the following procedure (inspired by a technique occasionally used in model theory to 'fake' the existence of inaccessible cardinals): Suppose we're trying to prove something about some objects that naturally live in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>κ</mi></msub></mrow><annotation encoding=\"application/x-tex\">H_{\\kappa}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (the set of sets hereditarily of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>) for some cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>. By passing to a forcing extension (or maybe to an inner model like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo stretchy=\"false\">[</mo><msub><mi>H</mi><mi>κ</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">L[H_\\kappa]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>), we can ensure that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">n &lt; \\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>κ</mi><mrow><mo>+</mo><mi>n</mi></mrow></msup><mo>=</mo><msub><mi mathvariant=\"normal\">ℶ</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>κ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\kappa^{+n} = \\beth_n(\\kappa)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">κ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">ℶ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">κ</span><span class=\"mclose\">)</span></span></span></span> (i.e., GCH holds in an interval above <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span>) without changing the truth value of statements of quantifiers bounded by elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>H</mi><mi>κ</mi></msub></mrow><annotation encoding=\"application/x-tex\">H_{\\kappa}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Now the sets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>n</mi></msub><mo><mi mathvariant=\"normal\">≔</mi></mo><msub><mi>H</mi><msup><mi>κ</mi><mrow><mo>+</mo><mi>n</mi></mrow></msup></msub></mrow><annotation encoding=\"application/x-tex\">U_n \\coloneqq H_{\\kappa^{+n}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mop\" style=\"position:relative;top:-0.0347em;\">:</span></span><span class=\"mrel\"><span class=\"mspace\" style=\"margin-right:-0.0667em;\"></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3419em;\"><span style=\"top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">κ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7027em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">+</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> behave approximately like Grothendieck universes in that (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> n &gt; 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>) they're closed under the formation of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>-types and satisfy that for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∈</mo><msub><mi>U</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">A \\in U_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>:</mo><mi>A</mi><mo>→</mo><msub><mi>U</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">B : A \\to U_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><msub><mi>U</mi><mrow><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">{</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">}</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_{x \\in A} B(x) \\in U_{\\max\\{n+1,m\\}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">A</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0385em;vertical-align:-0.3552em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop mtight\"><span class=\"mtight\">m</span><span class=\"mtight\">a</span><span class=\"mtight\">x</span></span><span class=\"mopen mtight\">{</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mclose mtight\">}</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span></span></span></span> (as opposed to an actual sequence of Grothendieck universes, which would satisfy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>x</mi><mo>∈</mo><mi>A</mi></mrow></msub><mi>B</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><msub><mi>U</mi><mrow><mi>max</mi><mo>⁡</mo><mo stretchy=\"false\">{</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo stretchy=\"false\">}</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_{x \\in A} B(x) \\in U_{\\max\\{n,m\\}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">A</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0385em;vertical-align:-0.3552em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mop mtight\"><span class=\"mtight\">m</span><span class=\"mtight\">a</span><span class=\"mtight\">x</span></span><span class=\"mopen mtight\">{</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mclose mtight\">}</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span></span></span></span>). Note that you do actually need to do something like passing to a forcing extension to ensure that this happens: If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>κ</mi></msup><mo>=</mo><msup><mi>κ</mi><mrow><mo>+</mo><mo>+</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^\\kappa = \\kappa^{++}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">κ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">++</span></span></span></span></span></span></span></span></span></span></span></span> for all cardinals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> but there are no inaccessible cardinals, then there is no sequence of cardinals with this property.</p>\n<p>Now I'm not that hopeful about this working in practice, but in principle one might be able to inspect some of the proofs in mathlib and determine that these weaker closure properties are actually sufficient, thereby showing that the proofs can be converted into ZFC proofs.</p>",
        "id": 545730642,
        "sender_full_name": "James E Hanson",
        "timestamp": 1760765706
    },
    {
        "content": "<p>Interesting; I hadn't heard of your proposal before. The main proposal I'm aware of for semi-automatically eliminating universes is Feferman's, as described for example in Shulman's paper, <a href=\"https://arxiv.org/abs/0810.1279\">Set theory for category theory</a> (he calls the system ZFC/S). What advantages do you think your proposal has over Feferman's?</p>",
        "id": 545749345,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1760786792
    },
    {
        "content": "<p>I’ve also seen this proposal for what seems to me to be a very manual and tedious process of rebuilding math inside ZFC inside Lean.  <a href=\"https://members.loria.fr/SMerz/stages/2025-zfc-lean.html\">https://members.loria.fr/SMerz/stages/2025-zfc-lean.html</a>. (The two proposers are not on this Zulip. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>)</p>",
        "id": 545750697,
        "sender_full_name": "Jason Rute",
        "timestamp": 1760788228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478409\">Timothy Chow</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/545749345\">said</a>:</p>\n<blockquote>\n<p>Interesting; I hadn't heard of your proposal before. The main proposal I'm aware of for semi-automatically eliminating universes is Feferman's, as described for example in Shulman's paper, <a href=\"https://arxiv.org/abs/0810.1279\">Set theory for category theory</a> (he calls the system ZFC/S). What advantages do you think your proposal has over Feferman's?</p>\n</blockquote>\n<p>One issue I anticipate with Feferman universes is that their inaccessible-like properties are only metatheoretical. In particular, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>κ</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>μ</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">μ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> are Feferman universes with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>&lt;</mo><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa &lt; \\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>, then in general <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>κ</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">κ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> won't look special internally inside <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><mi>μ</mi></msub></mrow><annotation encoding=\"application/x-tex\">V_\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">μ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>. For instance, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> may be singular.</p>\n<p>From the point of view of type theory, this means that Feferman universes are closed under things like 'small products of first-order definable families of small sets,' which seem to be hard to formalize cleanly in type-theoretic language.</p>",
        "id": 545769422,
        "sender_full_name": "James E Hanson",
        "timestamp": 1760807415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/545750697\">said</a>:</p>\n<blockquote>\n<p>I’ve also seen this proposal for what seems to me to be a very manual and tedious process of rebuilding math inside ZFC inside Lean.  <a href=\"https://members.loria.fr/SMerz/stages/2025-zfc-lean.html\">https://members.loria.fr/SMerz/stages/2025-zfc-lean.html</a>. (The two proposers are not on this Zulip. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>)</p>\n</blockquote>\n<p>A less manual and tedious way to get lots of math in ZFC in Lean is using the <a href=\"#narrow/channel/113488-general/topic/Prime.20number.20theorem.20in.20lean/near/168472336\">translation from metamath</a></p>",
        "id": 545776028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1760814057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/545020215\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130272\">David Michael Roberts</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/544081353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/116395-maths/topic/Consistency.20strength.20bounds.20from.20Lean.20proofs/near/517251295\">said</a>:</p>\n<blockquote>\n<p>Maybe this is implicit in the thread, but in his lectures at Collège de France, Thierry Coquand insisted that the basic Martin-Löf type theory, with universes, is weaker than second order Peano arithmetic.</p>\n</blockquote>\n<p>Do you have a link to Coquand's lectures or write-ups of them?</p>\n</blockquote>\n<p>I recently had cause to track down the sources for this claim (that MLTT embeds in second order arithmetic). I found the following:</p>\n<ol>\n<li><a href=\"https://www2.math.uu.se/~palmgren/universe.pdf\">https://www2.math.uu.se/~palmgren/universe.pdf</a></li>\n<li><a href=\"https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2024.44\">https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.CSL.2024.44</a></li>\n<li><a href=\"https://www.sciencedirect.com/science/article/pii/S0049237X08713648\">https://www.sciencedirect.com/science/article/pii/S0049237X08713648</a></li>\n<li><a href=\"https://link.springer.com/chapter/10.1007/978-3-319-63334-3_14\">https://link.springer.com/chapter/10.1007/978-3-319-63334-3_14</a></li>\n<li><a href=\"https://www.researchgate.net/publication/247365747_Recursive_models_for_constructive_set_theories\">https://www.researchgate.net/publication/247365747_Recursive_models_for_constructive_set_theories</a></li>\n</ol>\n<p>I believe (3) is the original reference, (4) is an overview of related results, and (5) was the easiest for me to understand the full construction</p>\n</blockquote>\n<p>Furthermore, Rathjen <a href=\"https://www.researchgate.net/publication/226597396_The_Constructive_Hilbert_Program_and_the_Limits_of_Martin-Lof_Type_Theory\">showed</a> that MLTT + Mahlo universes (which allow for inductive-recursive types) are also well below second order arithmetic in consistency strength.</p>",
        "id": 570230944,
        "sender_full_name": "Elliot Glazer",
        "timestamp": 1769486392
    },
    {
        "content": "<p>Feferman's seminal result is that MLTT with universes has ordinal strength Gamma_0, the same strength as ATR_0. In a series of papers, Feferman argued that this ordinal represents the limit of predicativity, in the sense that Hermann Weyl used the term in his 1918 monograph, Das Kontinuum.</p>",
        "id": 570619342,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1769621032
    }
]