[
    {
        "content": "<p>I think our definition <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StarModule#doc\">docs#StarModule</a> is not right if the scalars are not commutative. We should have the axiom <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>⋅</mo><mi>a</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup><mo>=</mo><msup><mi>a</mi><mo>∗</mo></msup><mo>⋅</mo><msup><mi>r</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">(r \\cdot a)^* = a^* \\cdot   r^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> rather than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>⋅</mo><mi>a</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup><mo>=</mo><msup><mi>r</mi><mo>∗</mo></msup><mo>⋅</mo><msup><mi>a</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">(r \\cdot  a)^* = r^* \\cdot  a^* </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. In particular, I claim this is a concept for bimodules.</p>",
        "id": 383664005,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691680386
    },
    {
        "content": "<p>Or in Lean I claim the \"right\" definition should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">StarModule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Star</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Star</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMul</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMul</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">star_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">MulOpposite.op</span> <span class=\"o\">(</span><span class=\"n\">star</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"bp\">•</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 383664156,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691680413
    },
    {
        "content": "<p>However burdening every user with the obligation to supply an <code>Rᵐᵒᵖ</code> action seems like a bad idea so I propose keeping the \"wrong\" axiom but restricting the typeclass to require a commutative multiplication.</p>",
        "id": 383664561,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691680468
    },
    {
        "content": "<p>Any remarks / corrections welcome!</p>",
        "id": 383664706,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691680489
    },
    {
        "content": "<p>I think I claimed this some time ago :)</p>",
        "id": 383669244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691681226
    },
    {
        "content": "<p>Two steps ahead as always :)</p>",
        "id": 383669400,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691681248
    },
    {
        "content": "<p>I'm not really affected by this but I'll try and do something about it in a few days if nobody else does.</p>",
        "id": 383669576,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691681274
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Is.20star_module.20sensible.20for.20non-commutative.20rings.3F/near/257272767\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Is.20star_module.20sensible.20for.20non-commutative.20rings.3F/near/257272767</a></p>",
        "id": 383669715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691681289
    },
    {
        "content": "<p>I think there's a big obstacle here, and it's that <code>Algebra R A</code> does not imply <code>SMul Rᵐᵒᵖ A</code></p>",
        "id": 383669969,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691681325
    },
    {
        "content": "<p>I spent quite some time fixing that in Lean3, but the PR (<a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">!3#10716</a>) went stale</p>",
        "id": 383670038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1691681336
    },
    {
        "content": "<p>I'm proposing that we deal with this the way we currently deal with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Derivation#doc\">docs#Derivation</a>: we restrict typeclasses so that the definition can only be used in the commutative case, when it is actually correct.</p>",
        "id": 383670419,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1691681400
    },
    {
        "content": "<p>Something I ran into just now: I can't define <code>StarRing (TrivSqZeroExt R M)</code> for non-commutative <code>R</code> without the proposed fix to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StarModule#doc\">docs#StarModule</a>. I don't really need it anyway, but it would have been nice to have.</p>",
        "id": 411838165,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704758910
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9570\">#9570</a> is a prototype...</p>",
        "id": 411845010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704762066
    }
]