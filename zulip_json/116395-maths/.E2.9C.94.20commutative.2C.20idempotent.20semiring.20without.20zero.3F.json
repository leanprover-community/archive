[
    {
        "content": "<p>This is a math question and, although it's got nothing to do with Lean, I figured that this community might have the right word for what I'm looking for -- given the sensitivity to various type classes (and <code>OrderedCommRing</code> or <code>NonAssocSemiring</code> or whatever...)</p>\n<p>I've got a structure <code>(S, 1, &lt;=, +, *)</code> with the following properties:</p>\n<ul>\n<li><code>+</code> and <code>*</code> are commutative, associative, and idempotent: <code>x+x=x</code>, <code>x*x=x</code>.</li>\n<li>Distributive property: <code>a*(b+c) = a*b+a*c</code></li>\n<li>1 is an additive and multiplicative identity: <code>a*1 = 1*a = a+1 = a+1 = a</code>.</li>\n</ul>\n<p>This is sort of like a commutative, idempotent semiring (as in, idempotent addition and multiplication) except that there's no multiplicative zero.</p>\n<p>As far the ordering:</p>\n<ul>\n<li><code>&lt;=</code> is a partial order</li>\n<li>Both operations respect the ordering, and act as a sort of max, where multiplication is stronger: <code>a &lt;= a+b &lt;= a * b</code>. And similarly <code>a &lt;= b</code>, <code>c &lt;= d</code> implies <code>a+c &lt;= b+d</code>, and likewise for multiplication. This also implies that <code>a &lt;= b</code> implies <code>b = a+b = a*b</code>.</li>\n</ul>\n<p>Does anyone have any ideas for how to describe this kind of structure? I think as far as <em>just</em> the additive structure is concerned, this is a semilattice with a minimum element. And the same goes for the multiplicative structure. But the distributive property makes this considerably more interesting to me, there should be some sensible way to talk about \"polynomials\" in this lattice. But since it's not actually a semiring, it feels awkward.</p>",
        "id": 503362830,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741121862
    },
    {
        "content": "<p>From your ordering axioms, for any <code>a,b</code>, we have <code>a \\leq a + b</code>, so <code>a = a + (a + b)</code>. However, by associativity and idempotence, <code>a + (a + b) = a + b</code>. If I'm not mistaken, this implies <code>S</code> is a subsingleton.</p>",
        "id": 503448050,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1741162616
    },
    {
        "content": "<p>Oops, one typo in the \"this also implies\" -- should get that b = a + (a + b). :) But thanks for taking a look!</p>",
        "id": 503467379,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741168437
    },
    {
        "content": "<p>Can you write a <code>class</code> that extends <code>Monoid</code> and <code>AddSemigroup</code> and <code>PartialOrder</code>, and adds your extra axioms?</p>",
        "id": 503467722,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1741168540
    },
    {
        "content": "<p>Can you give an explicit example of your structure with more than one element?</p>",
        "id": 503535750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741185734
    },
    {
        "content": "<p>Sure, take any max-semilattice with a minimum element, and take + and * to both be <code>max</code>. So, for example, the natural numbers, where both operations are max, and the neutral element is zero. </p>\n<p>As an example where + and * are not the same: <br>\nS={1,A,B,2,3}. The partial order is <code>1 &lt;= A &lt;= 2 &lt;= 3</code>, <code>1 &lt;= B &lt;= 2 &lt;= 3</code>, and A/B are incomparable.<br>\nDefine <code>+</code> by <code>A+B = A+2 = B+2 = 2</code>, anything added with 3 is 3.<br>\nDefine <code>*</code> by <code>A*B = A*2 = B*2 = 3</code>, anything multiplied with 3 is 3. (The remaining values are filled by idempotence, commutativity, and 1 being the identity for both operations.)</p>",
        "id": 503539516,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741186569
    },
    {
        "content": "<p>This doesn't satisfy the ordering for multiplication:<br>\n<code>A ≤ 2</code><br>\n<code>B ≤ 2</code><br>\n<code>A * B = 3</code><br>\n<code>2 * 2 = 2</code><br>\ntherefore<br>\n<code>3 = A * B ≤ 2 * 2 = 2</code><br>\nso<br>\n<code>3 = 2</code> by antisymmetry<br>\nand addition and multiplication are then pointwise equal.</p>",
        "id": 503542355,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187155
    },
    {
        "content": "<p>I think the ordering rules implies that the only structures that satisfy these conditions must be a max-semilattice with bot, with addition and multiplication both <code>max</code>.</p>",
        "id": 503542972,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187283
    },
    {
        "content": "<p>since both addition and multiplication satisfy the universal property for <code>max</code></p>",
        "id": 503543611,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187424
    },
    {
        "content": "<p>Oh. Shucks. You're right.<br>\nAlright, I'd made a silly mistake in how I arrived at this. (An 'obviously true' condition turned out to not always be true.)<br>\nMm, I guess in the actual structure this is arriving from, * isn't idempotent. The example with {1,A,B,2,3} really should have 2*2=3.<br>\nBut now I'm not even confident in the distributive property always holding, either.</p>",
        "id": 503544400,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741187603
    },
    {
        "content": "<p>Well, I should go back and check my 'obvious' conditions. Thanks for the checking, haha. :)</p>",
        "id": 503544480,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741187621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/commutative.2C.20idempotent.20semiring.20without.20zero.3F/near/503543611\">said</a>:</p>\n<blockquote>\n<p>since both addition and multiplication satisfy the universal property for <code>max</code></p>\n</blockquote>\n<p>How did you arrive to the universal property?</p>",
        "id": 503544636,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741187651
    },
    {
        "content": "<p>If <code>a ≤ c</code> and <code>b ≤ c</code> then <code>a + b ≤ c + c = c</code> and likewise for multiplication<br>\nCompare this to <code>max</code>: if <code>a ≤ c</code> and <code>b ≤ c</code> then <code>a ⊔ b ≤ c</code></p>",
        "id": 503544867,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187706
    },
    {
        "content": "<p>That's the universal property of the infimum</p>",
        "id": 503545295,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741187787
    },
    {
        "content": "<p>Well now that you've edited it it's the universal property of the supremum <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 503545429,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1741187817
    },
    {
        "content": "<p>I got confused on the ordering a bit</p>",
        "id": 503545497,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187834
    },
    {
        "content": "<p>I think this should be correct</p>",
        "id": 503545849,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741187904
    },
    {
        "content": "<p>Could you tell us more about your actual application?</p>",
        "id": 503603706,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1741200332
    },
    {
        "content": "<p>We've got a result about some complexity classes, about ways to construct problems that are complete for these classes. The <code>&lt;=</code> relation here is containment, and the identity element is <code>P</code> (DTIME(poly)). The classes have a natural (sort of) construction for this addition/multiplication ... the concept hasn't really appeared in the literature before, because essentially the only classes studied that this applied to were P and NP, which give a pretty trivial S = {1,2} structure. But we show how to give a few more classes the necessary properties, and then we can start generating all sorts of strange classes from \"polynomials\" of these base classes.</p>",
        "id": 503628517,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741207038
    },
    {
        "content": "<p>I think that indeed a \"polynomial\" over our generators will be the way to go - just repeatedly apply the distributive property until it's a sum of products. But if there was some better name to refer to, that would be nice</p>",
        "id": 503628720,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741207095
    },
    {
        "content": "<p>It's an application that I think is nice, but I don't think going more into the details of the construction will be very enlightening to my initial problem description -- unless you <em>really</em> care about quantum complexity theory. :)</p>",
        "id": 503628912,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741207167
    },
    {
        "content": "<p>Well: after fixing a few subtle errors in our proofs, it turns out we <em>do</em> have a proper semiring. The mistake is kind of neat... there's a multiplicative identity 0, and an additive identity 1. 0 is the least element in the lattice (as it has to be). If you exclude 0, you still have all the closure properties, and there's a new unique bottom element, which is 1.</p>\n<p>This means that if you \"forget to include\" 0 in your algebra, then 1 is indeed both an identity element for addition and multiplication, which was the initial source of my headache and this thread. But by sort of working back from \"what would an absorbing element 0 even look like\" I was able to find this element 0, and indeed all of the semiring properties work out. Pretty happy. :)</p>",
        "id": 504183681,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741381323
    },
    {
        "content": "<p>In case anyone is curious... all of the things in our semiring are classes up to polytime reduction (P-reduction). In principle things go through with more fine-grained reductions (logspace should work, and we do explain that in the paper) but we're not interested in that at the moment.</p>\n<p>So, P is the identity 1, and it seems natural that you can't have anything <em>simpler</em> than P since you close everything under P-reductions anyway. Even the most boring class \"powers up\" to be equal to P when you add P-reductions.</p>\n<p>Nope! You can take the complexity class with a single language \"All\", the set of all strings. This language accepts everything. If you reduce any other language to All in polytime, you still must end up with All, so this actually stays below P even after closure by P-reductions. This very silly class ends up being our 0. (It also satisfies all the other properties we need, and turns out to be an additive identity and multiplicative absorbing element, just like we need!)</p>",
        "id": 504184269,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741381537
    },
    {
        "content": "<p>Anyway, I'll close this thread, since my main 'general' mathy question is now irrelevant. :)</p>",
        "id": 504184613,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1741381657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> has marked this topic as resolved.</p>",
        "id": 504184628,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741381668
    }
]