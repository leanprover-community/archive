[
    {
        "content": "<p>Hi all,</p>\n<p>I was wondering whether anyone thought about formalizing categorical logic in Lean. Specifically, I am interested in general definitions for different fragments of geometric logic: algebraic theories, regular theories and geometric theories.</p>\n<p>For those not familiar with the subject, let me give you the TL;DR for the mathematics involved. In the same way that in model theory one can define a first-order theory and what its models are, in categorical logic we define theories, but instead of having models be sets equipped with a certain structure, we can consider models in any other category (with sufficient structure).</p>\n<p>For instance, one can define a theory of rings and consider models in any category with finite limits. This means that any equation that we deduce in this theory of rings will have validity in any category with finite limits. A related key example are local rings.</p>\n<p>In fact, one can go much further than that and define a class of categories in which we can take models of a first-order-theory. Typically though, in this area, we do use something like geometric logic instead of first-order-logic, where classical reasoning (like negation) is not allowed so that we allow models in categories like sheaves over a topological space.</p>\n<p>One reason that I think this is interesting to formalize is that it provides us with a way of proving statements in a very general setting, which can have useful consequences in different settings. Things like group objects, ring objects and module objects are considered all the time, and with this there would be no discussions of continuity or naturality of maps like the division map for groups (To be fair, these facts simply follow from composability of morphisms. But I do not know how this, and more complex statements, possibly involving quantification, plays out in the formalized setting).</p>\n<p>Perhaps a better reason to play with this, is that that it lets us work synthetically by proving statements in these theories instead of working with specific models. By doing this, we remove questions of typeclass-inference and definitional equality from the problem, and it also opens the door to using ATPs. Of course, working within the constrains of the theory would also be challenging at times (or not possible).</p>\n<p>I honestly have no idea of how this would play out <span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span> I do suspect that these ideas might lead to an interesting way to build APIs (using macros to define logical formulas?) or even useful computational procedures, but in the end we really don't know until we try. I would say it's definitely something to explore. Unfortunately, I never got around to starting to look into this in more detail and formulating some less vague applications <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But maybe someone will find this useful or has also had thoughts in a similar direction :)</p>\n<p>Generally, I think that if we can prove statements <em>synthetically</em> or by <em>abstract nonsense</em>, this will pay off much more when working on a proof assistant than when working with pen-and-paper.</p>\n<p>Side note: This is all related to the theory of classifying toposes. One can also explore formalizing those, but the above is more accessible.</p>",
        "id": 528142454,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752173717
    },
    {
        "content": "<p>I have an open PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/25735\">#25735</a>, currently gatekeeped by boring stuff about colimits preservation of tensor products) that characterizes sifted categories as those for which the colimit functor preserves finite products. Once it's merged, I plan on adding some stuff related to algebraic theories, following Ad√°mek-Rosicky-Vitale's book, such as the fact that finite-product preserving presheaves on a category with finite coproducts is a free sifted-colimit completion, and basic general fact about algebraic categories.</p>",
        "id": 528155470,
        "sender_full_name": "Robin Carlier",
        "timestamp": 1752179765
    },
    {
        "content": "<p>There was a <a href=\"https://msp.cis.strath.ac.uk/types2025/abstracts/TYPES2025_paper49.pdf\">TYPES abstract</a> by Kenji Maillard and Yiming Xu on geometric logic in Lean. The <a href=\"https://msp.cis.strath.ac.uk/types2025/slides/TYPES2025-slides49.pdf\">slides</a> and <a href=\"https://www.youtube.com/watch?v=5wedd2ogEKI\">recording</a> are available too.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"5wedd2ogEKI\" href=\"https://www.youtube.com/watch?v=5wedd2ogEKI\"><img src=\"https://uploads.zulipusercontent.net/37ca67f508668698de19b869c559937580d8f0c2/68747470733a2f2f692e7974696d672e636f6d2f76692f3577656464326f67454b492f6d7164656661756c742e6a7067\"></a></div>",
        "id": 528252793,
        "sender_full_name": "Tom de Jong",
        "timestamp": 1752218576
    },
    {
        "content": "<p>Thank both of you! This is the sort of stuff I was looking for. I will dig a little deeper into the geometric logic formalization and see what is there. If I find something cool one can do, I might report back!</p>",
        "id": 528314384,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752231913
    },
    {
        "content": "<p>It just occurred to me that I could ping <span class=\"user-mention\" data-user-id=\"261023\">@Kyod</span> (Kenyi) and <span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> (not sure if this is same person as the co-author of the abstract)</p>",
        "id": 528326465,
        "sender_full_name": "Tom de Jong",
        "timestamp": 1752236029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926793\">Tom de Jong</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528326465\">said</a>:</p>\n<blockquote>\n<p>It just occurred to me that I could ping <span class=\"user-mention silent\" data-user-id=\"261023\">Kyod</span> (Kenyi) and <span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> (not sure if this is same person as the co-author of the abstract)</p>\n</blockquote>\n<p>Thank you for pinging me! (Moreover, the other one is also me... I was previously at the ANU.)</p>",
        "id": 528328801,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752236808
    },
    {
        "content": "<p>Yes I am the one from the LMU. One of the authors. FYI, I am currently formalizing a construction of classifying topos. It is equivalent to, but not quite the same as the one in Johnstone. This is the PhD work of Joshua Wrigley, as outlined here (the topology is defined around 17:00 of the video): <a href=\"https://www.youtube.com/watch?v=jjmAScdm4D4\">https://www.youtube.com/watch?v=jjmAScdm4D4</a><br>\nWe are currently working towards an interpretation on sheaf topoi (for sheaves on the site, i.e. just the Grothendieck topoi stuff). Feel free to email or DM me to chat about it.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"jjmAScdm4D4\" href=\"https://www.youtube.com/watch?v=jjmAScdm4D4\"><img src=\"https://uploads.zulipusercontent.net/fe92588380a46738316007b2d47d1df7ea146a5a/68747470733a2f2f692e7974696d672e636f6d2f76692f6a6a6d415363646d3444342f6d7164656661756c742e6a7067\"></a></div>",
        "id": 528329978,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752237193
    },
    {
        "content": "<p>Wow, this is great! I will look into your work and if anything arises I will dm you. Just to confirm, is <a href=\"https://github.com/kyoDralliam/model-theory-topos\">this</a> the correct repo for your ongoing work on formalizing a construction for the classifying topos?</p>",
        "id": 528338515,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752239820
    },
    {
        "content": "<p>Yes indeed, but I have something not pushed yet. That was my failure that I did not include the link in my slides.</p>",
        "id": 528352392,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752244321
    },
    {
        "content": "<p>Let me mention that I formalised some of the above material on toposes 5-6 years ago here: <a href=\"https://github.com/b-mehta/topos\">https://github.com/b-mehta/topos</a>. The \"What's coming soon?\" section is a bit out of date, since 1 and 4 were done and 2 was partially done too. This was attempting to lay the groundwork to formalise my Part III essay on classifying toposes.</p>",
        "id": 528419886,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1752279481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528419886\">said</a>:</p>\n<blockquote>\n<p>Let me mention that I formalised some of the above material on toposes 5-6 years ago here: <a href=\"https://github.com/b-mehta/topos\">https://github.com/b-mehta/topos</a>. The \"What's coming soon?\" section is a bit out of date, since 1 and 4 were done and 2 was partially done too. This was attempting to lay the groundwork to formalise my Part III essay on classifying toposes.</p>\n</blockquote>\n<p>There are very useful materials that would be beneficial if someone could translate them into Lean4. It would be very ideal if someone encounters this post, sees the hope of getting a neat library for categorical semantics in Lean, and starts working on that. I am very happy to help with that because I think I will use that.</p>",
        "id": 528445508,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752312582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>   Yes, I've run into Lean 3 topos theory repository before!</p>\n<p><span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> Yeah that would be cool! I want to look at things a bit on weekends, but unfortunately I do not have a big amount resources  to dedicate to this <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span> .</p>\n<p>I also tried to build your repository with <code>lake exe cache get</code> and then <code>lake build</code>, but there are multiple files that do not check. Is this because you do not have the mathlib version pinned or is this just stuff that needs to be fixed?</p>",
        "id": 528454950,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752323168
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528454950\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span>   Yes, I've run into Lean 3 topos theory repository before!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> Yeah that would be cool! I want to look at things a bit on weekends, but unfortunately I do not have a big amount resources  to dedicate to this <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span> .</p>\n<p>I also tried to build your repository with <code>lake exe cache get</code> and then <code>lake build</code>, but there are multiple files that do not check. Is this because you do not have the mathlib version pinned or is this just stuff that needs to be fixed?</p>\n</blockquote>\n<p>Yes I understand, it is always challenging to convince oneself to dedicate to something. Just playing around and you can find a bunch of fun possibilities. We can communicate more concretely about this. For example, what I am recently formalizing is supposed to pave the way of reasoning with propositional geometric logic internally. I am interested in digging in that direction as well (I am a fan of seeing things to be put together in a coherent framework, I want to see that but I only have one head so I have not touched anything relevant yet...). In that direction, a whole bunch of interesting topics around locale would be nice to have. (If you would like to explore this direction, perhaps you want to search for \"Stone duality\" + \"classifying topos\". ) The other big topic to explore is the construction of classifying topoi (maybe for restricted fragments of logics). The syntactical approach appears to be a canonical thing to do, I do not have time to try, but I want to see, model-theoretic approaches as well. Something like this one <a href=\"https://arxiv.org/abs/1008.3145\">https://arxiv.org/abs/1008.3145</a> .</p>\n<p>I have not updated Mathlib in the past two or three months! So this should build with an earlier version I think. Maybe this is the reason... I will check and attempt to fix things in recent days.</p>",
        "id": 528466306,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752334245
    },
    {
        "content": "<p>I do not know what best practices are, and maybe someone else can give some input on this, but one idea would be to fix the mathlib version in the <code>lakefile.lean</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">require</span><span class=\"w\"> </span><span class=\"n\">mathlib</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">git</span>\n<span class=\"w\">  </span><span class=\"s2\">\"https://github.com/leanprover-community/mathlib4.git\"</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"w\"> </span><span class=\"s2\">\"v4.20.0-rc4\"</span>\n</code></pre></div>\n<p>putting the desired mathlib version where it sais <code>v4.20.0-rc4</code> (one can also specify a git commit).  Then it would make sure that other people are using the intended version (even if the mathlib version is a bit out of date).</p>\n<p>I did watch your talk and also Joshua Wrigley's talk and I thought it was quite interesting. I thought that it was pretty cool that you defined the semantics in presheaf topoi and proved the soundness of the Hilbert calculus. I'm still in the process of looking through the formalization though. I also thought it was interesting that you could construct the syntactic site by only taking the morphisms that are substitutions instead of all provably-functional formulas.</p>\n<p>About the reasoning with reasoning with propositional geometric logic internally, I am not completely sure what type of result you mean. Is this related to Joshua Wrigley's work? I am aware though, that there is are some really interesting things in the area of duality, (syntax-semantics duality, results concerning representation by topological groupoids) but that may be out of scope for formalization for now :)</p>\n<p>One quite fundamental thing I would like to see (lets see when I have some time..) is defining a hierarchy of formulas <code>AlgebraicFormula: RegularFormula: CoherentFormula: GeometricFormula</code> and the analogous hierarchy on properties of categories <code>CartesianCategory: RegularCategory: CoherentCategory: GeometricCategory</code>. Then, the definition of semantics of those formulas in those different categories and possibly a discussion of deduction calculi as you have done (This is an area where one could attempt to write some algorithms!).</p>\n<p>When attempting to do this, especially when formalizing, we might expect to have some extra care when defining the semantics. When we work with formulas everything works up to equality, but in the respective categories we are using (co-)limits like pullbacks and coequalizers, where there might be no canonical choices of those and things only hold up to isomorphism (strictness concerns).</p>\n<p>I have not looked into how the <code>model-theory-topos</code> repo does this, but perhaps working with presheaves simplifies this, since in presheaves (co-)limits can be computed pointwise.</p>",
        "id": 528470267,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752338347
    },
    {
        "content": "<p>I am very happy to see that you would like to see the hierarchy stuff. With my collaborators, we are going to discuss if we should throw time in this direction. I think it would be helpful because you do not need full geometric theory to do useful things. (Thanks to <span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span> for reminding me about that possibility recently.) For example, regular theories are already useful to prove properties about a category. On the other end, we do not have to stop at geometric category. If we have internal HOL (in elementary topoi), then we can even do more.</p>",
        "id": 528470670,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752338793
    },
    {
        "content": "<p>Regarding propositional geometric logic stuff, yes it is relevant to Joshua Wrigley's work. I will say it is a bit far, indeed, but not as far as the duality stuff. You are right that this will not be the first thing to try at this stage.</p>",
        "id": 528470734,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752338865
    },
    {
        "content": "<p>In Lean we have HasFiniteProduct and ChosenFiniteProduct for instances of category having fin products, we work with the second one, and expect we can work chosen lims/colimits in a similar way. Moreover, I think we have the option of not directly attack geometric categories, but Grothendieck topoi, if we want canonical choice of almost everything? And yes,  in presheaves, we did it pointwise.</p>",
        "id": 528470833,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752339000
    },
    {
        "content": "<p>Maybe this is considered slightly separate, but I have been working on categorical semantics of lambda calculi in Lean. (This will be a major topic of my PhD). It is surprisingly difficult to express the categorical semantics of a concrete representation of a lambda calculus formally. Even for simple types there are issues:</p>\n<ol>\n<li>In Mathlib, we cannot work with morphisms in Prop without universe lifting </li>\n<li>If our typing derivations have separate types for contexts and types, we must decide how to translate this to a single type of objects</li>\n</ol>",
        "id": 528470871,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752339055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528470871\">said</a>:</p>\n<blockquote>\n<p>Maybe this is considered slightly separate, but I have been working on categorical semantics of lambda calculi in Lean. (This will be a major topic of my PhD). It is surprisingly difficult to express the categorical semantics of a concrete representation of a lambda calculus formally. Even for simple types there are issues:</p>\n<ol>\n<li>In Mathlib, we cannot work with morphisms in Prop without universe lifting </li>\n<li>If our typing derivations have separate types for contexts and types, we must decide how to translate this to a single type of objects</li>\n</ol>\n</blockquote>\n<p>Thanks for jumping out and pointing out the directions in type theories. I asked <span class=\"user-mention\" data-user-id=\"261023\">@Kyod</span> about concrete possibilities on topoi from dependent type theories. And the conclusion is that this is a bit far if we want to reach there from our current work. </p>\n<p>I am curious though, if it is fine to ask, why would you like different types for (models of?) contexts and (models of?) types?</p>",
        "id": 528471451,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752339654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528470833\">said</a>:</p>\n<blockquote>\n<p>In Lean we have HasFiniteProduct and ChosenFiniteProduct for instances of category having fin products, we work with the second one, and expect we can work chosen lims/colimits in a similar way. Moreover, I think we have the option of not directly attack geometric categories, but Grothendieck topoi, if we want canonical choice of almost everything? And yes,  in presheaves, we did it pointwise.</p>\n</blockquote>\n<p>Yes! But when one does this, concerns like <em>are our chosen pullbacks strictly functorial or just functorial up to iso?</em> (pullback-pasting up to iso or up to equality on objects) might come up, which is what my concern is about. I am not entirely sure if this is needed though.</p>",
        "id": 528471588,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752339813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528470871\">said</a>:</p>\n<blockquote>\n<p>Maybe this is considered slightly separate, but I have been working on categorical semantics of lambda calculi in Lean. (This will be a major topic of my PhD). It is surprisingly difficult to express the categorical semantics of a concrete representation of a lambda calculus formally. Even for simple types there are issues:</p>\n<ol>\n<li>In Mathlib, we cannot work with morphisms in Prop without universe lifting </li>\n<li>If our typing derivations have separate types for contexts and types, we must decide how to translate this to a single type of objects</li>\n</ol>\n</blockquote>\n<p>Typed or untyped?</p>",
        "id": 528471648,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752339874
    },
    {
        "content": "<p>Nevermind, it's probably typed.</p>",
        "id": 528471708,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752339929
    },
    {
        "content": "<p>We do not need the notion of pullback of presheaves to define semantics on presheaves. But in general, people have criticism on working with equality between functors. So if we want to work with strict equality, <del>we may need to fight against some criticism (but sometimes we have to do it...)</del> we will also encounter relevant heterogeneous equality problems. In this project, we are trying to avoid equality between functors. But personally, since I work with equality between functors on another thing, I personally do not against strict equalities, but I need to be convinced first that they are objectively equalities, and we are not making strong assumptions that will make our development weaker. (i.e. if we define two functors, and they are objectively equal, we have the option of working with equality between functors or equivalence between functors. In this case, I am can take the option of just working with equalities. But I will be careful with assumptions/instances stating \"we consider interpretations in a category with chosen limits where pullback-pasting squares are strict.\")</p>",
        "id": 528472034,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752340217
    },
    {
        "content": "<p>I think that while philosophically, we might want to think of isomorphisms only, I think it is very practical to think of equality and certainly also definitional equality when working in Lean.</p>\n<p>Okay, you are right, you do not need pullbacks just to define semantics of formulas/sequents :) But, when defining semantics of substitutions, you would need to use pullbacks, right (and aren't substitutions part of the Hilbert calculus)? Then, you might want (I am not sure if you do) a functoriality property for substitutions: If we apply two substitutions to a formula, we are applying two pullbacks to a formula and maybe we might want strict functoriality (the object given by applying both substitutions in sequence is equal to the object given by applying the composition of the substitutions). Does this come up at all in your soundness proof or is this not relevant? :)</p>",
        "id": 528472558,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752340829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528471451\">said</a>:</p>\n<blockquote>\n<p>I am curious though, if it is fine to ask, why would you like different types for (models of?) contexts and (models of?) types?</p>\n</blockquote>\n<p>I mean that there is a mismatch between a typical type signature for typing derivations versus morphisms in a category. Typically in formalized metatheory we have some inductive type of derivations <code>‚ä¢ : Ctx ‚Üí Ty ‚Üí ùí∞</code>, where ùí∞ is some universe. We have separate types for contexts and types for many reasons, ranging from practicality (maybe it is nice to reuse a standard list or multiset type) to conceptually mirroring the fact that one is metatheoretic and the other object level. On the other hand, morphisms in a category should have a single type for objects.</p>",
        "id": 528472573,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752340842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528472558\">said</a>:</p>\n<blockquote>\n<p>I think that while philosophically, we might want to think of isomorphisms only, I think it is very practical to think of equality and certainly also definitional equality when working in Lean.</p>\n<p>Okay, you are right, you do not need pullbacks just to define semantics of formulas/sequents :) But, when defining semantics of substitutions, you would need to use pullbacks, right (and aren't substitutions part of the Hilbert calculus)? Then, you might want (I am not sure if you do) a functoriality property for substitutions: If we apply two substitutions to a formula, we are applying two pullbacks to a formula and maybe we might want strict functoriality (the object given by applying both substitutions in sequence is equal to the object given by applying the composition of the substitutions). Does this come up at all in your soundness proof or is this not relevant? :)</p>\n</blockquote>\n<p>I will say people with intention of against functor equalities have philosophy in their mind. But I am not sure if strong assumption can cause problem in practice. I am not familiar with concrete examples, but I have the impression that type theory people can work with crazy elementary topoi, and it is not necessarily true that the pb square is always strict, or people do not care it... (I will appreciate if some one can throw me a concrete example.) It will be better if our work can be useful for such cases as well.</p>\n<p>Are you talking about modelling substitutions of formulas? If so, iterated substitution does not occur in proof rules, so the soundness proof is not relevant to this. We do have the definition of interpreting substitutions, this is by pre-compositon (yes, it is also called pullback, but we do not need to have a pullback in Psh to define it).</p>",
        "id": 528473589,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752341839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528472573\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528471451\">said</a>:</p>\n<blockquote>\n<p>I am curious though, if it is fine to ask, why would you like different types for (models of?) contexts and (models of?) types?</p>\n</blockquote>\n<p>I mean that there is a mismatch between a typical type signature for typing derivations versus morphisms in a category. Typically in formalized metatheory we have some inductive type of derivations <code>‚ä¢ : Ctx ‚Üí Ty ‚Üí ùí∞</code>, where ùí∞ is some universe. We have separate types for contexts and types for many reasons, ranging from practicality (maybe it is nice to reuse a standard list or multiset type) to conceptually mirroring the fact that one is metatheoretic and the other object level. On the other hand, morphisms in a category should have a single type for objects.</p>\n</blockquote>\n<p>If I understand correctly, you mean you need to control the universe level of the type you obtained from a context and the universe level of the context. If so, then I am convinced...</p>",
        "id": 528474303,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752342687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528474303\">said</a>:</p>\n<blockquote>\n<p>If I understand correctly, you mean you need to control the universe level of the type you obtained from a context and the universe level of the context. If so, then I am convinced...</p>\n</blockquote>\n<p>This is true if typing derivations live in <code>Type</code>, but not what I was tying to point out. I will try to explain better. Look at this (slightly informal, but standard) diagram:<br>\n<a href=\"/user_uploads/3121/bu5JpqqrRXSIbJ9y0PaSRhbE/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/bu5JpqqrRXSIbJ9y0PaSRhbE/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"478x290\" src=\"/user_uploads/thumbnail/3121/bu5JpqqrRXSIbJ9y0PaSRhbE/image.png/840x560.webp\"></a></div><p>We are mapping into some ccc <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathscr{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span>, taking contexts/types to objects and derivations to morphisms. Look at the object in the upper right. This <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> is used as a type in the first derivation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œî</mi><mo>‚ä¢</mo><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta \\vdash \\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œî</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> of the composition, then as a context in the proceeding morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\vdash \\tau</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span></span></span></span>. </p>\n<p>This does not immediately allow for composition, because the semantics of a derivation has type </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math display=\"block\" xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mo lspace=\"0em\" rspace=\"0em\">‚ä¢</mo></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi>œÑ</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\Gamma \\vdash \\tau \\rrbracket}_{\\vdash} :\n\\mathscr{C}({\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}},{\\llbracket \\tau \\rrbracket}_{\\mathrm{Ty}})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚ä¢</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>To be able to compose this formally, we need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mo>‚ãÖ</mo><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\cdot \\rrbracket}_{\\mathrm{Ctx}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">‚ãÖ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mo>‚ãÖ</mo><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\cdot \\rrbracket}_{\\mathrm{Ty}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">‚ãÖ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span> are compatible in the sense that they map to equal objects, and we can then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom#doc\">docs#CategoryTheory.eqToHom</a> to construct an indentity morphism to switch from treating <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> as a type to treating it as an object. So our diagram really looks like<br>\n<a href=\"/user_uploads/3121/F2VOjG-6fBMIB8plg__XTusg/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/F2VOjG-6fBMIB8plg__XTusg/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"475x313\" src=\"/user_uploads/thumbnail/3121/F2VOjG-6fBMIB8plg__XTusg/image.png/840x560.webp\"></a></div><p>where  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>‚Äâ</mtext><mtext>‚Äâ</mtext><mover accent=\"true\"><mo>‚ãÖ</mo><mo stretchy=\"true\">^</mo></mover><mo>:</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow><mo>‚Üí</mo><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\, \\, \\widehat{\\cdot} : \\mathrm{Ctx} \\to \\mathrm{Ty}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6845em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6845em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mbin\">‚ãÖ</span></span><span class=\"svg-align\" style=\"top:-3.4444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg height=\"0.24em\" preserveaspectratio=\"none\" viewbox=\"0 0 1062 239\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"></path></svg></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Ctx</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span> is a function that we prove satisfies the identity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo>=</mo><msub><mrow><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\widehat{\\Gamma} \\rrbracket}_{\\mathrm{Ty}} =  {\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3591em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg height=\"0.24em\" preserveaspectratio=\"none\" viewbox=\"0 0 1062 239\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"></path></svg></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 528477115,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752345793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> I am really glad to hear that this pullback strictness business does not come up here and I hope it continues not to come up :) I was actually a bit worried haha</p>",
        "id": 528478868,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752347585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528477115\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528474303\">said</a>:</p>\n<blockquote>\n<p>If I understand correctly, you mean you need to control the universe level of the type you obtained from a context and the universe level of the context. If so, then I am convinced...</p>\n</blockquote>\n<p>This is true if typing derivations live in <code>Type</code>, but not what I was tying to point out. I will try to explain better. Look at this (slightly informal, but standard) diagram:<br>\n<a href=\"/user_uploads/3121/bu5JpqqrRXSIbJ9y0PaSRhbE/image.png\">image.png</a></p>\n<p>We are mapping into some ccc <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathscr{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span></span></span></span>, taking contexts/types to objects and derivations to morphisms. Look at the object in the upper right. This <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> is used as a type in the first derivation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œî</mi><mo>‚ä¢</mo><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta \\vdash \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œî</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> of the composition, then as a context in the proceeding morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\vdash \\tau</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span></span></span></span>. </p>\n<p>This does not immediately allow for composition, because the semantics of a derivation has type </p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mo lspace=\"0em\" rspace=\"0em\">‚ä¢</mo></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi>œÑ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\Gamma \\vdash \\tau \\rrbracket}_{\\vdash} :\n\\mathscr{C}({\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}},{\\llbracket \\tau \\rrbracket}_{\\mathrm{Ty}})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚ä¢</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>To be able to compose this formally, we need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mo>‚ãÖ</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\cdot \\rrbracket}_{\\mathrm{Ctx}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">‚ãÖ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mo>‚ãÖ</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\cdot \\rrbracket}_{\\mathrm{Ty}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">‚ãÖ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span></span></span></span> are compatible in the sense that they map to equal objects, and we can then use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.eqToHom#doc\">docs#CategoryTheory.eqToHom</a> to construct an indentity morphism to switch from treating <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> as a type to treating it as an object. So our diagram really looks like<br>\n<a href=\"/user_uploads/3121/F2VOjG-6fBMIB8plg__XTusg/image.png\">image.png</a></p>\n<p>where  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>‚Äâ</mtext><mtext>‚Äâ</mtext><mover accent=\"true\"><mo>‚ãÖ</mo><mo stretchy=\"true\">^</mo></mover><mo>:</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow><mo>‚Üí</mo><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\, \\, \\widehat{\\cdot} : \\mathrm{Ctx} \\to \\mathrm{Ty}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6845em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6845em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mbin\">‚ãÖ</span></span><span class=\"svg-align\" style=\"top:-3.4444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Ctx</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span> is a function that we prove satisfies the identity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo>=</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\widehat{\\Gamma} \\rrbracket}_{\\mathrm{Ty}} =  {\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3591em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span></p>\n</blockquote>\n<p>I think I see--you are trying to emphasize on eqToHom stuff. Yes that is very painful, and depend on cases you may want to turn it into HEq to see it looks better, very hard to predict. (I encounter eqToHom a lot for formalizing a model of type theory, but it is not such a problem for formalizing geometric logic semantics.) Thanks for writing and drawing all this for the clarification!</p>",
        "id": 528484778,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752354617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528478868\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> I am really glad to hear that this pullback strictness business does not come up here and I hope it continues not to come up :) I was actually a bit worried haha</p>\n</blockquote>\n<p>I do not think it will come up for the soundness as long as we do not have a proof rule about it. It is a bit hard for me to imagine why would we ever want a proof rule with iterated substitution, maybe it happens in some type theory? Have not encountered such a thing yet. I also cannot predict when it would be used. If I find something suspicious, I will comment on this post to let you know.</p>",
        "id": 528484880,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752354782
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> You're welcome, glad that made sense! Yes, it is essentially an issue about using eqToHom. It seems unavoidable if we do not either alter our derivation typing or use multicategories. Do you have any examples in a public repo where you've worked with models of type theories? I've not tried to use HEq like you suggest and would be interested to see what that looks like.</p>",
        "id": 528485396,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752355670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528485396\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> You're welcome, glad that made sense! Yes, it is essentially an issue about using eqToHom. It seems unavoidable if we do not either alter our derivation typing or use multicategories. Do you have any examples in a public repo where you've worked with models of type theories? I've not tried to use HEq like you suggest and would be interested to see what that looks like.</p>\n</blockquote>\n<p>Unfortunately what we find is that it is just unavoidable as well. I mean in proof exploration you may encounter some <code>eqToHom ... &gt;&gt; term &gt;&gt; eqToHom ...</code>, you may want to get rid of too many eqToHoms in your goal, in which case you can try these lemmas with \"comp\" and \"eqToHom\" <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.comp_eqToHom_iff\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.comp_eqToHom_iff</a></p>\n<p>For instance, you see</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">heq_eqToHom_comp_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">heq_comp_eqToHom_iff</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">eqToHom_comp_heq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">comp_eqToHom_heq_iff</span>\n</code></pre></div>\n<p>in <br>\n<a href=\"https://github.com/sinhp/groupoid_model_in_lean4/blob/master/GroupoidModel/Groupoids/Sigma.lean\">https://github.com/sinhp/groupoid_model_in_lean4/blob/master/GroupoidModel/Groupoids/Sigma.lean</a><br>\n(My collaborators wrote this and I am still getting better on these things.)</p>",
        "id": 528500340,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752378931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528477115\">said</a>: ...</p>\n<p>Hi, I'm very curious in what the problem is here, could you please help me understand this? What is the the lambda calculus in this picture? I'm in particular not sure what this  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>‚Äâ</mtext><mtext>‚Äâ</mtext><mover accent=\"true\"><mo>‚ãÖ</mo><mo stretchy=\"true\">^</mo></mover><mo>:</mo><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow><mo>‚Üí</mo><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\, \\, \\widehat{\\cdot} : \\mathrm{Ctx} \\to \\mathrm{Ty}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6845em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6845em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mbin\">‚ãÖ</span></span><span class=\"svg-align\" style=\"top:-3.4444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Ctx</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span>  function is supposed to be.</p>",
        "id": 528598026,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752477109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span> This lambda calculus is just STLC, extended with pairs and a unit type. That function takes a context and gives a type such that both have as their semantics the same object in a CCC. Explicitly, it can just map a context to the product of its elements, terminated with the unit type for the empty context. </p>\n<p>To rephrase what I say above, the question here is what it means to compose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œî</mi><mo>‚ä¢</mo><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta \\vdash \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œî</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma \\vdash \\tau</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span></span></span></span>. If contexts and types are <strong><em>syntactically different entities</em></strong>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> must be either a context or type (I choose context here), and we need to speak about the composition of</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œî</mi><mo>‚ä¢</mo><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mo lspace=\"0em\" rspace=\"0em\">‚ä¢</mo></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œî</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\Delta \\vdash \\widehat{\\Gamma} \\rrbracket}_{\\vdash} : \\mathscr{C}({\\llbracket \\Delta \\rrbracket}_{\\mathrm{Ctx}},{\\llbracket \\widehat{\\Gamma} \\rrbracket}_{\\mathrm{Ty}})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.223em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œî</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚ä¢</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3591em;vertical-align:-0.4358em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œî</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><br>\nand<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>œÑ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mo lspace=\"0em\" rspace=\"0em\">‚ä¢</mo></msub><mo>:</mo><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub><mo separator=\"true\">,</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi>œÑ</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\Gamma \\vdash \\tau \\rrbracket}_{\\vdash} : \\mathscr{C}({\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}},{\\llbracket \\tau \\rrbracket}_{\\mathrm{Ty}})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1864em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">‚ä¢</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord mathscr\" style=\"margin-right:0.1689em;\">C</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<p>which typechecks becasue we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi></mrow></msub><mo>=</mo><msub><mrow><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo></mrow><mrow><mi mathvariant=\"normal\">C</mi><mi mathvariant=\"normal\">t</mi><mi mathvariant=\"normal\">x</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">{\\llbracket \\widehat{\\Gamma} \\rrbracket}_{\\mathrm{Ty}} = {\\llbracket \\Gamma \\rrbracket}_{\\mathrm{Ctx}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3591em;vertical-align:-0.4358em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\" style=\"margin-right:0.01389em;\">Ty</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">Ctx</span></span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span></span></span></span>. </p>\n<p>If it helps you to read code, see this <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMBQOJgCmAdnAMIqEDm0AngCqqF2ITETAAmS6FM1dPAHoAtCLgAFKBE4BXAMbwkxTnABms4ouBs4MWkQDOAOjj0DhQ3CRRCcMDaQhC/KMABehVVlpxDEZzgqaU1VfSI4AAMAaUjTESEcYBUFGGAANztzOAAKaLgALjMLAEocODhRcQBVYmB4cwiE8rgAHzha+sLiuGiWqrgAQTgsJENgeT0LZor2gCExuyL8wCTCHr6KgeGNLTTdcLscwGHgOEAlwjhAEeASuBm2oagobuzV9bg15/6xIftpOUUpiLHOCAeipLtdbu0pDInr4Xs83usWpxCG50skqHAAEqEMBQAA0cAAIoR5FwkFh0IQAKIARzwyTUwAAHlACgA2AAMcAARCCeXAALwAPmKxihnCSxEZLIKAHYubzAMyU/OFosGDxwuMI0oKAE4FQA/FUi8zGBaGQjCcTDeRsfhM+DAKzjcDoXxIOCYQzwCBqAGWG6JclYWzpcgwJm5fJFRqEa4FAVwAAyTvgOWeZRw6RswHJlLgAG9o8UiABfOAAbT4AigsIAupWKLBLLniAg2BxuLxKDRa70G1WbPxxsoyOgIBbVNE61bviAkGAwOj1NIQP6rMkYBBrOQhy3lHB5OPJ4ee3RTDkAOp2MaGWSBNCEXyGVA2OyjC3r8GJAACFZdYAzuwWgBGAsgwHmdjIn6pqbiiYAwr0CJ9JCvxwCcFyCiKRzGHBUAIYA6USXLhxCuGAODtOqjzoZcWHoSRZFwIAn+QVBcDHwRRcDmnYADWdE8ZxnTwKqgAlRAA+r0eDsBBezEAUNgYtygBn5LyJzcoA5+SAOq4vKqrBpHwehVrWnA86LsuairoedqEA6G6kduHpNsOraHseXinvwva0PEv7/qAgE4MBtrgOBkFwNB4ZMux+HdGQEZIWsKGVg2okSWJnEnAURSAMnAdE4XhhGRdFCHZVJEAyTockKTyKlwLlGmADm4OkinFUUFXVRlzguS7EBiFkBFZ+kOno24HHor7wFqFpQJkdlkbYFW6M0f4ATOEWtcYW5ifosXxXCsKcRWKUmt5QmcagqhZXo6B0RdfIbVtO0wOgnUPRA22+FNKKzX4hDzqRExWM0j7QH9RWPbQYmEDSuS5UUrW9PGcBKdlm3vfoWmCsj2XqQ1hSJj4cDJH8sl1XAAA8ADcIpIJYBB4H+tP+AhmiGEgah2BWtrEN6UCpNAhgEvIiyGHWM7E6kGR2MSjxFuW8N7Qi8JrFC5HtNmsu5Uc8s0YAEERk2sMtk0cnHoE4hZa5cOtG0CV3ZdcmGGyiZNAsqVycd1Fs0Rc1vO7lrtggiRuW07jy5RcnGAAPAgCBBF7GG+2HuQnKCVxB37hntJHgBBBHHVvdMHSd8qnodkxH7QOMAmvewnxsIkS6eO/XidAinZTtJowAWzXuWmmdko6gALAqcCAEVExpN3gIO2GuMvGDZ8By17gApwLtkbROWOSoN0uWAGFEcBL9ctvrEjmU5XAe+n/v+MjO6dPkTgU9g7PtjEE4diLwWuUrwra/lgW2vb3PlfNYuUx4nDWCvMB18fAtE3NIKwgBB4HCiiFooYUTwCQSvWBKRtC6GRI8KmIo4ETgptTawd9J5MFBjPFEc9bKFnXsvVevQN7jAxEUQAAESFm1gSE4+tcoQNHuhJGXD/5WwJJhfWl8BE0SupA2icAWgJhvtgmA8DvYmT+i0YWForDOBANoxYcAmBIFUKqJm9MKg6LsBBYAN19F0Rskgf4L8365EJhYsAh82GaJAJmR+NCoDGDvFgb0DC/5f2YYwnIPjOHcNLLwuA/CETyKONcf+OtQE0UEVA5RMCKjEKsPg1BhBMiwD8MADES9sEk0qsgghZDClXzYYYz8Gs6KeNaXYM2a5LaYQksALeqonH/B6bkQZuR57OkqSUMoVijGewwnANKyzlmqlsIyYgdgfyexWUsgA/BJQ5pCaYUPmZ+GOGiVnDKZM4+AP5Ll7NojkDxd85mnguTnJZ1yRQjPudnVZEklkvNvszd51j7BIErlcwFqz1namSNsiujwnmYWOccwh5DmZdLgB3DpFCcBfAAO52GFsQAA5PAIlbh+DjSdHAQgYw7G+CwCSJAshPzIDQJgLA4UICWApfASk8AQDQDAKgJ0IArCYEyETUgqsCRYHAnSjcVhHwVKoK/GAshbBwBJXq5QMBjDGpwBFWe7VP5RL/pldYmShHgNyCjXGcBABv5BUJSRwtLxkTP4B4tBArlRQJVeSUBFK1TUupQAErjNSbsVQyhLxBMF1fS9VwVIDjFJskcaUFczBHNgASXCrYIlBQH5UOnn4WQoSYBiUpCAechYV5w0iiwwsmEYywg3pwAAjN0eRqMIaH04AAJkAWPVOOQkFxLER2lhiTkk5OEYUFoSke1RrgIAayIGU0noBAAAEgNHIA70aQ2htcLdq7h3rsTJe4JVawkIPXco31tYgA\">Lean 4 Web link</a>. (I admit the definition of the semantics of a derivation because universes used in Mathlib's category definition makes it difficult to write it directly in Prop).</p>",
        "id": 528607081,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752480834
    },
    {
        "content": "<p>I see, thanks for sharing the code and clearly explaining things! </p>\n<p>Is there a reason on why you use Prop-valued derivations instead of type-valued terms? This is what causing the first problem. I just now realize I could also ask this to <span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span>  w.r.t. the geometric logic project.</p>\n<p>About the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">subst_lemma</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d1</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">eqToHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">to_ty_eq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d2</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d2</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">œÅ</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The <code>‚ü¶d1‚üß·µà ‚â´ eqToHom (Œì.to_ty_eq)</code> approach seems a bit weird to me. What I had seen before is giving semantics to contexts morphisms <code>‚àÄ {œÉ : Ty K}, œÉ ‚àà Œì ‚Üí Œî ‚ä¢ œÉ</code> of type <code>‚ü¶Œî‚üß·∂ú ‚ü∂ ‚ü¶Œì‚üß·∂ú</code> and using this instead. This has the conceptual benefit of working for type theories that do not have product types. If you want then you could show that this is the same as using <code>‚ü¶d1‚üß·µà ‚â´ eqToHom (Œì.to_ty_eq)</code> but at least you won't see more <code>eqToHom</code>s anymore.</p>",
        "id": 528618133,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752484583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528618133\">said</a>:</p>\n<blockquote>\n<p>I see, thanks for sharing the code and clearly explaining things! </p>\n<p>Is there a reason on why you use Prop-valued derivations instead of type-valued terms? This is what causing the first problem. I just now realize I could also ask this to <span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span>  w.r.t. the geometric logic project.</p>\n<p>About the lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">subst_lemma</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œî</span><span class=\"w\"> </span><span class=\"bp\">‚ä¢</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d1</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"n\">eqToHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">to_ty_eq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚â´</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d2</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">d2</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">œÅ</span><span class=\"bp\">‚üß·µà</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The <code>‚ü¶d1‚üß·µà ‚â´ eqToHom (Œì.to_ty_eq)</code> approach seems a bit weird to me. What I had seen before is giving semantics to contexts morphisms <code>‚àÄ {œÉ : Ty K}, œÉ ‚àà Œì ‚Üí Œî ‚ä¢ œÉ</code> of type <code>‚ü¶Œî‚üß·∂ú ‚ü∂ ‚ü¶Œì‚üß·∂ú</code> and using this instead. This has the conceptual benefit of working for type theories that do not have product types. If you want then you could show that this is the same as using <code>‚ü¶d1‚üß·µà ‚â´ eqToHom (Œì.to_ty_eq)</code> but at least you won't see more <code>eqToHom</code>s anymore.</p>\n</blockquote>\n<p>At least for our current formulation of the (Josh's construction of) syntactic category, we do not care about what is the actual proof, but only care about the fact that we have a proof. So the fact that we do not store a Type-valued proof term. Otherwise, I may have misunderstood you (in which case it would be helpful to define your relevant notions with examples...). I remember you asked me on TYPES in person before.</p>",
        "id": 528621340,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752485607
    },
    {
        "content": "<p>I forgot sorry, you're indeed right :)</p>",
        "id": 528621562,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752485678
    },
    {
        "content": "<p>Ah no worries! BTW, regarding the treatment of proof theory, we may also try sequent calculi, but depend on how much time/energy we have...</p>",
        "id": 528621868,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752485778
    },
    {
        "content": "<p><del>I guess this is then remedied by making the interpretation of formulas (<code>interp_fml</code>) noncomputable</del></p>",
        "id": 528621911,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752485788
    },
    {
        "content": "<p>There are a bunch of noncomputable that is only because Lean imposes noncomputable to something. And if we remove the noncomputable in the relevant notion from Mathlib, many of the things are computable.</p>",
        "id": 528622109,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752485852
    },
    {
        "content": "<p>We aim to make (almost, to be safe) everything computable. Myself is not entirely clear about the computability technology involved. I should figure these things out at some point.</p>",
        "id": 528622152,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752485867
    },
    {
        "content": "<p>I see, my previous comment is completely wrong, so please ignore that.</p>",
        "id": 528622807,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752486068
    },
    {
        "content": "<p>No worries! I think computability issues are confusing. I have the impression that sometimes it is not the fact that things does not compute, but rather the designers of Mathlib do not want people to compute with them. Therefore, there exist things that are marked noncomputable but actually computable (it seems that the designers intend to discourage people from doing something). We should ask about why it happens months ago... but happened to forget it.</p>\n<p>(If an expert passes by, many thanks for explaining that to me by answering the question: why are there something computable marked noncomputable in Mathlib?)</p>",
        "id": 528623309,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1752486219
    },
    {
        "content": "<p>As an example I just ran into, it happens when you are constructing data from a proposition, which you did not prove to satisfy <code>Decidable</code> (this is a condition that says that we can compute with a certain proposition). For example, you might say you want the <em>least natural number</em> satisfying a property (this is <code>Nat.find</code>), but unless you prove that your property is <code>Decidable</code>, the computer will not be able to use commands like <code>#reduce</code> to compute it.</p>\n<p>So while classical reasoning ('every proposition is true or false') is allowed when working with <code>Prop</code>, computability can break down when you move from <code>Prop</code> to other types (by things like case distinctions or the axiom of choice).  These things result in objects in mathlib like <code>Polynomial</code> not being computable, because it seems like it would take some extra effort to make it computable. There is a whole thread on this <a href=\"#narrow/channel/287929-mathlib4/topic/Why.20is.20.60Polynomial.60.20noncomputable.3F\">here</a> (I do not know the exact details of where <code>Polynomial</code> uses classical reasoning for construction of data).</p>\n<p>In any case, this is my understanding of how this works.</p>",
        "id": 528631434,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752489293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span>  Thank you for the illuminating web link with the interpretation of non-depedent type theory into cartesian-closed categories. You actually ran into the exact issue I am describing in the previous message <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> </p>\n<p>You are constructing <code>Der</code> as a proposition, which means that it carries no data. So Lean can't extract data from <code>Der</code> to construct a morphism in <code>K</code> unless you rely on noncomputable behaviour. One is a property and the other one is an arrow in a category! Think about it this way: Each way to derive a sequent gives you a (a priori) <strong>possibly distinct</strong> interpretation as a morphism in <code>K</code>. So, of course, you could just say <em>choose some way to derive and make it a morphism</em> (use the axiom of choice).</p>\n<p>You could also keep things computable and define <code>Der</code> to actually carry the data of how we arrived at the derivation (make it <code>Type</code>-valued, as <span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span>  sais) and use this. You can always still define a predicate <code>Derives</code> to say that <em>there exists a derivation</em>. In code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">constructors</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"kd\">]</span><span class=\"o\">]</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚§≥</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚§≥</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÑ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">œÄ‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚®Ø</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">œÄ‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚®Ø</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÑ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\">  </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚®Ø</span><span class=\"w\"> </span><span class=\"n\">œÑ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">uni</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Unit</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Derives</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÉ</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then you should have no trouble constructing the desired map</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der'</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œì</span><span class=\"bp\">‚üß·∂ú</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\">  </span><span class=\"bp\">‚ü¶</span><span class=\"n\">œÉ</span><span class=\"bp\">‚üß·µó</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>by structural recursion.</p>\n<p>For your second issue, the problem is that the equality <code>‚ü¶Œì.to_ty‚üß·µó = ‚ü¶Œì‚üß·∂ú</code> does not hold <em>definitionally</em>. So while the terms can be proved to be equal, Lean cannot prove this automatically with the tactic <code>rfl</code> when it checks composability. One way to fix it is to define <code>‚ü¶Œì‚üß·∂ú := ‚ü¶Œì.to_ty‚üß·µó</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> </p>\n<p>Here is the modified part of your web code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A mapping from context to type that preserves interpretation -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">‚®Ø</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span><span class=\"w\"> </span><span class=\"n\">tl</span>\n\n<span class=\"sd\">/-- A mapping from contexts into a Cartesian closed category. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span>\n\n<span class=\"kn\">notation</span><span class=\"o\">:</span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"s2\">\"‚ü¶\"</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"s2\">\"‚üß·∂ú\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"n\">Œì</span>\n\n<span class=\"sd\">/-- Ctx.to_ty preserves semantics -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"bp\">.</span><span class=\"n\">to_ty_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œì</span><span class=\"bp\">.</span><span class=\"n\">to_ty</span><span class=\"bp\">‚üß·µó</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œì</span><span class=\"bp\">‚üß·∂ú</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This fixes the composability issue and you will not have to use <code>Ctx.to_ty_eq</code> to compose. Lets just hope that this doesn't run you into any trouble anywhere else :)</p>\n<p>I hope this helps even though I did not provide any working examples!</p>",
        "id": 528672319,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752502464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"402440\">@Adrian Marti</span> Redefining <code>Ctx.interp</code> in that way is interesting! Seems it might be easier to work with when proving soundness.</p>\n<p>I have previously constructed <code>Der</code> in <code>Type</code> similar to what you describe. You are completely correct, I just find this unsatisfying because this is downstream of Mathlib having morphisms in <code>Type</code> rather than <code>Sort</code> (I recently asked about this in <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/categories.20with.20morphisms.20in.20Prop/with/528286569\">#mathlib4 &gt; categories with morphisms in Prop</a>, there are some links about the history of this decision)</p>",
        "id": 528683391,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752505701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528618133\">said</a>:</p>\n<blockquote>\n<p>Is there a reason on why you use Prop-valued derivations instead of type-valued terms? </p>\n</blockquote>\n<p>I have done this previously both ways, having derivations in <code>Prop</code> or <code>Type</code>. Here I just copied over the <code>Prop</code> one because it was more succinct as an example. In general, I find this limitation of disallowing <code>Prop</code>-valued morphisms an unfortunate implementation detail.</p>\n<p>I do not quite follow</p>\n<blockquote>\n<p>What I had seen before is giving semantics to contexts morphisms <code>‚àÄ {œÉ : Ty K}, œÉ ‚àà Œì ‚Üí Œî ‚ä¢ œÉ</code> of type <code>‚ü¶Œî‚üß·∂ú ‚ü∂ ‚ü¶Œì‚üß·∂ú</code> and using this instead. This has the conceptual benefit of working for type theories that do not have product types.</p>\n</blockquote>\n<p>do you mean something related to the categories of context renamings or context substitutions? If so, I think I understand. I agree it is desirable to not require product types. For the \"usual\" semantics of STLC in CCCs it is a bit stange when we extend the type theory at the object level to mirror the structure of contexts at the meta level.</p>",
        "id": 528687064,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752506753
    },
    {
        "content": "<p>Why would you like to have morphisms in <code>Prop</code>? I would say that the issue is that you are mapping from a proposition to a type. If you would like to use derivations in <code>Prop</code> you can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Der</span><span class=\"bp\">.</span><span class=\"n\">interp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ctx</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Der</span><span class=\"w\"> </span><span class=\"n\">Œì</span><span class=\"w\"> </span><span class=\"n\">œÉ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">‚ü¶</span><span class=\"n\">Œì</span><span class=\"bp\">‚üß·∂ú</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\">  </span><span class=\"bp\">‚ü¶</span><span class=\"n\">œÉ</span><span class=\"bp\">‚üß·µó</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">der</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">der</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Your construction by structural recursion here</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but you won't be able to compute things (and I don't think that there is a way around this).</p>",
        "id": 528687478,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752506885
    },
    {
        "content": "<p>Unless of course, you want to discuss semantics in cartesian closed categories with morphisms in <code>Prop</code> (i.e. Heyting algebras only). But I think it would be nice to get general cartesian-closed categories :)</p>",
        "id": 528688318,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752507128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528687478\">said</a>:</p>\n<blockquote>\n<p>Why would you like to have morphisms in <code>Prop</code>? I would say that the issue is that you are mapping from a proposition to a type.</p>\n</blockquote>\n<p>Yes, the issue is mapping from <code>Prop</code> to <code>Type</code>. I am just saying the reason this problem exists (at least partially) is because of our definition of a category, which differs from several other category theory libraries in not allowing morphisms in <code>Prop</code>. As a practical matter your noncomputable solution is fine, because we already have other sources of noncomputability, and I agree that it is nice to consider CCCs more generally.</p>\n<p>To clarify why I'm bothering with this at all: usually when someone is working with categorical semantics formally, they are also the ones defining the syntax and make certain allowances to smooth the formalization. My interest is when we take a more \"off the shelf\" formalization of a lambda calculus that has idiomatic features like typing derivations living in <code>Prop</code>. I think it is interesting to explore what techniques we need to adopt in this situation where the syntax was not written to ease formalization of a categorical semantics.</p>",
        "id": 528691866,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752508248
    },
    {
        "content": "<p>I guess in the end its a matter of taste whether to use <code>Prop</code> (if we do not care about computability).</p>\n<p>Part of what I'm envisioning for the potential future is being able to specify terms in different categories by using general logical symbols (a kind of metaprogramming), and I think that the constructive approach is much more suitable for this application. Of course, after one is done with the constructive definition, one can always deduce the nonconstructive definition by using <code>Nonempty</code> as I did above.</p>\n<p>One should also keep in mind the practicalities that computable definitions give you: They will have better-behaved definitional equalities and will require less rewriting/simping. On the hand, doing things computably can require a bit more thinking, and it seems to be mathlib's approach to not bother with it if its not easy (which is very reasonable).</p>",
        "id": 528699448,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752510377
    },
    {
        "content": "<p>Yes, very much a matter of taste. Your metaprogramming idea is something I have also been thinking about as well! It seems like we should be able to write a term in the syntax and interpret it in whichever categories are included in the semantics. I also had the thought that you should be able to search for theorems in this way, but this is more complicated because you can only rely on the structure given by the semantics.</p>",
        "id": 528700388,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752510693
    },
    {
        "content": "<p>I've been told that <span class=\"user-mention\" data-user-id=\"128280\">@ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí</span>  Is working on this kind of metaprograming applications, though I don't know the specifics. (This also seem like a good opportunity to find out)</p>",
        "id": 528705749,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752512761
    },
    {
        "content": "<p>I have no understanding of the theory which is being talked about here, but I have a dumb question. For me two categories are \"the same\" if they are equivalent. In my kind of mathematics this is the right notion of \"the same\", sometimes theorems are proved by saying \"we want to prove stuff about things in this super-abstract category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> most of whose objects we can't understand, but by a deep theorem in arithmetic geometry this category is equivalent to some totally different-looking category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, and in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> we can do explicit calculations because there are basically formulae for all the objects, and because we have been careful not to be evil we can deduce deep theorems about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> via concrete calculations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. This is a key technique in my area. As a result, for me \"don't be evil\" is high priority, because I might not be able to use evil ideas (e.g. equality of functors) when I'm pulling off tricks like this.</p>\n<p>To give an example of two functors which are absolutely not equal, we have these equivalences from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> and from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, and if you apply one functor and then the other,  the result is a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> which is provably <em>not</em> equal to the identity functor, for dumb set-theoretic reasons (it would be like taking the double-dual of a finite-dimensional vector space and getting a new vector space which is both completely canonically isomorphic to the original space but also definitely not equal to it, because a general element of the original space is a vector and a general element of the double dual is a function which induced by a vector). </p>\n<p>When I see computer scientists asking about things like equality of functors my initial instinct is to regard what they are doing as a dubious approach. But now on reading stuff like this I'm wondering whether there are some people who are also using category theory in their work but who in practice are using a different notion of what it means for two categories to be \"the same\", or maybe don't even have to wrestle with what it means for two different categories to be \"the same\" because they are only actually interested in an explicit collection of categories which they can write down and are not attempting to prove that any of them are \"the same as\" any of the others. If this concept of categories being \"the same\" is not relevant in certain areas, then it would not surprise me if stuff like equality of functors started to play a far more prominent role. </p>\n<p>Is there anything in this or am I just completely off track here?</p>",
        "id": 528713346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1752515648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528713346\">said</a>:</p>\n<blockquote>\n<p>for dumb set-theoretic reasons</p>\n</blockquote>\n<p>Are they really dumb 'set-theoretic' reasons when the exact same thing would happen in Lean?</p>",
        "id": 528715368,
        "sender_full_name": "James E Hanson",
        "timestamp": 1752516413
    },
    {
        "content": "<p>Or rather it would be independent of Lean whether the resulting type are equal.</p>",
        "id": 528715556,
        "sender_full_name": "James E Hanson",
        "timestamp": 1752516491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I think this makes some sense to me? In the context of doing categorical semantics in Lean, I am thinking about a category as roughly a type with enough structure posited by typeclasses to ensure it can interpret my lambda calculus syntax. I don't necessarily care about the same notion of \"sameness\" as standard category theory. And in this thread at least, it seems people have found being at least a little evil unavoidable in this application.</p>",
        "id": 528718309,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752517769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528713346\">said</a>: ...</p>\n<p>I think the approach you described is also used by people doing categorical logic and type theory. E.g., when HoTT people reason about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àû</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">‚àû</span></span></span></span>-toposes, they also care about stuff only up to (some notion of) equivalence, but have to use strict equalities when setting things up. Once these are set up, you can just proceed to forget about them completely. </p>\n<p>I'm not following this part:</p>\n<blockquote>\n<p>...and because we have been careful not to be evil we can deduce deep theorems about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> via concrete calculations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. </p>\n</blockquote>\n<p>If we were evil somehow, say consider equality of functors in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, then the conclusion in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is an isomorphism of functors, which is anyways the \"right\" notion. I guess my point is that there are no problems on being evil on the category that is being used to compute, this is roughly what is happening in categorical logic too. The category that is being used to compute is the syntactic category, which is very very evil, but once you do a bit of setup you can forget about this.</p>",
        "id": 528719206,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752518163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528718309\">said</a>:</p>\n<blockquote>\n<p>...it seems people have found being at least a little evil unavoidable in this application.</p>\n</blockquote>\n<p>I don't think this is quite right. You can avoid evilness completely by modelling judgemental equality only up to iso. This, to me, seems a bit weird since (usually) the categories usually have all the structure necessary to model the theory strictly, so it seems to me it's an unnecessary loss of information. An example of this, for dependent type theory, is replacing C-systems by display map categories. I'd believe one can do the same for STLC and CCC.</p>",
        "id": 528720406,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752518693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528715556\">said</a>:</p>\n<blockquote>\n<p>Or rather it would be independent of Lean whether the resulting type are equal.</p>\n</blockquote>\n<p>For the double dual example he suggested, these are independent , since a vector space is equal to its double dual in HoTT. (I could be wrong but I think this is the case)</p>",
        "id": 528721464,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752519145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528721464\">said</a>:</p>\n<blockquote>\n<p>For the double dual example he suggested, these are independent , since a vector space is equal to its double dual in HoTT. (I could be wrong but I think this is the case)</p>\n</blockquote>\n<p>Right but Lean has UIP, so you can show that a type is not equal to itself along a non-trivial automorphism, right? I think this means you can define two double-dual functors, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, on the category of finite-dimensional vector spaces such that Lean proves '<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">F_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are naturally isomorphic but not equal.' It's just independent whether either of them is equal to the identity functor.</p>",
        "id": 528722879,
        "sender_full_name": "James E Hanson",
        "timestamp": 1752519697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/stream/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528720406\">said</a>:</p>\n<blockquote>\n<p>You can avoid evilness completely by modelling judgemental equality only up to iso... I'd believe one can do the same for STLC and CCC.</p>\n</blockquote>\n<p>I think this makes sense to me, though you still have to take care to avoid talking about equality of objects for composition? (e.g. the way <span class=\"user-mention\" data-user-id=\"402440\">@Adrian Marti</span> revised my code earlier in the thread)</p>",
        "id": 528722975,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752519741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> right, my bad; too used to Agda. I'm not sure if its independent but yeah that would also be my guess.</p>",
        "id": 528723370,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752519892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> For composition instead of using the equality of objects you use an isomorphism in between, which was anyways what you had to do in <code>‚ü¶d1‚üß·µà ‚â´ eqToHom (Œì.to_ty_eq) ‚â´ ‚ü¶d2‚üß·µà</code>, as <code>eqToHom</code> is an iso.</p>",
        "id": 528723662,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752519992
    },
    {
        "content": "<p>Making sure I understand this idea of \"judgemental equality up to iso\". For instance, how would the statement of soundness change?</p>",
        "id": 528727049,
        "sender_full_name": "Chris Henson",
        "timestamp": 1752521539
    },
    {
        "content": "<p>I can't speak for other people, but here is my take on this. I do not think that there really is any dispute in equivalence of categories being the right mathematical notion of sameness for categories. Two equivalent categories satisfy the same properties (this can be made logically precise!).</p>\n<p>So the categories <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> in your example are the same and we can use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> to prove properties about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>. However, there is one key difference between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>, which is how it behaves computationally (which the mathematician also does care about!). As you said, it might be hopeless to compute with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, but it might be possible to use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> for it.</p>\n<p>I am specifically interested in exploring whether we can state our definitions in such a way that certain computations in categories is easy and even easy to automate. For example, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> was a category of certain representations and we have an understanding of the irreducible ones, if we were really careful of how we defined everything, we it might be possible to check whether two objects in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> are the same (isomorphic) by simply running an algorithm that heavily borrows from our formalization.</p>\n<p>While this is a different setting than the categorical logic we are talking about above, I think that it illustrates the point why we might want to building a sort of <em>computational library</em> to make our lives as easy as possible when working with categories.</p>\n<p>In fact, one could even imagine that you could tackle problems that are not easy to tackle by humans. For instance, if our objects are big, we might get decompositions into irreducibles that have 100+ terms. But since we are working with Lean, there might be ways to compute and work with these things in the same way that algebraic identities (with no additional free variables, n fixed) in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/n\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span> become trivial in Lean, because you can find a computational solution (trying all numbers out).</p>\n<p>These ideas are fairly vague, but I think that there is definitely room for exploring these things.</p>\n<p>Of course, there is also the issue that strictness/equality concerns can actually come up when we want to interpret logical formulas (such as from type theories, as <span class=\"user-mention\" data-user-id=\"587858\">@Fernando Chu</span>  mentions) in certain categories. There can be some evil-looking technical details involved in this, but I don't think that is because people do have a different notion of sameness of categories.</p>",
        "id": 528734851,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752524877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528727049\">said</a>:</p>\n<blockquote>\n<p>Making sure I understand this idea of \"judgemental equality up to iso\". For instance, how would the statement of soundness change?</p>\n</blockquote>\n<p>So you model everything up to iso, e.g. <code>‚ü¶A, B‚üß·∂ú</code> is an object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> with an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>‚âÖ</mo><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi>A</mi><msup><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo><mi>c</mi></msup><mo>√ó</mo><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚ü¶</mo><mi>B</mi><msup><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚üß</mo><mi>c</mi></msup></mrow><annotation encoding=\"application/x-tex\">X \\cong ‚ü¶A‚üß·∂ú \\times ‚ü¶B‚üß·∂ú</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚âÖ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0543em;vertical-align:-0.25em;\"></span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8043em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0543em;vertical-align:-0.25em;\"></span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8043em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span></span></span></span></span></span></span></span></span></span>, similarly for types. Substitution is then the same diagram as here, except that the endo-arrow is a (possibly non-refl) isomorphism, and the triangle only commutes up to iso<br>\n<a href=\"/user_uploads/3121/ScZWYTpl8sC9y-wjOuTb2YIg/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ScZWYTpl8sC9y-wjOuTb2YIg/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"475x313\" src=\"/user_uploads/thumbnail/3121/ScZWYTpl8sC9y-wjOuTb2YIg/image.png/840x560.webp\"></a></div>",
        "id": 528799116,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752565860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873607\">@Johannes Folttmann</span> is a bachelor student in Bonn that is currently formalizing toposes and (some) internal logic of a topos <a href=\"https://github.com/johannesfoltt/topos\">here</a> for his bachelor's thesis, in a fork of <span class=\"user-mention\" data-user-id=\"218940\">@Charlie Conneen</span>'s repository.</p>",
        "id": 528890310,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1752594138
    },
    {
        "content": "<p>Nice, this is pretty useful! Looking at it superficially, I do not think that he got to the logic part yet, but he's probably working on foundations.</p>\n<p>It also would be nice if we could eventually gather the results in one place with consistent naming conventions and some basic documentation. If I start playing with things on my own we would have yet another repository <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> My original aim was to do the different fragments of geometric logic, but the simply typed lambda calculus or even dependent versions (or other forms of HOL) would also be a 'nice-to-have'. However, one should be aware that this is a bit separate from the geometric logic topic. </p>\n<p>We would have to agree on some specific common aims though (and this should be clarified much more, if there actually is any interest in this).</p>\n<ul>\n<li>Are we interested in metaprogramming?</li>\n<li>Are we broadly collecting categorical facts that are useful (i.e. topos theory and similar facts) or should the focus be more on logic and semantics?</li>\n</ul>\n<p>There is also the question of whether any of this is relevant for mathlib, since <span class=\"user-mention\" data-user-id=\"873607\">@Johannes Folttmann</span> 's repo seems to claim that these things may go to mathlib at some point.</p>",
        "id": 528901259,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752597605
    },
    {
        "content": "<p>The conjunction is here: <a href=\"https://github.com/johannesfoltt/topos/blob/main/Topos/ClassifierMeet.lean\">https://github.com/johannesfoltt/topos/blob/main/Topos/ClassifierMeet.lean</a>, stated for both the subobject classifier and power objects (so there is also already machinery to translate between those two formulations). The other propositional connectives are forthcoming. (Higher-order) quantification is likely out of scope of his thesis project.</p>",
        "id": 528902023,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1752597855
    },
    {
        "content": "<p>Ah, makes sense. Is there any plan to define formulas with inductive types and interpret those?</p>",
        "id": 528902560,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752598042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528901259\">said</a>:</p>\n<blockquote>\n<p>...My original aim was to do the different fragments of geometric logic, but the simply typed lambda calculus or even dependent versions (or other forms of HOL) would also be a 'nice-to-have'.</p>\n</blockquote>\n<p>Would be nice if we could develop a very general notion of logic such that most logics can just be a subtype/class on the wffs of this. It would have to be at least some notion of linear multi-mode modal infinitary dependent type theory...</p>",
        "id": 529011359,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752656040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"402440\">Adrian Marti</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528902560\">said</a>:</p>\n<blockquote>\n<p>Ah, makes sense. Is there any plan to define formulas with inductive types and interpret those?</p>\n</blockquote>\n<p>Those plans existed at one point, but we had to limit the scope of the thesis to make it feasible. So there are no such plans anymore.</p>",
        "id": 529021401,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1752659625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/529011359\">said</a>:</p>\n<blockquote>\n<p>Would be nice if we could develop a very general notion of logic such that most logics can just be a subtype/class on the wffs of this. It would have to be at least some notion of linear multi-mode modal infinitary dependent type theory...</p>\n</blockquote>\n<p>I gave it some thought, and there are essentially 4 types of objects we are constructing.</p>\n<ul>\n<li><em>Sorts</em> (or types in type theory), these have constructors such as function types or cartesian products or even simple inductive types like coproducts. Semantics are the objects of a category.</li>\n<li><em>Terms</em> (or terms in context in type theory). These arise from composing (and possibly renaming by mapping <code>Fin n \\to Fin m</code>) different given function symbols. These produce arrows between objects in a category. Substructural logics like in monoidal categories may have more restrictive ways of constructing terms (maybe we can leave this aside in the beginning). A very nice example for terms is <span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> 's simple type theory interpretation.</li>\n<li><em>Formulas</em>. These do not arise in type theory, since we build formulas in <code>Prop</code>, as a special case of the previous two cases. They might have a wide variety of constructors, such as the ones found in FOL or even infinitary versions of conjunction and disjunction. These interpret to subobjects of objects in a category and different operations in the subobject lattice.</li>\n<li><em>Sequents</em>. These interpret to statements of inclusion in subobject lattices, they are mostly relevant for intuitionistic logic (I am not referring to the type-theoretical version of sequents here).</li>\n</ul>\n<p>Arguably, one could also add a fifth category, of <em>equations</em>, which take two terms and state that they are equal. They simply interpret to the fact that two arrows are equal in a category (this might be relevant when working in purely algebraic settings, where there might not always be subobjects to interpret the formula <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>=</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">t= s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>.).</p>\n<p>It would be nice to design a deduction systems that work in for these different logics. Some thought needs to be put into how one would handle deduction in algebraic logics with proof rules like cut, substitution, etc. in such a way that both type theory and the different fragments of geometric logic extend this. If one wants to add monoidal (instead of cartesian) variants of terms eventually in such a way that we have a hierarchy where formulas, proof rules and semantics get progressively extended, this might get more complex.</p>",
        "id": 529151748,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1752693122
    },
    {
        "content": "<p>Related to the above, I was hoping that the Flypitch authors (e.g. <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>) could comment on the set up of categorical logic, given their experience with FOL. In particular,</p>\n<ol>\n<li>Even for the FOL case, is there anything that you think could have been designed better? E.g., change the definition of language, (pre)terms, (pre)formulas, etc.</li>\n<li>Do you think the partially applied terms/formulas approach would be a good fit for categorical logic? Since it is multisorted the indexing type would have to be somewhat more complicated, and not just <code>‚Ñï</code>.</li>\n<li>Were there any approaches you tried and decided they were not good approaches?</li>\n</ol>",
        "id": 529224688,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1752739758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687698\">Chris Henson</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528607081\">said</a>: ...</p>\n<p>I haven't looked too carefully at what you're doing, but could this be resolved by having two separate judgment forms: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œî</mi><msub><mo>‚ä¢</mo><mi>s</mi></msub><mi>œÉ</mi><mo>:</mo><mi mathvariant=\"normal\">Œì</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta ‚ä¢_s œÉ : \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">Œî</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">‚ä¢</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">œÉ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Œì</span></span></span></span> for well-formed substitutions, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Œì</mi><mo>‚ä¢</mo><mi>t</mi><mo>:</mo><mi>œÑ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma ‚ä¢ t : œÑ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Œì</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚ä¢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span></span></span></span> for well-typed terms? Then the former can be interpreted into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œî</mi><msub><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo><mrow><mi>C</mi><mi>t</mi><mi>x</mi></mrow></msub><mo separator=\"true\">,</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><msub><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo><mrow><mi>C</mi><mi>t</mi><mi>x</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C(‚ü¶\\Delta‚üß_{Ctx}, ‚ü¶\\Gamma‚üß_{Ctx})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mopen\">(</span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œî</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Ct</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Ct</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, the latter into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mo stretchy=\"false\">(</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi mathvariant=\"normal\">Œì</mi><msub><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo><mrow><mi>C</mi><mi>t</mi><mi>x</mi></mrow></msub><mo separator=\"true\">,</mo><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚ü¶</mo><mi>œÑ</mi><msub><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">‚üß</mo><mrow><mi>T</mi><mi>y</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal C(‚ü¶\\Gamma‚üß_{Ctx}, ‚ü¶œÑ‚üß_{Ty})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mopen\">(</span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord\">Œì</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Ct</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\"><span class=\"mopen\">[</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mopen\">[</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">œÑ</span><span class=\"mclose\"><span class=\"mclose\"><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:-0.1778em;\"></span><span class=\"mclose\">]</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and you don't need the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi mathvariant=\"normal\">Œì</mi><mo stretchy=\"true\">^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\widehat \\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9233em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9233em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">Œì</span></span><span class=\"svg-align\" style=\"top:-3.6833em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span style=\"height:0.24em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"0.24em\" viewBox=\"0 0 1062 239\" preserveAspectRatio=\"none\"><path d=\"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\"/></svg></span></span></span></span></span></span></span></span></span> operation.</p>",
        "id": 529709138,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1753040572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/528705749\">said</a>:</p>\n<blockquote>\n<p>I've been told that <span class=\"user-mention silent\" data-user-id=\"128280\">ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí</span>  Is working on this kind of metaprograming applications, though I don't know the specifics. (This also seem like a good opportunity to find out)</p>\n</blockquote>\n<p>My personal belief is that if you want to use the internal language of any category in practice, you pretty much need a proof assistant for it; nobody wants to write down deeply embedded proof terms by hand. So we've been implementing that in the <a href=\"http://github.com/sinhp/groupoid_model_in_lean4/\">groupoid project</a> (see also our <a href=\"https://www.youtube.com/watch?v=Vwx_933aE_0\">TYPES talk</a> by <span class=\"user-mention\" data-user-id=\"133584\">@joseph hua</span>). In our case the internal language is intentionally designed to be a dependent type theory very close to Lean so that the proof assistant can just be Lean. We then use some metaprogramming magic to translate the outputs of Lean elaboration into objects in the model (the model is a natural model/CwF). This is all WIP.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Vwx_933aE_0\" href=\"https://www.youtube.com/watch?v=Vwx_933aE_0\"><img src=\"https://uploads.zulipusercontent.net/c2815f44c8915204648e71c5d6b978cd82262701/68747470733a2f2f692e7974696d672e636f6d2f76692f5677785f39333361455f302f6d7164656661756c742e6a7067\"></a></div>",
        "id": 529709648,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1753041326
    },
    {
        "content": "<p>The separate judgement should work. I have some interest in how things play out if you aren't able to alter your syntax or judgements, say someone hands you an already complete formalization, this is what I was describing. </p>\n<p>Yes, I listened to the talk and took a look at the repo, it looks really interesting! Especially in having a very \"concrete\" syntax to implement a proof mode. I noticed you mention Autosubst and thought that was interesting. I have been playing around with the idea of some Lean metaprogramming inspired by their MetaCoq implementation to generate locally nameless syntaxes.</p>",
        "id": 529710321,
        "sender_full_name": "Chris Henson",
        "timestamp": 1753042235
    },
    {
        "content": "<p>This is a really cool project! I've long had in the back of my mind that this (or at least similar things) should be done. There are so many uses for it. Here are some thoughts.</p>\n<ul>\n<li>Having the structural identity principle internally enables us to (at least in theory) rewrite along isomorphic structures, which is something that is really cool to see. Especially because (from what I've seen) it can be annoying to transfer properties along isomorphic structures in Lean. Also, we can synthetically reason, not only about structures, but about collections (groupoids) of structures in an isolated (synthetic) environment.</li>\n<li>I especially look forward to interpretations in general presheaf toposes or even sheaf toposes (or their (2,1)-variations). In this way, we can use classifying topos constructions to model type theories that may contain additional, <em>axiomatically introduced</em>, structures, such as a type theory that additionally contains a generic type that is a group (or a ring). In this way, we can prove generic statements about structures.</li>\n<li>Given a logical geometric morphisms we should be able to transfer statements across different settings. If your geometric morphism doesn't happen to be logical, no worries. The dependent type theory conservatively extends the fragment of the logic that is geometric (doesn't contain pi-types, sigma-types should be allowed, at least I think). This means that we can use the power of the embedded proof assistant to prove a geometric statement and then transfer it along a geometric morphism to a different setting (As in Olivia Caramello's ideas).</li>\n<li>You could use this to prove that there are (2,1)-stacks classifying certain classes of objects (as you would like to do in some areas of mathematics) by providing logical formulas for them in the appropriate (classifying) topos(keep in mind that the any representability statements for those stacks are not free, if you really want those).</li>\n</ul>\n<p>I realize that probably not all the machinery for this is in place (interpretations in (2,1)-stacks?), but this definitely brings us one good step closer to it. I apologize for writing a lot about ideas, a not so much about concrete mathematics/formalization. I'm just glad that there is work in this direction.</p>",
        "id": 529961317,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1753129997
    },
    {
        "content": "<p>Related to the original question: Did anyone do operads/multicategories?</p>",
        "id": 543159072,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1759667301
    },
    {
        "content": "<p>To be sure, are you aware of the HoTT Lean project? It formalizes the semantics of HoTT in Lean.<br>\n<span class=\"user-mention\" data-user-id=\"420917\">@Sina Hazratpour</span> is involved and is an expert on geometric logic.</p>",
        "id": 543300407,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1759753792
    },
    {
        "content": "<p>There's also recent work by Ulrik Buchholz on geometric type theory, unfortunately google is currently not very helpful finding it... (I believe it was in the TYPES proceedings)</p>",
        "id": 543301543,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1759754077
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776892\">@Yiming Xu</span> <span class=\"user-mention\" data-user-id=\"261023\">@Kyod</span> thanks for the nice abstract! This is cool. Are you aware of Steve Vickers' work on Geometric type theory? It may be more convenient for formalization. <a href=\"https://sjvickers.github.io/LocTopSpaces.pdf\">https://sjvickers.github.io/LocTopSpaces.pdf</a></p>\n<p>Your work is also reminiscent of the line of work on universal algebra in type theory.</p>",
        "id": 543303048,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1759754451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/543301543\">said</a>:</p>\n<blockquote>\n<p>There's also recent work by Ulrik Buchholz on geometric type theory, unfortunately google is currently not very helpful finding it... (I believe it was in the TYPES proceedings)</p>\n</blockquote>\n<p>There's an early abstract from the HoTT/UF 2025 workshop: <a href=\"https://hott-uf.github.io/2025/abstracts/HoTTUF_2025_paper_25.pdf\">https://hott-uf.github.io/2025/abstracts/HoTTUF_2025_paper_25.pdf</a></p>",
        "id": 543303106,
        "sender_full_name": "Tom de Jong",
        "timestamp": 1759754464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926793\">@Tom de Jong</span> better than Google <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span></p>",
        "id": 543303217,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1759754492
    },
    {
        "content": "<p>See also this recent talk at a CIRM conference by Ulrik: <a href=\"https://library.cirm-math.fr/Record.htm?idlist=1&amp;record=19394786124911129689\">https://library.cirm-math.fr/Record.htm?idlist=1&amp;record=19394786124911129689</a></p>",
        "id": 543303420,
        "sender_full_name": "Tom de Jong",
        "timestamp": 1759754552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/543300407\">said</a>:</p>\n<blockquote>\n<p>To be sure, are you aware of the HoTT Lean project? It formalizes the semantics of HoTT in Lean.<br>\n<span class=\"user-mention silent\" data-user-id=\"420917\">Sina Hazratpour</span> is involved and is an expert on geometric logic.</p>\n</blockquote>\n<p>I am also a collaborator in HoTTLean :-) . On the theory of implementing syntax + a sound semantics and use that to do something useful, <span class=\"user-mention\" data-user-id=\"128280\">@ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí</span> is an expert on that.</p>",
        "id": 543351504,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1759765083
    },
    {
        "content": "<p>Our HoTTLean is formalizing Martin-L√∂f theories, and it is more ambitious in the sense that we want a dual-mode theorem prover. And we should be able to give definitions in the level of the particular model, not only from the syntax, as well.</p>",
        "id": 543352271,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1759765246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/116395-maths/topic/Categorical.20logic.20in.20Lean.3F.20.28algebraic.20theories.2C.20etc.2E.29/near/543303048\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776892\">Yiming Xu</span> <span class=\"user-mention silent\" data-user-id=\"261023\">Kyod</span> thanks for the nice abstract! This is cool. Are you aware of Steve Vickers' work on Geometric type theory? It may be more convenient for formalization. <a href=\"https://sjvickers.github.io/LocTopSpaces.pdf\">https://sjvickers.github.io/LocTopSpaces.pdf</a></p>\n<p>Your work is also reminiscent of the line of work on universal algebra in type theory.</p>\n</blockquote>\n<p>Thank you for the link! I am very interested in work by Steve Vickers in general because I think his writting involve a strong intention of treating the geometric intuition. I will read it in more details.</p>",
        "id": 543353117,
        "sender_full_name": "Yiming Xu",
        "timestamp": 1759765427
    },
    {
        "content": "<p>In response to a <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561915781\">related discussion</a>, I can share an update on our progress.</p>\n<p>HoTTLean now contains a module called SynthLean (for 'synthetic mathematics in Lean') which interprets terms in (a very stripped down fragment of) Lean's type theory in any model belonging to an abstract class of category-theoretic models (<em>natural models</em>; these carry the same data as <em>categories with families</em>). We are going to present this at <a href=\"https://popl26.sigplan.org/details/CPP-2026-papers/4/A-Certifying-Proof-Assistant-for-Synthetic-Mathematics-in-Lean\">CPP 2026</a> in January, and you can read the preprint <a href=\"https://voidma.in/assets/papers/2025nawrocki_certifying_proof_assistant_synthetic_mathematics_lean.pdf\">here</a>. This is an early prototype and our next step is to actually make constructions in specific models using this technology, but feel free to try out <a href=\"https://github.com/sinhp/HoTTLean/tree/1b5abb33f040f47c44fd172230063969b0d638b5/test\">some of our demos</a>. Importantly, SynthLean gives you all the usual proof assistant tooling so that internal language arguments can be developed using standard (constructive unless your model happens to validate a lot of axioms!) tactics.</p>\n<p>CC <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 562049115,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1764924968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561924413\">said</a>:</p>\n<blockquote>\n<p>how to translate Lean's structure defeqs into being explicit rewrites</p>\n</blockquote>\n<p>If I understand you correctly, this is the \"strictness problem\" for categorical interpretations of type theory, and the modern solution is to axiomatize a class of categorical models in which we know how to interpret all the type-theoretic constructs s.t. it is always the case that defeqs are semantically validated, e.g. ‚ü¶(Œªx. b) t‚üß = ‚ü¶b[t]‚üß for Œ≤-reduction. The tradeoff is whether the class of models is closer to the syntax, so that interpreting syntax in any model is trivial, but constructing actual models is harder, or further away from the syntax so that it takes more work to show that all the type-theoretic defeqs hold, but maybe it's easier to assemble a model from mathematical objects. The first page of \"Type Theory in Type Theory using a Strictified Syntax\" has a nice depiction of the various choices along this spectrum.</p>",
        "id": 562050849,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1764925437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561924413\">said</a>:</p>\n<blockquote>\n<p>can we automatically derive equalities in the category which correspond to this theorem?</p>\n</blockquote>\n<p>I implemented this <a href=\"https://github.com/sinhp/HoTTLean/pull/168/commits/3f32fabd47d143839545ba3d2dd812beeb359f52\">here</a>. The main components are</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aux1</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">myPi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myPair</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">aux2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Here the <code>empty</code> stands for 'empty theory': we are doing this in MLTT with no additional axioms. <code>aux2</code> has some spurious arguments in order to make the two sides have equal contexts; otherwise it doesn't make sense to ask whether they're equal. Then we do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">emptyInterp</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">interpTm</span><span class=\"w\"> </span><span class=\"n\">aux1</span><span class=\"bp\">.</span><span class=\"n\">wf_val</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">emptyInterp</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">interpTm</span><span class=\"w\"> </span><span class=\"n\">aux2</span><span class=\"bp\">.</span><span class=\"n\">wf_val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">interpTm_eq</span><span class=\"w\"> </span><span class=\"c1\">-- Reduce to internal judgmental equality</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- Run the typechecker</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">TypecheckerM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">equateWfTms</span>\n<span class=\"w\">      </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Axioms</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">([])</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">aux1</span><span class=\"bp\">.</span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">aux1</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">aux2</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">aux1</span><span class=\"bp\">.</span><span class=\"n\">tp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">closeMainGoal</span><span class=\"w\"> </span><span class=\"ss\">`equateTms</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"n\">TpEnvEqCtx</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">aux1</span><span class=\"bp\">.</span><span class=\"n\">wf_val</span><span class=\"w\"> </span><span class=\"n\">aux2</span><span class=\"bp\">.</span><span class=\"n\">wf_val</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note that this targets models-of-MLTT rather than CCCs.</p>",
        "id": 562103908,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1764942357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/113488-general/topic/Lean4Less.20discussion.20thread/near/561926569\">said</a>:</p>\n<blockquote>\n<p>ideally we should be able to interpret in any category with enough structure, so eg convert the natural number game automatically into a topos with NNO, and convert any fully polymorphic constructive proof in mathlib into a topos, and convert any proof in mathlib into a category satisfying ETCS.</p>\n</blockquote>\n<p>This is indeed the folklore, but afaict turning this into actual Lean theorems/tactics would require making things quite a bit more precise. In the context of SynthLean, one would have to construct a natural model (or something related that we are now calling an <code>UnstructuredModel</code>) out of a given \"nice\" category (a topos). This requires constructing a \"universe\", which is a \"universal type-in-context\"; all types-in-context (of a given size) that we care about should arise as pullbacks of this. There is a note of Streicher on \"Universes in Toposes\", various constructions in LCCCs, as well as some constructions specific to Grothendieck toposes (e.g. \"Strict universes for Grothendieck topoi\").</p>",
        "id": 562106936,
        "sender_full_name": "ùö†ùöòùöìùöåùöíùöéùöåùöë ùöóùöäùö†ùöõùöòùöåùöîùöí",
        "timestamp": 1764943239
    }
]