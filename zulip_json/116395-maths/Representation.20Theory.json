[
    {
        "content": "<p>Hello, That good <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>\n<p>But for me the big step is really to make the application over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> ! </p>\n<p>For example, the decomposition of a representation in irreducible representation.</p>\n<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>",
        "id": 198297535,
        "sender_full_name": "orlando",
        "timestamp": 1590049880
    },
    {
        "content": "<p>Could we move this thread to the math stream?</p>",
        "id": 198307212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590057748
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Representation.20Theory\">#new members &gt; Representation Theory</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>",
        "id": 198341355,
        "sender_full_name": "Notification Bot",
        "timestamp": 1590077920
    },
    {
        "content": "<p>Thanks Mario.</p>",
        "id": 198346016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590079921
    },
    {
        "content": "<p>I am very new to Lean (Ive checked it in the past many years ago but I had deemed it to unwieldy to get started). I am just curious why the PR for Maschke's Thm don't define the notion of semisimplicity, and just state that k[G] is semisimple, which I think would be how most people would think Maschke's Thm actually looks like. (It unpacks the notion of semisimplicity into the notion of every submodule has a complementary subspace, which I think its equivalent?, though I only work with algebra over (commutative unital) rings, so I don't know the subtleties.)</p>",
        "id": 198419189,
        "sender_full_name": "Syx Pek",
        "timestamp": 1590137645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128818\">@Syx Pek</span> Welcome! The reason is only that the definitions are not there yet. This PR does all the \"real work\", and we can easily repackage it in a follow-up PR. I agree that this should be done. We cannot claim that it's completely done yet (-;</p>",
        "id": 198421905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590139787
    },
    {
        "content": "<p>In particular, the design decisions around \"which definition of semisimplicity should we use\" are probably harder than the actual calculation I did in that PR.</p>",
        "id": 198422199,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139975
    },
    {
        "content": "<p>There are a lot of ways to talk about semisimplicity!</p>",
        "id": 198422220,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139992
    },
    {
        "content": "<p>Yes, I think the issue will be that nobody has defined semisimple algebras yet. I wonder if this is one of those situations where mathematicians are quite happy with several definitions of the same thing but computer scientists can't have this. Is the definition of a semisimple algebra something like \"finite sum of simple algebras\" or \"its representation theory is semisimple\"? There are theorems to be proved here and nobody has got round to it yet</p>",
        "id": 198422229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590139999
    },
    {
        "content": "<p>Yeah what Scott said</p>",
        "id": 198422268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140026
    },
    {
        "content": "<p>They won't be hard</p>",
        "id": 198422340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140044
    },
    {
        "content": "<p>It's just that we are understaffed right now because the universities aren't teaching this stuff</p>",
        "id": 198422381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140083
    },
    {
        "content": "<p>Hello,</p>\n<p>I'm an incoming freshman student in California, USA, interested in mathematics and computer science. In particular, I'm interested in developing the representation theory library in mathlib. I'm looking for guidance, perhaps in the form of a summer internship, or someone who would be willing to oversee me in a project in representation theory. </p>\n<p>I was wondering if anyone here could be looking for interns or knew of such opportunities.</p>\n<p>I have experience contributing elementary results to mathlib. I'm comfortable with basic concepts in type theory, abstract algebra, and category theory. I'm not knowledgable in the fine details of representation theory, so there would be some inertia for me to contribute mathlib-level material--I would essentially be learning as I go. I know there's already a significant amount of un-PR'ed code spread out everywhere; I'm fine doing code transfer, but would prefer if I could prove something new. </p>\n<p>I'm excited to learn, and I would be happy to talk about this in more detail. Thanks for reading!</p>",
        "id": 231378582,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616444548
    },
    {
        "content": "<p>There's a ton of basic representation theory which is do-able but not done yet. You'd be welcome to join my group of students who will be meeting on Tuesdays throughout July and August.</p>",
        "id": 231378705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616444613
    },
    {
        "content": "<p>As a suggestion for source material: I like <a href=\"https://www-math.mit.edu/~etingof/repb.pdf\">Pavel Etingof's notes</a> (it's an AMS book, but also freely available from his webpage), which I think should be pretty readily formalisable.</p>",
        "id": 231389370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449390
    },
    {
        "content": "<p>I would love to see more rep th too. I did a little (the core fact of Maschke's theorem is at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.is_semisimple_module/src\">src#monoid_algebra.is_semisimple_module</a>), but it didn't seem like there were others wanting to work on it in the near future, so paused again.</p>",
        "id": 231389657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449534
    },
    {
        "content": "<p>It would be wonderful to see the proof that the character table of a finite group is square.</p>",
        "id": 231390356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616449858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thank you for the response! I would love to join your group over the summer--could I DM you on Zulip or Discord to talk about more details?</p>",
        "id": 231409432,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616462458
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_semisimple_module\">docs#is_semisimple_module</a> now. I think I see two directions from here:</p>",
        "id": 231418262,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470934
    },
    {
        "content": "<ul>\n<li>Continuing on the abstract algebra of semisimplicity towards Artin-Wedderburn (maybe the Jacobson Density Theorem first)?</li>\n</ul>",
        "id": 231418287,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470982
    },
    {
        "content": "<ul>\n<li>Defining the setoid of conjugacy (if it isn't already lurking somewhere) and its quotient, the type of conjugacy classes of a group/monoid. From there, it's probably not such a long road to the basics of character theory.</li>\n</ul>",
        "id": 231418396,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616471109
    },
    {
        "content": "<p>I'd be happy to contribute at some point especially if someone wants to collaborate towards the first bullet point. A tricky point for the second bullet point is potentially to determine the correct set of assumptions on the ground field (because presumably one doesn't want to just work over the complex numbers).</p>",
        "id": 231433809,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1616486705
    },
    {
        "content": "<p>The work I did on Mashke only assumes the characteristic doesn't divide the order of the field.</p>",
        "id": 231437287,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616488842
    },
    {
        "content": "<p>Speaking of that, I feel like eventually whole files will assume that the characteristic doesn’t divide the order of the group, so we probably want to make that a <code>fact</code> instance</p>",
        "id": 231496296,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616515484
    },
    {
        "content": "<p>Hi. I'm trying to go through the code in <a href=\"https://github.com/leanprover-community/mathlib/tree/representation\">branch#representation</a> and make it work with the current version of lean again. I've run into this universe problem which I don't really understand. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n<span class=\"c1\">-- universe levels don't match</span>\n</code></pre></div>\n<p>Clicking on each thing in the viewer window tells me that <code>restrict_scalars</code> is a function <code>Type u_1 → Type u_2 → Type u_3 → Type u_3</code>. So I think the problem has to do with the final <code>u_3</code> not matching with the universe of <code>module k M</code>, but how do I fix this?<br>\n(cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> because this is basically a copy of his code.)</p>",
        "id": 231906728,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726596
    },
    {
        "content": "<p>Oh dear, that branch is very old. :-) I wouldn't believe it's a good idea...</p>",
        "id": 231906790,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616726654
    },
    {
        "content": "<p>Oh. What's wrong with this branch? I only needed to make minor changes up to this point, and everything seemed to work pretty well.</p>",
        "id": 231906852,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726757
    },
    {
        "content": "<p>I'll have a look. Do you want to push what you have?</p>",
        "id": 231909047,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728750
    },
    {
        "content": "<p>From memory there was still significant uncertainty about how best to represent the simultaneous actions of k and G. There are potentially 3 different <code>has_smul</code> instances available: <code>k</code>, <code>G</code> and <code>monoid_algebra k G</code>.</p>",
        "id": 231909132,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728813
    },
    {
        "content": "<p>Does the existence of <code>smul_comm_class</code> help with that?</p>",
        "id": 231910802,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730413
    },
    {
        "content": "<p>Pushed here: <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a></p>",
        "id": 231911110,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730662
    },
    {
        "content": "<p>It doesn't look like that branch has any commits that aren't on master?</p>",
        "id": 231911231,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730780
    },
    {
        "content": "<p>Oops. It should be there now.</p>",
        "id": 231911428,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730910
    },
    {
        "content": "<p>This is pointed out in the docs for <code>restrict_scalars</code>, but how about using <code>module k M</code>, <code>module (monoid_algebra k G) M</code>, and <code>is_scalar_tower k (monoid_algebra k G) M</code>? Then there's a <code>smul_comm_class</code> from the tower instance. </p>\n<p>Is there anything that says if <code>A</code> is an <code>R</code>-algebra and <code>M</code> an <code>A</code>-monoid, then <code>is_scalar_tower R A M</code>?</p>",
        "id": 231912045,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616731422
    },
    {
        "content": "<p>(I think my last work on this predates <code>is_scalar_tower</code>, and I've not yet got my head around it yet...)</p>",
        "id": 231914243,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616733456
    },
    {
        "content": "<p>Yes, this probably should use both <code>is_scalar_tower</code> and <code>smul_comm_class</code></p>",
        "id": 231916578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616735773
    },
    {
        "content": "<p><code>is_scalar_tower R A M</code> requires a <code>has_scalar R M</code> instance to be used</p>",
        "id": 231932529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749204
    },
    {
        "content": "<p>So I guess your question is \"is there a pair of definitions that produce a <code>has_scalar R M</code> instance and a corresponding <code>is_scalar_tower R A M</code>?\"</p>",
        "id": 231932824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749356
    },
    {
        "content": "<p>If a group <code>G</code> acts on an abelian group <code>M</code> then this can also be viewed as a <code>k[G]</code>-module on <code>M</code>.</p>",
        "id": 231935234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750827
    },
    {
        "content": "<p>And <code>G</code> also acts on <code>k[G]</code></p>",
        "id": 231935252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750840
    },
    {
        "content": "<p>So we want <code>is_scalar_tower G (monoid_algebra k G) M</code></p>",
        "id": 231935272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750854
    },
    {
        "content": "<p>And also one for k and k[G] and M?</p>",
        "id": 231939071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616752896
    },
    {
        "content": "<p>I still don't understand the concrete problem statement, but the error originally was confusing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars\">docs#restrict_scalars</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.semimodule\">docs#restrict_scalars.semimodule</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"bp\">$</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231939945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753308
    },
    {
        "content": "<p>You also want a distrib mul action of G on M</p>",
        "id": 231940084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753383
    },
    {
        "content": "<p>This type of thing is IMO a bad idea though, and safer is to not unfold <code>restrict_scalars</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span>\n  <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 231940091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753387
    },
    {
        "content": "<p>Alternatively just make M a module for the monoid algebra and deduce the k module structure and the distrib mul action structure from that</p>",
        "id": 231940228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753438
    },
    {
        "content": "<p>I think that to talk about a representation in a flexible way, we might need 4 lines of <code>variables</code></p>",
        "id": 231940465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753564
    },
    {
        "content": "<p>To give commuting k and G actions on M is to give an action of the monoid algebra</p>",
        "id": 231940484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753576
    },
    {
        "content": "<p>Mathematicians pass freely between the two points of view</p>",
        "id": 231940528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753609
    },
    {
        "content": "<p>I think the <code>restrict_scalars</code>-free way to set this up is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753699
    },
    {
        "content": "<p>And probably an <code>is_smul_comm_class</code> for good measurer?</p>",
        "id": 231940729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753718
    },
    {
        "content": "<p>That's inferred from <code>is_scalar_tower</code> <del>I think?</del> via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower.to_smul_comm_class\">docs#is_scalar_tower.to_smul_comm_class</a></p>",
        "id": 231940753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753733
    },
    {
        "content": "<p>aah, right. So that should be fine</p>",
        "id": 231940928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753831
    },
    {
        "content": "<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>",
        "id": 231941042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753888
    },
    {
        "content": "<p>You just want to say: \"Let <code>M</code> be a <code>k</code>-linear <code>G</code>-module.\"</p>",
        "id": 231941106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753924
    },
    {
        "content": "<p>Wait, actually I think you can do that</p>",
        "id": 231942405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754553
    },
    {
        "content": "<p><del>Certainly the <code>module (monoid_algebra k G) M</code> instance is inferred already</del></p>",
        "id": 231942453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754580
    },
    {
        "content": "<p>(my orange bars conspired against me again)</p>",
        "id": 231942537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754604
    },
    {
        "content": "<p>Of course ideally we would abstract of <code>monoid_algebra k G</code>, and introduce a <code>k</code>-algebra <code>A</code> together with a predicate <code>is_monoid_algebra k G A</code>.</p>",
        "id": 231942708,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754694
    },
    {
        "content": "<p>Because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo><msub><mo>⊗</mo><mi>k</mi></msub><mi>R</mi><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G] \\otimes_k R = R[G]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>, but Lean will not believe that equality.</p>",
        "id": 231942811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754736
    },
    {
        "content": "<p>I think perhaps this instance should exist and is missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231942983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754829
    },
    {
        "content": "<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>",
        "id": 231943915,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755250
    },
    {
        "content": "<p>Maybe Eric's suggestion is better.</p>",
        "id": 231943934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755261
    },
    {
        "content": "<p>That's goes in the reverse direction to most of mathlib, so is likely to form loops</p>",
        "id": 231943976,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755276
    },
    {
        "content": "<p>In practice, I have a Galois group <code>G</code> that acts on a field <code>L</code> that is an extension of <code>K</code>, and maybe I now want to view <code>L</code> as a <code>K[G]</code>-module.</p>",
        "id": 231944044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755322
    },
    {
        "content": "<p>So I don't want to derive the action of the Galois group <code>G</code> on <code>L</code> from the <code>K[G]</code>-module on <code>L</code>.</p>",
        "id": 231944126,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755344
    },
    {
        "content": "<p>I assume the instance you want is something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">kG</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 231944939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231941042\">said</a>:</p>\n<blockquote>\n<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>\n</blockquote>\n<p>I think they hit that limit in analysis some time ago!</p>",
        "id": 231944942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616755801
    },
    {
        "content": "<p>I'm pretty sure there's a clever way to build a bundled hom in <code>smul</code> such that all the <code>sorry</code>s are as trivial as the first two proofs</p>",
        "id": 231945115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755868
    },
    {
        "content": "<p>This gets two more proofs for free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">≃+</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.comp</span>\n      <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.pi</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but needs <a href=\"https://github.com/leanprover-community/mathlib/issues/6891\">#6891</a> for the <code>g  •</code>, and a definition of <code>add_monoid_hom.pi</code> which appears to be missing.</p>",
        "id": 231949820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616758489
    },
    {
        "content": "<p>Hi, I went back to trying stuff out with this and I've written up a representation theory version of <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s Maschke's lemma. It's pushed to <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. I've also copy pasted a whole bunch of stuff from <code>submodule</code> to create API for a<code>subrepresentation</code> structure I defined. There's also a lattice isomorphism between subrepresentations and submodules of the induced monoid algebra. (The equivalence between the module/representation theoretic versions of Maschke is easy after that.)</p>\n<p>I'm not really looking to push any of this into mathlib yet, since I mostly followed my nose and copy pasted along. I could very possibly have done something terribly wrong without realizing it. So, I just wanted to ask here for thoughts and suggestions from everybody. Also, I'm willing to put a lot more effort into this, but I thought it'd be best to tell everyone here first.</p>\n<p>Anything is welcome! :)</p>",
        "id": 236115794,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619408283
    },
    {
        "content": "<p>Looks promising! Presumably we should tweak <code>maschke.lean</code> so that it uses <code>representation</code>, rather than <code>module (monoid_algebra _ _)</code>.</p>",
        "id": 236121930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414503
    },
    {
        "content": "<p>Do you see any obstacle to doing that?</p>",
        "id": 236121934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414510
    },
    {
        "content": "<p>I'm about to PR Schur's lemma in any linear category over an algebraically closed field. I really hope we can use that statement to directly infer the group theoretical statement of Schur's lemma. (And, similarly, the Lie-theoretic statement.)</p>",
        "id": 236122000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414558
    },
    {
        "content": "<p>(This is now up as <a href=\"https://github.com/leanprover-community/mathlib/issues/7366\">#7366</a>, but it has some dependent PRs so may take a little while.)</p>",
        "id": 236124815,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619417280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236121934\">said</a>:</p>\n<blockquote>\n<p>Do you see any obstacle to doing that?</p>\n</blockquote>\n<p>No, it should be pretty easy. I've started to phase the <code>monoid_algebra k G</code> out and so far the proofs look exactly the same.</p>",
        "id": 236286551,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502408
    },
    {
        "content": "<p>Since you're also working with this stuff, you can always tell me about possible conflicting work, or maybe possible converging work. I'm always happy to coordinate  :)</p>\n<p>(But I'm probably going into the finite groups, character theory direction -- I don't know much about category theory)</p>",
        "id": 236286699,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502568
    },
    {
        "content": "<p>I think character theory is a lovely direction, and I don't have anything in progress there.</p>",
        "id": 236287912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503689
    },
    {
        "content": "<p>I would like to make sure my recent general statement of Schur's lemma is actually usable in representation theory.</p>",
        "id": 236287955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503716
    },
    {
        "content": "<p>Ok. I don't really know what that connection should look like, but I can make sure to set up most of the concrete instances on the ground</p>",
        "id": 236289133,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619504791
    },
    {
        "content": "<p>Again this would be a really nice example showing that we can get theorems about concrete structures of interest from \"abstract nonsense\".</p>",
        "id": 236297404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619510301
    },
    {
        "content": "<p>I don't think Schur's lemma for linear categories exactly counts as abstract nonsense...</p>",
        "id": 236299032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619511322
    },
    {
        "content": "<p>By \"abstract nonsense\" I just mean \"any theorem about categories\"! We've already proved that categories are useful for mathematical definitions, because of schemes. The next step is to prove they're useful for theorems not in category theory and it looks like right now we have two great candidates for this (this and profinite stuff). Homological algebra will be a third.</p>",
        "id": 236312110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619518390
    },
    {
        "content": "<p>I'd love to start using the category theory stuff we have. I don't expect to get to this for some time but getting Schur's lemma for Lie modules as a dividend is just the motivation I need.</p>",
        "id": 236313520,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619519171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, I like that you're moving forward on actually defining <code>representation</code>s and <code>rep_hom</code>s, but of course I have opinions on which definition should be the basic definition.</p>",
        "id": 236365846,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539887
    },
    {
        "content": "<p>Personally, I'd choose the definition currently used in the library (a <code>module (monoid_algebra k G) V</code>), and I'm about to say why, but ultimately as long as that instance, the <code>smul_comm</code> instance, and the <code>to_monoid_hom/of_monoid_hom</code> structure are still there at the end of the day, I don't think it matters that much what the underlying definition is.</p>",
        "id": 236366039,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539957
    },
    {
        "content": "<p>I vote for <code>representation k G V</code> to be defined as an <code>abbreviation</code> of <code>module (monoid_algebra k G) V</code>, because then <code>subrepresentation</code> can be an abbreviation of <code>submodule (monoid_algebra k G) V</code> and <code>rep_hom</code> can be an abbreviation of <code>linear_map</code>, again over <code>monoid_algebra k G</code>.</p>",
        "id": 236366454,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540123
    },
    {
        "content": "<p>You have to define all of the extra structure on <code>representation, subrepresentation, rep_hom</code> one way or another, but this way you don't have to copy and paste all the basic API just to define them and get the basic instances on them.</p>",
        "id": 236366833,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540277
    },
    {
        "content": "<p>Ok. Actually I think I agree with sticking to <code>monoid_algebra k G</code>; it would prevent all the duplication I've been doing.</p>",
        "id": 236366955,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619540297
    },
    {
        "content": "<p>It is not the definition we give to undergraduates, but experience has shown us that the fewer definitions we have, the better.</p>",
        "id": 236367068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540346
    },
    {
        "content": "<p>If I had seen the \"burn <code>vector_space</code>\" PR I would have suggested that it lived on as an <code>abbreviation</code></p>",
        "id": 236367170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540397
    },
    {
        "content": "<p>If you abbreviate these things, and provide the <code>smul_comm</code> instances and so on, it should still be possible to work entirely with those other approaches (although even my undergrad class eventually switched to mostly using group-ring-modules...)</p>",
        "id": 236367383,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540466
    },
    {
        "content": "<p>As we move further into the library, it should also be possible to make <code>irreducible_representation</code> an abbreviation for <code>simple_module</code> and so on</p>",
        "id": 236367518,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540523
    },
    {
        "content": "<p>Yes, the way I was taught it was all G-actions on k-vector spaces and then suddenly this bombshell half way through that it's just R-modules for R=k[G] and about 3/4 of the lemmas we'd proved until that point were true in far greater generality</p>",
        "id": 236367562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540530
    },
    {
        "content": "<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>",
        "id": 236367787,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540643
    },
    {
        "content": "<p>It'd also be nice if there's a short-and-sweet notation that approximates the <code>ρ g</code> notation that you use when talking about the group homomorphism</p>",
        "id": 236368254,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540814
    },
    {
        "content": "<p>Perhaps as simple as <code>ρ k M g</code>...</p>",
        "id": 236368493,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236367787\">said</a>:</p>\n<blockquote>\n<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>\n</blockquote>\n<p>I think this is what I've done indirectly. <code>representation</code> extends <code>smul_comm_class</code> for the <code>G</code> and <code>k</code> actions. Then I derive a <code>module</code> instance. </p>\n<p>I could just cut out defining a <code>representation</code> and do this directly</p>",
        "id": 236368832,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541036
    },
    {
        "content": "<p>But I didn't seem to hit any problems with the type class inference after I defined the <code>module</code> instance; is there an explicit loop we should be worried about?</p>",
        "id": 236369236,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541193
    },
    {
        "content": "<p>Presumably you want to provide a <code>smul_comm_class</code> given a <code>module (monoid_algebra _ _)</code> AND vice versa, but only one can be an instance</p>",
        "id": 236371894,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619542253
    },
    {
        "content": "<p>Without having followed earlier conversation - the <code>of'</code> in <code>representation_theory/basic.lean</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>",
        "id": 236373177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619542812
    },
    {
        "content": "<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>",
        "id": 236373373,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619542877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373177\">said</a>:</p>\n<blockquote>\n<p>Without having followed earlier conversation - the <code>of'</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>\n</blockquote>\n<p>Oh oops, I missed this. But the name is so long...</p>",
        "id": 236373901,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543078
    },
    {
        "content": "<p>Well, you can always define <code>of' := monoid_algebra.single_one_ring_hom</code> and sort out the name later - but there's no need to prove it again!</p>",
        "id": 236373979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619543113
    },
    {
        "content": "<p>Yeah, that's going to be the first thing I do</p>",
        "id": 236374100,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373373\">said</a>:</p>\n<blockquote>\n<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>\n</blockquote>\n<p>If we define a representation as <code>module (monoid_algebra k G) M</code>, then whenever we want to use a representation, we'll assume <code>[representation k G M]</code> which will be equivalent to <code>[module (monoid_algebra k G) M]</code>. Once we're there, we'll sometimes want to refer directly to the <code>k</code>-action, and sometimes to the <code>G</code>-action, so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. We'll also want to know that those commute with each other and with the action of <code>monoid_algebra k G</code>, hence you'll want <code>smul_comm_class</code> and <code>is_scalar_tower</code> instances</p>",
        "id": 236377716,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619544738
    },
    {
        "content": "<blockquote>\n<p>so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. </p>\n</blockquote>\n<p>This doesn't make any sense, because you're not allowed to write <code>[representation k G M]</code> without writing <code>[module k M] [distrib_mul_action G M]</code> first</p>",
        "id": 236378169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544943
    },
    {
        "content": "<p>It's like saying you want an instance to go from <code>module k M</code> to <code>add_comm_monoid M</code></p>",
        "id": 236378228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544967
    },
    {
        "content": "<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>",
        "id": 236378299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545019
    },
    {
        "content": "<p>Ohh, I understand. I'm also realizing that all of this was basically said before in this thread, I just didn't get it before (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  even wrote down the <code>module</code> instance explicitly right above my first comment <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> )</p>",
        "id": 236378308,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545023
    },
    {
        "content": "<p>Oh, I hadn't realized this thread had older replies from me in it!</p>",
        "id": 236378451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236378299\">said</a>:</p>\n<blockquote>\n<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>\n</blockquote>\n<p>Yes, I've been suggesting that we define it as <code>module (monoid_algebra k G) M</code>, which means basically flipping everything <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span> ' been doing backwards...</p>",
        "id": 236378555,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619545163
    },
    {
        "content": "<p>That's perfectly fine with me btw -- actually less work in the long run because there's no duplication</p>",
        "id": 236378757,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545264
    },
    {
        "content": "<p>Based on the recent <code>vector_space</code> removal, I think that is a definition that belongs only in a docstring</p>",
        "id": 236379929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545729
    },
    {
        "content": "<p>Although I guess that argument applies to the definition in the branch too</p>",
        "id": 236380009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545760
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>\n</blockquote>",
        "id": 236380037,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545771
    },
    {
        "content": "<p>I think the usual way to handle this is add instances in the forwards direction (the branch), and type aliases like <code>restrict_scalars</code> in the backwards direction (that suggestion)</p>",
        "id": 236380234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545837
    },
    {
        "content": "<p>Ok. It seems like I will follow the main mathlib direction with this setup then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- a representation</span>\n</code></pre></div>\n<p>And we can go backwards with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module\">docs#restrict_scalars.module</a> and, err, hopefully <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.distrib_mul_action\">docs#restrict_scalars.distrib_mul_action</a></p>",
        "id": 236381558,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619546307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236380037\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I definitely mean this.</p>",
        "id": 236426228,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619566023
    },
    {
        "content": "<p>Looking at the branch, this instance worries me a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">has_group_scalar</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>because when <code>k = G</code> you end up with two <code>has_scalar G (monoid_algebra G G)</code> instances which have different actions.</p>",
        "id": 236488008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608148
    },
    {
        "content": "<p>Perhaps no one ever uses <code>monoid_algebra G G</code> so it doesn't really matter</p>",
        "id": 236488210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608271
    },
    {
        "content": "<p>You'll have things like <code>G = units k</code>. But <code>G = k</code> is unlikely, I think.</p>",
        "id": 236488328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619608334
    },
    {
        "content": "<p>I think I've seen <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\mathbb{Z}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">]</span></span></span></span> before, but this is the integers as an additive monoid.</p>",
        "id": 236489458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609012
    },
    {
        "content": "<p>To avoid the issue we could create a type alias and instead declare the action <code>has_scalar (foo G) (monoid_algebra k G)</code></p>",
        "id": 236489696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619609140
    },
    {
        "content": "<p>I think that in the additive setting, this is more likely to be a problem.</p>",
        "id": 236490390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609474
    },
    {
        "content": "<p>Are we trying to do representation theory of additive monoid/groups as well?</p>",
        "id": 236490426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609492
    },
    {
        "content": "<p>Otherwise Kevin's example would end up begin <code>monoid_algebra int (multiplicative int)</code> and there wouldn't be a problem anyway.</p>",
        "id": 236490505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609524
    },
    {
        "content": "<p>I am playing with <code>monoid_algebra</code> for the LTE, and I indeed suggest to avoid <code>add_monoid_algebra</code> if possible</p>",
        "id": 236490720,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609642
    },
    {
        "content": "<p>It really makes things confusing</p>",
        "id": 236490789,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609657
    },
    {
        "content": "<p>Is that a good reason to avoid it?</p>",
        "id": 236490830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609674
    },
    {
        "content": "<p>I tried to prove the Riemann hypothesis but it really got confusing</p>",
        "id": 236490918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609731
    },
    {
        "content": "<p>I mean, one can prove everything for <code>monoid_algebra</code>, and at the end translate the results for <code>add_monoid_algebra</code> using the fact that they are isomorphic</p>",
        "id": 236490955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609756
    },
    {
        "content": "<p>Yes, that's a fair point.</p>",
        "id": 236490999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609765
    },
    {
        "content": "<p>Or, if you have an additive group <code>A</code> that you want to do representation theory with, just apply the theory to <code>multiplicative A</code></p>",
        "id": 236491066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609813
    },
    {
        "content": "<p>Hi a third time,</p>\n<p>So I didn't do anything with representation theory for awhile, because I kind of sidetracked onto a project to prove the Artin-Wedderburn Theorem, which is finally coming along in <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. It took 1500 loc though, so knowing me it will probably be another while before I can clean it up fully. </p>\n<p>Just posting this out here in case anyone else is planning (or already! -- that would be awkward) working on this.</p>",
        "id": 239917151,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621736902
    },
    {
        "content": "<p>I was working toward this, but I PRed all the work I did manage. I’ll take a look at what you’ve done.</p>",
        "id": 239919422,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1621739748
    },
    {
        "content": "<p>What is the maths-statement of the version of Artin-Wedderburn you're aiming at?</p>",
        "id": 239921043,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621741926
    },
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a semi-simple ring. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes as a direct sum of simple modules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>⨁</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bigoplus_{i = 1}^k n_i S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and there is an ring isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span>. Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">M</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal M_{n} (-)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> is the ring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices. Actually we want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mtext>op</mtext></msup><mo>≃</mo><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R^\\text{op} \\simeq \\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> but I haven't thought too hard about how the <code>op</code>'s go yet.</p>\n<p>The tricky part was to figure out how to write the sum properly. Because letting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> range from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1, \\dots, k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> really means something like going through the isomorphism classes of the set of simple submodules that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes into. Furthermore, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> quantifies the number of submodules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">S&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>≃</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S&#x27; \\simeq S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is the size of each isomorphism class containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<p>In <code>direct_sum_stuff.lean</code>, <code>isomorphism_quot R R</code> is the quotient of <code>decomposition R R</code> by an isomorphism relation. Then for any <code>i : isomorphism_quot R R</code>, we define <code>quotient.class i</code> as the class of <code>i</code>'s representative. So <code>isomorphism_quot R R</code> is supposed to be <code>1,...,k</code> and <code>quotient.class i</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span> looks like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">something</span> <span class=\"o\">[</span><span class=\"n\">is_semisimple_module</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">isomorphism_quot</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n    <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">i.out</span><span class=\"o\">))</span> <span class=\"bp\">≃+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 239922346,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621743587
    },
    {
        "content": "<p>Hopefully this looks correct and understandable. (and sane?) I would be very happy to take any suggestions and/or talk about my code!</p>",
        "id": 239922692,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Thanks in advance! Sorry everything is in the wrong place right now. I will be organizing code, files, and docstrings in the next few days so it should be much clearer then</p>",
        "id": 239922994,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744352
    },
    {
        "content": "<p>Oh and it shouldn't be too hard to go from the above and prove the version where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is also an algebra over some field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.</p>",
        "id": 239923135,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744468
    },
    {
        "content": "<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>",
        "id": 239929435,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752160
    },
    {
        "content": "<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>",
        "id": 239929499,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752250
    },
    {
        "content": "<p>I think an important part of Artin-Wedderburn is that this decomposition is unique up to relabelling.</p>",
        "id": 239929519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752294
    },
    {
        "content": "<p>I had been proving this on a branch a while ago --- the version I wanted was that if you had a collection of objects so that homs between them were either zero or isomorphisms (e.g. the set of all simple objects), then decompositions into direct sums of these objects were unique (before we even come to the question of existence).</p>",
        "id": 239929606,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929435\">said</a>:</p>\n<blockquote>\n<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>\n</blockquote>\n<p>Yes, I'm just using the definition.</p>",
        "id": 239982586,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621808945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929499\">said</a>:</p>\n<blockquote>\n<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>\n</blockquote>\n<p>As for the second part, I think I agree that the two parts are really separate things. I'm very out of depth on your first sentence though. What more general objects are you talking about when you say \"nothing to do with rings and modules\"?</p>",
        "id": 239982885,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809250
    },
    {
        "content": "<p>To be honest I wasn't even thinking about the unique part but now I'm realizing that it should also be a part of the proof. It shouldn't be too hard to prove from my approach just working concretely with the modules. May I ask how you've been approaching it? I guess which way do you think is more important?</p>",
        "id": 239983496,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809977
    },
    {
        "content": "<p>So we have the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.simple/src\">src#category_theory.simple</a>, which hopefully is enough to do the endomorphism ring calculation.</p>",
        "id": 239989405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816430
    },
    {
        "content": "<p>Say you have a collection of objects <code>X i</code> in a preadditive category such that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>. Then if you have a direct sum of these objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo>⨁</mo><msub><mi>n</mi><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A = \\bigoplus n_i X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (quite how to state that hypothesis is actually the trickiest thing here), then it should be easy to provide the ring isomorphism from <code>End A</code> to the direct sum of matrices over the <code>End (X i)</code>.</p>",
        "id": 239989732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816777
    },
    {
        "content": "<p>Then the next step is to assume something a little stronger: every nonzero morphism <code>X i ⟶ X i</code> is an isomorphism (e.g. this holds if you take <code>X i</code> to be the collection of simples). (I don't think we even need Schur's lemma yet, which says that if the category is linear over an algebraically closed field then every morphisms <code>X i ⟶ X i</code> is actually a multiple of the identity.)</p>\n<p>Now you can prove inductively, by a \"Gaussian elimination\" type argument, that if you have <span class=\"tex-error\">$$\\bigoplus n_i X_i \\iso \\bigoplus m_i X_i$$</span> then in fact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i = m_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 239989939,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816952
    },
    {
        "content": "<p>I should say I haven't actually done this. I made one aborted attempt that was unnecessarily complicated, but I would like to do this at some point.</p>",
        "id": 239989975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817001
    },
    {
        "content": "<p>A final thing that would be nice to prove: </p>\n<p>Let's give a name to the two above conditions on a collection of <code>X i</code> (that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>, and any nonzero endomorphism of an <code>X i</code> is invertible), \"<code>X</code> are mutually simple\". (Notice that the <code>X</code> aren't necessarily simple in this definition!)</p>\n<p>Then you can prove that if every object <code>Z</code> is isomorphic to some direct sum of the <code>X i</code> (in fact, in a unique way by the claim above), in fact the category is semisimple, and the <code>X i</code> are a set of representatives of the isomorphism classes of simples.</p>\n<p>This approach is useful for example in quantum topology: e.g. typically any \"diagrammatic algebra\", like the Temperley-Lieb algebra underlying the Jones polynomial, is awkward to prove semisimplicity \"via algebra\", and the best approach is to produce this family of mutually simple objects first, then conclude afterwards the category is semisimple. In the quantum topology literature this approach sometimes goes by the name \"Müger semisimplicity\", as he explained how to use it.</p>",
        "id": 239990403,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817452
    },
    {
        "content": "<p>In the literature \"mutually simple\" is called a \"semibrick\". There is a related condition of a \"simple-minded collection\" in a triangulated category.</p>",
        "id": 240006782,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621832959
    },
    {
        "content": "<p>Oh, interesting, where do people use \"semibrick\"? I hadn't heard that one.</p>",
        "id": 240013032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621839170
    },
    {
        "content": "<p>In representation theory of finite dimensional algebras, most recently in a generalisation of the classical theory of tilting modules called tau-tilting theory, see e.g. <a href=\"https://arxiv.org/abs/1610.05860\">https://arxiv.org/abs/1610.05860</a></p>",
        "id": 240014896,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621840675
    },
    {
        "content": "<p>Here's a first cut at proving that morphisms between direct sums of hom-orthogonal objects can be decomposed into direct sums of matrix blocks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.biproducts</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.eq_zero</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">o</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subsingleton.elim</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finite_biproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.matrix_decomposition</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"bp\">≫</span>\n      <span class=\"n\">biproduct.components</span> <span class=\"n\">z</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">biproduct.matrix</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">k</span> <span class=\"k\">then</span>\n      <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"n\">biproduct.lift_π</span><span class=\"o\">,</span> <span class=\"n\">biproduct.ι_matrix</span><span class=\"o\">],</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">o.eq_zero</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">w.symm</span><span class=\"o\">],</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- TODO additive version? linear version?</span>\n</code></pre></div>",
        "id": 240309657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028589
    },
    {
        "content": "<p>unique decomposition in a semibrick (a <code>hom_orthogonal</code> family where each object's nonzero endomorphisms are invertible) is going to be a little bit more involved, but I'll try it soon.</p>",
        "id": 240309823,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all your replies! Since you're planning to work on this, I don't think my approach really makes sense anymore. Especially because mine seems to be strictly less general. Would you mind though if I tried to redo some of my work following your thoughts on the category theoretic version? To be clear I would like to try as more of a learning project rather than a <code>for mathlib</code> project, in case you don't want interference.</p>",
        "id": 240422417,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093831
    },
    {
        "content": "<p>Although a side effect may be that I start asking a lot of random category theory questions here.</p>",
        "id": 240422426,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093849
    },
    {
        "content": "<p>Oops, sorry, I don't mean to stop you doing anything. I've been thinking about doing this for a while but haven't actually done it, so I don't want to discourage you!</p>",
        "id": 240422498,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622093910
    },
    {
        "content": "<p>I just didn't want to wait until you had a PR to make suggestions about how to decouple AW into smaller pieces. :-)</p>",
        "id": 240422583,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094031
    },
    {
        "content": "<p>One possibility would be to clean up what I posted above and get that ready for a PR. There are obvious next steps: show the equivalence I constructed is compatible with the obvious compositions on both sides, and then deduce the ring isomorphism for an endomorphism.</p>",
        "id": 240422632,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094116
    },
    {
        "content": "<p>Would you be interested in doing that?</p>",
        "id": 240422680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094159
    },
    {
        "content": "<p>Ah, my bad for misunderstanding. I kind of read too much into what you said lol</p>",
        "id": 240422685,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094183
    },
    {
        "content": "<p>You've seen all the work I've done so far! :-)</p>",
        "id": 240422699,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094204
    },
    {
        "content": "<p>Now I'm thinking I should definitely get my original code PR out so people can actually see what I'm trying to put into mathlib</p>",
        "id": 240422707,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094227
    },
    {
        "content": "<p>I would be very interested in doing a general version of Artin-Wedderburn as a follow up!</p>",
        "id": 240422765,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094287
    },
    {
        "content": "<p>Yes -- it's also no problem I think if first versions of things in mathlib are not in maximal generality. If someone upgrades your content later with something more general, you shouldn't feel sad about it, but happy that you provoked someone into doing work. :-)</p>",
        "id": 240422772,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094304
    },
    {
        "content": "<p>I think I just have a bad habit of writing too much code without PRing any of it. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Time too clean up all of my code...</p>",
        "id": 240422876,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094424
    },
    {
        "content": "<p>I mentioned in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> wanting to add more representation theory to mathlib. While I only learned it from Fulton &amp; Harris, <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> suggested Etingof. Just starting a thread here to gather some opinions and advice.</p>",
        "id": 241665540,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622943398
    },
    {
        "content": "<p>Others have certainly been thinking about this recently: e.g. <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, myself (very slowly, sorry). I'm looking forward to more representation theory!</p>\n<p>I'm actually doing a bunch of low-level work at the moment, generalising a lot of our code about dimensions and bases to arbitrary noetherian and/or commutative rings (where previously it was just done over a field). I'm hoping this will be useful in representation theory per se soon.</p>",
        "id": 241665598,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943528
    },
    {
        "content": "<p>Higher up in this same thread there is discussion about Artin-Wedderburn.</p>",
        "id": 241665601,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943537
    },
    {
        "content": "<p>We already have Maschke's theorem (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.submodule.is_complemented/src\">src#monoid_algebra.submodule.is_complemented</a>) and Schur's lemma.</p>",
        "id": 241665653,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943623
    },
    {
        "content": "<p>Although the current statement of Maschke's theorem is the \"core\" fact, and often you see it stated in a form that also gives various corollaries, so this might be a good first step. (i.e. find all the statements of Maschke's theorem you can in books, and make sure they follow from the version of Maschke's theorem already in mathlib!)</p>",
        "id": 241665664,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943700
    },
    {
        "content": "<p>I was actually having trouble finding Schur's lemma. Could you point me to it? I was actually trying to work up to proving it myself as practice. I'm not familiar with Maschke's theorem.</p>",
        "id": 241665801,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622943906
    },
    {
        "content": "<p>We actually have two independent proofs of versions of Schur's lemma!</p>",
        "id": 241665803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943911
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.bijective_of_ne_zero/src\">src#linear_map.bijective_of_ne_zero</a>, which states that a nonzero morphism between simple R modules is bijective.</p>",
        "id": 241665808,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943944
    },
    {
        "content": "<p>(for <code>R</code> any ring)</p>",
        "id": 241665810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943960
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso_of_hom_simple/src\">src#category_theory.is_iso_of_hom_simple</a></p>",
        "id": 241665853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943998
    },
    {
        "content": "<p>which is much more general, saying that any nonzero morphism between simple objects in a preadditive category with kernels is an isomorphism.</p>",
        "id": 241665860,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944028
    },
    {
        "content": "<p>We should unify these. I hadn't realised until today that the special case theorem existed in mathlib.</p>",
        "id": 241665864,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944053
    },
    {
        "content": "<p>There there are also various stronger versions of Schur's lemma.</p>",
        "id": 241665865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944067
    },
    {
        "content": "<p>in a <code>k</code>-linear category (<code>k</code> an algebraically closed field), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.finrank_hom_simple_simple_le_one/src\">src#category_theory.finrank_hom_simple_simple_le_one</a> says the dimension of the hom space between two simples is at most one.</p>",
        "id": 241665921,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944169
    },
    {
        "content": "<p>and two lemmas immediately afterwards say that it is 1 or 0 depending on whether the simple objects are isomorphic or not.</p>",
        "id": 241665941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944202
    },
    {
        "content": "<p>(Also --- if you're having trouble finding Schur's lemma, you haven't learnt how to use the right search tools: you should have the mathlib folder open in VSCode, and in the search bar type <code>Schur</code>. You can't miss it.)</p>",
        "id": 241665984,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944276
    },
    {
        "content": "<p>I did not know there are these generalisations to Schur's lemma! As a theoretical physics person, I only know it for matrix representations.</p>",
        "id": 241666045,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944392
    },
    {
        "content": "<p>Ah no wonder. I've been using the documentation site's search function.</p>",
        "id": 241666050,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944440
    },
    {
        "content": "<p>I'll take a look at Etingof and compare with mathlib.</p>",
        "id": 241666149,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944611
    },
    {
        "content": "<p>I'm working on the Artin-Wedderburn theorem (also very slowly!) with the far-away goal to prove that character tables for finite groups are square.</p>",
        "id": 241669742,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622950635
    },
    {
        "content": "<p>I wrote about 600 lines for some basic definitions and lemmas regarding representations of algebras, following the first few pages of Etingof. Would anyone like to give some advice/feedback? I'm getting stuck at defining the direct sum of representations and showing that decomposable representations are reducible.</p>",
        "id": 242457084,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512422
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lsULBUVPUtkKrbXpHVGyKJt1/representation.lean\">representation.lean</a></p>",
        "id": 242457096,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512486
    },
    {
        "content": "<p>The proofs are certainly not efficient, so I welcome suggestions for improvement or tricks I should know</p>",
        "id": 242457172,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512605
    },
    {
        "content": "<p>I have some reservation regarding the notation. Currently, <code>representation</code> has a <code>coe_fn</code> from an algebra to an endomorphism of modules, which means the representation is identified with the function. Usually however, we say \"let vector space V be a representation of the algebra A\", so a representation is identified with the target space. I don't have enough experience to tell which one is better for mathlib.</p>",
        "id": 242457457,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512910
    },
    {
        "content": "<p>Also, sorry in advance if the names don’t obey the convention</p>",
        "id": 242458440,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623514096
    },
    {
        "content": "<p>Winston, just in case you missed it (zulip doesn't mention if your topic title already exists), there is lots of discussion above your message</p>",
        "id": 242458558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514281
    },
    {
        "content": "<p>Also, rather than uploading the txt file to zulip, could you create a gist on github? I get encoding issues when trying to read your text file on Android, which won't be true of a gist</p>",
        "id": 242458642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I’ll do that in the morning (midnight here). Never done gist before</p>",
        "id": 242458947,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623514793
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span>, cool! Here are some thoughts from just looking at the file (I didn't actually run lean, so some of my suggestions might be wrong, let me know if I can clarify anything). Its easier for people to look at if you open a PR (tagged WIP for example) or at least make a git branch on mathlib so people can check the branch out more easily, let us know if you need assistance setting that up and we can help.</p>\n<ul>\n<li>If you have multiple rewrites in a row you can combine them so</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<ul>\n<li>If you just run one tactic with <code>by {simp}</code> the curly braces <code>{}</code> aren't needed.</li>\n<li>The character <code>ᾰ</code> is awkward to type on purpose, the idea is that you shouldn't use it! Instead give a name to the thing you want to refer to, for <code>has_bot</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span>\n</code></pre></div>\n<p>you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">submodule.mem_bot</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I believe.</p>\n<ul>\n<li>You apply theorems like <code>  apply linear_map.ext</code> you could likely replace this with just calling the <code>ext</code> tactic. Likewise for <code>    apply funext</code></li>\n<li>If you have multiple goals its easier to read and manage them if you separate each goal into a block with braces, so whenever you have <code>split</code> the next line should start with a brace <code>{</code> to focus the first goal only.</li>\n<li>There are some nice tactics for reducing repetition like <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#all_goals\">tactic#all_goals</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#repeat\">tactic#repeat</a>, for example you have</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span>\n</code></pre></div>\n<p>which could probably become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span> <span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li>You have a line</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>probably <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp\">tactic#dsimp</a> will do this for you</p>",
        "id": 242459381,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623515181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> those are great suggestions. Thank you!</p>",
        "id": 242459695,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623515636
    },
    {
        "content": "<p>A coule more: </p>\n<ul>\n<li>\n<p><code>Type _</code> is more usually done as <code>Type *</code>,</p>\n</li>\n<li>\n<p><code>simp</code> not at the end of the line is usually considered bad form, as it's hard to debug when you add more <code>@[simp]</code> lemmata. You should <code>squeeze_simp</code> them, or if you can put them at the end (potentially using <code>simpa</code>). You can also give <code>simp</code> bonus lemmata in the same sort of form that you pile up lemmata on <code>rw</code>, e.g. <code>simp [representation.smul_add]</code>.</p>\n</li>\n<li>\n<p>Some of your lemmas should definitely be tagged with <code>@[simp]</code>.</p>\n</li>\n<li>\n<p>You may be able to get away with reusing some lemmata from <code>linear_map</code> instead of having to re-prove them; you may have to put <code>local attribute [reducible] representation</code> in order to do this, though.</p>\n</li>\n<li>\n<p>You usually don't have to put <code>{ name . field := ... }</code> in the definitions of things; Lean will figure it out most of the time, and if it doesn't, it'll shout at you.</p>\n</li>\n<li>\n<p>I <em>think</em> the standard approach for sub-objects now is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a>.</p>\n</li>\n<li>\n<p>Lean usually prefers working backwards; proofs with a lot of <code>at this</code> tend to be a red flag that you could write it \"more idiomatically\".</p>\n</li>\n</ul>\n<p>There's some specific thoughts, too, that would be a lot easier to talk about in a github PR (e.g. the <code>rw</code> is unnecessary in <code>one_smul</code>). Have you got an invite to contribute to <code>mathlib</code>?</p>",
        "id": 242460159,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623516267
    },
    {
        "content": "<p>Not yet. I’ll try a GitHub PR in the morning and maybe get some help here</p>",
        "id": 242461842,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623518588
    },
    {
        "content": "<p>Before you go to sleep, drop your github username and maintainers should be able to give you an invite for the morning ^^</p>",
        "id": 242462375,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623519581
    },
    {
        "content": "<p>If you haven't already seen it, check out our page with tips for contributors: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>",
        "id": 242464386,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623522256
    },
    {
        "content": "<p>If somebody could invite me to GitHub: <a href=\"mailto:winstonyin@gmail.com\">winstonyin@gmail.com</a> Got too tired last night after all!</p>",
        "id": 242486001,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623552828
    },
    {
        "content": "<p>I just sent an invite to that email. You'll need to create a GitHub account if you don't already have one.</p>",
        "id": 242486534,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623553802
    },
    {
        "content": "<p>I've pushed my commit: <a href=\"https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9\">https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9</a> (&lt;---- this is a mistake)</p>",
        "id": 242497905,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572295
    },
    {
        "content": "<p>I only added representation.lean, so I'm not sure why there are all these other changed files.</p>",
        "id": 242497913,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572329
    },
    {
        "content": "<p>I think I see the issue. There's an existing branch called <code>representation</code>, which I've just pushed to... I'm sorry! Please help me fix this mistake, as I'm not good with git. It also looks like that branch is trying to do some of the same things I'm doing but differently.</p>",
        "id": 242498028,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572531
    },
    {
        "content": "<p>Ok the correct branch I've just created: <a href=\"https://github.com/leanprover-community/mathlib/compare/winstonyin/representation\">https://github.com/leanprover-community/mathlib/compare/winstonyin/representation</a></p>",
        "id": 242499506,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623575213
    },
    {
        "content": "<p>Hi,<br>\nI would like to try to contribute to the extent of my knowledge to the representation theory project in mathlib, but I am unsure where to starts since it looks like a few people are already working on this but there's not a lot in mathlib itself. I was wondering what is the state of the project right now.<br>\nI found the pull request <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>, which seems to introduce a definition of group representations and prove equivalences with other usual definitions; it seems like a good starting point, but it has been closed without merging. Why is that so, were there fundamental flaws in the approach of this PR?</p>",
        "id": 260792262,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636461998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 260792855,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636462324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Is there a particular thing in repn thy that you would like to work on?</p>",
        "id": 260796972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636464549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think that working towards orthogonality for characters of finite groups could be interesting. But I don't know if there are other things we'd need to get out of the way before working on that.</p>",
        "id": 260797537,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636464861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Sounds good. Maybe create a little mind map of the topics you would need?</p>",
        "id": 260800758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466429
    },
    {
        "content": "<p>E.g., mathlib doesn't have class functions at the moment. I guess you would want to have those</p>",
        "id": 260800793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466448
    },
    {
        "content": "<p>If you have a list of things, we can quickly tell you what is there and what is not</p>",
        "id": 260800833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466465
    },
    {
        "content": "<p>I remember from a past discussion of representation theory is that one difficulty is the variety of different ways a representation can be expressed.  As a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action\">docs#mul_action</a>, as a homomomorphism of the group into the automorphism group of the vector space, and as a module over the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra\">docs#monoid_algebra</a> of <code>G</code>.  I don't even think we have glue among these different notions.  Did we ever decide which one should be primary?</p>",
        "id": 260803019,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636467342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  Yeah, that's why I asked about <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>. The primary definition it takes is a <code>distrib_mul_action</code> such that the action of <code>G</code> commutes with that of <code>k</code> and it proves the equivalence with the two other definitions you mention. So it seems like it's already done, but have never been merged into mathlib.</p>",
        "id": 260813460,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471381
    },
    {
        "content": "<p>And yeah, I could try to create a little list of needed topics</p>",
        "id": 260813664,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471451
    },
    {
        "content": "<p>The direction mathlib has gone since is to avoid things like <code>representation</code> which bundles together both actions and their compatibility, and instead chooses to have three separate typeclasses for these facts.</p>",
        "id": 260854918,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489214
    },
    {
        "content": "<p>i.e. use the <code>smul_comm_class</code> (which quite possibly didn't even exist when I closed that PR??).</p>",
        "id": 260855034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489274
    },
    {
        "content": "<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>",
        "id": 260855176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489326
    },
    {
        "content": "<p>Personally I hope that we will also make a bundled version, perhaps as <code>Rep k G</code>, and provide a categorical API for everything, too.</p>",
        "id": 260855288,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489374
    },
    {
        "content": "<p>There are a lot of functors used early on in representation theory (induction and restriction, particularly), and it seems to me a great shame if we do not express these as functors!</p>",
        "id": 260855373,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260855176\">said</a>:</p>\n<blockquote>\n<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>\n</blockquote>\n<p>Ok, maybe I think I could try to do that first, since these equivalences seem to me like a necessary thing to get out of way before being able to work on interesting character theory.<br>\nI am not yet very comfortable with typeclasses and their subtleties, so would you mind explaining why it is a better approach to have separate typeclasses for the actions and their compatibilities? To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>",
        "id": 260874886,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636498701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 260880171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502024
    },
    {
        "content": "<p>So you'd want definitions (perhaps instances in one direction) translating between <code>[module k V] [distrib_mul_action G V] [smul_comm_class k G V]</code> and <code>[module (monoid_algebra k G) V]</code>.</p>",
        "id": 260880378,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502142
    },
    {
        "content": "<p>Some of these hopefully already exist, in the files that develop <code>monoid_algebra</code>.</p>",
        "id": 260880460,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502173
    },
    {
        "content": "<p>But then I'd also define <code>Rep k G</code> to be a structure, (parametrised also be the ring structure on <code>k</code> and the group structure on <code>G</code>), which has as fields the carrier type <code>V</code> and the remaining type classes. Then put a category instance on that.</p>",
        "id": 260880539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502239
    },
    {
        "content": "<p>Given the way we do bundled morphisms, there is not really a good way to say \"a function V to W which is both <code>k</code> linear and <code>G</code> linear\". So I suspect the <code>module (monoid_algebra k G) V</code> version is going to be important, because we <em>can</em> easily talk about a function which is <code>monoid_algebra k G</code>-linear.</p>",
        "id": 260880684,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502321
    },
    {
        "content": "<p>Thanks! So, for the backward direction (from <code>[module (monoid_algebra k G) V]</code>), would we have 3 definitions, one giving <code>[module k V]</code>, one giving <code>[distrib_mul_action G V]</code> and one giving <code>[smul_comm_class k G V]</code>, or should this be all bundled together somehow? In the first case, how would we formulate that the two parts pf the correspondence are inverses of each other?</p>",
        "id": 260886632,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636506365
    },
    {
        "content": "<p>There would be 3 definitions. (Almost surely the first one already exists.)</p>",
        "id": 260888128,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507683
    },
    {
        "content": "<p>I guess we could write an equivalence with lots of <code>letI := ...</code> statements on one side of the equivalence, to specifying explicitly using the instance that has gone back and forth through the equivalence.</p>",
        "id": 260888215,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507760
    },
    {
        "content": "<p>Another quick question : how can I make Lean figure out what the <code>distrib_mul_action</code> is in the definition of <code>[smul_comm_class k G V]</code>?<br>\nIn other words, how to avoid the error in the second definition here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_mul_action</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_has_scalar</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"o\">},</span>\n                     <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n                     <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260943866,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636517536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> One option is to use a type synonym for <code>V</code>, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span> <span class=\"kd\">def</span> <span class=\"n\">rep_space</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260944446,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518351
    },
    {
        "content": "<p>(The type synonym is when I rename <code>V</code> as <code>rep_space ρ</code>.)</p>",
        "id": 260944497,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518386
    },
    {
        "content": "<p>By the way, I rearranged your <code>distrib_mul_action_of_monoid_hom</code> a little for conciseness, but the only substantive change was from <code>def</code> to <code>instance</code>.</p>",
        "id": 260944511,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518432
    },
    {
        "content": "<p>What's the advantage of <code>instance</code> over <code>def</code>?</p>",
        "id": 260944587,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518517
    },
    {
        "content": "<p><code>instance</code> can be found by \"typeclass inference\", <code>def</code> can't.  So, for example, the fact that a metric space is in a natural way a topological space is found by typeclass inference.</p>",
        "id": 260944607,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518558
    },
    {
        "content": "<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>",
        "id": 260944624,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518599
    },
    {
        "content": "<p>Should <code>smul_comm_class_of_monoid_hom</code> also be an instance then?</p>",
        "id": 260944673,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518620
    },
    {
        "content": "<p>Yes!</p>",
        "id": 260944684,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518657
    },
    {
        "content": "<p>Btw, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is the person to talk to when it comes to scalar actions in mathlib. I'm sure he knows the best way for moving back and forth between </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and modules over <code>monoid_algebra k G</code>.</p>",
        "id": 260944760,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518743
    },
    {
        "content": "<p>He has been adding a lot of homomorphisms of the form <code>G -&gt; Aut _</code> or <code>R -&gt; End _</code> derived from scalar actions. So this might already be there.</p>",
        "id": 260944792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260944624\">said</a>:</p>\n<blockquote>\n<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>\n</blockquote>\n<p>OK, I got it working without typeclass inference (but as you can see, it's painful!).  Not even sure if I've missed some tricks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260945191,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636519316
    },
    {
        "content": "<p>Oof indeed, it seems like it's much better to use typeclass inference</p>",
        "id": 260945790,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636520075
    },
    {
        "content": "<p>Note that we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.of_End_hom\">docs#mul_action.of_End_hom</a>; so we <em>could</em> have something called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.of_add_monoid_End_hom\">docs#distrib_mul_action.of_add_monoid_End_hom</a> similar to the <code>distrib_mul_action_of_monoid_hom</code> above</p>",
        "id": 260964520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536738
    },
    {
        "content": "<p>Having said that, the implementation would just be <code>distrib_mul_action.comp_hom _ ρ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">distrib_mul_action.comp_hom</span> <span class=\"n\">_</span> <span class=\"n\">ρ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 260964705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks! Is there a reason you used def instead of instance as Heather suggested?<br>\nAlso is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>",
        "id": 260982846,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636547941
    },
    {
        "content": "<p>The first one can't be an instance because it depends on <code>ρ</code>, while the second one already exists so you don't need it anyway</p>",
        "id": 260988228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550815
    },
    {
        "content": "<blockquote>\n<p>Also is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>\n</blockquote>\n<p>Can you give me the lean statement?</p>",
        "id": 260988265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550828
    },
    {
        "content": "<p>Is this the forward statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- are these the defining properties of the action you want?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">of_smul</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map_smul</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">algebra_map</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 260988453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550917
    },
    {
        "content": "<p>What do you think of the proposition of Heather which is to define a vector space which is just a copy of <code>V</code> and put <code>distrib_mul_action</code> and <code>smul_comm_class</code> instances on it? And yes, that would be the forward statement .</p>",
        "id": 260990340,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636551867
    },
    {
        "content": "<p>I think that's a reasonable idea</p>",
        "id": 260992095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636552720
    },
    {
        "content": "<p>Whether it's necessary depends on whether <code>V = monoid_algebra k G</code> would create ambiguity</p>",
        "id": 261003750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636557281
    },
    {
        "content": "<p>I don't think I understand what you mean, <code>V</code> is the module, not the monoid algebra</p>",
        "id": 261006106,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636558231
    },
    {
        "content": "<p>V is any type that satisfies the module axioms. <code>V = monoid_algebra k G</code> is one such type.</p>",
        "id": 261008694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559337
    },
    {
        "content": "<p>If your instance can be parameterized to give a <code>has_scalar (monoid_algebra k G) (monoid_algebra k G)</code> instance, it must definitionally satisfy <code>a • b = a * b</code> to avoid diamonds</p>",
        "id": 261008980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260874886\">said</a>:</p>\n<blockquote>\n<p>To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>\n</blockquote>\n<p>In addition to the great advice, examples already provided you could also look at some of our Lie theory, at least to see one way to set things like this up in terms of typeclasses. E.g., <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_module\">docs#lie_module</a> is the definition of a representation of a Lie algebra.</p>",
        "id": 261025294,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636565775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you know if we have the equivalence, for an algebra <code>A</code> over <code>k</code>, of <code>module A M</code> with <code>is_scalar_tower k A M</code> and algebra maps from <code>A</code> to <code>M →ₗ[k] M</code></p>",
        "id": 261293336,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636742127
    },
    {
        "content": "<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>",
        "id": 261294067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742491
    },
    {
        "content": "<p>It seems we have neither</p>",
        "id": 261294169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742526
    },
    {
        "content": "<p>Oh, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.to_linear_map\">docs#distrib_mul_action.to_linear_map</a>, if you just want <code>A → M →ₗ[R] M</code></p>",
        "id": 261294863,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742890
    },
    {
        "content": "<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">module.to_module_End_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">one_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261295133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743065
    },
    {
        "content": "<p>I never PR'd that because I couldn't find a good place to put it where I had all the typeclasses available</p>",
        "id": 261295173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261294067\">said</a>:</p>\n<blockquote>\n<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>\n</blockquote>\n<p>Actually I mostly want the other direction</p>",
        "id": 261295580,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743273
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.apply_module\">docs#linear_map.apply_module</a></p>",
        "id": 261295690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743349
    },
    {
        "content": "<p>Which probably should be renamed to <code>module.End.apply_module</code></p>",
        "id": 261295709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743362
    },
    {
        "content": "<p>Or at least, it's that if you combine it with <code>module.comp_hom f</code> where <code>f : A →+* module.End R M</code></p>",
        "id": 261295782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743395
    },
    {
        "content": "<p>Note that <code>is_scalar_tower</code> was the wrong condition, <code>smul_comm_class</code> is what you need</p>",
        "id": 261295952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743494
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 261296811,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261295133\">said</a>:</p>\n<blockquote>\n<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n</blockquote>\n<p>PR'd as <a href=\"https://github.com/leanprover-community/mathlib/issues/10300\">#10300</a></p>",
        "id": 261298706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636744879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> are you still working on this?</p>",
        "id": 265624146,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1640039878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267205\">@Nicolò Cavalleri</span>  I've put it on hold a little bit to do other stuff including some linear algebra which I felt would be needed for rep theory, but yes I have some stuff done and I have the intention to come back to it soonish.</p>",
        "id": 265624695,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1640040275
    },
    {
        "content": "<p>Hi,<br>\nI was wondering if anyone understand why the scalar action is not recognized in <code>smul_single</code>. It works with <code>of k G g</code> but not with <code>finsupp.single g 1</code>, which is quite annoying.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.trace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">monoid_algebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">representation</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">as_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">g'</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_monoid_hom_apply_apply</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">as_algebra_hom</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_def</span> <span class=\"o\">:</span>\n  <span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_algebra_hom_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">as_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">module.comp_hom</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_module_apply</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">):</span>\n  <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453119,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685146
    },
    {
        "content": "<p>Here's a hacky fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→₀</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685331
    },
    {
        "content": "<p>Even though <code>monoid_algebra k G</code> and <code>G →₀ k</code> are definitionally equal, they are not syntactically equal, and type class inference works up to syntactic equality. What is happening in <code>(finsupp.single g 1 : monoid_algebra k G)</code> is that the syntactic type of <code>finsupp.single g 1</code> is <code>G →₀ k</code>, and <code>(finsupp.single g 1 : monoid_algebra k G)</code> means \"check <code>finsupp.single g 1</code> has type <code>monoid_algebra k G</code> and then continue\" -- but it doesn't actually <em>syntactically change</em> the type, so <code>has_scalar (G →₀ k) V</code> is what Lean ends up searching for, and it can't find it. However adding that little <code>id</code> hack actually does syntactically change the type of the term to <code>monoid_algebra k G</code> and then type class inference works. The \"correct\" thing to do here would be to use the appropriate <code>monoid_algebra</code> constructor for <code>monoid_algebra k G</code> as opposed to <code>finsupp.single g 1</code> which is the <code>finsupp</code> constructor.</p>",
        "id": 274453907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685601
    },
    {
        "content": "<p>Will the simplifier still simplify <code>(finsupp.single g 1) •  v</code> to <code>g •  v</code> if I add <code>id</code>?</p>",
        "id": 274454254,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685746
    },
    {
        "content": "<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274454386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274454386\">said</a>:</p>\n<blockquote>\n<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>My first intention was to state it as <code>(of k G g) • v = g • v</code> but the linter complained that the LHS simplifies to <code>(finsupp.single g 1) •  v</code>. Won't the same problem happen with <code>of_magma</code>?</p>",
        "id": 274455018,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646686120
    },
    {
        "content": "<p>oh I see!</p>",
        "id": 274455552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686401
    },
    {
        "content": "<p>Yes you're absolutely right, the simp linter doesn't like it. I think that it's a bad idea to have <code>of = single</code> and <code>of_magma = single</code> as global <code>@[simp]</code> lemmas. I can quite understand why one might want them locally to be <code>simp</code> lemmas when making the API, but for a \"user\" like you who doesn't ever want to see <code>finsupp</code>s but still wants to use the simplifier, the strategy of making <code>of = single</code> a <code>simp</code> lemma is preventing you from doing this.</p>\n<p>I saw the same phenomenon showing up in the <a href=\"https://github.com/ImperialCollegeLondon/complex-number-game\">complex number game</a>. I wanted to make <code>complex.ext</code> a <code>simp</code> lemma, so that whenever Lean was faced with a goal <code>z = w</code> it would replace it with <code>z.re = w.re</code> and <code>z.im = w.im</code>. This worked <em>great</em> for me when I was making the API for complex numbers, because to e.g. prove that multiplication of complex numbers is associative you <em>absolutely</em> want to check this on real and imaginary parts. However when you go deeper into the theory and are developing complex analysis, the last thing you want the simplifier to do is to keep taking real and imaginary parts of things; you want this to be available to you as an option, but definitely <em>not</em> be the \"this is the only sensible way to proceed\" option, which is kind of what <code>simp</code> lemmas are.</p>\n<p>So I would suggest that (perhaps after getting the nod from one or more maintainers) that you make a PR removing the global simp tags from the lemmas which are causing the trouble and then adding them again with <code>local attribute [simp] of_eq_single</code> (or whatever it's called) so that they're there for API development of <code>monoid_algebra</code> but don't leak out.</p>",
        "id": 274456417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686810
    },
    {
        "content": "<p>In my opinion <code>monoid_algebra</code> should be irreducible and <code>finsupp.single G 1 : monoid_algebra</code> should not even typecheck. I mean, it should typecheck in the file making the API for <code>monoid_algebra</code>, and then it should stop typechecking and the simplifier should stop trying to flow in that direction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 274456898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> am I talking nonsense?</p>",
        "id": 274456955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687028
    },
    {
        "content": "<p>I've not read the whole of today's discussion, but yes, we shouldn't be writing <code>finsupp.single</code> about <code>monoid_algebra</code></p>",
        "id": 274457169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687111
    },
    {
        "content": "<p>The problem is that the alternative is copying over all the lemmas about <code>finsupp.single</code> to a new <code>monoid_algebra.single</code></p>",
        "id": 274457220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687134
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> should I make a PR to remove the global simp tag to lemmas like <code>monoid_algebra.of_apply</code>?</p>",
        "id": 274458555,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646687693
    },
    {
        "content": "<p>I'm not sure. I guess you could open one with the WIP tag and see what breaks</p>",
        "id": 274458632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687722
    },
    {
        "content": "<p>I am not convinced that there is too much stuff to be said about <code>monoid_algebra.single</code>. One could even get away with not having it, and just sticking with <code>of</code>. The big advantage of <code>single</code> over <code>of</code> is that <code>single</code> span <code>G -&gt;_0 k</code> as an abelian group so you can use simpler induction principles, but I wonder whether we ever see these in practice.</p>",
        "id": 274458657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687731
    },
    {
        "content": "<blockquote>\n<p>I am not convinced that there is too much stuff to be said about monoid_algebra.single. </p>\n</blockquote>\n<p>(edit: we would need lemmas saying what the) Behavior of 0, 1, addition, subtraction, negation, multiplication, nsmul, zsmul, pow, and maybe some stuff about summation is?</p>",
        "id": 274458855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687795
    },
    {
        "content": "<p>Also I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_algebra.of\">docs#add_monoid_algebra.of</a> is nasty due to <code>multiplicative</code></p>",
        "id": 274458925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687833
    },
    {
        "content": "<p>I don't know what you mean by all this.</p>",
        "id": 274458941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687842
    },
    {
        "content": "<p>Also <code>of</code> doesn't work on magma algebras, which is annoying</p>",
        "id": 274459054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687885
    },
    {
        "content": "<p>sure define <code>0</code> and <code>1</code> and etc in the <code>monoid_algebra.lean</code> API file using <code>single</code>, and then close it off, giving the user access to <code>of</code>, and a proof that <code>of (g * h) = of g * of h</code></p>",
        "id": 274459073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687894
    },
    {
        "content": "<p>I think if we want to remove <code>of_apply</code>, we need to unbundle <code>of</code></p>",
        "id": 274459076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687896
    },
    {
        "content": "<p>Things like addition are not about <code>of</code> or <code>single</code></p>",
        "id": 274459151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687942
    },
    {
        "content": "<p>Ah, you're talking about the \"One could even get away with not having [monoid_algebra.single]\" option, which is where we are today minus the finsupp mess</p>",
        "id": 274459163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274459151\">said</a>:</p>\n<blockquote>\n<p>Things like addition are not about <code>of</code> or <code>single</code></p>\n</blockquote>\n<p><code>single g r + single g s = single g (r + s)</code> is the type of thing I'm describing</p>",
        "id": 274459202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687967
    },
    {
        "content": "<p>But we only want <code>single x 1</code> so I'm not interested in this</p>",
        "id": 274459293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687994
    },
    {
        "content": "<p>I disagree, we need <code>single x r</code> for <code>polynomial.monomial</code></p>",
        "id": 274459403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688030
    },
    {
        "content": "<p>Unless you also want to kill <code>monomial</code> at the same time</p>",
        "id": 274459439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688048
    },
    {
        "content": "<p>I'm well aware that we need it for <code>G -&gt;0 k</code></p>",
        "id": 274459447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688053
    },
    {
        "content": "<p>I'm suggesting that we forego it only for <code>monoid_algebra</code> because to me it looks a bit useless when we're thinking about group representation theory.</p>",
        "id": 274459522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688084
    },
    {
        "content": "<p><code>polynomial</code> is <code>(add_)monoid_algebra</code> not <code>-&gt;0</code> though</p>",
        "id": 274459544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688097
    },
    {
        "content": "<p>Right. I'm suggesting we don't need <code>single</code> for <code>monoid_algebra</code> (only).</p>",
        "id": 274459644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688127
    },
    {
        "content": "<p>Are you suggesting we should have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>?</p>",
        "id": 274459712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688163
    },
    {
        "content": "<p>What I learnt when working on a multivariable polynomial project was that it's really handy to have <code>single</code> because then you can prove stuff about <code>G -&gt;_0 k</code> by checking it's true on <code>single x y</code> and then checking that the subset where it's true is a subgroup. I'm suggesting that this is not a common method of proof for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274459884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688228
    },
    {
        "content": "<p>If I call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> then you can figure out what I mean in Lean, but I mean \"the group ring\". I'm not talking about subtle differences between additive and multiplicative structures. I just mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">tg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> doesn't show up much in this theory when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">t\\not=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 274460048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688297
    },
    {
        "content": "<p>So I don't care if I not only can't coerce <code>finsupp.single x y</code> into <code>monoid_algebra</code> but that there's no substitute in monoid_algebra world, because I will just do <code>of_ring x * of_group y</code> for the appropriate <code>of</code>s (one from the ring, one from the group).</p>",
        "id": 274460260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688381
    },
    {
        "content": "<p>I think multivariate polynomials are confusing things here, since they are of type <code>add_monoid_algebra R (σ →₀ ℕ)</code> which has both things you're talking about in it</p>",
        "id": 274460395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688453
    },
    {
        "content": "<p>My polynomial remarks are about <code>polynomial R = add_monoid_algebra R ℕ</code> where <code>polynomial.monomial = add_monoid_algebra.single</code> (modulo structure eta)</p>",
        "id": 274460535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688520
    },
    {
        "content": "<p>If we forbid using <code>finsupp.single</code> with <code>add_monoid_algebra</code> and don't add a <code>add_monoid_algebra.single</code> to replace it, then we're pulling the rug out from under <code>polynomial</code>.</p>",
        "id": 274460602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688558
    },
    {
        "content": "<p>And if we have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>, then we're being inconsistent</p>",
        "id": 274460651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688589
    },
    {
        "content": "<p>I see. Do you understand <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274463333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646689946
    },
    {
        "content": "<p>Yes, but unrelated to the <code>single</code> topic, I don't yet know how to avoid the diamonds that PR creates</p>",
        "id": 274463782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690190
    },
    {
        "content": "<p>do we have any diamonds that don't get fixed with definitional eta? i've often said how little I like the current diamond-fixing approach as much as I understand it's necessary</p>",
        "id": 274464196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690383
    },
    {
        "content": "<p>Yeah, these are straight-up non-equal diamonds</p>",
        "id": 274464224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690394
    },
    {
        "content": "<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>",
        "id": 274464383,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690425
    },
    {
        "content": "<p>(there are some equal-but-not-defeq diamonds that appear in that PR too, but they're not so big a deal)</p>",
        "id": 274464426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690430
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138\">https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138</a> is the proof of the non-equal diamond</p>",
        "id": 274464525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690470
    },
    {
        "content": "<p>But it amounts to saying that the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> is ambiguous, as is the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 274464673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690523
    },
    {
        "content": "<p>(I bring up the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> example to avoid the \"well we only care about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a group\" counterargument)</p>",
        "id": 274464904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274464383\">said</a>:</p>\n<blockquote>\n<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>\n</blockquote>\n<p>I think this would solve the problem, but I suspect it will be very annoying for what Kevin wants to do.</p>",
        "id": 274465037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690692
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- If this were an instance, it would conflict with the natural</span>\n<span class=\"c1\">-- action of `k[k]` on itself given by multiplication.</span>\n</code></pre></div>\n<p>The thing is that <code>k[k]</code> doesn't happen except in pathological computer science land (edit: just seen your comment on k[k^*]). In fact if <code>R</code> is a nontrivial ring (which it always is) and <code>G</code> is a group (which it always is, except when you're making polynomials) then <code>R</code> can never be <code>G</code> because nontrivial rings can never be groups. However they can certainly be additive groups.</p>\n<p>So there is something interesting going on here with <code>monoid_algebra</code> v <code>add_monoid_algebra</code>. I claim that they are in some sense different beasts, because <code>monoid_algebra</code> eats a ring and a monoid, and <code>add_monoid_algebra</code> eats a ring and an add_monoid. Problems with scalar actions might occur with one if the ring is the monoid and with the other if the ring is the add_monoid. In particular the two problems are not \"reflected\" by <code>to_additive</code>.</p>",
        "id": 274465074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690707
    },
    {
        "content": "<p>I don't think we need to worry about <code>add_monoid_algebra k A</code> much here, since it's just <code>monoid_algebra k (multiplicative A)</code> so the same arguments apply</p>",
        "id": 274465283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690800
    },
    {
        "content": "<p>OK so it really is true that there are two distinct actions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274465293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690806
    },
    {
        "content": "<p>So we just make the important one (the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>) the instance</p>",
        "id": 274465367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690848
    },
    {
        "content": "<p>and then just use <code>of k * x</code> for the other one</p>",
        "id": 274465391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690864
    },
    {
        "content": "<p>The other action is the one that says <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-algebra though, which is also important</p>",
        "id": 274465511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690911
    },
    {
        "content": "<p>Sure, but that's the K-action not the K^*-action. Or does every R-action on a thing induce an R^*-action?</p>",
        "id": 274465571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690941
    },
    {
        "content": "<p>When this sort of thing happens in lectures, mathematicians just introduce two different notations for the two actions</p>",
        "id": 274465632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690976
    },
    {
        "content": "<blockquote>\n<p>Or does every R-action on a thing induce an R^*-action?</p>\n</blockquote>\n<p>Yes (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.mul_action\">docs#units.mul_action</a>). This turns out to be useful, because it means we can turn every monoid action into a group action if we know we're working with the units</p>",
        "id": 274465634,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690977
    },
    {
        "content": "<p>It can absolutely happen that X can act on Y in more than one way.</p>",
        "id": 274465723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691006
    },
    {
        "content": "<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>",
        "id": 274465894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691109
    },
    {
        "content": "<p>One way out of the problem is to just use <code>f : X →* perm Y</code> and <code>f x y</code> instead of <code>x • y</code></p>",
        "id": 274465952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691125
    },
    {
        "content": "<p>Or even <code>f x • y</code> if you like your <code>•</code>s, since we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.apply_mul_action\">docs#equiv.perm.apply_mul_action</a></p>",
        "id": 274465999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274465894\">said</a>:</p>\n<blockquote>\n<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>\n</blockquote>\n<p>This would be more appealing if we could tell lean to emit an error if someone tries to work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> rather than giving them rope to hang themselves with</p>",
        "id": 274466114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691240
    },
    {
        "content": "<p>That is, a means of blacklisting instances</p>",
        "id": 274466172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691254
    },
    {
        "content": "<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>",
        "id": 274472578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646694659
    },
    {
        "content": "<p>Do people ever actually think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> and/or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> in real life?</p>",
        "id": 274473440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695205
    },
    {
        "content": "<p>I once wrote a paper in a scenario where this on this sort of thing, and I did use a type synonym. I had a Lie group G and was doing representation theory over the complex numbers. An example of the Lie group could have been <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> but I called it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"true\">‾</mo></mover><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\overline{\\R}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0501em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0501em;\"><span style=\"top:-3.3418em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> because the mathematics was telling me that it was a \"different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>\" to the one in the coefficient field.</p>",
        "id": 274473445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695210
    },
    {
        "content": "<p>Adam -- yes. Representation theory of real reductive groups.</p>",
        "id": 274473465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695225
    },
    {
        "content": "<p>Ah right</p>",
        "id": 274473475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695236
    },
    {
        "content": "<p>But as I say, they're in some sense \"two different copies of the complex numbers\"; one of them is just an abstract algebraic closure of the reals (or at least it was in the paper of Langlands I was using).</p>",
        "id": 274473512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695268
    },
    {
        "content": "<p>I should say that Langlands didn't explicitly say this, it came out of me trying to make what was happening in the paper more functorial.</p>",
        "id": 274473535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695305
    },
    {
        "content": "<p>But anyway I agree with you Kevin, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> inside of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> should really be thought of as different from the scalars</p>",
        "id": 274473544,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695313
    },
    {
        "content": "<p>The correct spelling of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> should be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[\\mathbb{G}_m(K)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)]</span></span></span></span> anyway.</p>",
        "id": 274474089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274473465\">said</a>:</p>\n<blockquote>\n<p>Adam -- yes. Representation theory of real reductive groups.</p>\n</blockquote>\n<p>I'm surprised that the case I constructed to prove a point actually turns out to be a thing people care about</p>",
        "id": 274475980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274472578\">said</a>:</p>\n<blockquote>\n<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>\n</blockquote>\n<p>This seems like a reasonable argument to me as long as we're only talking about <code>K[G]</code> on groups and not monoids (which is why we probably need separate <code>group_algebra</code> and <code>monoid_algebra</code></p>",
        "id": 274476865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697615
    },
    {
        "content": "<p>I know that in Iwasawa theory people talk about the completion of the group ring <span class=\"tex-error\">$$\\Z_p{\\Z_p^\\times]$$</span> too. I would like to argue that this diamond is there independent of this whole group ring business. If we just have a group G and a field k acting on an object (which can happen independent of whether one has made the group ring) then the units of the field act on the object so if the units of the field happen to be the group then you have two actions and already this is a diamond in some sense. The fix here should be a type synonym eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><msub><mi>L</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">GL_1(R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> instead of <code>units R</code>. What I'm saying is that the monoid algebra definition is not creating any <em>new</em> diamonds, it's just bringing to the fore an issue which was already there because if we use typeclasses then we're only allowed one action of X on Y, just like we're only allowed one monoid structure on X (which is an action of X on X). So I propose we ignore this issue as I don't believe it will impede progress.  With this in mind do we still need this type synonym in the group algebra PR?</p>",
        "id": 274503456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722741
    },
    {
        "content": "<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>",
        "id": 274503631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722872
    },
    {
        "content": "<p>I agree that this is probably just a diamond that we have to live with.</p>",
        "id": 274503842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723064
    },
    {
        "content": "<p>But it would be good to record it somewhere, so that we don't forget when it exists.</p>",
        "id": 274503866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723096
    },
    {
        "content": "<p>It's because it's there in reality! The complex representation theory of real reductive groups really does give you two different actions of C^* on a vector space</p>",
        "id": 274503957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646723171
    },
    {
        "content": "<p>Sure, but the question is how to deal with it later on. This could be via a type synonym for the group, or via specialized notation to distinguish the two actions. But we can figure that out when we get there.</p>",
        "id": 274504315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723538
    },
    {
        "content": "<blockquote>\n<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>\n</blockquote>\n<p>This situation doesn't arise in mathlib though: we don't have instances that go in this direction, precisely because they would create diamonds. Instances build data for \"big\" types (like <code>G × H</code>) out of instances on the pieces, not vice versa.</p>",
        "id": 274505789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725044
    },
    {
        "content": "<p>Does <code>G</code> act on <code>G \\times H</code>? I can imagine we would have an instance for that in mathlib.</p>",
        "id": 274506085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725258
    },
    {
        "content": "<p>Well then I claim we shouldn't have an induced action of <code>units K</code> on V given an action of K on V for the same reason</p>",
        "id": 274506139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725309
    },
    {
        "content": "<p>Because <code>units K</code> is obviously smaller than K (although the type theorists are going to argue that it's bigger)</p>",
        "id": 274506205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725349
    },
    {
        "content": "<p>Yes, I mean \"big\" in the type theory sense</p>",
        "id": 274506242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> But if we have an action of <code>G</code> on <code>G \\times H</code>, and also an action of <code>H</code> on <code>G \\times H</code>, then we have a diamond. That's the same problem as we have with <code>monoid_algebra</code>.</p>",
        "id": 274506350,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725451
    },
    {
        "content": "<p>And the fix is not yet another type ascription, it's to just leave it alone and let people fix it if they run into it. Mathematicians will know if they're running into it, their Spidey senses go off if they have two actions of X on Y</p>",
        "id": 274506485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725563
    },
    {
        "content": "<p>We have no global instance for <code>has_scalar G (G × H)</code> though (unless G acts on H too, then it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar\">docs#prod.has_scalar</a>), nor would it be safe to add one</p>",
        "id": 274506493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725570
    },
    {
        "content": "<p>Oh boo</p>",
        "id": 274506508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725581
    },
    {
        "content": "<p>How about bimodules? Do we have these yet?</p>",
        "id": 274506603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725681
    },
    {
        "content": "<p>Over two different rings? Yes, <code>[module R M] [module Sᵐᵒᵖ M] [smul_comm_class R Sᵐᵒᵖ M]</code></p>",
        "id": 274506704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725801
    },
    {
        "content": "<p>Modules for group rings are a situation in real mathematics where two (generically) distinct objects act on the same side on an object. We have to support this and worry about \"what if the objects are the same\" later</p>",
        "id": 274506769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725851
    },
    {
        "content": "<p>Why don't we add an action of <code>G^mop</code> on <code>monoid_algebra K G</code>? Does that solve all our problems?</p>",
        "id": 274506782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725870
    },
    {
        "content": "<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there. But that doesn't mean that we can't develop a theory of bimodules. It just means we ignore the issue</p>",
        "id": 274506851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725923
    },
    {
        "content": "<blockquote>\n<p>Does that solve all our problems</p>\n</blockquote>\n<p>Not after <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> it doesn't, which adds the kᵐᵒᵖ action</p>",
        "id": 274506874,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725940
    },
    {
        "content": "<blockquote>\n<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there.</p>\n</blockquote>\n<p>Why can't we use the spelling above for bimodules over the same ring?</p>",
        "id": 274506961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726040
    },
    {
        "content": "<p>Fair enough. But it will certainly make the problems very tiny.</p>",
        "id": 274507002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726049
    },
    {
        "content": "<p>If we're going to use this with a type synonym like <code>mul_opposite</code>, we could also solve it with a dedicated synonym</p>",
        "id": 274507045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726100
    },
    {
        "content": "<p><code>mul_opposite</code> would be natural: On <code>k[G]</code> there is an action of <code>k</code> on the left, and an action of <code>G</code> on the right.</p>",
        "id": 274507077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726145
    },
    {
        "content": "<p>Lean forces us to accept an action of <code>k</code> on the right. But maybe <em>that</em> shouldn't be a global instance.</p>",
        "id": 274507137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726183
    },
    {
        "content": "<p>I agree that algebras are bimodules, but should that be a <code>def</code> or an <code>instance</code>?</p>",
        "id": 274507152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726206
    },
    {
        "content": "<p>It could <del>certainly</del> maybe be an instance only in a locale</p>",
        "id": 274507196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726249
    },
    {
        "content": "<p>Although if algebras must be bimodules (and therefore carry a right action), then the <code>algebra R (A →ₗ [R] A)</code> instance requires lean to find the right action on <code>A</code></p>",
        "id": 274507472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726424
    },
    {
        "content": "<p>I could still be persuaded that <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> is a bad idea, but am like 80% sure we probably want it</p>",
        "id": 274507545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726486
    },
    {
        "content": "<p>So how do you suggest we deal with the <code>G</code>-action on <code>k[G]</code>?</p>",
        "id": 274508053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726884
    },
    {
        "content": "<p>Just multiply with <code>of g</code>, where <code>of : G -&gt; k[G]</code>?</p>",
        "id": 274508072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726903
    },
    {
        "content": "<p>In representation theory you absolutely want that action because it's the regular representation. Already you have this pathological \"what if G is syntactically k^*\" question</p>",
        "id": 274508210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646727006
    },
    {
        "content": "<p>What's the downside of the <code>of g * x</code> approach? (Other than being less appealing visually)</p>",
        "id": 274509871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728374
    },
    {
        "content": "<p>Presumably there are bits of the action API you want access to; do you know which bits?</p>",
        "id": 274510006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728465
    },
    {
        "content": "<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>",
        "id": 274510759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646728987
    },
    {
        "content": "<p>For me, you saying \"well perhaps we have to completely avoid making the action because of the extremely unlikely event that G is syntactically k^*\" is like you saying \"well I think we should stop using typeclasses for groups because of the extremely unlikely event that we want two distinct groups structures on a type\"</p>",
        "id": 274510900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646729068
    },
    {
        "content": "<p>To be clear, I'm begrudgingly ok with the action as long as it's on the <code>group_algebra</code> where it's less likely to cause harm than the <code>(add_) monoid_algebra</code></p>",
        "id": 274511444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729436
    },
    {
        "content": "<p>But I'd also like to understand what actually changes in practice if we say \"let's not use • syntax for this action, let's just use a suitably bundled function\"</p>",
        "id": 274511507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>This can be phrased as how the <code>k[G]</code>-module <code>k[G]</code> over itself decomposes as sum of irreducibles.</p>",
        "id": 274511813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729718
    },
    {
        "content": "<p>Often, the action is also written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">L_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">R_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> if you want to act on the left or on the right. This could be easily mimicked by using a type synonym <code>foo G</code> for <code>G</code>, acting on whatever you want, and calling the identity map from <code>G</code> to <code>foo G</code> as <code>L</code>, and then writing <code>L g \\bu a</code> is totally non-ambiguous, diamond free, and close enough to common mathematical practice.</p>",
        "id": 274512020,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646729867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>",
        "id": 274512203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729995
    },
    {
        "content": "<p>Another solution would be a pretty way of writing \"<code>g</code> viewed as element of <code>k[G]</code>\". I'm not sure a coercion will do. In maths, it is common to write <code>[g]</code>.</p>",
        "id": 274512205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729998
    },
    {
        "content": "<p>We discussed having the quotient brackets work for free constructions like that in another thread</p>",
        "id": 274512369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730043
    },
    {
        "content": "<p>I think there was general agreement but no one volunteered to do the work</p>",
        "id": 274512400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274512203\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>\n</blockquote>\n<p>As Johan says, it should probably be a statement of the form \"The R-module R is R-isomorphic to a certain exterior direct sum\"</p>",
        "id": 274512414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730077
    },
    {
        "content": "<p>Where did R come from?</p>",
        "id": 274512446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730108
    },
    {
        "content": "<p>It's k[G]</p>",
        "id": 274512510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730128
    },
    {
        "content": "<p>It doesn't sound like the lean statement even mentions a G action then?</p>",
        "id": 274512747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730295
    },
    {
        "content": "<p>The thing is that a k-linear G-action on a k-vector space is the same thing as a k[G]-action. We already have a good theory of module actions, so if we could get the group algebra merged somehow (and right now I'm really confused about whether it needs to be different from the module algebra) then the theory of G-modules could just be developed as a theory of k[G]-modules.</p>",
        "id": 274512898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> how about making <code>monoid_algebra</code> and <code>add_monoid_algebra</code> irreducible and not making <code>group_algebra</code> at all, and disregarding the issue that G could in theory syntactically be <code>units k</code> because mathematicians are only too well aware when they have two distinct actions of A on B and will know to take evasive action via a type synonym (which can be described to them in some docstring). Does this solve the problems which started this thread and the problems with <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274513365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730706
    },
    {
        "content": "<p>The examples which have been flagged before have had <code>G</code> definitionally <code>k^*</code> but not syntactically.</p>",
        "id": 274513478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730766
    },
    {
        "content": "<p>The main problem I had that started this thread was <code>monoid_algebra.of</code> simplifying to <code>finsupp.single</code> even though that's not really wanted. I suppose this wouldn't be the case anymore if <code>monoid_algebra</code> was made irreducible?</p>",
        "id": 274618062,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646779085
    },
    {
        "content": "<p>Making <code>monoid_algebra</code> irreducible is orthogonal to your issue</p>",
        "id": 274618820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779599
    },
    {
        "content": "<p>Removing the simp lemma is enough, but right now that creates more problems that it solves</p>",
        "id": 274618851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779621
    },
    {
        "content": "<p>Because we can't choose <code>of</code> as the canonical spelling (right now) because it doesn't work on magma algebras</p>",
        "id": 274618919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779668
    },
    {
        "content": "<p>So until we introduce something better, the only suitable spelling right now is <code>finsupp.single</code>, even though that had the wrong type.</p>",
        "id": 274619026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779715
    },
    {
        "content": "<p>I see, so for now I guess I'll just make my problematic lemma use <code>of</code> but not make it a <code>simp</code> lemma</p>",
        "id": 274619862,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646780239
    },
    {
        "content": "<p>Hi! I want to define the tensor product of two representations of a monoid <code>G</code> by <code>g • (v ⊗ₜ w) = (g • v) ⊗ₜ (g • w)</code>, but I noticed that there is already <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_has_scalar\">docs#tensor_product.left_has_scalar</a> which defines the action by letting <code>G</code> act only on the left factor. What are the reasons for this definition of an action on the left only, and is it possible to define the action I want on <code>V ⊗ W</code> without ambiguity with the other definition? Do I need to use a type synonym?</p>",
        "id": 279021918,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649970897
    },
    {
        "content": "<p>I suspect the action on the left is useful when you want to consider the base-change of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> to some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, which is defined as the tensor product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">B \\otimes_A M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 279022137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649971016
    },
    {
        "content": "<p>The action on the left is the obvious one when the action is by the field of the two vector spaces (and equal to the equivalent action on the right), which is why it's the default</p>",
        "id": 279024322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972209
    },
    {
        "content": "<p>So I have to use a type synonym?</p>",
        "id": 279024399,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972273
    },
    {
        "content": "<p>If you want to use <code> •</code> notation and not something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.map\">docs#tensor_product.map</a>, yes</p>",
        "id": 279024627,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972406
    },
    {
        "content": "<p>I don't know whether it makes more sense to put the type synonym on the tensor type or the action type</p>",
        "id": 279024744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972474
    },
    {
        "content": "<p>You might be able to get away without the synonym... What would the typeclass requirements for such an action be?</p>",
        "id": 279024931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024931\">said</a>:</p>\n<blockquote>\n<p>You might be able to get away without the synonym... What would the requirements for such an action be?</p>\n</blockquote>\n<p>Something like that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 279025054,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972675
    },
    {
        "content": "<p>Is that enough for <code>distrib_mul_action G (V ⊗[R] W)</code>?</p>",
        "id": 279025205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972784
    },
    {
        "content": "<p>I think it is, yes</p>",
        "id": 279025363,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972891
    },
    {
        "content": "<p>Yeah, you definitely need a type synonym then</p>",
        "id": 279025548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973024
    },
    {
        "content": "<p>I would guess putting the type synonym on G works out better</p>",
        "id": 279025891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279025891\">said</a>:</p>\n<blockquote>\n<p>I would guess putting the type synonym on G works out better</p>\n</blockquote>\n<p>Why is that? Putting the type synonym on the tensor product seems more natural to me since otherwise we can't compare the tensor representation to other representations of <code>G</code>.</p>",
        "id": 279028773,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649975026
    },
    {
        "content": "<p>Youch. Yes both the diagonal action for a tensor product group rep and the left action for base extension are pretty important :-/</p>",
        "id": 279038375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649983229
    },
    {
        "content": "<p>shame our subscript options are so limited, or we could use  •_D and  •_L</p>",
        "id": 279043388,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989316
    },
    {
        "content": "<p>or the like</p>",
        "id": 279043389,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989317
    },
    {
        "content": "<p>It's not really a matter of notation but a matter of API. If you start using <code>•_D</code> and <code>•_L</code>, then all the lemmas about <code>•</code> don't apply anymore.</p>",
        "id": 279054053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650004755
    },
    {
        "content": "<p>Is this evidence that we should <em>not</em> define a G-representation over a field k as being definitionally a k[G]-module?</p>",
        "id": 279056734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650007797
    },
    {
        "content": "<p>I thought <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260880171\">we already decided</a> that <code>[module (monoid_algebra k G) X]</code> was definitely the wrong way to go anyway (and instead to go via the separate actions of <code>k</code> and <code>G</code>)</p>",
        "id": 279059055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010168
    },
    {
        "content": "<p>Perhaps a type alias <code>representation</code> used as <code>representation G</code> solves most of the issues</p>",
        "id": 279059110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024399\">said</a>:</p>\n<blockquote>\n<p>So I have to use a type synonym?</p>\n</blockquote>\n<p>Yes.</p>\n<p>I thought about this in some detail a while back and shared some details here: <a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a> which may or may not be useful.</p>",
        "id": 279068370,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650018517
    },
    {
        "content": "<p>I am  trying to implement the type synonym following <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>'s suggestions, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">tensor_rep</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">V</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">tensor_rep</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n<span class=\"kd\">notation</span> <span class=\"n\">v</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.tmul</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The last line is problematic because I reference <code>V</code> and <code>W</code>. This shouldn't be a problem since I think there should be a way to infer <code>V</code> and <code>W</code> as the types of <code>v</code> and <code>w</code>. Is there a way to do that?</p>",
        "id": 279115715,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650051601
    },
    {
        "content": "<p>You should define a <code>to_rep</code> function that changes a tensor product to your type</p>",
        "id": 279115876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051713
    },
    {
        "content": "<p>Like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/to_lex\">docs#to_lex</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual.to_dual\">docs#order_dual.to_dual</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/conj_act.to_conj_act\">docs#conj_act.to_conj_act</a>, etc</p>",
        "id": 279115940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051743
    },
    {
        "content": "<p>Then use that definition in your notation</p>",
        "id": 279115978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051779
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 279117268,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650052634
    },
    {
        "content": "<p>Hi! After working for a bit on representation theory, I noticed that the approach I took to define <code>k</code>-linear representations of <code>G</code> on a vector space <code>V</code> as <code>distrib_mul_action G V</code> + <code>smul_comm_class G k V</code>causes a lot of issues due to ambiguity between different actions and potential diamonds. After some discussion with <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , we came to the conclusion that it might be better to avoid entirely scalar multiplication when doing representation theory and stick with the definition <code>G →* (V →ₗ [k] V)</code>, writing <code>φ g v</code> everywhere we previously wrote <code>g • v</code>, where <code>φ </code> is the name of the representation (which is slightly less convenient, especially when  <code>φ </code> is actually a long name, but seems like the least worst solution).<br>\nBefore I start refactoring all I did so far, I was wondering what were the opinions of other people interested in representation theory in mathlib on this matter. Does anyone see downsides of this approach that we might have missed?</p>",
        "id": 279432277,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650385064
    },
    {
        "content": "<p>I think we should be able to obtain a situation similar to informal mathematics: when there is a single (or distinguished) action on a space then we can use the scalar multiplication notation. However when we are considering several actions simultaneously, and do not wish to distinguish any of them, (as happens quite a bit in representation theory) then we will be explicit and give the action a name.</p>",
        "id": 279433648,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385662
    },
    {
        "content": "<p>If you've been talking with Eric about this then it's very likely the approach you have in mind is sound.</p>",
        "id": 279433866,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385746
    },
    {
        "content": "<p>To elaborate on that idea, the outline was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">representation</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.trivial</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.tprod</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">tensor_product.map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"bp\">..</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- I have no idea what a good name is</span>\n<span class=\"kd\">def</span> <span class=\"n\">representation.on_monoid_algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- notation something like `rV →R rW` -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">representation_map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_repr</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">rW</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 279434138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385845
    },
    {
        "content": "<p>My feeling generally was that this would generate less boilerplate than the equivalent approach with type synonyms</p>",
        "id": 279434321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385923
    },
    {
        "content": "<p>I think we'll probably want both approaches eventually but I am certain that we'll want something similar to the above whatever we do.</p>",
        "id": 279435049,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650386248
    },
    {
        "content": "<p>For what it's worth, I also much prefer this approach over using <code>has_scalar</code>, there are just too many scalar actions around in this context.</p>",
        "id": 279494087,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1650425003
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a></p>",
        "id": 279695863,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650554983
    },
    {
        "content": "<p>I've defined <code>Rep k G</code>, the category of (bundled) representations of <code>G</code> over <code>k</code>. It seems to be nicely compatible with the new design.</p>",
        "id": 280033231,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872637
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></p>",
        "id": 280033274,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872646
    },
    {
        "content": "<p>I was pleased to find that verifying it has (co)limits and a natural monoidal structure was very smooth!</p>",
        "id": 280033334,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872697
    },
    {
        "content": "<p>The PR doesn't include preparing the <code>preadditive</code> and <code>abelian</code> instances, but this shouldn't be too hard now.</p>",
        "id": 280033706,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872921
    },
    {
        "content": "<p>Cool! Unfortunately you're hitting a timeout here: <a href=\"https://github.com/leanprover-community/mathlib/pull/13683/files\">https://github.com/leanprover-community/mathlib/pull/13683/files</a></p>",
        "id": 280033812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650872982
    },
    {
        "content": "<p>I'm still a bit sad that it looks like we can't use scalar multiplication in rep'n theory. But I guess that's life in lean, for now.</p>",
        "id": 280033990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650873096
    },
    {
        "content": "<p>Fixed the timeouts.</p>",
        "id": 280035459,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650873860
    },
    {
        "content": "<p>Nice, that's definitely gonna be very useful! If we prove enough properties of this category we're gonna be able to use <code>category_theory.preadditive.schur</code>, which is great since I'll need Schur's lemma to get to the orthogonality of characters.</p>",
        "id": 280088170,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650901545
    },
    {
        "content": "<p>I've added PRs</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>: <code>Rep k G</code> is symmetric monoidal</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a>: <code>Rep k G</code> is abelian</li>\n</ul>",
        "id": 280089298,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650901995
    },
    {
        "content": "<p>I guess showing that it is a <code>k</code>-linear category should be done as well (easy?), and also that it is monoidal closed (not sure).</p>",
        "id": 280089393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650902037
    },
    {
        "content": "<p>For monoidal closed, I think the internal hom should be what I called <code>lin_hom</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a>, and I don't think it should be too hard to prove that it's adjoint to the tensor product.</p>",
        "id": 280093222,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650903673
    },
    {
        "content": "<p>Another TODO:</p>\n<ul>\n<li>Equivalence with <code>Module k[G]</code>.</li>\n</ul>",
        "id": 280095000,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650904509
    },
    {
        "content": "<p>Another to-do: Tannakian?</p>",
        "id": 280144176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650930043
    },
    {
        "content": "<p>I've never really dared to say it. But Tannaka duality would be a wonderful milestone.</p>",
        "id": 280162585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650950292
    },
    {
        "content": "<p>I did the equivalence with <code>Module k[G]</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>. (Still needs some linting, and one declaration is mysteriously incredibly slow; if anyone wants to have a look at <code>counit_iso</code> in <code>src/representation_theory/Rep.lean</code>?)</p>",
        "id": 280206399,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978244
    },
    {
        "content": "<p>This is a bit painful as we have to grapple with all the different actions and fight the typeclass system as we convert between them. But it seems to work out okay.</p>",
        "id": 280206464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978273
    },
    {
        "content": "<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>",
        "id": 280206623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978350
    },
    {
        "content": "<p>More immediately important is to hook up the existing work on schur's lemma and maschke's theorem, and show <code>Rep k G</code> is semisimple when it is.</p>",
        "id": 280206726,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978380
    },
    {
        "content": "<p>I've added <code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, which acquires cheaply a rigid structure when <code>G</code> is a group.</p>",
        "id": 280332358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651056821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280206623\">said</a>:</p>\n<blockquote>\n<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>\n</blockquote>\n<p>Maybe we can actually get Tannaka <em>reconstruction</em> fairly quickly in the case of <em>finite groups</em>. After all, the general case requires algebraic groups, and I don't think we are anywhere near those.</p>",
        "id": 280333854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651057543
    },
    {
        "content": "<p>Here's a summary of the current stack of PR's on representation theory.</p>\n<ul>\n<li><code>Rep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></li>\n<li><code>Rep k G</code> is symmetric monoidal in <a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>, depending on a PR about braidings in <a href=\"https://github.com/leanprover-community/mathlib/pull/13684\">#13684</a></li>\n<li><code>Rep k G</code> is abelian in <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a></li>\n<li><code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13738\">#13738</a> which in turn depends on two PRs about rigid structures in <a href=\"https://github.com/leanprover-community/mathlib/pull/13736\">#13736</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>.</li>\n<li><code>Rep k G ≌ Module (monoid_algebra k G)</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>, depending on refactoring PRs in <a href=\"https://github.com/leanprover-community/mathlib/pull/13760\">#13760</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a>.</li>\n</ul>",
        "id": 280580666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201005
    },
    {
        "content": "<p>In particular currently needing review are <a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13684\">#13684</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13736\">#13736</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>, and <a href=\"https://github.com/leanprover-community/mathlib/pull/13760\">#13760</a>. (<a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a> is back to me after a helpful review from Eric.)</p>",
        "id": 280580748,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all those PRs. I finally had some time to look at them. They're great.</p>",
        "id": 280583593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651204255
    },
    {
        "content": "<p>Added:</p>\n<ul>\n<li><code>Rep k G</code> is <code>k</code>-linear and <code>k</code>-linear monoidal, waiting on <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a>.</li>\n</ul>",
        "id": 280594717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651216697
    },
    {
        "content": "<p>and</p>\n<ul>\n<li><code>FinVect k</code> has all finite limits, <a href=\"https://github.com/leanprover-community/mathlib/pull/13793\">#13793</a> depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13792\">#13792</a></li>\n</ul>",
        "id": 280636687,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651240860
    },
    {
        "content": "<p>I'm very satisfied by the last one. We've had Schur's lemma in mathlib for over a year, but stated in maximal generality: it holds for any linear category over an algebraically closed field, with finite dimensional hom spaces, and kernels.</p>\n<p>Finally, <code>fdRep k G</code> satisfies those hypotheses, so we can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Verify that Schur's lemma applies out of the box.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">finrank_hom_simple_simple</span> <span class=\"o\">[</span><span class=\"n\">is_alg_closed</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">fdRep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finrank</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">≅</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">category_theory.finrank_hom_simple_simple</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n</code></pre></div>",
        "id": 280640690,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242678
    },
    {
        "content": "<p>That's wonderful! I think we're not very far from the orthogonality of characters, though there's still some linear algebra missing.</p>",
        "id": 280641174,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651242946
    },
    {
        "content": "<p>Sometime over the weekend I'll hook up Maschke's theorem with the new setup.</p>",
        "id": 280641252,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242970
    },
    {
        "content": "<p>After that, I think if I keep working on representation theory I might take an excursion into semisimple categories, and decompositions into simple objects.</p>",
        "id": 280641351,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651243028
    },
    {
        "content": "<p>For Schur's lemma applied to endomorphisms, there's a generalization due to Dixmier (and generalized further by <a href=\"https://www.ams.org/journals/proc/1969-021-01/S0002-9939-1969-0238892-4/home.html\">Quillen</a>) that if you have a simple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an algebra over an algebraically closed field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, if  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">End</mi><mo>⁡</mo></mrow><mi>A</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{End}_A(M)\\cong k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. (If you drop \"algebraically closed\" then instead the conclusion is that endomorphisms are all algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>). For example, the space of endomorphisms of a countable-dimensional simple representation of a group over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is one-dimensional.</p>\n<p>If somebody were to try to formalize this, where would be a good place for it? (still src/category_theory/preadditive/schur.lean?) Potentially it would pull in things about transcendence degree.</p>",
        "id": 280650353,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651247144
    },
    {
        "content": "<blockquote>\n<p>For example, the space of endomorphisms of a countable-dimensional simple representation of a group over \\mathbb{C}C is one-dimensional.</p>\n</blockquote>\n<p>This result is used in the basic theory of smooth admissible representations of p-adic groups, which we will have all the ingredients for when we've figured out how to do continuous representations of topological groups.</p>",
        "id": 280678849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651261068
    },
    {
        "content": "<p>This would be great to have. If it pulls in transcendence degrees then just make a new file for it.</p>",
        "id": 280698947,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272730
    },
    {
        "content": "<p>Does the proof really use that it is an A-module? I've never looked at these generalisations. Schur's lemma is usually stated for modules, but in fact this is irrelevant for the version in mathlib.</p>",
        "id": 280699162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272933
    },
    {
        "content": "<p>It seems like it's important that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module, but maybe there's some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>-linear category trick. There's a step where you give <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> the structure of a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> using the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure. You also need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> to get its dimension.</p>\n<p>Here's the proof I know: Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">f:M\\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-linear endomorphism. Suppose for sake of contradiction that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is not algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. Then by Schur's lemma, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is an isomorphism since it's not zero.  We have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over the field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> of rational functions, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> acting by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is nonzero we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></msub><mi>M</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\dim_{k(t)}M\\geq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0496em;vertical-align:-0.3552em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>M</mi><mo>≥</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\dim_k M \\geq \\dim_k k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>t</mi><mo>−</mo><mi>c</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>c</mi><mo>∈</mo><mi>k</mi><mo stretchy=\"false\">}</mo><mo>⊂</mo><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\{ (t-c)^{-1} \\mid c\\in k\\}\\subset k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> is a linearly independent set over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> (since, clearing denominators, a linear dependence would be that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>), we also have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\dim_k k(t) \\geq |k|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span></span></span></span>. But, we assumed that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, so we have a contradiction, hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>.</p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is algebraically closed, then you use the minimal polynomial to get an eigenvalue for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and do the usual algebraically closed Schur's lemma proof.</p>",
        "id": 280703983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277282
    },
    {
        "content": "<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>",
        "id": 280709008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651282823
    },
    {
        "content": "<p>This this is the proof Taylor taught me :-) I thought the 1/(t-c) trick was brilliant.</p>",
        "id": 280714084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651290267
    },
    {
        "content": "<p>That same trick is also used for what I've seen referred to as a \"quick and dirty\" proof of the Nullstellensatz.  You can see the trick in the highest scoring answer <a href=\"https://mathoverflow.net/questions/15226/elementary-interesting-proofs-of-the-nullstellensatz\">here</a>.</p>",
        "id": 280716318,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651293604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280709008\">said</a>:</p>\n<blockquote>\n<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>\n</blockquote>\n<p>Oh, yeah, that's all you need. I got confused and forgot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> was just an endomorphism, so the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure is not used. (If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> acts on the right, then I like to think of the morphisms as acting on the left since then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>x</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">fxa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">a</span></span></span></span> suggests the usual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">af(x)=f(ax)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>.  The proof only uses the left action by the category and some things about dimension.)</p>\n<p>It's interesting how this is true no matter the faithful k-linear functor. Over an algebracially closed field, is it true that there's always one that sends simple modules to 1D vector spaces? I know that's true for semisimple algebras over an algebraically closed field.</p>",
        "id": 280744646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651336872
    },
    {
        "content": "<p>Hi! I need to talk about equivalence of representations, and I was wondering if I should use for that the isomorphisms provided by the category <code>Rep k G</code> defined by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> or if I should define independently types <code>rep_hom</code> and <code>rep_equiv</code> which would extend <code>linear_map</code> and <code>linear_equiv</code>. I'm not very familiar with how category theory is used in mathlib, so I'd appreciate some advice on this.</p>",
        "id": 280875885,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651499480
    },
    {
        "content": "<p>We're potentially on new ground here... I'm tempted to suggest we try and proceed \"within\" the category theory API for now, and only bail out and define everything \"unbundled\" as necessary. But we will have to be careful trip interpret \"necessary\" liberally: the first sign of your theoretic troubles caused by using the category theory library should cause us to retreat.</p>",
        "id": 280941829,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529623
    },
    {
        "content": "<p>But this is only one opinion, and a biased one.</p>",
        "id": 280941856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529639
    },
    {
        "content": "<p>But I do like the idea of finally being able to stop defining the same basic ideas (isomorphism, etc), and using the polymorphic model provide by category theory. Worth a try, as an experiment?</p>",
        "id": 280941956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529694
    },
    {
        "content": "<p>This all said, I think most of the future work on representation theory for a while should be developing the representation theory of (finite dimensional) algebras.</p>",
        "id": 280942100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529764
    },
    {
        "content": "<p>The main representations-of-groups specific fact is already there in <code>maschke.lean</code>, and most of what is needed to hook that up to decomposition into irreducibles and character theory is true more generally.</p>",
        "id": 280942201,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529847
    },
    {
        "content": "<p>I was thinking that perhaps we should just plough through Etingof's notes on representation theory. They are a bit nonlinear, but if we just do whatever subset is on the minimal path to his treatment of representations of finite groups I think we'd get a very pretty, and appropriately generalized, treatment.</p>",
        "id": 280942370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529953
    },
    {
        "content": "<p>This is actually why I wrote my \"simple implies indecomposable\" PR last night: it was the first statement I could find in his notes that we didn't have.</p>",
        "id": 280942479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651530013
    },
    {
        "content": "<p>So far I focused on group representations because my goal was to get orthogonality of characters. I'm not really aware of how character theory generalizes to finite-dimensional algebras, is there a more general version of orthogonality of characters for finite groups?</p>",
        "id": 280943437,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651530662
    },
    {
        "content": "<p>Something that comes to mind is finite-dimensional Hopf algebras. These have a one-dimensional space of \"integrals\" that you can use to generalize averaging-over-the-group arguments.  (Group algebras are Hopf algebras, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_{g\\in G}g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is an integral.) I'm pretty sure these are all you need to get that characters of non-isomorphic simple representations are orthogonal, where you define something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">(</mo><mo>∫</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V, W\\rangle = \\operatorname{tr}_{V\\otimes W^*}(\\Delta(\\int))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1111em;vertical-align:-0.3061em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span><span class=\"mbin mtight\">⊗</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Δ</span><span class=\"mopen\">(</span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"mclose\">))</span></span></span></span> (the trace of the action of the comultiplication of the integral on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V\\otimes W^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>). That can be rewritten in terms of characters for V and W.</p>\n<p>The way that formula expands for groups using the un-scaled integral is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>V</mi></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V,W\\rangle = \\sum_{g\\in G} \\operatorname{tr}_V(g)\\operatorname{tr}_W(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2499em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, using the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><msup><mi>W</mi><mo>∗</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_{W^*}(g)=\\operatorname{tr}_{W}(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (for Hopf algebras in general, the antipode can be used to put things in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>)</p>",
        "id": 280945611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651532149
    },
    {
        "content": "<p>even if we don't go via hopf algebras, while orthogonality of characters doesn't hold generally, there are interesting statements. e.g. Theorem 3.6.2 of <a href=\"https://klein.mit.edu/~etingof/repb.pdf\">https://klein.mit.edu/~etingof/repb.pdf</a></p>\n<blockquote>\n<p>(i) Characters of (distinct) irreducible finite dimensional representations of A are linearly independent.<br>\n(ii) If A is a finite dimensional semisimple algebra, then these characters form a basis of (A/[A, A])^∗</p>\n</blockquote>",
        "id": 280949933,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535577
    },
    {
        "content": "<p>But I guess for just checking orthogonality there's no point knowing anything about the relationship with characters of algebras.</p>",
        "id": 280950147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535773
    },
    {
        "content": "<p>But the facts the characters span, and determine the representation, come from more general facts, and ideally we would deduce these facts in the Rep G setting from the more general statements.</p>",
        "id": 280950171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535822
    },
    {
        "content": "<p>but don't hesitate to do whatever work on orthogonality you like</p>",
        "id": 280950406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536003
    },
    {
        "content": "<p>if we want to relate the characters you define for G and the characters for k[G], we can retrofit that later</p>",
        "id": 280950458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536024
    },
    {
        "content": "<p>Anyway for now I've been mostly doing linear algebra and proving stuff about traces of linear maps, which will be useful both for algebras and for groups</p>",
        "id": 280950592,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536122
    },
    {
        "content": "<p>I forget -- do you need anything beyond semisimplicity to get that A/[A,A] is isomorphic to the center Z(A) as a vector space?</p>",
        "id": 280950644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651536143
    },
    {
        "content": "<p>But I'll try to get more familiar with the category theory API soon</p>",
        "id": 280950783,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> has open PRs defining several natural maps involving dual modules, contractions and traces (<a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR147-R157\">for example</a>), and I am wondering whether all this stuff (including definition of trace) should be rewritten in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact_pairing\">docs#category_theory.exact_pairing</a>. I'm not suggesting to simply adopt the categorical formalism, but at least we would like to easily convert between both formalisms. And the current definition of trace (which landed in mathlib two years ago <a href=\"https://github.com/leanprover-community/mathlib/pull/3125\">#3125</a>) only works for finite free modules, but I think we eventually want it for finite projective modules as well, for K-theory or whatever, and <code>exact_pairing</code> probably offers us greatest generality. I'd appreciate comments from <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> on this.</p>",
        "id": 280956826,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542515
    },
    {
        "content": "<p>Yes, I hope this can be aligned as closely as possible, so that \"bundling\" statements up as statements about rigid categories is as trivial as possible.</p>",
        "id": 280956912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651542631
    },
    {
        "content": "<p>Is it true that <code>dual_tensor_hom R M N</code> is an equivalence whenever <code>M</code> is a finite projective module?</p>",
        "id": 280956947,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651542685
    },
    {
        "content": "<p>I believe so. (Here is a \"reference\": <a href=\"https://mathoverflow.net/a/156274/3332\">https://mathoverflow.net/a/156274/3332</a>)</p>",
        "id": 280957013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542756
    },
    {
        "content": "<p>It seems in the module case, you can derive all isomorphisms involving duals from <code>(module.dual R M) ⊗[R] M →ₗ[R] module.End R M</code> being an isomorphism, which seems a simpler statement than exact_pairing. Is there some advanced theory that I can look into?</p>",
        "id": 280957056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542839
    },
    {
        "content": "<p>Can you derive the more general <code>(module.dual R M) ⊗[R] N →ₗ[R] (M →ₗ[R] N)</code> from this?</p>",
        "id": 280957224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543049
    },
    {
        "content": "<p>It's pretty easy to define <code>Mᵛ → M → (M → N) → Mᵛ ⊗ N</code> which <code>lift</code> to <code>Mᵛ ⊗ M → (M → N) → Mᵛ ⊗ N</code>, and if you have the canonical element in <code>Mᵛ ⊗ M</code> that corresponds to <code>1 : End M</code> then you get <code>(M → N) → Mᵛ ⊗ N</code>. (I'm using <code>ᵛ</code> to denote the dual; I think this is a common notation but forget where I saw it; Wikipedia uses <code>*</code>.)</p>",
        "id": 280957542,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651543352
    },
    {
        "content": "<p>I see, that's nice!</p>",
        "id": 280958372,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543991
    },
    {
        "content": "<p>The check notation is particularly nice for duals once you reach dagger categories and start interacting with operator algebras. At that point <code>*</code> is so massively overloaded that no one is allowed to use it. :-)</p>",
        "id": 280958856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651544440
    },
    {
        "content": "<p>It seems that the following are all equivalent:<br>\n(1) The identity is in the image of the natural map <code>Mᵛ ⊗ M → End M</code>.<br>\n(2) <code>M</code> is a <a href=\"https://en.wikipedia.org/wiki/Rigid_category\">rigid object</a> in the category of <code>R</code>-modules, with <code>M</code> and <code>Mᵛ</code> forming an exact_pairing ((1) is basically one of the \"triangle\" identities saying <code>M → M</code> is id, and the other one follows (the proof invokes extensionality, showing that two linear functionals agree on every element of <code>M</code>, and doesn't seem to follow from axioms of symmetric closed monoidal categories)).<br>\n(3) The natural map <code>Mᵛ ⊗ M → End M</code> is an isomorphism (with inverse given by the construction <code>(M → N) → Mᵛ ⊗ N</code> above (also on the Wikipedia page)).<br>\n(4) <code>M</code> is a finite projective module (finiteness is trivial; projectivity follows from <a href=\"https://en.wikipedia.org/wiki/Projective_module#Dual_basis\">https://en.wikipedia.org/wiki/Projective_module#Dual_basis</a>, <a href=\"https://math.stackexchange.com/a/22403/12932\">proof</a>).</p>\n<p>So we can just work with finite projective modules for maximal generality.<br>\nNotice that <code>M → Mᵛᵛ</code> being an isomorphism (<code>M</code> reflexive) is strictly weaker, as <code>M</code> doesn't have to be finite or projective (e.g. the direct sum of countably many Z).</p>\n<p>One may be tempted to construct all natural maps involving tensor and Hom and prove identities between them using the axioms of symmetric closed monoidal categories and rigid objects, but that's likely cumbersome (though a ramped up <code>coherence</code> tactic might help); simply using extensionality would be easier: if the identity doesn't involve the inverse of <code>Mᵛ ⊗ M → End M</code> it's probably <code>rfl</code>, but I think we need to figure out a better (and uniform) way to do <a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR159\">proofs like this</a> where the inverse is involved.</p>",
        "id": 281160272,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651673286
    },
    {
        "content": "<p>In the categorical language, when the inverse is involved can't we just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso.inv_comp_eq\">docs#category_theory.is_iso.inv_comp_eq</a> to get rid of the inverse, just as I used <code>linear_map.cancel_right</code> when doing these kinds of proofs in the linear algebra language?</p>",
        "id": 281218942,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651698120
    },
    {
        "content": "<p>Could I just ping on a few PRs on the <a href=\"https://bit.ly/3zVLgqR\">#queue</a>: <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13870\">#13870</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13908\">#13908</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13967\">#13967</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> (and hopefully <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, it's just linting now after a merge conflict)?</p>",
        "id": 281507930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651882820
    },
    {
        "content": "<p>I started trying to work with <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> 's <code>Rep k G</code> category, and one issue I noticed is that it assumes that <code>k</code> is a ring (due to <code>Module k</code> assuming a ring), while so far I've tried to only assume <code>semiring</code> when possible. Is there any reason why <code>Module k</code> isn't defined for semirings?</p>",
        "id": 281620148,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652046881
    },
    {
        "content": "<p>I don't know if there's really any interesting case in which we have a semiring which is not a ring, but if there are some things that we can state in this generality I guess that it's better to do so?</p>",
        "id": 281620224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652047019
    },
    {
        "content": "<p>Probably this can be generalized. I suspect that at the time Module was defined the library was less generalized than it is now. If you'd like to have a go at this please do, otherwise I can try soon.</p>",
        "id": 281622233,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050290
    },
    {
        "content": "<p>And yes, I think it's good if results are stated as generally as possible. It seems to pay off later in a mathlib style library. :-) Also often it's helpful for understanding proofs when the hypotheses are as weak as possible --- fewer misleading clues about wrong directions you might take!</p>",
        "id": 281622306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050396
    },
    {
        "content": "<p>I tried quickly to check what happens what happens if I replace <code>ring</code> by <code>semiring</code> in <code>Module</code>, and the problem is that we also need to replace <code>add_comm_group</code> by <code>add_comm_monoid</code> for the underlying abelian group of the module, which causes some problems for example in <code>has_forget_to_AddCommGroup</code> since <code>M</code> doesn't have an <code>add_comm_group</code> instance anymore.</p>",
        "id": 281627211,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652057971
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.add_comm_monoid_to_add_comm_group\">docs#module.add_comm_monoid_to_add_comm_group</a> but it's a def and not an instance so I'm not sure how to use it.</p>",
        "id": 281627327,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652058055
    },
    {
        "content": "<p>Okay, I spent a while on this, and I think it is sadly impossible.</p>",
        "id": 281632116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064483
    },
    {
        "content": "<p>I can get <code>Module/basic.lean</code> to compile, but only be constructing dubious instances, which later break everything.</p>",
        "id": 281632149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064521
    },
    {
        "content": "<p>Hm, that's unfortunate...</p>",
        "id": 281632163,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652064552
    },
    {
        "content": "<p>I'd been worried that we would need a different <code>Module</code> to handle modules over <code>k</code>-algebras, but so far I can get away with just the one.</p>",
        "id": 281632281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064713
    },
    {
        "content": "<p>But this seems worse.</p>",
        "id": 281632284,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064717
    },
    {
        "content": "<p>What did you want to do over semirings? Maybe looking at a concrete statement will lead to inspiration. :-)</p>",
        "id": 281632377,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064810
    },
    {
        "content": "<p>As an example, I was thinking of restating <a href=\"https://leanprover-community.github.io/mathlib_docs/find/representation.lin_hom\">docs#representation.lin_hom</a> in the category theory language using <code>Rep k G</code>. Currently this definition works for semirings, but <code>Rep k G</code> requires a ring.</p>",
        "id": 281632572,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652065069
    },
    {
        "content": "<p>I see. It would be nice to construct the closed monoidal instance on <code>Rep k G</code>.</p>",
        "id": 281635261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068292
    },
    {
        "content": "<p>I propose that for now we just proceed with the restriction that <code>k</code> is a ring in <code>Rep k G</code>...</p>",
        "id": 281635265,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068310
    },
    {
        "content": "<p>I don't think I've ever met someone who does representation theory over semirings.</p>",
        "id": 281635321,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068345
    },
    {
        "content": "<p>Fair enough</p>",
        "id": 281635593,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652068709
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13845\">#13845</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> would like some review, and are on the \"representation theory queue\", if anyone reading here would like to take a look. :-)</p>",
        "id": 282393704,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597477
    },
    {
        "content": "<p>I'm hoping that soon I will have the equivalence of \"is a sum of simple objects\" and \"every subobject is complemented\" in any preadditive category (with a few bits and pieces), and after that the density theorem (the map <code>A ⟶ End V</code> is surjective for any irreducible f.d. representation V of a <code>k</code>-algebra A).</p>",
        "id": 282393819,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597651
    },
    {
        "content": "<p>I  see that we have a <code>right_rigid_category</code> instance for <code>fdRep k G</code>, but we don't have <code>left_rigid_category</code>. This is very annoying since we need the left version in order to get the <code>monoidal_closed</code> structure (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoidal_closed_of_left_rigid_category\">docs#monoidal_closed_of_left_rigid_category</a>). <br>\nI looked at <code>FinVect</code> and noticed that here also we weirdly only have the right rigid structure but not the left one. Is there any reason for that?  If I want to access the monoidal structure of <code>fdRep k G</code>, should I go back to <code>FinVect</code> and add the left rigid structure there, or is it available in another way that I am missing?</p>",
        "id": 283176767,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653143901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 283176870,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144034
    },
    {
        "content": "<p>I think no good reason this is missing. Maybe it would be nice to show that if you're braided one implies the other?</p>",
        "id": 283176887,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144089
    },
    {
        "content": "<p>Or just do it directly for FinVect.</p>",
        "id": 283176888,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144100
    },
    {
        "content": "<p>The PR that did this was just plugging together immediately available pieces.</p>",
        "id": 283176934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144141
    },
    {
        "content": "<p>I don't think we even have that <code>FinVect</code> is braided so for now I think the second option is simpler.</p>",
        "id": 283177291,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144629
    },
    {
        "content": "<p>Though proving braiding for <code>FinVect</code> shouldn't be too hard. The natural way to do it would be to prove it more generally for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.full_monoidal_subcategory\">docs#category_theory.monoidal_category.full_monoidal_subcategory</a>. By the way, is there a reason why this is not an instance?</p>",
        "id": 283178197,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653145772
    },
    {
        "content": "<p>Ok, so trying to prove that <code>FinVect</code> is symmetric, I figured I should probably use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.braided_category_of_fully_faithful\">docs#category_theory.braided_category_of_fully_faithful</a>, but for that I need a monoidal version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.full_subcategory_inclusion\">docs#category_theory.full_subcategory_inclusion</a>. How do I get lean to figure out the monoidal structure on <code>{X : C // P X}</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">full_monoidal_subcategory_inclusion</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_id</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h_tensor</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoidal_functor</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">//</span> <span class=\"n\">P</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 283179780,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653147933
    },
    {
        "content": "<p>I think the best approach here will be to introduce <code>monoidal_subcategory P  h_id h_tensor</code> as a synonym for <code>{X : C // P X}</code> and put a monoidal_category instance on that.</p>",
        "id": 283208421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191120
    },
    {
        "content": "<p>Perhaps even add <code>monoidal_predicate</code> which bundles together <code>P</code>, <code>h_id</code> and <code>h_tensor</code>.</p>",
        "id": 283208428,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191156
    },
    {
        "content": "<p>Does that make sense / seem plausible?</p>",
        "id": 283208487,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191177
    },
    {
        "content": "<p>Sounds good, done in <a href=\"https://github.com/leanprover-community/mathlib/pull/14311\">#14311</a>. Let me know what you think.</p>",
        "id": 283247112,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653247068
    },
    {
        "content": "<p>Left a few comments. Mostly looks promising, thanks for doing this!</p>",
        "id": 283256290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653260036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What are your thoughts on <a href=\"https://github.com/leanprover-community/mathlib/pull/14311#discussion_r878940321\">that comment</a>?</p>",
        "id": 283320796,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653313554
    },
    {
        "content": "<p>Yes, this looks good.</p>",
        "id": 283697414,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653367947
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>",
        "id": 286095492,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1655222718
    },
    {
        "content": "<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>",
        "id": 307566451,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406691
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 307566748,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/286095492\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>\n</blockquote>\n<p>(I am also a new user, so maybe I'm doing something wrong, but I think this commit is not in my local copy yet...)</p>",
        "id": 307566857,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406793
    },
    {
        "content": "<p>All those commits are on a branch (<a href=\"https://github.com/leanprover-community/mathlib/tree/orthogonality\">branch#orthogonality</a>) which is not yet merged into master so your local version of master won't have them yet.</p>",
        "id": 307567981,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407101
    },
    {
        "content": "<p>It looks like the first thing that needs to happen to get the ball rolling on these again is to fix the merge conflicts in <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> with master</p>",
        "id": 307568538,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407271
    },
    {
        "content": "<p>I just tried to fix <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> lets see if the other branches also work now</p>",
        "id": 307579089,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667410150
    },
    {
        "content": "<p>Ok and I've merged branch 'semorrison/fdRep-linear' into semorrison/fdRep-schur and it looks like it builds ok, so <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> will hopefully turn green after a while and be ready for review when the first PR is merged</p>",
        "id": 307585217,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667411915
    },
    {
        "content": "<blockquote>\n<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>\n</blockquote>\n<p>Yes, we basically have orthgonality of characters modulo the merging of these old PRs. We don't have yet that the characters span the class functions though, that would be a next natural step.</p>",
        "id": 307625238,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426292
    },
    {
        "content": "<p>Or incorporating this in a more general setting of representations of algebras.</p>",
        "id": 307625365,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426358
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> for fixing <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>. It's merged now, and I've just updated <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (Schur's lemma applies to fdRep) and it looks good. Hopefully someone can approve it shortly.</p>",
        "id": 307650969,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667445678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Oh great! Should I pick it up somewhere, or are you rolling with these representations?</p>",
        "id": 307730132,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482709
    },
    {
        "content": "<p>(Our local Lean workshop is working towards Burnside's p^aq^b theorem, so there are many other parts that I could start working on.)</p>",
        "id": 307730213,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482736
    },
    {
        "content": "<p>But I love thinking about general finite dimensional representation theory too, so I'm more than happy to dive in here as well.</p>",
        "id": 307730476,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482807
    },
    {
        "content": "<p>I haven't worked on that for a few months, so feel free to start working on any result that we don't currently have.</p>",
        "id": 307730711,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482886
    },
    {
        "content": "<p>Let me know if you have any questions on the current API.</p>",
        "id": 307731021,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482977
    },
    {
        "content": "<p>I've updated <a href=\"https://github.com/leanprover-community/mathlib/pull/16043\">#16043</a>, it's now ready to be reviewed.</p>",
        "id": 307818092,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667502388
    },
    {
        "content": "<p>It seems that the last thing about representations of finite groups merged into mathlib was this PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/16043\">#16043</a> which adds orthonormality of characters, but mathlib still doesn't know that the characters span the space of class functions, and the consequence that there are as many characters as conjugacy classes. Has anyone proved the p^a q^b theorem, no matter in Lean 3 or Lean 4? Maybe progress stalled due to the port.</p>\n<p>Has anyone attempted to compute some character tables? Many tables require some induced characters to fill; the concrete definition of induced representations with explicit basis from coset representatives is probably good for computation, while the definition via tensor product is good for proving Frobenius reciprocity (but mathlib's TensorProduct needs a noncommutative generalization). Has anyone worked towards <a href=\"https://en.wikipedia.org/wiki/Brauer%27s_theorem_on_induced_characters\">Brauer's theorem on induced characters</a>?</p>\n<p>I'm asking because I'm trying to find possible projects in this area for a bachelor student's thesis. I've also found another topic <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Leiden.20representation.20theory.20project/near/303591762\">#general &gt; Leiden representation theory project @ 💬</a> which is also from the Lean 3 era. Is there any activity in the Zulip stream mentioned there?</p>",
        "id": 498025955,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1738811185
    },
    {
        "content": "<p>For me the difficulty with undergraduate representation theory projects is that half of the results we have are about vector spaces with group actions and the other half are shrouded in category theory and are about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FDRep#doc\">docs#FDRep</a> . Moving between the two setups is not at all easy because typeclass instances don't round-trip very well</p>",
        "id": 498068649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738832624
    },
    {
        "content": "<p>Javier's FLT subproject is seemingly plagued with this issue as well</p>",
        "id": 498072309,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738833673
    },
    {
        "content": "<p>Is there a reason why representation theory in mathlib is based on category theory and not unbundled like the other algebraic library?<br>\nIs it to connect to the homology library better?</p>",
        "id": 498073481,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1738834007
    },
    {
        "content": "<p>Hmm, I think it is just because I did the early work, and was over-eager to use the category theory library.</p>",
        "id": 498076564,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738834858
    },
    {
        "content": "<p>I was quite keen to e.g. use a general theory of semisimple objects, without having separate-but-close definitions for representations of groups and of rings, etc.</p>",
        "id": 498076710,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738834897
    },
    {
        "content": "<p>I'm happy to call it a historical mistake? :-)</p>",
        "id": 498076754,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1738834913
    },
    {
        "content": "<p>How do you propose that mathlib should proceed with developing representation theory? Would you oppose a parallel, more concrete approach? Coming from physics, I’m always excited to see more representation theory, but I have not been able to help develop or make effective use of the current library.</p>",
        "id": 498539037,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1739051445
    },
    {
        "content": "<p>Once upon a time I asked this and got the response from somebody that category theory is “the right way” to do things. I couldn’t tell if that was said partly in humour or based on valid design considerations, so I’d like to ask again.</p>",
        "id": 498539205,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1739051592
    },
    {
        "content": "<p>I would like to lobby for the representation theory of 𝔰𝔲(2) to be studied, maybe culminating in the theorem that demonstrates self-duality for SU(2)-representations. It could be a good foot in the door.</p>\n<p>There is also a mysterious and deep analogy with Pontrjagin duality in its relation with S¹, the unit ball in ℂ; SU(2)  is the unit ball in the quaternions and is simply connected so determined by the Lie-algebra structure via the Lie-algebra functor using precomposition with the exponential map of a Lie group.</p>",
        "id": 498652434,
        "sender_full_name": "Dean Young",
        "timestamp": 1739149955
    },
    {
        "content": "<p>Right now here is the car crash that is representation theory in mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- How do we do \"a representation of the group G on a k-vector space\"?</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- non-category method via typeclasses</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- non-category method via Representation</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- non-category method via k[G]-modules</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V''</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V''</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V''</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V''</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- category method via Rep</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝓥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- category method via FDRep</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝓥'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Perhaps the community needs to make a decision on which of the five choices we have should be built upon in order to prove something like the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mi>a</mi></msup><msup><mi>q</mi><mi>b</mi></msup></mrow><annotation encoding=\"application/x-tex\">p^aq^b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0435em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span></span></span></span> theorem (or, more ambitiously, to get AI to formalise the classification of finite simple groups). </p>\n<p>The reason that <code>FDRep</code> is a thing is that bare representation theory of a group is not really a thing beyond the case of finite groups. This is not entirely true, there some countable groups which people study bare representations of (although I don't know if people study infinite-dimensional representations of them). The moment one goes to infinite groups one typically has a topology (Galois groups, Weil groups, Lie groups, locally profinite groups are four examples which spring to mind immediately) and one only studies representations which are continuous in some appropriate sense. And there's a rich theory of representations of Lie algebras (as Elliot mentions above), but Lie algebras aren't groups so the axioms are a bit different.</p>",
        "id": 498710886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739180332
    },
    {
        "content": "<p>/poll Which of Kevin's approaches do you like best?</p>\n<ul>\n<li>non-category method via typeclasses</li>\n<li>non-category method via Representation</li>\n<li>non-category method via k[G]-modules</li>\n<li>category method via Rep</li>\n<li>category method via FDRep</li>\n</ul>",
        "id": 498720586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739182861
    },
    {
        "content": "<p>Maybe worth a bit commentary. Off the top of my head I'd probably say:</p>\n<ul>\n<li>Use \"non-category method via typeclasses\" when you want to develop theory wrt a single fixed rep (this should be the default)</li>\n<li>Use \"non-category method via Representation\" when you need to make statements that involve several representations (e.g., the number of irreps of a finite group is number of conjugacy classes)</li>\n<li>Have instances to use \"non-category method via k[G]-modules\" internally in a proof (e.g., if want to use some theory of simple modules) but never make statements in this language</li>\n<li>Use \"category method\"(s) when you actually want to apply it as a tool and / or study this category as a thing in its own right</li>\n</ul>",
        "id": 498727392,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1739184642
    },
    {
        "content": "<p>I feel like my instinctual answer (an option 6, using the category of k[G]-modules) is being quite strongly influenced by both personal preferences and it being unclear whether we expect developments after this point to be applicable outside the realm of <em>group</em> representation theory.  If/when we want to build tools that we can use for representation theory of algebras, I would argue for a categorical approach.  But (a) it seems from a glance at the thread (but not a careful read of it all) that there is a specific group-theoretic aim to this project and (b) it reminds me slightly of Oliver's talk on root systems (as in \"we'll know the right definition when several other versions have failed to work\").</p>",
        "id": 498731635,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1739185661
    },
    {
        "content": "<p>I agree very much that one should develop the basic theory of representations of (finite-dimensional) algebras, and then leverage that as much as possible via k[G].</p>",
        "id": 498731927,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739185731
    },
    {
        "content": "<p>When I was doing rep theory years ago in Lean I was intending to follow Etingof's book along these lines.</p>",
        "id": 498731992,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1739185758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/498727392\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Use \"non-category method via Representation\" when you need to make statements that involve several representations (e.g., the number of irreps of a finite group is number of conjugacy classes)</li>\n</ul>\n</blockquote>\n<p>I don't understand this one. Would you mind elaborating please?<br>\nI would expect your example statement to go via isomorphism classes, and hence categorical language.</p>",
        "id": 498733187,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739186102
    },
    {
        "content": "<blockquote>\n<p>I feel like my instinctual answer (an option 6, using the category of k[G]-modules)</p>\n</blockquote>\n<p>Darn it, I thought I had them all!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- category method via k[G]-modules</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">𝓥''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"741122\">@Jan Grabowski</span> ! I added it to the list of options.</p>",
        "id": 498733953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739186351
    },
    {
        "content": "<p>Also, as a side note, my experience of teaching rep theory of finite groups - including up to Burnside's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mi>a</mi></msup><msup><mi>q</mi><mi>b</mi></msup></mrow><annotation encoding=\"application/x-tex\">p^a q^b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0435em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span></span></span></span></span></span></span></span> theorem - was that at some point it felt like there was a branching off.  One direction was about categories, modules, extensions etc. (what I would somewhat loosely call \"representation theory\") and the other was characters (\"character theory\" <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> ).  The notes I have, based on James--Liebeck, suggest that you need very little representation theory in this sense for Burnside's theorem - algebraic integers, orthogonality of characters, a smidge of Sylow theory.  Despite voting for <a href=\"https://github.com/leanprover-community/mathlib4/pull/6\">#6</a> (obvs), I am not at all certain this is going to be the most helpful way of getting to that particular result and may indeed get in the way.</p>",
        "id": 498735410,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1739186813
    },
    {
        "content": "<p>Oh here's a 7th option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(the SMulCommClass input got permuted). Turns out that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SMulCommClass.symm#doc\">docs#SMulCommClass.symm</a> isn't an instance so this is a genuinely different set-up.</p>\n<p>In representation theory people usually put a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>-action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><msub><mi>m</mi><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom_k(V,W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span> via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mi>f</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(gf)(v)=g(f(g^{-1}v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">))</span></span></span></span> but this is not the default action of <code>G</code> on <code>V →ₗ[k] W</code>.</p>",
        "id": 498753751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739192157
    },
    {
        "content": "<p>I will read this whole discussion more carefully later, but please keep in mind that whatever method is chosen needs to be able to be enriched with topology at some point (both for the group and the vector space). I’m naturally leaning towards the <code>smul</code> definition precisely for that reason: we already have the corresponding continuity assumption as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousSMul#doc\">docs#ContinuousSMul</a></p>",
        "id": 498787592,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1739200428
    },
    {
        "content": "<p>Another issue with the <code>SMulCommClass</code> approach is that it's probably difficult to do things like work with two 1-dimensional representations where we would probably have <code>V = k</code> but two different actions of <code>G</code>. The <code>Representation</code> approach avoids this.</p>",
        "id": 498788423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739200623
    },
    {
        "content": "<p>I would like to point out that there is an issue with the \"category method with <code>ModuleCat</code>\". The category of representations can be thought as the category of <code>k[G]</code>-modules, but this is not compatible with the tensor product, because the tensor product of representations is given by the tensor product of the underlying <code>k</code>-modules, not by the tensor product of <code>k[G]</code>-modules (which is not defined anyway unless <code>G</code> is commutative). Then, categorywise, we need to use a different name.</p>",
        "id": 498802204,
        "sender_full_name": "Joël Riou",
        "timestamp": 1739203571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/498788423\">said</a>:</p>\n<blockquote>\n<p>Another issue with the <code>SMulCommClass</code> approach is that it's probably difficult to do things like work with two 1-dimensional representations where we would probably have <code>V = k</code> but two different actions of <code>G</code>. The <code>Representation</code> approach avoids this.</p>\n</blockquote>\n<p>This is a good observation. But I feel like as soon as we migrate to <code>V = k</code>, then we are in pretty special territory and we might want special API for that case anyway. So it might as well get a separate name.<br>\nFor example, there will be quite some overlap with <code>MulChar</code>. (And maybe we can even reuse it?)</p>",
        "id": 498802915,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1739203783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> I'm confused by something in your comments - quite possibly it's flagged a mathematical subtlety I've not thought about carefully enough.</p>\n<p>The group algebra is a Hopf algebra, with the diagonal coproduct, and this makes its module category a monoidal category (whether G is Abelian or not).  Are you saying this is somehow not compatible with a tensor product of representations?</p>",
        "id": 498806290,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1739204663
    },
    {
        "content": "<p>Responding to the 1-dimensional case, surely we'll want to be able to handle e.g. the regular representation of a finite Abelian group, wherein several different 1-dim reps will be needed, at the same time?</p>\n<p>Edit: what I was thinking but probably didn't manage to say clearly was that I didn't quite understand the rationale for a special API, since having multiple 1D reps around is not exactly rare.</p>\n<p>(Do we have an emoji for \"treat my posts as essentially uninformed speculation as to what might be a better choice <em>for formalization</em>, and thank you for your patience\"? <span aria-label=\"face with spiral eyes\" class=\"emoji emoji-1f635-200d-1f4ab\" role=\"img\" title=\"face with spiral eyes\">:face_with_spiral_eyes:</span>, maybe?)</p>",
        "id": 498806617,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1739204748
    },
    {
        "content": "<p>(Noting indeed that MulChar is relevant! And with apologies for lack of formatting, due to incompetence...)</p>",
        "id": 498806845,
        "sender_full_name": "Jan Grabowski",
        "timestamp": 1739204807
    },
    {
        "content": "<p>I would imagine that the Hopf algebra tensor product is exactly the representation tensor product (but I didn't check). What Joel is saying is that if G is abelian then we may already have a tensor product on <code>ModuleCat k[G]</code> and it will be the wrong one.</p>",
        "id": 498807411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739204951
    },
    {
        "content": "<p>I'm a bit late to this conversation, but I'd like to point out that for the non-cat type class Vs <code>Representation</code> discussion, a similar (I think?) decision was made for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra#doc\">docs#Algebra</a> (as evidenced by the module doc string)</p>",
        "id": 498946669,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739259982
    },
    {
        "content": "<p>Do these plans intend to incorporate Lie groups or the Peter-Weyl theorem? Representations for those are continuous.</p>",
        "id": 499011231,
        "sender_full_name": "Dean Young",
        "timestamp": 1739281035
    },
    {
        "content": "<p>I think that right now we're figuring out how to do representations, and we're hoping that we'll be able to add continuous representations later (e.g. with <code>ContinuousSMul</code>).</p>",
        "id": 499042876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739289639
    },
    {
        "content": "<p>Juste a note that continuous representations of a topological group on a topological vector space will fit <code>ContinuousSMul</code> but won't coincide with continuous morphisms from the group to the group of continuous automorphisms of the topological vector space.</p>",
        "id": 499237242,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1739367915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> did you mean '<em>to</em> ...' (emphasis added) (ellipsis added)</p>",
        "id": 499268163,
        "sender_full_name": "Dean Young",
        "timestamp": 1739375558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"559197\">Dean Young</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/498652434\">said</a>:</p>\n<blockquote>\n<p>S¹, the unit ball in ℂ; SU(2)  is the unit ball in the quaternions</p>\n</blockquote>\n<p>Did you mean 'unit <em>sphere</em>'s?</p>",
        "id": 507607184,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1742764837
    },
    {
        "content": "<p>The poll from Feb 10 over [here, broken link check below] was quite strongly in favour of a \"maximally unbundled\" approach. I'm going to attempt a refactor of the library in that style.</p>",
        "id": 511360776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744277952
    },
    {
        "content": "<p>(the link is broken)</p>",
        "id": 511360919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744277999
    },
    {
        "content": "<p><a class=\"message-link\" href=\"/#narrow/channel/116395-maths/topic/Representation.20Theory/near/498720586\">#maths &gt; Representation Theory @ 💬</a></p>",
        "id": 511361062,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744278032
    },
    {
        "content": "<p>I am proposing the following definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A representation of `G` on the `k`-module `V` is TODO. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">single_one_smul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Representation</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">single_smul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">single</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">single_one_smul</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"bp\">.</span><span class=\"n\">smul_single'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul_comm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SMulCommClass</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk_of_action</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SMulCommClass</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toModuleEnd</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">smul_zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">smul_add</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">add_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">zero_smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">smul_assoc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">map_smul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toModuleEnd</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">    </span><span class=\"n\">apply_fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">single_one_smul</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"bp\">.</span><span class=\"n\">lift_single</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toModuleEnd</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">apply_fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">one_smul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toModuleEnd_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap_apply</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">of</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk_mulAction_of_module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">one_smul</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">one_smul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">mul_smul</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">map_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_smul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">smul_zero</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">smul_add</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">smul_add</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">of</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk_of_module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk_mulAction_of_module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">    </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DistribMulAction</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk_mulAction_of_module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">smul_comm</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">algebraMap_smul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">commutes</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">algebraMap_smul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">single_one_smul</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Representation</span>\n</code></pre></div>",
        "id": 511633929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373070
    },
    {
        "content": "<p>If this design isn't torn apart, then I will start building instances for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">⊗</span></span></span></span>, internal Hom, and add the notion of morphisms and subrepresentations.</p>",
        "id": 511634078,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373121
    },
    {
        "content": "<p>And then there are a few results on characters that can be carried over.<br>\nFinally, we should connect this unbundled approach to the category theory files, of which there are a few.</p>",
        "id": 511634348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373193
    },
    {
        "content": "<p>I could imagine informally that there are examples where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> acts on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> both trivially and nontrivially (for example a finite group can act on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> in more than one way). That's my reservation about making <code>Representation</code> a class.</p>",
        "id": 511635495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744373507
    },
    {
        "content": "<p>Fair enough. But I wonder if those non-trivial actions should use a type synonym.</p>",
        "id": 511635656,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373543
    },
    {
        "content": "<p>So you would make an instance of <code>Representation R G R</code> with the trivial action?</p>",
        "id": 511635822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744373584
    },
    {
        "content": "<p>Yes</p>",
        "id": 511635869,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373596
    },
    {
        "content": "<p>So then every group would act trivially on every ring in mathlib?</p>",
        "id": 511635945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744373610
    },
    {
        "content": "<p>Ouch, I hadn't thought about that yet <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 511636193,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373680
    },
    {
        "content": "<p>Even worse: every monoid on every comm-semiring...</p>",
        "id": 511636275,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744373703
    },
    {
        "content": "<p>I haven’t been following this discussion too closely. What’s the issue with just using <code>Module (MonoidAlgebra ..) ..</code>?</p>",
        "id": 511650578,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744377709
    },
    {
        "content": "<p>And derive things like <code>[SMul G V]</code> from that?</p>",
        "id": 511650984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744377820
    },
    {
        "content": "<p>I was worried that would lead to diamonds... I think we want to be able to write <code>g \\bu v</code>, and not only <code>of R G g \\bu v</code>.</p>",
        "id": 511651141,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744377861
    },
    {
        "content": "<p>Or just make up some new notation for conveniently talking about elements of G acting on V.</p>",
        "id": 511651191,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744377874
    },
    {
        "content": "<p>But you want to <code>rw [mul_smul]</code> and things like that... I guess.</p>",
        "id": 511651292,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1744377906
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_smul#doc\">docs#mul_smul</a></p>",
        "id": 511651328,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744377922
    },
    {
        "content": "<p>Ok, yeah such things would only work after breaking up the mul in the monoid algebra.</p>",
        "id": 511651610,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744378004
    },
    {
        "content": "<p>[<code>Module (MonoidAlgebra</code>...] will also not allow you have to two actions of G on k</p>",
        "id": 511691838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744388948
    },
    {
        "content": "<p>Yeah I agree. I think we should just bundle and call it a day.</p>",
        "id": 511695865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1744390434
    },
    {
        "content": "<p>Here’s a wild suggestion which has been on my mind for a while, and that I want to at least mention. </p>\n<p>It seems to me that, in informal maths, people really like naming their actions. This is already the case for some group actions (e.g the one by conjugation), but for representations I would say this is even more common (or at least in the areas I’ve been in contact with). Is there a way that we can turn <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SMul#doc\">docs#SMul</a> into a « there is a canonical action denoted in the usual way », but develop the whole theory for named actions ?</p>\n<p>To be clear I know this is quite far from anything we've done, and I expect their are some insurmountable issues. But I would really like to be able to talk about both the left and right regular representation of a (discrete) group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> on the same type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">ℓ</mi><mn>2</mn></msup><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\ell^2\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">Γ</span></span></span></span>…</p>",
        "id": 511698040,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1744391252
    },
    {
        "content": "<p>Anatole, I had the suggestion to make notation for the case of action by a type synonym. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=translate#doc\">docs#translate</a> could (almost) be defined by <code>translate a f := DomMulAct.mk a • f</code> (it's instead equal to <code>DomMulAct.mk (-a) • f</code>, but I still believe we could change it)</p>",
        "id": 511699004,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744391602
    },
    {
        "content": "<p>So my idea would be:</p>\n<ul>\n<li>Stick to <code>SMul</code> as it is today</li>\n<li>If you want a different action than the canonical <code>SMul G X</code>one, define a type synonym <code>Foo G</code> and provide <code>SMul (Foo G) X</code></li>\n<li>If you want nice <code>•</code>-like notation, define it by doing something like <code>g •Foo x := Foo.mk g • x</code></li>\n</ul>",
        "id": 511699326,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744391725
    },
    {
        "content": "<p>Eg this is what the <code>RightActions</code> scope does for you in the case of <code>Foo := MulOpposite</code></p>",
        "id": 511699409,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744391757
    },
    {
        "content": "<p>But in the context of representation theory the type alias would be on the acted on side right ?</p>",
        "id": 511699557,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1744391805
    },
    {
        "content": "<p>What's the reasoning that brings you to this conclusion?</p>",
        "id": 511699774,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744391883
    },
    {
        "content": "<p>I don’t have a complete argument (and I have to leave the discussion for now), but it feels weird to me to change the group when you are studying the representations of a fixed group.</p>",
        "id": 511700573,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1744392170
    },
    {
        "content": "<p>If a monoid has a left and a right action on a type <code>X</code>, it will be painful to have to write everytime <code>g • x</code> for the left one, and <code>toRight g • x</code> for the other one, but one could imagine that some notation makes this simpler, such as <code>g •ₗ x</code> and <code>g  •ᵣ x</code>, and why not <code>x  •ᵣ g</code>.<br>\nEspecially when <code>X</code> can be <code>G</code> itself.</p>",
        "id": 511800830,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744455628
    },
    {
        "content": "<p>It could be an interesting test of what notation works if one tries to formalize the statement and the main steps of the proof of the Skolem-Noether theorem.</p>",
        "id": 511800988,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1744455751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/511800830\">said</a>:</p>\n<blockquote>\n<p>If a monoid has a left and a right action on a type <code>X</code>, it will be painful to have to write everytime <code>g • x</code> for the left one, and <code>toRight g • x</code> for the other one, but one could imagine that some notation makes this simpler, such as <code>g •ₗ x</code> and <code>g  •ᵣ x</code>, and why not <code>x  •ᵣ g</code>.<br>\nEspecially when <code>X</code> can be <code>G</code> itself.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">RightActions</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;•</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 511805446,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744459193
    },
    {
        "content": "<p>Hi there.<br>\nI am currently working on a project of formalizing math to add to mathlib and my supervisor wants me to add Artin's theorem.<br>\nI just wanted to ask: has that already been done or is someone already working on it?</p>",
        "id": 524957082,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1750374749
    },
    {
        "content": "<p>Can you state the theorem? The Artins have proved lots of theorems.</p>",
        "id": 524959582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750377407
    },
    {
        "content": "<p>I am working on formalising a theorem of Artin (and Schreier) but I doubt it's the same one <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 524962147,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1750379159
    },
    {
        "content": "<p>It states that a character on a finite group is a rational linear combination of characters induced from all cyclic subgroups of the group</p>",
        "id": 525077426,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1750439589
    },
    {
        "content": "<p>This one:<br>\n<a href=\"https://en.wikipedia.org/wiki/Artin%27s_theorem_on_induced_characters\">https://en.wikipedia.org/wiki/Artin%27s_theorem_on_induced_characters</a></p>",
        "id": 525078562,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1750440163
    },
    {
        "content": "<p>I'd rather see Brauer's theorem (the integral version) formalised as I need this for FLT!</p>",
        "id": 525112362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750459985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/511633929\">said</a>:</p>\n<blockquote>\n<p>I am proposing the following definition<br>\n...</p>\n</blockquote>\n<p>Has this gone any further than <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...jmc-repth\">here</a>?</p>",
        "id": 525429982,
        "sender_full_name": "Raghuram",
        "timestamp": 1750729815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/511698040\">said</a>:</p>\n<blockquote>\n<p>Is there a way that we can turn <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SMul#doc\">docs#SMul</a> into a « there is a canonical action denoted in the usual way », but develop the whole theory for named actions ?</p>\n</blockquote>\n<p>BTW regarding this, how about adding notation <code>a •[rho] b</code> (and similarly for the \"sided\" notations in the <code>RightActions</code> namespace scope) where <code>rho</code> is simply the instance of <code>SMul</code>? Then the difference between defining a canonical and a named action is just <code>instance</code> vs <code>def</code>, and similarly while specifying it (this does require a coercion from any class for which one uses names instead of instances to <code>SMul</code>). If this (or allowing that coercion) is too \"invasive\", it could be scoped to a namespace (say <code>NamedActions</code>) and only for a more special class such as <code>Representation</code>.</p>",
        "id": 525430400,
        "sender_full_name": "Raghuram",
        "timestamp": 1750730306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"501683\">@Raghuram</span> Thanks for asking! I've been convinced by <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> and <span class=\"user-mention silent\" data-user-id=\"118107\">Amelia Livingston</span> that the current setup is the best option we currently have/know.<br>\nAnd the whole pipeline of PRs that Amelia has lined up is a proof that the current setup can be made to work quite well!</p>",
        "id": 525466291,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1750753703
    },
    {
        "content": "<p>Thanks for your reply. I have a couple of questions:</p>\n<ul>\n<li>Which interface does \"current setup\" refer to? <code>Representation</code> (as a non-typeclasse?), <code>Module</code>-<code>DistribMulAction</code>-<code>SMulCommClass</code>, <code>Rep</code>, <code>FDRep</code> or <code>ModuleCat (MonoidAlgebra ..)</code>?</li>\n<li>Is <a href=\"https://github.com/leanprover-community/mathlib4/pulls/101damnations\">this</a> the sequence of PRs you're referring to?</li>\n</ul>",
        "id": 525530480,
        "sender_full_name": "Raghuram",
        "timestamp": 1750774897
    },
    {
        "content": "<p>Indeed, that's the list of PRs. And they're mostly in terms of <code>Rep</code>.</p>",
        "id": 525662570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1750840938
    },
    {
        "content": "<p>I know that mathlib already has charcters of a group representation defined, but is there a way to take all the irreducible characters of a group? I'm trying to define virtual characters and need to take the free abelian group generated by all such characters.</p>",
        "id": 526502347,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751327574
    },
    {
        "content": "<p>There are several ways to write down the character of a group representation. When you say you know mathlib has them, what exactly did you have in mind? Can you write some fully working code? </p>\n<p>There are several ways to do representation theory in mathlib. Have you thought about which way is best suited for your application?</p>",
        "id": 526538134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751353515
    },
    {
        "content": "<p>I guess what I mean is I want to be able to take the set of all irreducible representations of a group, not just define a particular representation/character</p>",
        "id": 526829458,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751470216
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/526829458\">said</a>:</p>\n<blockquote>\n<p>I guess what I mean is I want to be able to take the set of all irreducible representations of a group, not just define a particular representation/character</p>\n</blockquote>\n<p>is it a set?</p>\n<p>(this is not just some off-hand comment, it's a really nasty fact that it isn't a set, and you have to do some arbitrary constructions here; it will either live one universe higher, or you'll end up with something that is horrible in some way)</p>",
        "id": 526835363,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472053
    },
    {
        "content": "<p>I looked <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/Basic.html\">at the library</a> and it doesn't seem like they defined what it means to be irreducible</p>",
        "id": 526835607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/526835363\">said</a>:</p>\n<blockquote>\n<p>is it a set?</p>\n</blockquote>\n<p>One could consider the set of irreducible quotients of the regular representation, maybe.</p>",
        "id": 526836059,
        "sender_full_name": "Raghuram",
        "timestamp": 1751472278
    },
    {
        "content": "<p>If you work with k-representation of a finite group G with (|G|, char k) = 1 then you can take all <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isotypicComponent#doc\">docs#isotypicComponent</a> of the k[G]-module k[G] and choose a simple submodule from each of them ...</p>",
        "id": 526836113,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1751472295
    },
    {
        "content": "<blockquote>\n<p>One could consider the set of irreducible quotients of the regular representation, maybe.</p>\n</blockquote>\n<p>Yeah this is more general, and mathlib knows <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isSimpleModule_iff_quot_maximal#doc\">docs#isSimpleModule_iff_quot_maximal</a><br>\nIt's still possible that different maximal (left) ideals give rise to isomorphic simple modules, so you need to take a quotient of the type of maximal ideals.</p>",
        "id": 526836543,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1751472386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> here's a mathematically correct definition that you shouldn't use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RepresentationTheory</span><span class=\"bp\">.</span><span class=\"n\">Rep</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">irreps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Skeleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">fromSkeleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">fromSkeleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 526836955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472525
    },
    {
        "content": "<p>but you would essentially want to do something like that, possibly with modification as suggested by the other helpful users above</p>",
        "id": 526837007,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472542
    },
    {
        "content": "<p>here's one implementation decision that you'll have to make <span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span>: We currently have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/Rep.html#Rep.equivalenceModuleMonoidAlgebra\">Rep.equivalenceModuleMonoidAlgebra</a> saying <code>Rep k G ≌ ModuleCat (MonoidAlgebra k G)</code>, so from this point onwards you need to decide whether you want to use <code>Rep k G</code> or whether you want to use <code>ModuleCat (MonoidAlgebra k G)</code>. The two definitions Junyan linked to above are for modules, not reps, and afaik they haven't been translated to the language of reps</p>",
        "id": 526837470,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751472719
    },
    {
        "content": "<p>I still have to figure out the stuff about universes because I don't understand why the irreducibles have to live in a higher universe, but thank you for the help</p>",
        "id": 526837908,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751472805
    },
    {
        "content": "<p>Kenny is just pointing out an analogue of the observation that the collection of all groups of order 1 isn't a set because it's \"too big to be a set\".</p>",
        "id": 526838914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751473176
    },
    {
        "content": "<p>I see. <br>\nHowever,  if I'm talking about a particular finite group, all its irreducible k-linear representations would be finite right?</p>",
        "id": 526839388,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751473335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> the set of all finite dimensional R-vector spaces is still not a set</p>",
        "id": 526839484,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473369
    },
    {
        "content": "<p>you've confused yourself by taking equivalence classes</p>",
        "id": 526839537,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473388
    },
    {
        "content": "<p>when you use i-forgot-the-name's theorem to make a neat square of irreps and conjugacy classes, you're looking at equivalence classes of irreps</p>",
        "id": 526839599,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473407
    },
    {
        "content": "<p>hmm, gpt says there's no name for that theorem</p>",
        "id": 526839965,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/526839388\">said</a>:</p>\n<blockquote>\n<p>I see. <br>\nHowever,  if I'm talking about a particular finite group, all its irreducible k-linear representations would be finite right?</p>\n</blockquote>\n<p>It looks like Lean's definition of \"equal\" is different to yours, probably that's where the problem lies. If I have a vector space V with an action of G, and then I make a new vector space by choosing an element v, removing that element from V, and adding a completely different element v' instead, giving a (different?) vector space V', and then I let G act on this new vector space V' by saying that it acts on all the other elements of V in the same way, and it acts on v' the way the old representation acted on v, would you say that V and V' were <em>equal</em>? Or would you say that they were <em>isomorphic</em>? And when you talk about \"all\" the irreducible reps of a group, do you mean that two representations are different if they are not <em>equal</em> or if they are not <em>isomorphic</em>? Welcome to formalization :-)</p>",
        "id": 526840196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751473632
    },
    {
        "content": "<p>From what I've interpreted so far: in my head I'm thinking about isomorphism classes of representations, but when I work with lean I have to treat it differently?</p>",
        "id": 526840629,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751473818
    },
    {
        "content": "<p>what you said right now is correct, when you work with lean you have to always remember that they are isomorphism classes, and two reps that are isomorphic are not \"equal\"</p>",
        "id": 526840873,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473913
    },
    {
        "content": "<p>what went wrong earlier was when you assumed that they were \"equal\" instead of \"isomorphic\"</p>",
        "id": 526840913,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751473929
    },
    {
        "content": "<p>Right, there's certainly a finite set of isomorphism classes, but Lean has two different symbols for isomorphism and for equality, that's all, they're different things. This is completely irrelevant to what you want to talk about, it's just that formalization forces you to be very precise.</p>",
        "id": 526840920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751473932
    },
    {
        "content": "<p>i gave you the code above which is one translation that is mathematically correct, but that's definitely not the <strong>only</strong> translation, and definitely not the <strong>best</strong> translation</p>",
        "id": 526841169,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474016
    },
    {
        "content": "<p>so when you're formalising, you also have to always bear in mind that there is more than one way to translate something</p>",
        "id": 526841243,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474042
    },
    {
        "content": "<p>This is not a problem in formalization, but a problem in mathematics. Here is a copy of the a page in Bourbaki's Algebra 8 volume, showing how this question can be taken care of in “standard” math. <br>\n<a href=\"/user_uploads/3121/pAMHKMRFI9bUF0dVZpGzjeiy/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/pAMHKMRFI9bUF0dVZpGzjeiy/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1088x1044\" src=\"/user_uploads/thumbnail/3121/pAMHKMRFI9bUF0dVZpGzjeiy/image.png/840x560.webp\"></a></div>",
        "id": 526841260,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474046
    },
    {
        "content": "<p>So in defining the representation ring of a finte group G (I don't think it's in mathlib yet), I think I would have to state it as the free abelian group generated by the set of isomorphism classes of irreducible representations</p>",
        "id": 526841298,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751474061
    },
    {
        "content": "<p>More or less, depending on what you mean with “set of isomorphism classes of irreducible representations”, which, itself depends on what you mean with “isomorphism classes”. If you mean that an isomorphism class is the set of all representations isomorphic to a given one, then there is no such set. But it is true (and a theorem, not a too difficult one) that there exists a set, all of whose elements are irreducible representations, such that any irreducible representation is isomorphic to exactly one of them.</p>",
        "id": 526841711,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/526841298\">said</a>:</p>\n<blockquote>\n<p>So in defining the representation ring of a finte group G (I don't think it's in mathlib yet), I think I would have to state it as the free abelian group generated by the set of isomorphism classes of irreducible representations</p>\n</blockquote>\n<p>What I've been trying to say to you is that you first need a good definition for \"set of isomorphism classes of irreducible representations\"</p>",
        "id": 526841798,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474209
    },
    {
        "content": "<p>there are at least 5 ways to do it (don't quote me on this)</p>",
        "id": 526841869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474235
    },
    {
        "content": "<p>good I understand what to do now or at least start working on</p>",
        "id": 526841940,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751474259
    },
    {
        "content": "<p>the first decision that you need to make, which I've mentioned above (and you seem to have ignored), is this: you need to choose between <code>Rep k G</code> and <code>k[G]-Module</code></p>",
        "id": 526841975,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474273
    },
    {
        "content": "<p>And <code>Representation k G V</code></p>",
        "id": 526842144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751474331
    },
    {
        "content": "<p>I understood that part</p>",
        "id": 526842145,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1751474332
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation#doc\">docs#Representation</a></p>",
        "id": 526842180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751474345
    },
    {
        "content": "<p>this latter type is not very useful in this context because it takes an additional argument (the space on which it acts).</p>",
        "id": 526842256,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474376
    },
    {
        "content": "<p><code>Rep k G</code> and <code>ModuleCat k[G]</code> are bundled versions of <code>Representation k G V</code> and <code>Module k[G] V</code> respectively</p>",
        "id": 526842385,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474423
    },
    {
        "content": "<p>\"bundle\" here meaning that V has been hidden away under it</p>",
        "id": 526842466,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751474457
    },
    {
        "content": "<p>You can take  the subtype of <code>Rep k G</code> consisting of irreducible representations, quotient by isomorphism, and you will get a type on which you can construct your representation ring. However, if <code>k G : Type u</code>, this will be <code>Type (u+1)</code> (probably bad design here, we need <code>k</code> to live in its universe, and to be <code>Small.{u}</code>) and your representation ring will be too. However, you can show that it is small and then <em>define</em> <code>IrredRep k G : Type u</code> to be its <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Shrink#doc\">docs#Shrink</a>.</p>",
        "id": 526843062,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474721
    },
    {
        "content": "<p>(Terminology: why naming it <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rep#doc\">docs#Rep</a> and not <code>RepCat</code>?)</p>",
        "id": 526843150,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474760
    },
    {
        "content": "<p>The other option (at least as soon as one does not discuss continuous representations of topological groups) to define the type of irreducible representations would be to note (as done above) that they have a model as a quotient of the group algebra, leading to a type <code>IrredRep</code> which naturally belongs to the same universe as <code>G</code>. Then, a <em>theorem</em> will prove that any irreducible representation, wherever universe it lives in, will be isomorphic to exactly one of those of that type <code>IrredType</code>.</p>",
        "id": 526843549,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1751474925
    },
    {
        "content": "<p>Here's a terrible idea:</p>\n<ol>\n<li>Let S be the set of maximal submodules of k[G] (it is really a set!).</li>\n<li>Form the k[G]-module that is the direct product of k[G]/M across M in S.</li>\n<li>Take the equivalence class of irreducible submodules of that big module.</li>\n</ol>\n<p>Now given M irreducible:</p>\n<ol start=\"4\">\n<li>For each x in M non-zero, let Ann(x) be { r : k[G] | r x = 0 }, then it is a maximal submodule.</li>\n<li>Define the following map from M to that big module:</li>\n<li>uh actually idk how to make this work maybe other people will have worse ideas, i give up lol</li>\n</ol>",
        "id": 526845893,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751475856
    },
    {
        "content": "<p>For some group/monoid G, I was told to try taking the disjoint union of all Hom(G, GL_n(k)) or Hom(G, End(k^n)) ranging over all natural n then modding by isomorphism to define the \"set of all isomorphism classes of finite dimensional k-linear representations\".<br>\nI wanted to ask if this makes sense since it's different from all the suggestions above.</p>",
        "id": 527769215,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1752007201
    },
    {
        "content": "<p>sounds good to me</p>",
        "id": 527769650,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752007417
    },
    {
        "content": "<p>Yes that's a great idea because it avoids all the foundational difficulties.</p>",
        "id": 527770199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1752007661
    },
    {
        "content": "<p>Really any construction is fine as long as you have the proper API. What I would expect is:</p>\n<ul>\n<li>the type should live in the same universe as the group (okay maybe the field has to come into play, but no +1). Otherwise we’re losing some (admittedly rarely useful) mathematical content.</li>\n<li>I really don’t think any of this is specific to finite groups, right?</li>\n<li>there should be a function building an element given an arbitrary irreducible representation, and a lemma that two representations give equal elements iff they are isomorphic.</li>\n<li>there should be a way to get back a representation from an element. This is not generally how we use quotients, but in this case mathematicians really pick representatives all the time (a bit like for L^p spaces, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.AEEqFun.instCoeFun#doc\">docs#MeasureTheory.AEEqFun.instCoeFun</a>) so it makes sense to have it.</li>\n</ul>",
        "id": 527784786,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1752016887
    },
    {
        "content": "<p>What is definitely specific to finite groups is that irreductible representations are finite dimensional.</p>",
        "id": 527785751,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1752017769
    },
    {
        "content": "<p>Sure, but the construction of the irreducible dual can be done just once for all groups (and indeed, even for all algebras instead of the ones associated with groups), so I claim we should work in this generality from the beginning.</p>",
        "id": 527880516,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1752065190
    },
    {
        "content": "<p>I'm not entirely sure how to do finite direct sums on lean; I'm trying to take k^n for some field k</p>",
        "id": 529158823,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1752696184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529158823\">said</a>:</p>\n<blockquote>\n<p>I'm not entirely sure how to do finite direct sums on lean; I'm trying to take k^n for some field k</p>\n</blockquote>\n<p>either Fin n -&gt; k or Fin n \\-&gt;\\0 k</p>",
        "id": 529177187,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752705815
    },
    {
        "content": "<p>personally i prefer the former</p>",
        "id": 529177211,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752705841
    },
    {
        "content": "<p>does this have the structure of a vector space?</p>",
        "id": 529540915,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1752886280
    },
    {
        "content": "<p>in Lean</p>",
        "id": 529540920,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1752886288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529540915\">said</a>:</p>\n<blockquote>\n<p>does this have the structure of a vector space?</p>\n</blockquote>\n<p>of course</p>",
        "id": 529568554,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752922491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529540915\">said</a>:</p>\n<blockquote>\n<p>does this have the structure of a vector space?</p>\n</blockquote>\n<p>You don't need to ask -- you can just check yourself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 529579775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1752935274
    },
    {
        "content": "<p>thank you; I wasn't aware of #synth</p>",
        "id": 529941538,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753121003
    },
    {
        "content": "<p>How can we take infinite sum types? I wanted to take the disjoint union stuff indexed by all the natural numbers</p>",
        "id": 529955105,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753126843
    },
    {
        "content": "<p>What do you want to union?</p>",
        "id": 529955135,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753126861
    },
    {
        "content": "<p>The dependent sum type is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a></p>",
        "id": 529955174,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753126880
    },
    {
        "content": "<p>I wanted to take the union of all Hom(G, End(k^n)) for all natural N</p>",
        "id": 529956006,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753127328
    },
    {
        "content": "<p>I mean all natural n</p>",
        "id": 529956039,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753127349
    },
    {
        "content": "<p>that would be done with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a> (disjoint union of <del>sets</del> types)</p>",
        "id": 529956229,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753127447
    },
    {
        "content": "<p>I don't understand how to do disjoint unions with Sigma types</p>",
        "id": 529979311,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753140787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529979311\">said</a>:</p>\n<blockquote>\n<p>I don't understand how to do disjoint unions with Sigma types</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Pi</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">Bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 529979996,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753141449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> Sigma types are explained in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html#defining-structures\">7.1 in MiL</a>. I would highly recommend reading the book.</p>",
        "id": 529980101,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753141526
    },
    {
        "content": "<p>thank you; I may also have sort of skipped that part in chapter 7</p>",
        "id": 529980483,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753141815
    },
    {
        "content": "<p>definitely looking into it more now</p>",
        "id": 529980492,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753141824
    },
    {
        "content": "<p>I don't know where I can find in mathlib that linear equivalences of modules form a group under composition which I'm pretty sure is true</p>",
        "id": 531212450,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753650283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531212450\">said</a>:</p>\n<blockquote>\n<p>I don't know where I can find in mathlib that linear equivalences of modules form a group under composition which I'm pretty sure is true</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 531212917,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753650472
    },
    {
        "content": "<p>Are there specific steps necessary to define a structure on a quotient type? I want to show that the representation ring is a semiring but I was told that I have to be careful because its elements are equivalence classes and not actually representations.</p>",
        "id": 531274477,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753678653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> yes, please use <code>Quotient.lift</code> instead of <code>Quotient.out</code> to define the functions</p>",
        "id": 531306311,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753691255
    },
    {
        "content": "<p>Do we have a notion of a direct sum of 2 representations? I know we have the tensor product but I cannot seem to find a direct sum.</p>",
        "id": 531420211,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753723169
    },
    {
        "content": "<p>We have many ways of talking about representations, your question would be easier to answer with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . Perhaps the answer is <code>V × W</code> and if it isn't then could you ask your question in code rather than in informal language?</p>",
        "id": 531422165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753723714
    },
    {
        "content": "<p>How do we say in lean that 2 k-modules M and N are isomorphic?</p>",
        "id": 531716094,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753831709
    },
    {
        "content": "<p>You give the <code>k</code>-linear equivalence between them</p>",
        "id": 531716586,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753831965
    },
    {
        "content": "<p>a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would be very helpful</p>",
        "id": 531716859,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753832123
    },
    {
        "content": "<p>but without any other context I would say <code>M ≃ₗ[k] N</code></p>",
        "id": 531716903,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753832150
    },
    {
        "content": "<p>Is that not a type? <br>\nAlso I'm not sure what to even type so I can't really show a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 531718262,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753832975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531716586\">said</a>:</p>\n<blockquote>\n<p>You give the <code>k</code>-linear equivalence between them</p>\n</blockquote>\n<p>I want to say there exists a k-linear equivalence but don't really necessarily know what it is.</p>",
        "id": 531718432,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753833079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531718432\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531716586\">said</a>:</p>\n<blockquote>\n<p>You give the <code>k</code>-linear equivalence between them</p>\n</blockquote>\n<p>I want to say there exists a k-linear equivalence but don't really necessarily know what it is.</p>\n</blockquote>\n<p>What's the context for this? Usually you want to know which <code>k</code>-linear equivalence you have.</p>",
        "id": 531718582,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753833176
    },
    {
        "content": "<p>I want to prove the following:<br>\nGiven representations (x1 x2 y1 y2 : Rep k G),  (x1 isomorphic to x2), (y1 isomorphic to y2),<br>\nthen (x1 + y1) is isomorphic to (x2 + y2)</p>",
        "id": 531718897,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753833391
    },
    {
        "content": "<p>Where by + I mean direct sum</p>",
        "id": 531718922,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753833403
    },
    {
        "content": "<p>So clearly you do want to know the specific isomorphism here</p>",
        "id": 531718964,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753833429
    },
    {
        "content": "<p>there are a lot of ways you can state this one</p>",
        "id": 531719085,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753833495
    },
    {
        "content": "<p>you would not need to use <code>Rep</code> if it was a theorem about <code>k</code>-modules so why are you using <code>Rep</code> here?</p>",
        "id": 531719245,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753833610
    },
    {
        "content": "<p>I wanted to restate representations as k[G]-modules because I think it would be easier to deal with, but also prove things for rep theory</p>",
        "id": 531719409,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753833689
    },
    {
        "content": "<p>so it depends on what you're using it for but given no additional information I would state this using the category theory</p>",
        "id": 531719741,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753833849
    },
    {
        "content": "<p>Some extra information: I ultimately want to define the representation ring which consists of equivalence classes of representations. To define the sum as the direct sum, I believe I have to show that it's independent on choice of representative.</p>",
        "id": 531719975,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753833974
    },
    {
        "content": "<p>which direct sum are you using?</p>",
        "id": 531720112,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753834040
    },
    {
        "content": "<p>For k[G]-modules V and W, V \\times W</p>",
        "id": 531720227,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753834086
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.prodCongr#doc\">docs#LinearEquiv.prodCongr</a></p>",
        "id": 531720337,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753834137
    },
    {
        "content": "<p>thank you</p>",
        "id": 531722447,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753835418
    },
    {
        "content": "<p>(sorry if this is off-topic. I just started learning a little bit of representation theory and this thread happens to be named the same)<br>\nDoes anyone know what this comment in 1000.lean is referring to? <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/docs/1000.yaml#L639\">https://github.com/leanprover-community/mathlib4/blob/master/docs/1000.yaml#L639</a></p>\n<blockquote>\n<p>title: Maschke's theorem<br>\n # <code>RepresentationTheory/Maschke</code> comes very close, but doesn't prove the standard form yet...</p>\n</blockquote>\n<p>To my untrained eyes, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/Maschke.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RepresentationTheory/Maschke.html</a> seems to be already a full formalization to Maschke's theorem comparing to other material I am reading about the theorem. What is the \"standard form\" referring to here?</p>",
        "id": 531723798,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1753836355
    },
    {
        "content": "<p>I have the following definition in terms of functions, but I want to make them into morphisms of their respective objects (first is monoid homomorphism then the second is linear maps). How would I go about doing this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Rep</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Direct sum of representations -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">dsum</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">asModule</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">asModule</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">asModule</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">asModule</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 531924205,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753907238
    },
    {
        "content": "<p>Your code has errors</p>",
        "id": 531925017,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753907539
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize\n  Ring k\n\nHint: Additional diagnostic information may be available using the `set_option diagnostics true` command.\n</code></pre></div>",
        "id": 531925057,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753907556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> the \"w\" in <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> stands for \"no errors\". I would really like to encourage you to ask questions with <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>'s as it makes them ambiguity-free. But regardless of errors, I am confused about your question because you start with terms of type <code>Rep k G</code> (i.e. objects in the category of k-linear G-reps) and then immediately turn them into k[G]-modules with <code>.ρ.asModule</code>. You and I both know that these things are \"the same\" but Lean would be the first to point out that as far as it's concerned they are not the same (they are the same mathematical information packaged up in two completely different ways). You would be better off choosing exactly one way of thinking about representations and building on that. My instinct is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Representation#doc\">docs#Representation</a> is the way which is easiest for beginners.</p>",
        "id": 531927892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753908605
    },
    {
        "content": "<p>I am surprised that I can find tensor product of representations, representations on hom sets and dual representations all in <code>Mathlib.RepresentationTheory.Basic</code> but no direct sum of two representations?</p>",
        "id": 531939126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753912869
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Representation</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">dsum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How do I turn all the functions into morphisms?</p>",
        "id": 531939734,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753913133
    },
    {
        "content": "<p>What kind of morphisms do you want?</p>",
        "id": 531945100,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753915519
    },
    {
        "content": "<p>Right now you have morphisms in the category of types</p>",
        "id": 531945128,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753915538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> let me stress that there are a lot of ways to translate a given mathematical sentence into Lean, and most often when you're just starting out, the first one you pick will not be the most conventional one.</p>\n<p>So for example here, you might view \"is isomorphic\" as a proposition, but as you've pointed out, conventionally we regard it as a type. (If you really want the proposition and have a very good reason for it, use <code>Nonempty (M ≃ₗ[k] N)</code>.)</p>",
        "id": 531949354,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917678
    },
    {
        "content": "<p>and for the latest question since you want to construct a term of type <code>Representation k G (V \\x W)</code>, you should follow <code>Representation</code> and look at its constructor.</p>",
        "id": 531949396,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917711
    },
    {
        "content": "<p>Do we not already have the split Grothendieck groups of an additive category? (And Grothendieck ring when it is monoidal?)</p>",
        "id": 531963394,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1753926909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/531945100\">said</a>:</p>\n<blockquote>\n<p>What kind of morphisms do you want?</p>\n</blockquote>\n<p>Surely the question is clear here -- they just want the direct sum as a <code>Representation</code></p>",
        "id": 531984567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753940078
    },
    {
        "content": "<p>And I couldn't find it</p>",
        "id": 531984637,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753940118
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531939126\">said</a>:</p>\n<blockquote>\n<p>I am surprised that I can find tensor product of representations, representations on hom sets and dual representations all in <code>Mathlib.RepresentationTheory.Basic</code> but no direct sum of two representations?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/27755\">#27755</a> maybe makes a start at addressing this..</p>",
        "id": 532107249,
        "sender_full_name": "Bryan Wang",
        "timestamp": 1753976322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531949354\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> let me stress that there are a lot of ways to translate a given mathematical sentence into Lean, and most often when you're just starting out, the first one you pick will not be the most conventional one.</p>\n<p>So for example here, you might view \"is isomorphic\" as a proposition, but as you've pointed out, conventionally we regard it as a type. (If you really want the proposition and have a very good reason for it, use <code>Nonempty (M ≃ₗ[k] N)</code>.)</p>\n</blockquote>\n<p>I made a proposition on if 2 representations are isomorphic and used it as an equivalence relation to make a quotient type. Though I'm not too sure if this is the right approach.</p>",
        "id": 532144249,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753987134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/531963394\">said</a>:</p>\n<blockquote>\n<p>Do we not already have the split Grothendieck groups of an additive category? (And Grothendieck ring when it is monoidal?)</p>\n</blockquote>\n<p>If we do, I have heard that the representation ring is just the Grothendieck ring in the category Rep. I'm not sure how to deal with it though so I have just been working explicitly with Representation.</p>",
        "id": 532144531,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1753987232
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> yes, that is the right approach, but you should also have the versions without <code>Nonempty</code>, and only include the <code>Nonempty</code> in the last step</p>",
        "id": 532154909,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753991021
    },
    {
        "content": "<p>What I did was make the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Representation</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">isom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>",
        "id": 532183742,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754003188
    },
    {
        "content": "<p>You don't want to do that, you want to give the data. It's much easier to work with in a theorem prover. It's surprising how often a mathematician says \"theorem: there exists an isomorphism\" when what they mean is \"definition: we're only ever talking about this isomorphism\". An example is the first isomorphism\"theorem\" which doesn't say \"G/ker is iso to image\", it says \"...and we always use this specific isomorphism so we can do diagram chases\". You can't get that data out of an abstract Prop</p>",
        "id": 532242309,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1754032727
    },
    {
        "content": "<p>I'm sorry it's taken so long for me to get back to your questions Jester. Here is a more idiomatic way to define direct sum of two representations and equivalence of representations in the <code>Representation</code> world:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prodMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RepresentationEquiv</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">toFun</span>\n</code></pre></div>\n<p>On top of that you could define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">isom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RepresentationEquiv</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but even though this is how mathematicians are trained to think, this concept is less fundamental in the formalisation of mathematics and probably doesn't need its own definition.</p>",
        "id": 532279925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1754045557
    },
    {
        "content": "<p>So if a proposition isn't the best way to get an equivalence relation to define a setoid, what should I do to mod out the representations by isomorphism?</p>",
        "id": 533208939,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754535906
    },
    {
        "content": "<p>Is it <em>useful</em> to mod out representations by isomorphisms?</p>",
        "id": 533213439,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1754539857
    },
    {
        "content": "<p>only when you're dealing with size issues</p>",
        "id": 533222005,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754546216
    },
    {
        "content": "<p>this thread has been going on so long that i forgot what the original moivationi was, but there are certainly some situations where you would need to deal with size issues</p>",
        "id": 533222124,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754546310
    },
    {
        "content": "<p>e.g. it's a famous theorem that the character table is a square</p>",
        "id": 533222148,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754546323
    },
    {
        "content": "<p>I'm trying to define the representation ring which is a quotient of representations by isomorphism</p>",
        "id": 533291423,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754572803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529979996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529979311\">said</a>:</p>\n<blockquote>\n<p>I don't understand how to do disjoint unions with Sigma types</p>\n</blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Pi</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">Bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>So I was gonna use this and then mod out by the equivalence relation of isomorphism</p>",
        "id": 533292286,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754573052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> yes, that is good, but i'm saying that the \"main\" stuffs should not be propositions</p>",
        "id": 533295051,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754573844
    },
    {
        "content": "<p>e.g. taking the direct sum of two representations shouldn't be a proposition</p>",
        "id": 533295092,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754573857
    },
    {
        "content": "<p>(the thing that we discovered was missing)</p>",
        "id": 533295128,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754573868
    },
    {
        "content": "<p>yes that part I understand at least</p>",
        "id": 533295319,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754573920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> I suspect you might not ever need to mod Rep.Bound out by isomorphism</p>",
        "id": 533295555,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754573986
    },
    {
        "content": "<p>how should I define the representation ring?</p>",
        "id": 533295710,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754574030
    },
    {
        "content": "<p>maybe something similar to <a href=\"https://github.com/leanprover-community/mathlib4/pull/25337/files#diff-144b5f64627ab06b282beea08690707af5f05eb0dd0043b2669b4f3e208322e6R322\">Pic</a>?</p>",
        "id": 533296025,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574121
    },
    {
        "content": "<p>i.e. <code>Shrink</code> the <code>Rep</code> category and hope that you get a semiring...</p>",
        "id": 533296130,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574142
    },
    {
        "content": "<p>btw how do you make the <em>ring</em> after modding out <code>Rep.Bound</code> in your original proposal?</p>",
        "id": 533296231,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574168
    },
    {
        "content": "<p>I was told to prove that sums and products are invariant under choice of representative; i.e. if M = M' and N = N' then M+N = M' + N'</p>",
        "id": 533296596,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754574273
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRingCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Skeleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Skeleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ModuleCat</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 533296602,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574274
    },
    {
        "content": "<p>I think we need more infrastructure to make this one work...?</p>",
        "id": 533296643,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/533296596\">said</a>:</p>\n<blockquote>\n<p>I was told to prove that sums and products are invariant under choice of representative; i.e. if M = M' and N = N' then M+N = M' + N'</p>\n</blockquote>\n<p>Then I think this allows me to use direct sum and tensor product as semiring operations on the quotient type</p>",
        "id": 533296784,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754574327
    },
    {
        "content": "<p>and then how do you get the ring?</p>",
        "id": 533296865,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574352
    },
    {
        "content": "<p>you probably do the Grothendieck construction?</p>",
        "id": 533296889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574359
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 533297018,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/533296865\">said</a>:</p>\n<blockquote>\n<p>and then how do you get the ring?</p>\n</blockquote>\n<p>I forgot but my supervisor told me how it's constructed; I was planning to ask him once I finished the semiring step</p>",
        "id": 533297071,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754574420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> AddCommMonoid (CategoryTheory.Skeleton _)<br>\n<span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> AddMonoid (CategoryTheory.Skeleton _)<br>\n<span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Add (CategoryTheory.Skeleton _)<br>\n<span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> Zero (CategoryTheory.Skeleton _)</p>",
        "id": 533297094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574426
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 533297097,
        "sender_full_name": "loogle",
        "timestamp": 1754574427
    },
    {
        "content": "<p>yeah I think we're missing infrastructure</p>",
        "id": 533297186,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> I advise you to provide the infrastructure as stated above, and then just <code>Shrink</code> the whole thing in the end; it will be mathematically isomorphic to the semiring you construct in the other proposal</p>",
        "id": 533297901,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574643
    },
    {
        "content": "<p>(and much more easier to work with)</p>",
        "id": 533297953,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754574656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> Could you remind me the use of the rep ring?</p>",
        "id": 533358126,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754597974
    },
    {
        "content": "<p>I believe actually the importance is virtual characters, because that's what is used in Artin's theorem on induced characters</p>",
        "id": 533370117,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754604811
    },
    {
        "content": "<p>so I think we can map each representation to its character in the ring of class functions of a finite group G</p>",
        "id": 533370205,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754604867
    },
    {
        "content": "<p>But you don't need to do anything complicated like you're doing to prove Artin's theorem, this is just messing around with functions from G to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mord\">.</span></span></span></span> We need Artin's theorem for FLT by the way!</p>",
        "id": 533419472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1754641447
    },
    {
        "content": "<p>Serre's linear representations of finite groups proof of Artin's theorem relies on it does it not?</p>",
        "id": 533650924,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1754831332
    },
    {
        "content": "<p>I don't know, I'm in a field for the week. Why not sketch the proof here?</p>",
        "id": 533992899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755008571
    },
    {
        "content": "<p>I apologize for the late response, but I think Serre basically states Artin’s theorem as a corollary to this</p>",
        "id": 535233455,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755661719
    },
    {
        "content": "<p>Let X be a family of subgroups of a finite group G. Let Ind: \\oplus_{H in X} R(H) \\to R(G) be defined by the family of Ind H. Then the following are equivalent:</p>\n<p>(i) G is the union of the conjugates of subgroups in X</p>\n<p>(ii) The cokernel of Ind is finite</p>",
        "id": 535233471,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755661733
    },
    {
        "content": "<p>Here R(H)/R(G) is the virtual characters which I think is isomorphic to their respective representation rings</p>",
        "id": 535233540,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755661823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/533297901\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> I advise you to provide the infrastructure as stated above, and then just <code>Shrink</code> the whole thing in the end; it will be mathematically isomorphic to the semiring you construct in the other proposal</p>\n</blockquote>\n<p>I don't fully understand what you're suggesting and the stuff about skeletons and shrinking in Lean, so I have decided to continue the painstaking process of constructing the representation ring. This is also because I understand this more and already have some work done on it and I don't have much time left to work.</p>",
        "id": 535233728,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755662031
    },
    {
        "content": "<p>How do we construct a specific element of a sigma type? I want to define a function (specifically addition) for the following:<br>\n<span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529979996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/529979311\">said</a>:</p>\n<blockquote>\n<p>I don't understand how to do disjoint unions with Sigma types</p>\n</blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Pi</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rep</span><span class=\"bp\">.</span><span class=\"n\">Bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 535234169,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755662486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/535234169\">said</a>:</p>\n<blockquote>\n<p>How do we construct a specific element of a sigma type?</p>\n</blockquote>\n<p>\\&lt;a, b\\&gt;</p>",
        "id": 535261452,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755677726
    },
    {
        "content": "<p>Is there an k-linear isomorphism of vector spaces between k^n*k^m and k^(n+m) in mathlib?<br>\nI want to write the product representation as a representation of k^(n+m) rather than the former.</p>",
        "id": 535373211,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755716327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/535373211\">said</a>:</p>\n<blockquote>\n<p>Is there an k-linear isomorphism of vector spaces between k^n*k^m and k^(n+m) in mathlib?<br>\nI want to write the product representation as a representation of k^(n+m) rather than the former.</p>\n</blockquote>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Pi.html#LinearEquiv.sumArrowLequivProdArrow\">LinearEquiv.sumArrowLequivProdArrow</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Equiv/Basic.html#LinearEquiv.funCongrLeft\">LinearEquiv.funCongrLeft</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Fin/Basic.html#finSumFinEquiv\">finSumFinEquiv</a></li>\n</ol>",
        "id": 535374660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755716900
    },
    {
        "content": "<p>thank you</p>",
        "id": 535374870,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1755716962
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/532279925\">said</a>:</p>\n<blockquote>\n<p>I'm sorry it's taken so long for me to get back to your questions Jester. Here is a more idiomatic way to define direct sum of two representations and equivalence of representations in the <code>Representation</code> world:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prodMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RepresentationEquiv</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">smul</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">toFun</span>\n</code></pre></div>\n<p>On top of that you could define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">isom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RepresentationEquiv</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but even though this is how mathematicians are trained to think, this concept is less fundamental in the formalisation of mathematics and probably doesn't need its own definition.</p>\n</blockquote>\n<p>For this definition of Equivalence, is there a way to extend the definition so that given some (x : RepresentationEquiv ...) I can use (x.trans, x.symm) including the structure of smul?</p>",
        "id": 536878692,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1756516589
    },
    {
        "content": "<p>Hopefully that question makes sense</p>",
        "id": 536878719,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1756516626
    },
    {
        "content": "<p>Yeah you would have to build API for <code>RepresentationEquiv</code> just like any other definition needs API. Take a look at the mathlib definitions of eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv#doc\">docs#LinearEquiv</a> , they no doubt come with hundreds of lines of boilerplate code directly after. </p>\n<p>The specific problem with representation theory is that the community seems confused about whether to develop the API for <code>Representation</code> or <code>Rep/FDRep</code>, so statements of the form \"why don't morphisms/isomorphisms of <code>Representation</code> exist?\" might be met with answers of the form \"well morphisms and isomorphisms of objects in categories exist so use those instead\". Historically for most branches of basic algebra (eg groups, rings, modules) the elementary approach existed before category theory in mathlib was even viable, so the structure was built up in the non-category way. But for representation theory this didn't occur and now we have this kind of mess.</p>",
        "id": 536898479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756540776
    },
    {
        "content": "<p>I'm trying to prove a fact about a quotient type with the following tactic:<br>\n\"induction q using Quotient.ind\" where q is a variable in the type, but when I do this it removes the variable name and replaces it with \"a✝\".<br>\nHow do I add a label to this variable so that I can refer to it in my proof?</p>",
        "id": 537949128,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757107268
    },
    {
        "content": "<p><code>induction q using Quotient.ind with | _ q =&gt;</code></p>",
        "id": 537949495,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757107496
    },
    {
        "content": "<p>thank you very much</p>",
        "id": 537952146,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757109150
    },
    {
        "content": "<p>does mathlib have a notion of a zero-dimensional vector space and thus a zero representation?</p>",
        "id": 538100575,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757273614
    },
    {
        "content": "<p>I think you probably want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsingleton#doc\">docs#Subsingleton</a></p>",
        "id": 538101662,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1757274960
    },
    {
        "content": "<p>For example, here is how you prove that every vector is zero in this setting:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Field.Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Module.Defs</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Subsingleton.elim</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 538101914,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1757275271
    },
    {
        "content": "<p>Lastly see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.finrank_zero_of_subsingleton#doc\">docs#Module.finrank_zero_of_subsingleton</a></p>",
        "id": 538101962,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1757275331
    },
    {
        "content": "<p>thank you</p>",
        "id": 538136884,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757310511
    },
    {
        "content": "<p>Is there also a defined linear equivalence between finite dimensional V and k^n or should I definite it myself?</p>",
        "id": 538136958,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757310555
    },
    {
        "content": "<p>You'll need to choose a basis but then it's there</p>",
        "id": 538143357,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757314054
    },
    {
        "content": "<p>And if you don't have a basis to hand then you can obtain one via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Free.chooseBasis#doc\">docs#Module.Free.chooseBasis</a></p>",
        "id": 538153535,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1757317986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/535374660\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/535373211\">said</a>:</p>\n<blockquote>\n<p>Is there an k-linear isomorphism of vector spaces between k^n*k^m and k^(n+m) in mathlib?<br>\nI want to write the product representation as a representation of k^(n+m) rather than the former.</p>\n</blockquote>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Pi.html#LinearEquiv.sumArrowLequivProdArrow\">LinearEquiv.sumArrowLequivProdArrow</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Equiv/Basic.html#LinearEquiv.funCongrLeft\">LinearEquiv.funCongrLeft</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Logic/Equiv/Fin/Basic.html#finSumFinEquiv\">finSumFinEquiv</a></li>\n</ol>\n</blockquote>\n<p>Are there analogous theorems to construct a k-linear equivalence between (k^n \\otimes k^m) and (k^(n*m))?</p>",
        "id": 539162571,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757711084
    },
    {
        "content": "<p>also, is there a way to refer to a component of a pure tensor<br>\nv⊗ₜ[k] w</p>",
        "id": 539166253,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757713264
    },
    {
        "content": "<p>nvm about that last question actually I think I need to figure out first how to take a variable (u : V ⊗[k] W) and decompose it using the basis of pure tensors</p>",
        "id": 539166837,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757713558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539162571\">said</a>:</p>\n<blockquote>\n<p>Are there analogous theorems to construct a k-linear equivalence between (k^n \\otimes k^m) and (k^(n*m))?</p>\n</blockquote>\n<p>We seem to be missing this, the closest one is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsuppTensorFinsupp%27#doc\">docs#finsuppTensorFinsupp'</a> with finsupp</p>",
        "id": 539167711,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757714010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539166253\">said</a>:</p>\n<blockquote>\n<p>also, is there a way to refer to a component of a pure tensor<br>\nv⊗ₜ[k] w</p>\n</blockquote>\n<p>you first need to show that it forms a basis, which is some more work built upon the my previous comment</p>",
        "id": 539167807,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757714059
    },
    {
        "content": "<p>Is it a mathematical fact that we can take any u in the vector space V ⊗ₜ[k] W and express it as v ⊗ₜ[k] w for some  (v : V) (w : W)</p>",
        "id": 539173828,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757717167
    },
    {
        "content": "<p>no I'm pretty sure that's false</p>",
        "id": 539173863,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757717190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539173828\">said</a>:</p>\n<blockquote>\n<p>Is it a mathematical fact that we can take any u in the vector space V ⊗ₜ[k] W and express it as v ⊗ₜ[k] w for some  (v : V) (w : W)</p>\n</blockquote>\n<p>what is true is that you can express it as the sum of finitely many of those, and that is in mathlib</p>",
        "id": 539175528,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757718210
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/TensorProduct/Finiteness.html#TensorProduct.exists_finset\">TensorProduct.exists_finset</a></p>",
        "id": 539175617,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757718269
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>",
        "id": 539175649,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757718282
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539175528\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539173828\">said</a>:</p>\n<blockquote>\n<p>Is it a mathematical fact that we can take any u in the vector space V ⊗ₜ[k] W and express it as v ⊗ₜ[k] w for some  (v : V) (w : W)</p>\n</blockquote>\n<p>what is true is that you can express it as the sum of finitely many of those, and that is in mathlib</p>\n</blockquote>\n<p>Oh yes that is what I need; thank you</p>",
        "id": 539179519,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757720977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/539173828\">said</a>:</p>\n<blockquote>\n<p>Is it a mathematical fact that we can take any u in the vector space V ⊗ₜ[k] W and express it as v ⊗ₜ[k] w for some  (v : V) (w : W)</p>\n</blockquote>\n<p>The way to see that this is false is to look at the following model: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is length 2 row vectors, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> is length 2 column vectors, and then a model for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> is 2 by 2 matrices, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> being modelled as the product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">vw</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> (product of a 2x1 and 1x2 matrix is a 2x2 matrix). It's not hard to see that 2x2 matrices of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">vw</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> are very special -- they all have rank at most 1. So a special case of your question is \"does every 2x2 matrix have rank at most 1?\" and the identity matrix is a counterexample.</p>",
        "id": 539179741,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757721105
    },
    {
        "content": "<p>It's nice to have toy models for lots of things in mathematics. Tensor products are very abstract objects and they're only defined by this funny universal property, which means they're only defined up to unique isomorphism as opposed to being defined on the nose. Mathlib has <code>TensorProduct</code> (a concrete model, defined as a quotient of a hugely infinite object which is totally hopeless to compute with) but it also has <code>IsTensorProduct</code> (where you can use far more concrete models). The concrete model of matrices as tensor products of vector spaces was super-helpful for me when getting oriented with tensor products.</p>",
        "id": 539179982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757721252
    },
    {
        "content": "<p>It's also very disconcerting to discover that a general element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> cannot be written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>. For many other constructions in mathematics, for example direct sums, products, quotients etc it's very easy to write down a general formula for an element of this exotic new object and get a clear understanding as to what extent the formula uniquely defines the element (for example an element of a  product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\times Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is just a pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>, and an element of a quotient group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G/H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> is a coset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">gH</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> or you can think of it as an equivalence class <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>g</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[g]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy=\"false\">]</mo><mo>=</mo><mo stretchy=\"false\">[</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[g_1]=[g_2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> iff <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>g</mi><mn>1</mn><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>g</mi><mn>2</mn></msub><mo>∈</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">g_1^{-1}g_2\\in H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1205em;vertical-align:-0.2663em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8542em;\"><span style=\"top:-2.4337em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span><span style=\"top:-3.1031em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2663em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span>). But for tensor products this sort of concrete way of modelling elements is completely hopeless. We know that elements of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> give you elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> and it's a theorem that every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> can be written as a finite sum of things of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>, but trying to figure out e.g. if two finite sums represent the same element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, or (equivalently) trying to work out if a finite sum of explicit elements of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> is zero or not, can be an extremely hard problem. So it's far more difficult to do concrete calculations with tensor products than it is to do calculations with other objects like direct products, and you often have to resort to the universal property, or earlier-proved theorems, if you want to reason about it.</p>",
        "id": 539180477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757721583
    },
    {
        "content": "<p>In mathlib we have some very nice universal properties for tensor products, such as \"if you're trying to prove things about all elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>, and if you can prove it for elements of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span> and if you can also show that if your property is true for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> then it's true for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a+b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>, then your property is true for all elements of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">V\\otimes W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span>. This is another (rather nice) way of saying that every element is a finite linear combination of things of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>⊗</mo><mi>w</mi></mrow><annotation encoding=\"application/x-tex\">v\\otimes w</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span></span></span></span>.</p>",
        "id": 539180788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757721737
    },
    {
        "content": "<p>Is there a difference between (Fin n to k) and the Finsupp version?<br>\nI understand Lean treats them as different types but is there a difference mathematically?</p>",
        "id": 539212574,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1757741637
    },
    {
        "content": "<p>Finitely-supported functions from a type to k will embed into all functions from that type to k, and the embedding will be a bijection if the source type is finite yes.</p>",
        "id": 539253493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757752101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Finsupp/Defs.html#Finsupp.linearEquivFunOnFinite\">Finsupp.linearEquivFunOnFinite</a></p>",
        "id": 539533276,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757936548
    },
    {
        "content": "<p>I want to define a function on an element v of a tensor product, but I want to define it in terms of  a finite sum of pure tensors. I know using TensorProduct.exists_finset that I can rewrite v, but I do not understand how to use this rewrite in a function definition.</p>",
        "id": 540341515,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1758236493
    },
    {
        "content": "<p>can you do it inductively or use the universal property?</p>",
        "id": 540342207,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758236647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/540341515\">said</a>:</p>\n<blockquote>\n<p>using TensorProduct.exists_finset</p>\n</blockquote>\n<p>this is already a bad idea mathematically, because there are different ways to represent the same tensor, so you'll need to prove that your definition is independent of the way to express it.</p>\n<p>for example going back to 2x2-matrix, where <code>v1⊗v2</code> is the matrix <code>v1 v2^T</code> where <code>v1</code> and <code>v2</code> are column vectors, then (1 0; 0 1) is e1⊗e1 + e2⊗e2, but it's also (e1+e2)⊗(e1-e2) - e2⊗e1 + e1⊗e2 + 2e2⊗e2</p>\n<p>mathematically, the correct way to define a function on V⊗W is to use the universal property, which says that a linear map V⊗W -&gt; M corresponds to a bilinear map V x W -&gt; M</p>",
        "id": 540342919,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758237059
    },
    {
        "content": "<p>right that makes sense</p>",
        "id": 540343022,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1758237150
    },
    {
        "content": "<p>I'm really struggling with proving that the tensor product of  representations distributes over direct sum of representations. I know what the map is or should be between the spaces, but I can't figure out how to define it in Lean.</p>",
        "id": 540355375,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1758244195
    },
    {
        "content": "<p>I'm trying to define the isomorphism using this answer in stack exchange:<br>\n<a href=\"https://math.stackexchange.com/questions/805019/distributivity-of-tensor-products-over-direct-sums-for-group-representations\">https://math.stackexchange.com/questions/805019/distributivity-of-tensor-products-over-direct-sums-for-group-representations</a></p>",
        "id": 540355599,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1758244401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> you shouldn't need to prove it yourself, every standard fact would be in mathlib already</p>",
        "id": 540411713,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758274221
    },
    {
        "content": "<p>The product/sum of representations was not even defined before; I don't think the actual isomorphism has been defined in Mathlib</p>",
        "id": 541139915,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1758688157
    },
    {
        "content": "<p>It's just <code>M \\times N</code>. It's certainly there.</p>",
        "id": 541141801,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1758689339
    },
    {
        "content": "<p>Note that the \"product\" of representations in your ring will be <code>Representation.tprod</code>, and <code>M \\times N = Representation.prod M N</code> is the product of the <em>types</em> <code>M</code> and <code>N</code>, which is algebraically the direct sum — you can see this if you look at the definition of <code>DirectSum</code>, which is a pi-type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DirectSum</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">Π₀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>(ignoring what changes when the sum is infinite)</p>",
        "id": 541500999,
        "sender_full_name": "Thomas Waring",
        "timestamp": 1758817739
    },
    {
        "content": "<p>ah, that reminds me, <code>Representation.tprod</code> really shoud be renamed (since it clashes with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tprod#doc\">docs#tprod</a>)</p>",
        "id": 541505594,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1758819338
    },
    {
        "content": "<p>Using TensorProduct.exists_finset I know that anything in (V \\otimes W) is a finite sum of pure tensors, but is there a way I can use this to prove that anything in (V \\otimes W) \\otimes U is a finite sum of pure tensors of 3 vectors?</p>",
        "id": 543216812,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1759725037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> yes, tensor distributes over addition, and you can choose a finset for each one again</p>",
        "id": 543253148,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759740816
    },
    {
        "content": "<p>i.e.given x in (V ⊗ W) ⊗ U, write it as ∑ vw_i ⊗ₜ u_i, then for each i write vw_i as ∑ v_ij ⊗ₜ w_ij, then x = ∑∑ v_ij ⊗ₜ w_ij ⊗ₜ u_i</p>",
        "id": 543253533,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759740909
    },
    {
        "content": "<p>the \"for each i\" part is the <code>choose</code> tactic</p>",
        "id": 543253576,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759740923
    },
    {
        "content": "<p>What would that look like in lean?</p>",
        "id": 544069181,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760058090
    },
    {
        "content": "<p>nevermind I think I can figure it out myself</p>",
        "id": 544069281,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760058155
    },
    {
        "content": "<p>is there a way to turn a semiring into a ring similar to how we can turn a commutative monoid into a commutative group using the grothendieck group?</p>",
        "id": 544070667,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760059148
    },
    {
        "content": "<p>grothendieck ring?</p>",
        "id": 544071576,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760059721
    },
    {
        "content": "<p>it's the \"ring of differences\"</p>",
        "id": 544071612,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760059742
    },
    {
        "content": "<p>the left adjoint to the forgetful functor from rings to semirings</p>",
        "id": 544071707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760059792
    },
    {
        "content": "<p>(I'm assuming you're talking about unital rings but I don't see why it shouldn't work with nonunital rings too)</p>",
        "id": 544071755,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760059822
    },
    {
        "content": "<p>where can I find that in mathlib?</p>",
        "id": 544077910,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760064329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/543253533\">said</a>:</p>\n<blockquote>\n<p>i.e.given x in (V ⊗ W) ⊗ U, write it as ∑ vw_i ⊗ₜ u_i, then for each i write vw_i as ∑ v_ij ⊗ₜ w_ij, then x = ∑∑ v_ij ⊗ₜ w_ij ⊗ₜ u_i</p>\n</blockquote>\n<p>So I've used the choose tactic and gotten a hypothesis of the form \"For all w in (V ⊗ W), w =  ∑  ...\". <br>\nHow can I rewrite x in terms of this? I can't seem to get rw to work with it.</p>",
        "id": 544086981,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760072357
    },
    {
        "content": "<p>I don't understand how to use rw to rewrite the elements \"vw_i\" in the summation</p>",
        "id": 544089033,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760073763
    },
    {
        "content": "<p>Could you post an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? It is very unlikely that writing a general element as a sum over pure tensors is the right approach. Instead, it is often easier to use so called \"induction principles\". These are statements of the form: \"If the claim holds for the zero element, is stable under addition and holds for all pure tensors, then it is true for every element of the tensor product\" (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.induction_on#doc\">docs#TensorProduct.induction_on</a>).</p>",
        "id": 544089598,
        "sender_full_name": "Christian Merten",
        "timestamp": 1760074204
    },
    {
        "content": "<p>There's a few representation isomorphisms I was defining using tensor product module isomorphisms (distributivity over direct sum,  tensor product with 0 is still zero) so I had to show they commute with the g-action. In every case except associativity, simply just using \"exists_finset\" for any vector in the tensor product sufficed. <br>\nI think these induction principles could work so I'll try it.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544089598\">said</a>:</p>\n<blockquote>\n<p>Could you post an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? It is very unlikely that writing a general element as a sum over pure tensors is the right approach. Instead, it is often easier to use so called \"induction principles\". These are statements of the form: \"If the claim holds for the zero element, is stable under addition and holds for all pure tensors, then it is true for every element of the tensor product\" (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.induction_on#doc\">docs#TensorProduct.induction_on</a>).</p>\n</blockquote>",
        "id": 544090767,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760075089
    },
    {
        "content": "<p>Yes the induction principles should be perfect for checking G-actions.</p>",
        "id": 544098029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1760079156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544077910\">said</a>:</p>\n<blockquote>\n<p>where can I find that in mathlib?</p>\n</blockquote>\n<p>Probably not exactly this is in mathlib but maybe if you're lucky you'll find something like \"all algebraic theories are monadic\"</p>",
        "id": 544132096,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760091018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544090767\">said</a>:</p>\n<blockquote>\n<p>these induction principles could work</p>\n</blockquote>\n<p>these new ways are more unfamiliar but in my experience better, that's just a fact of life that you'll have to go through</p>",
        "id": 544132936,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760091285
    },
    {
        "content": "<p>So I need to show this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"bp\">⇑</span><span class=\"o\">(((</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">((</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>where v is an element of (V \\otimes W) \\otimes U, but when I try to apply the theorem \"TensorProduct.induction_on\" it doesn't seem to work properly. Am I just doing it wrong?</p>",
        "id": 544227484,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760121313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> <code>induction v using TensorProduct.induction_on</code></p>",
        "id": 544228986,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760122011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544228986\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <code>induction v using TensorProduct.induction_on</code></p>\n</blockquote>\n<p>When I do this, I get  an implicit variable in  (V \\otimes W). How can I use this variable as an explicit term?</p>",
        "id": 544289079,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760159336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544289079\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Representation.20Theory/near/544228986\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"926344\">Jester Cabading</span> <code>induction v using TensorProduct.induction_on</code></p>\n</blockquote>\n<p>When I do this, I get  an implicit variable in  (V \\otimes W). How can I use this variable as an explicit term?</p>\n</blockquote>\n<p>when you hover over <code>induction</code> you get the instruction manual</p>",
        "id": 544289637,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760160006
    },
    {
        "content": "<p>see the part with <code>with</code></p>",
        "id": 544289643,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760160011
    },
    {
        "content": "<p>it keeps saying unknown tactic when I try to use with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">tmul</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 544290400,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760160900
    },
    {
        "content": "<p>did you <code>import Mathlib</code>?</p>",
        "id": 544290592,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760161084
    },
    {
        "content": "<p>yes</p>",
        "id": 544290843,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760161356
    },
    {
        "content": "<p>can you post <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 544290880,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760161406
    },
    {
        "content": "<p>well it doesn't work so I don't think it counts as a mwe</p>",
        "id": 544290991,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760161519
    },
    {
        "content": "<p>but I can post what I have written so far</p>",
        "id": 544291002,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760161532
    },
    {
        "content": "<p>A MWE needs to work not in the sense that it builds fully, but in the sense that it shows the error/problem you are encountering</p>",
        "id": 544291030,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760161566
    },
    {
        "content": "<p>otherwise there would be no point in posting an mwe</p>",
        "id": 544291115,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760161636
    },
    {
        "content": "<p>that makes sense</p>",
        "id": 544291143,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760161659
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Representation</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RepEquiv</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">toFun</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tprod_assoc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RepEquiv</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">tprod</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"n\">toLinearEquiv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">U</span>\n<span class=\"n\">smul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">tmul</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 544291471,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760162026
    },
    {
        "content": "<p>from what I understand, \"with\" for induction allows you to add names for the variables</p>",
        "id": 544291573,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760162145
    },
    {
        "content": "<p>You are writing <code>| tmul =&gt; x y</code> but the syntax is <code>| tmul x y =&gt; _</code></p>",
        "id": 544291715,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1760162319
    },
    {
        "content": "<p>ah ok thank you</p>",
        "id": 544291862,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760162458
    },
    {
        "content": "<p>So characters have been defined and developed in FDRep; I want to be able to use characters and those properties, but everything I've been working with is in Representation k G. I imagine I'd have to do some functorial stuff to show that RepEquiv (which is defined in the code above) is the same as an isomorphism in Rep. Is this the way go about it?</p>",
        "id": 544363382,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760234278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> yes, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Category/Ring/Basic.html#RingEquiv.toCommRingCatIso\">RingEquiv.toCommRingCatIso</a> for example</p>",
        "id": 544378063,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760253331
    },
    {
        "content": "<p>So I have instantiated the Representation Ring as a semiring; is there a way to use the Grothendieck construction to turn a semiring into a ring?</p>",
        "id": 544850517,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760483339
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/GroupTheory/MonoidLocalization/GrothendieckGroup.html#Algebra.GrothendieckAddGroup\">Algebra.GrothendieckAddGroup</a> but you might need to first turn it to a ring</p>",
        "id": 544852716,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760484985
    },
    {
        "content": "<p>my goal is to get a ring, but I can only know how to define it as a semiring</p>",
        "id": 544856234,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760487835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"926344\">@Jester Cabading</span> i'm saying my linked thing gives you an abelian group which is the correct ring except that the ring structure hasn't been defined</p>",
        "id": 544856396,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760487907
    },
    {
        "content": "<p>oh I see what you mean</p>",
        "id": 544857296,
        "sender_full_name": "Jester Cabading",
        "timestamp": 1760488655
    }
]