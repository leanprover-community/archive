[
    {
        "content": "<p>I was reading through a Representation Theory textbook and a question came to my mind: Have the theory been implemented in any LEAN library?</p>",
        "id": 178343253,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571276342
    },
    {
        "content": "<p>No, there's essentially no representation theory at this point (although there is some commutative algebra).</p>",
        "id": 178344006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571277587
    },
    {
        "content": "<p>Thank you for answering. If so, how much it will be worth (for this community) to implement the theory in a library? It's a classical theory, but the fact that it is not yet implemented seems to somewhat imply that there are more urgent needs for other theories now. I want to know the context if any exists.</p>",
        "id": 178345476,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571279772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242240\">@Jineon Baek</span> It only somewhat implies that we don't have enough people power. It's a relatively small group of contributors, and they just hack on whatever they think is fun.</p>",
        "id": 178345702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280156
    },
    {
        "content": "<p>There are several people on this chat that think that representation theory is extremely important. But we just haven't got round to doing anything so far.</p>",
        "id": 178345714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280198
    },
    {
        "content": "<p>At some point <span class=\"user-mention\" data-user-id=\"220718\">@Ben McDonnell</span> started working on some rep.theory. Maybe he can share what he's got so far somewhere.</p>",
        "id": 178345726,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571280238
    },
    {
        "content": "<p>Yes, I'd love to see some! A lot depends on what generality you want to do things in, and often for mathlib the answer is \"a lot of generality\".</p>",
        "id": 178346393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281376
    },
    {
        "content": "<p>The theory of abelian categories is on the horizon, and might be useful to have in place, so if someone wants to work on that I'd be happy to provide some pointers (and get around to doing some of the things I promised to do).</p>",
        "id": 178346406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281424
    },
    {
        "content": "<p>But generally --- pick a (good) book, and have a go. :-)</p>",
        "id": 178346410,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281441
    },
    {
        "content": "<p>I'd love to see someone start on Etingof's Representation Theory: <a href=\"http://www-math.mit.edu/~etingof/repb.pdf\" target=\"_blank\" title=\"http://www-math.mit.edu/~etingof/repb.pdf\">http://www-math.mit.edu/~etingof/repb.pdf</a></p>",
        "id": 178346477,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571281532
    },
    {
        "content": "<p>Thanks for the input everyone! I'm a newbie both in this lean game and representation theory, so I'm thinking of learning both by implementing theorems in a textbook as I learn them like the 'intro to proof' course project.</p>",
        "id": 178348965,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571285735
    },
    {
        "content": "<p>Full generality is definitely what standard library should aim for though. If my own little project works out well I'll share. Would happy to hear pointers for a starting point. I'm wondering if I should give it a try for finite group rep. with finite dimensional vector space first, or in a bit more generality.</p>",
        "id": 178349170,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571286006
    },
    {
        "content": "<p>Why not try to prove the first interesting thing about finite group representations: averaging over the group is the projection onto the trivial isotypic component?</p>",
        "id": 178349357,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286244
    },
    {
        "content": "<ol>\n<li>define the operator 1/|G| \\Sigma_g g</li>\n<li>prove that it is idempotent</li>\n<li>prove that anything in its image is fixed by the group</li>\n<li>prove that if you are fixed by every group element you are fixed by this operator</li>\n</ol>",
        "id": 178349402,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286345
    },
    {
        "content": "<p>You'll need to see how to work with linear operators, and use <code>finset.sum</code> to handle the summations.</p>",
        "id": 178349473,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1571286441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242241\">@Seewoo Lee</span></p>",
        "id": 178349554,
        "sender_full_name": "Jineon Baek",
        "timestamp": 1571286592
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242240\">@Jineon Baek</span> But certainly you will make your Lean life a lot easier by not putting those finiteness assumptions in your definition</p>",
        "id": 178352673,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571291403
    },
    {
        "content": "<ol start=\"5\">\n<li>prove that the subset of elements fixed by the group is a sub-vectorspace.</li>\n</ol>",
        "id": 178352690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571291456
    },
    {
        "content": "<p>Representation theory is one of the many things on my list of stuff we need to get done at some point. It's a beautiful theory, and essentially self-contained. The first part of Serre's book would be the kind of goal we'd need</p>",
        "id": 178354918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571294764
    },
    {
        "content": "<p>inb4 it's a special case of L^2(G) and Peter--Weyl theorem</p>",
        "id": 178359160,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571299469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  When we developed Axiom at IBM Research there was an effort made to invite and actively support people who worked in areas where we needed implementations, for example, in finite fields. It might be interesting to \"talent search\" among mathematicians and actively recruit their participation. Perhaps Microsoft could be convinced to do a \"Microsoft Summer of Code\", providing a summer support program for mathematicians with proposals for lean development.</p>",
        "id": 178416100,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571342381
    },
    {
        "content": "<p>I don't think we need a \"person who works in representation theory\" -- all we need is an intelligent undergraduate who is trained in type theory and is interested, and I'm sure I'll find one in the end.</p>",
        "id": 178451453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571385005
    },
    {
        "content": "<p>I've collected together some of the bits and pieces of mathlib that I will require to define linear representations, but I'm still too new to be able to assemble them into a definition. I think the following is all the component parts, but it's just a heap of nonsense at the moment. Would some kind soul be able to align them into something I can start expressing lemmas about? (I'll probably only need a few of this kind of really basic question before I can answer such trivia myself.)</p>\n<p>One particular question I don't know the answer to: should I be expressing \"linear representation\" as a typeclass or merely a record? </p>\n<p>Alternatively, is there some kind of Lean walkthrough of how to assemble a definition like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">field</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Definition. Let V be a finite-dimensional vector space over F. A (linear) repre-</span>\n<span class=\"c1\">-- sentation of G on V is a homomorphism ρ = ρ_V : G → GL(V).</span>\n\n<span class=\"c1\">--def general_linear_group := units (M →ₗ[R] M)</span>\n<span class=\"c1\">--class is_group_hom [group α] [group β] (f : α → β) extends is_mul_hom f : Prop</span>\n</pre></div>",
        "id": 190638253,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584264123
    },
    {
        "content": "<p>The variables are quite right. The variables are the underlying types, and the structures are anonymous typeclass variables. Like so:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 190638449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264525
    },
    {
        "content": "<p>Similarly, <code>G</code> is a group means <code>variables {G : Type*} [group G]</code></p>",
        "id": 190638461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264564
    },
    {
        "content": "<p>and then a linear representation would be an element of <code>G -&gt;* units (V -&gt;l[F] V)</code></p>",
        "id": 190638536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584264622
    },
    {
        "content": "<p>Thanks. The way I had previously expected this to look was something like <code>def linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p</code>, but I suspect my mental model is wrong in a way that I don't understand (that line certainly doesn't compile). Is it clear to you what I've misunderstood?</p>",
        "id": 190639239,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584265629
    },
    {
        "content": "<p>to be clear, I currently have:</p>\n<div class=\"codehilite\"><pre><span></span>import algebra.field\nimport linear_algebra.finite_dimensional\nimport linear_algebra.basic\nimport algebra.module\n\nopen linear_map\n\nuniverses u v\nvariables {F : Type u} {V : Type v}\nvariables [discrete_field F]\nvariables (n : Type u) [fintype n] [decidable_eq n]\nvariables [field F]\nvariables {G : Type*} [add_comm_group G]\nvariables [vector_space F G]\n\ndef linear_representation (p : G -&gt; general_linear_group F (n -&gt; F)) := is_monoid_hom p\n</pre></div>",
        "id": 190639427,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584265859
    },
    {
        "content": "<p>You have two instances on <code>F</code>, one a <code>field</code> and one a <code>discrete_field</code>, that's definitely wrong. That is saying that <code>F</code> has two independent field structures. (In the latest version of lean/mathlib <code>discrete_field</code> has been renamed to <code>field</code>, replacing the original <code>field</code>.)</p>",
        "id": 190640530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267504
    },
    {
        "content": "<p>It's true that I didn't say anything about the finite dimensionality in the version I gave. That could be a predicate on <code>V</code>, something like <code>dim V &lt; omega</code>, although perhaps there's a typeclass for this now</p>",
        "id": 190640544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267579
    },
    {
        "content": "<p>But in your version, <code>vector_space F G</code> means that <code>G</code> is the <code>F</code>-vector space</p>",
        "id": 190640597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267645
    },
    {
        "content": "<p>which could be what you mean but doesn't match the math text in the comment</p>",
        "id": 190640604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267706
    },
    {
        "content": "<p>The way you have set up <code>linear_representation p</code> is as a predicate on functions from G asserting that they are a linear representation, whereas the approach I gave takes linear representations to be the entire type <code>G -&gt;* units (V -&gt;l[F] V)</code>, which bundles together the function with the proof that it is a group hom</p>",
        "id": 190640656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190640604\">said</a>:</p>\n<blockquote>\n<p>which could be what you mean but doesn't match the math text in the comment</p>\n</blockquote>\n<p>Ah, you're quite right - I don't know how I could have made that mistake :P</p>",
        "id": 190640695,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584267852
    },
    {
        "content": "<p>mathlib is slowly moving away from unbundled homs like <code>is_monoid_hom</code> in favor of bundled homs like <code>G -&gt;+ H</code></p>",
        "id": 190640704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584267879
    },
    {
        "content": "<p>OK, that makes sense - thanks</p>",
        "id": 190640707,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584267890
    },
    {
        "content": "<p>The flood of my questions should decay exponentially, but in the meantime: the following doesn't compile because \"type expected at <code>linear_representation</code>\" in the last line. How can I pass a linear representation into the function <code>dimension</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span> <span class=\"o\">:=</span> <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">dimension</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector_space</span><span class=\"bp\">.</span><span class=\"n\">dim</span> <span class=\"n\">V</span>\n</pre></div>",
        "id": 190641233,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584268874
    },
    {
        "content": "<p>Have a look at <code>#check linear_representation</code></p>",
        "id": 190641409,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269139
    },
    {
        "content": "<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>",
        "id": 190641447,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269163
    },
    {
        "content": "<p>Also try <code>#check @linear_representation</code>, and try to think about what is <code>V</code> at the very end of your code, and how it relates to <code>p</code>.</p>",
        "id": 190641510,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641447\">said</a>:</p>\n<blockquote>\n<p>Maybe you don't quite understand how <code>variable</code> works yet.</p>\n</blockquote>\n<p>Ah right - again, I've been misled by Agda, which tends to do this via parameterised modules</p>",
        "id": 190641511,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269315
    },
    {
        "content": "<p>There is also a problem which is completely independent of language differences.</p>",
        "id": 190641522,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269373
    },
    {
        "content": "<p>Your <code>V</code> in the body of the definition has no relation whatsoever with <code>p</code>.</p>",
        "id": 190641531,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269395
    },
    {
        "content": "<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>",
        "id": 190641589,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190641589\">said</a>:</p>\n<blockquote>\n<p>Your <code>p</code> obviously has dimension <code>n</code> by definition.</p>\n</blockquote>\n<p>You're right, I actually want the <code>n</code> from the body of <code>linear_representation</code> - but I am happy to leave questions like \"have I got the definition correct\" for the moment (I'll discover they're wrong as soon as I come to formulate any theorems) while I learn how to use Lean</p>",
        "id": 190641647,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269529
    },
    {
        "content": "<p>You have <code>V</code> and also <code>n -&gt; F</code> as vector spaces. Which do you want?</p>",
        "id": 190641660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269585
    },
    {
        "content": "<p>In case this isn't clear: Mario's question is about the same topic as mine.</p>",
        "id": 190641666,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269607
    },
    {
        "content": "<p><code>linear_representation</code> has too many implicit variables</p>",
        "id": 190641667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269618
    },
    {
        "content": "<p><code>n -&gt; F</code> - but I can almost certainly work out how to do that by myself, once I've correctly passed a linear representation into <code>dimension</code>. I'll rejig it so that the right variables are explicit and then it'll probably all just fall out</p>",
        "id": 190641671,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269641
    },
    {
        "content": "<p>Thanks</p>",
        "id": 190641673,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584269642
    },
    {
        "content": "<p>you need to make the type variables explicit, and then write e.g. <code>p : linear_representation F G V</code></p>",
        "id": 190641711,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269653
    },
    {
        "content": "<p>or <code>linear_representation F G n</code> if you want that version</p>",
        "id": 190641720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269689
    },
    {
        "content": "<p>That's why I wrote a bunch of <code>#check</code></p>",
        "id": 190641729,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269757
    },
    {
        "content": "<p>If the definition has the form <code>linear_representation F G n</code>, then the dimension is <code>n</code>, and there is no need for a definition <code>dimension</code>. This is what patrick is saying</p>",
        "id": 190641768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584269765
    },
    {
        "content": "<p>Because in this situation Lean will typically complain it cannot synthesize a term of type<code>Type u</code> without telling which implicit variable it wasn't able to synthesize and this is not easy to debug without <code>#check</code></p>",
        "id": 190641776,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584269817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> <code>field</code> means different things in Lean 3.4.2 (the officially sanctioned version of Lean, which is frozen, as is mathlib support) and 3.6.1 (the community version, which current mathlib compiles with). I guess I'd recommend you use 3.6.1 but I just wanted to flag this now.</p>",
        "id": 190643018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584272218
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- working with Lean 3.6.1 and current mathlib</span>\n<span class=\"c1\">-- don&#39;t need all of these imports for group_module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"n\">class</span> <span class=\"n\">group_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span>  <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">one_smul</span> <span class=\"n\">smul_smul</span> <span class=\"n\">smul_add</span> <span class=\"c1\">-- I think?</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">group_module</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_neg</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_zero</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">smul_sub</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">m</span> <span class=\"bp\">-</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">group_module</span>\n\n<span class=\"c1\">-- new file with more imports</span>\n\n<span class=\"n\">class</span> <span class=\"n\">group_representation</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"err\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">group_representation</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group_module</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">dim</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">vector_space</span><span class=\"bp\">.</span><span class=\"n\">dim</span> <span class=\"n\">V</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">group_representation</span>\n</pre></div>\n\n\n<p>There's my effort, but definitions are not my strong point.</p>",
        "id": 190643511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273206
    },
    {
        "content": "<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>",
        "id": 190643519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273238
    },
    {
        "content": "<p>furthermore the definitions should be in two different files really, because someone interested in group cohomology might not want to import the representation theory stuff.</p>",
        "id": 190643565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273280
    },
    {
        "content": "<p>The following doesn't compile because \"maximum class-instance resolution depth has been reached\" on the last line for <code>monoid_hom</code>; presumably that means Lean can't figure out that I've specified a homomorphism, so I need to supply an instance of <code>is_monoid_hom</code> to go with the lambda-term. </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">trivial_representation</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span>\n</pre></div>\n\n\n<p>But my best attempt at that instance is the following, which doesn't compile (\"don't know how to synthesize placeholder\" on <code>general_linear_group</code>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>This problem persists even if I supply <code>F</code> as well (i.e. prepend the arguments <code>(F : Type*) [discrete_field F]</code> to <code>identity_is_hom</code>). It's not clear to me that I can supply any more information to Lean here; what have I missed?</p>",
        "id": 190643691,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643519\">said</a>:</p>\n<blockquote>\n<p>There should really be a bunch of lemmas about <code>group_module</code> first, because this is a simpler object (no field involved)</p>\n</blockquote>\n<p>Fair enough - I'm using this more as a \"learn Lean\" exercise than a \"produce something to go into mathlib\" at the moment, so am happy just playing around with the definitions at the moment</p>",
        "id": 190643708,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273593
    },
    {
        "content": "<p>OK I'll take a look at your version.</p>",
        "id": 190643758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273636
    },
    {
        "content": "<p>Which version of Lean are you using?</p>",
        "id": 190643826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273772
    },
    {
        "content": "<p>Your def of <code>linear_representation</code> has a V as an input which is never used</p>",
        "id": 190643894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643826\">said</a>:</p>\n<blockquote>\n<p>Which version of Lean are you using?</p>\n</blockquote>\n<p>leanprover-community/lean:3.5.1, according to my <code>leanpkg.toml</code></p>",
        "id": 190643899,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584273930
    },
    {
        "content": "<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>",
        "id": 190643945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584273978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190643945\">said</a>:</p>\n<blockquote>\n<p>You should probably upgrade because I just noticed that it's a pain to look at your code because of all this deprecated <code>discrete_field</code> stuff. There will be a painless way to do it with <code>leanproject</code> I suspect.</p>\n</blockquote>\n<p>OK, thanks - I'll do that before anything else</p>",
        "id": 190643949,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584274000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what do you think of my version by the way? Once we have the definitions right the lemmas should be fun, but the definitions are a minefield.</p>",
        "id": 190643952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274014
    },
    {
        "content": "<p>I think it should be a monoid rather than a group</p>",
        "id": 190644083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274261
    },
    {
        "content": "<p>it also looks suspiciously like a group action</p>",
        "id": 190644089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274285
    },
    {
        "content": "<p>It <em>is</em> a group action</p>",
        "id": 190644090,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584274300
    },
    {
        "content": "<p>A group module is a group action by module homs</p>",
        "id": 190644091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274300
    },
    {
        "content": "<p>Mario is pointing out that it could extend group actions</p>",
        "id": 190644096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274316
    },
    {
        "content": "<p>(then you get a bunch of theorems for free)</p>",
        "id": 190644135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274328
    },
    {
        "content": "<p>You also get a bunch of theorems for free if you don't define this at all and use the high level characterization instead</p>",
        "id": 190644157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274406
    },
    {
        "content": "<p>I'm not sure what you mean, but whatever you mean I suspect people will want this in practice.</p>",
        "id": 190644259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274464
    },
    {
        "content": "<p>Don't you get all this if you just say <code>linear_representation := G -&gt;* units (V -&gt;l[F] V)</code>?</p>",
        "id": 190644262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274473
    },
    {
        "content": "<p>Yes absolutely</p>",
        "id": 190644267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274489
    },
    {
        "content": "<p>it's not clear to me what the tradeoffs are here</p>",
        "id": 190644304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274538
    },
    {
        "content": "<p>Is that a high-level characterisation? There is another one -- there's a ring <code>G -&gt;_0 F</code> called the group ring, and a group representation is the same thing as a module over that ring</p>",
        "id": 190644305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274547
    },
    {
        "content": "<p>sure, any of those sound good to me</p>",
        "id": 190644342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274563
    },
    {
        "content": "<p>they are already very compact</p>",
        "id": 190644344,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274570
    },
    {
        "content": "<p>You're a computer scientist so can see advantages in the compactness</p>",
        "id": 190644351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274593
    },
    {
        "content": "<p>It's less clear to me</p>",
        "id": 190644353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274600
    },
    {
        "content": "<p>Isn't this usually how the mathematicians do it?</p>",
        "id": 190644401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274612
    },
    {
        "content": "<p>I would prefer clarity</p>",
        "id": 190644403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274614
    },
    {
        "content": "<p>I feel like we've swapped sides of this argument</p>",
        "id": 190644418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274626
    },
    {
        "content": "<p>If you define it as a module over the group ring then all of a sudden you don't have <code>g \\bub v</code> you have <code>\\u g \\bub v</code> etc</p>",
        "id": 190644421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274656
    },
    {
        "content": "<p>and these invisible functions can cause confusion, make rewriting harder etc</p>",
        "id": 190644424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274678
    },
    {
        "content": "<p>remind me who is playing the role of the CS guy again</p>",
        "id": 190644466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274713
    },
    {
        "content": "<p>With your approach there are coercions to fun etc, whereas sometimes <code>g \\bub v</code> is just the thing you want.</p>",
        "id": 190644471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274726
    },
    {
        "content": "<p>My understanding here is that there is no perfect solution.</p>",
        "id": 190644476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274749
    },
    {
        "content": "<p>That's certainly going to be the case</p>",
        "id": 190644478,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274767
    },
    {
        "content": "<p>how about you CS guys make the system we want then ;-)</p>",
        "id": 190644480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274784
    },
    {
        "content": "<p>Like I said, there is a tradeoff here and I don't have a good grasp of it</p>",
        "id": 190644484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274789
    },
    {
        "content": "<p>because you don't know what mathematicians actually use group representations for. This is why we need the area to get bigger, we need people who are experts at everything at once.</p>",
        "id": 190644530,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274823
    },
    {
        "content": "<p>Mathematicians just invoke the invisible function machine and pass seamlessly from one concept to the other</p>",
        "id": 190644594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274866
    },
    {
        "content": "<p>I have already argued that DTT is the problem but you're already bought in so ¯\\_(ツ)_/¯</p>",
        "id": 190644595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274874
    },
    {
        "content": "<p>and we don't check the diagrams commute because this is trivial</p>",
        "id": 190644596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274879
    },
    {
        "content": "<p>in set theory it really is that easy to pass between representations</p>",
        "id": 190644604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274892
    },
    {
        "content": "<p>I'm not going back to assembly language now</p>",
        "id": 190644653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584274911
    },
    {
        "content": "<p>to use a rust analogy, I don't want assembly language, I want <code>unsafe</code> blocks</p>",
        "id": 190644718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584274961
    },
    {
        "content": "<p>You lost me :-/ but I'm happy to hear more.</p>",
        "id": 190644770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275043
    },
    {
        "content": "<p>I want the ability to get around the type system without it getting mad at me forever</p>",
        "id": 190644781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275064
    },
    {
        "content": "<p>In set theory if <code>x \\in A</code> and <code>A = B</code> then <code>x \\in B</code></p>",
        "id": 190644786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275091
    },
    {
        "content": "<p>in type theory this will cause the proof assistant to hate you forever</p>",
        "id": 190644792,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> the problem with your code, I guess, is that you've defined a function <code>j</code> from G to <code>general_linear_group F (fin 1 → F)</code> but Lean has no particular reason to know that this function has the property that <code>j(g*h)=j(g)*j(h)</code>.</p>",
        "id": 190644805,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190644792\">said</a>:</p>\n<blockquote>\n<p>in type theory this will cause the proof assistant to hate you forever</p>\n</blockquote>\n<p>In type theory we have to insert an invisible coercion from A to B and then coerce x over.</p>",
        "id": 190644875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275187
    },
    {
        "content": "<p>it's not invisible</p>",
        "id": 190644909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275207
    },
    {
        "content": "<p>I wish it was</p>",
        "id": 190644912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275217
    },
    {
        "content": "<p>we try very hard to make it not too annoying with mixed success</p>",
        "id": 190644918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275238
    },
    {
        "content": "<p>Sure -- I just meant \"invisible to mathematicians\"</p>",
        "id": 190644922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275244
    },
    {
        "content": "<p>and we have a rather liberal notion of <code>=</code></p>",
        "id": 190644973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275259
    },
    {
        "content": "<p>I think that lean is a great system, probably the best among all systems I know at the user experience. I also think that this property has almost nothing to do with the fact that it implements DTT</p>",
        "id": 190645022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275319
    },
    {
        "content": "<p>We understand the concept of an equivalence of categories, but all these structures on one vector space V (a linear action of a group, a group hom to the automorphisms, a module for the group ring) are all equal because they are simply different ways of packing up precisely the same information. They are a tedious implementation issue which we cunningly avoid by seamlessly changing our implementation decisions mid-proof.</p>",
        "id": 190645030,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275357
    },
    {
        "content": "<p>in lean, we can do this with equivs of various kinds, and maybe this will eventually be packed into some category machinery</p>",
        "id": 190645106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275452
    },
    {
        "content": "<p>but I do think it is essential to be able to do concrete work in any of those representations</p>",
        "id": 190645116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584275486
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">of</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">monoid_hom.of :</span>\n<span class=\"cm\">  Π {M : Type u_3} {N : Type u_4} [mM : monoid M] [mN : monoid N] (f : M → N) [h : is_monoid_hom f], M →* N</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>Patrick -- this definition of <code>monoid_hom.of</code> says \"you give me a map <code>f</code> and I will then use type class inference to find a term <code>h</code> of type <code>is_monoid_hom f</code>. Once I've found it I'll give you back a monoid homomorphism (which is essentially the pair consisting of f and h).</p>",
        "id": 190645117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275487
    },
    {
        "content": "<p>Yep, I'd got that far - I'm struggling to construct that term though</p>",
        "id": 190645122,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275516
    },
    {
        "content": "<p>The type class inference system is a bunch of lemmas of the form \"a ring homomorphism is a monoid homomorphism\" etc.</p>",
        "id": 190645123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275518
    },
    {
        "content": "<p>The following doesn't compile, for example, because \"don't know how to synthesize placeholder\" at <code>general_linear_group</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 190645216,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275557
    },
    {
        "content": "<p>It will probably know that <code>general_linear_group X Y</code> is a group and hence a monoid but it won't know that your map is a monoid hom.</p>",
        "id": 190645267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275648
    },
    {
        "content": "<p>The issue with the synthesizing placeholder will be that Lean can't figure out which ring you're working over.</p>",
        "id": 190645273,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275676
    },
    {
        "content": "<p>I was hoping to tell it this was a hom, in the bit where I currently have <code>sorry</code></p>",
        "id": 190645276,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275685
    },
    {
        "content": "<p>Before the sorry Lean is failing to elaborate the term.</p>",
        "id": 190645288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275712
    },
    {
        "content": "<p>It can't figure out the type of <code>linear_equiv.refl (fin 1 -&gt; F)</code></p>",
        "id": 190645290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275723
    },
    {
        "content": "<p>The type is that <code>(fin 1 -&gt; F)</code> is isomorphic to itself as a module over...some metavariable.</p>",
        "id": 190645334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275775
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 190645345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275833
    },
    {
        "content": "<p>The variable inputs in <code>{}</code> brackets are ones which are supposed to be inferred by unification, but we're claiming that the identity map <code>fin 1 -&gt; F</code> is R-linear where R is a ring acting on <code>fin 1 -&gt; F</code> and we give no indication as to what this ring is. Whatever R is, this theorem is still true. My gut feeling is that your problem has come from a possibly questionable design decision to make the R input implicit.</p>",
        "id": 190645454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275951
    },
    {
        "content": "<p>Ooh, yuck - thanks; in Agda you can supply any particular implicit variable, like <code>f {A = B} arg1 {C = C} arg2</code> where <code>A</code> and <code>C</code> were implicit args. It looks like in Lean you can only \"make all args explicit\"?</p>",
        "id": 190645461,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584275963
    },
    {
        "content": "<p>PS I am now talking to you as if you were an expert. Let me know if I'm going over your head.</p>",
        "id": 190645464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584275968
    },
    {
        "content": "<p>Yes, you can make all args explicit or none of them! That is a really cool agda thing, I wish we had that in Lean.</p>",
        "id": 190645496,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276002
    },
    {
        "content": "<p>Yep, I see what you mean</p>",
        "id": 190645512,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584276010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can you just pop that into 3.7.2 for us?</p>",
        "id": 190645513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276019
    },
    {
        "content": "<p>there is a concrete syntax for this in lean 4 but I forget what it is</p>",
        "id": 190645533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276073
    },
    {
        "content": "<p>if we used that notation it would get confused with passing a singleton of an equality to <code>f</code></p>",
        "id": 190645582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276132
    },
    {
        "content": "<p>MS should employ an intern who gets an email whenever an issue like this comes up, and solves it manually</p>",
        "id": 190645587,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276181
    },
    {
        "content": "<p>Oh here's a better idea -- just use a new kind of bracket.</p>",
        "id": 190645593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276201
    },
    {
        "content": "<p>Even if it did exist, the name of the argument could only possibly be the name of the binder, and typeclass args always have ugly names like <code>_inst_1</code></p>",
        "id": 190645602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276221
    },
    {
        "content": "<p>Why are we using <code>{}</code> for both implicit variable and set notation anyway?</p>",
        "id": 190645603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276224
    },
    {
        "content": "<p>Here we were missing <code>R</code> not some typeclass thing. The issue here was with unification failing, not type class inference.</p>",
        "id": 190645697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276263
    },
    {
        "content": "<p>Binders are always distinguishable because they come after binding notation tokens</p>",
        "id": 190645699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276265
    },
    {
        "content": "<p>but implicit function args are just in regular expression position</p>",
        "id": 190645707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276289
    },
    {
        "content": "<p>Mathematicians got <code>{}</code> first for sets, you just need some wacky unicode for your implicit instances and then we're all set.</p>",
        "id": 190645731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276324
    },
    {
        "content": "<p>there is no problem with binders because they only come after <code>\\lam</code> and stuff</p>",
        "id": 190645782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276368
    },
    {
        "content": "<p><code>\\lam {x | x &gt; 0}</code> doesn't make any sense</p>",
        "id": 190645785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276383
    },
    {
        "content": "<p>I don't know what a binder is. I thought that was forall etc.</p>",
        "id": 190645788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276392
    },
    {
        "content": "<p>yes</p>",
        "id": 190645790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276395
    },
    {
        "content": "<p><code>\\Pi</code>, <code>\\forall</code>, <code>\\lam</code>, <code>\\sum</code>, etc</p>",
        "id": 190645795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276410
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_5</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"n\">M</span> <span class=\"err\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span>\n</pre></div>\n\n\n<p>Should R be explicit here?</p>",
        "id": 190645796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276413
    },
    {
        "content": "<p>I think so</p>",
        "id": 190645801,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276425
    },
    {
        "content": "<p>I am confused about what binders have to do with the fact that I just had to write <code>@foo F _ _ _ _</code></p>",
        "id": 190645802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276431
    },
    {
        "content": "<p>There are no binders involved in the expression <code>@foo F _ _ _ _</code></p>",
        "id": 190645807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276463
    },
    {
        "content": "<p>whereas I wanted to write <code>foo {R = F}</code></p>",
        "id": 190645809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276465
    },
    {
        "content": "<p>but <code>{R = F}</code> is actually a valid expression, of type <code>set Prop</code></p>",
        "id": 190645855,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276488
    },
    {
        "content": "<p>and that's why I'm saying you should keep your grubby implicit variable hands off our set notation and come up with some different bracket system.</p>",
        "id": 190645860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276515
    },
    {
        "content": "<p>which is kind of nonsense, but <code>foo</code> might nevertheless have type <code>set Prop -&gt; T</code> and then <code>foo {R = F}</code> is valid</p>",
        "id": 190645861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276522
    },
    {
        "content": "<p>Oh, if the notation is something other than <code>@foo {R = F}</code> then we're fine probably</p>",
        "id": 190645869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276561
    },
    {
        "content": "<p>or treat us like dirt, like you usually do, and make us use different weird brackets so as to confuse the regular mathematicians</p>",
        "id": 190645870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276562
    },
    {
        "content": "<p>I mean we already have those funny unicode brackets that are a pain to type for semi implicit</p>",
        "id": 190645876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276593
    },
    {
        "content": "<p>You wouldn't believe how many times I've been asked why <code>2 | 4</code> throw up wacky errors</p>",
        "id": 190645881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276597
    },
    {
        "content": "<p>when it works in LaTeX</p>",
        "id": 190645966,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276611
    },
    {
        "content": "<p><code>2 \\mid 4</code> is the way to do it in latex</p>",
        "id": 190645971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276630
    },
    {
        "content": "<p>(actually it doesn't even work in LaTeX, the glue is incorrect and the user should use <code>\\mid</code> ;-) )</p>",
        "id": 190645973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276635
    },
    {
        "content": "<p>Because of the possibility of conflict, it seems pretty sensitive what notation is used for passing implicit arguments like this. I should see what lean 4 picked</p>",
        "id": 190646000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276705
    },
    {
        "content": "<p>but yes, if it's some <code>foo {&lt;&lt;R = F&gt;&gt;}</code> thing then we're fine</p>",
        "id": 190646045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276736
    },
    {
        "content": "<p>then again, typing that may become annoying</p>",
        "id": 190646053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276777
    },
    {
        "content": "<p>syntax is hard</p>",
        "id": 190646056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584276791
    },
    {
        "content": "<p>You all seem to be happy with all that &gt;=-+ monad stuff</p>",
        "id": 190646061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276816
    },
    {
        "content": "<p>This is a feature that isn't meant to be used very often</p>",
        "id": 190646062,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584276819
    },
    {
        "content": "<p>So what you're saying is that instead of all this bracket banter I should just be making a PR changing {R} to (R)? :-)</p>",
        "id": 190646108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276876
    },
    {
        "content": "<p>unfortuately it won't work for 3.4.2 ;-)</p>",
        "id": 190646110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276893
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">identity_is_hom</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_monoid_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">F</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>is how to make the instance, in case you didn't know Lean syntax</p>",
        "id": 190646177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584276973
    },
    {
        "content": "<p>I got this in VS Code by writing <code>... := {! !}</code> and then clicking on the little lightbulb which appeared and selecting \"create a skeleton\"</p>",
        "id": 190646191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584277048
    },
    {
        "content": "<p>It's really hard to Google for the <code>example</code> keyword :P is it possible for me to name an example, or do I have to make it a <code>def</code> if I want to refer to it? Currently I have a definition which works, and now I want to run it through <code>#check</code> but I can't work out how to refer to it.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- Trivial representation</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">general_linear_group</span><span class=\"bp\">.</span><span class=\"n\">of_linear_equiv</span> <span class=\"o\">(</span><span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span>\n    <span class=\"k\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span>\n  <span class=\"o\">}</span>\n</pre></div>",
        "id": 190661151,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584297880
    },
    {
        "content": "<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>",
        "id": 190661478,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1584298280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259186\">Daniel Keys</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/190661478\">said</a>:</p>\n<blockquote>\n<p>You can try giving it a name, like so: <code>def even (n : ℤ) := 2 ∣ n</code></p>\n</blockquote>\n<p>Sure, I was just wondering if I could use the <code>example</code> syntax to name an example, or whether I was forced to use <code>def</code></p>",
        "id": 190661482,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584298303
    },
    {
        "content": "<p>I think you need to make it a lemma or theorem in order to give it a name.</p>",
        "id": 190661543,
        "sender_full_name": "Daniel Keys",
        "timestamp": 1584298361
    },
    {
        "content": "<p>Here's a stupid question: I've defined some stuff, and I want to #eval it to see whether it looks right (before I start going to the effort of proving things about it). For example, I've defined the dimension of a representation, and I want to check that the dimension of a certain representation is in fact 2 when I expect it to be. But for the life of me I can't find any actual examples of groups in mathlib (and so I have nothing to pass into #eval): the cyclic groups seem not to have been defined, Q and R appear not to have been endowed with group structures, etc. Are there actually any groups anywhere? And how should I be trying to find them in mathlib?</p>",
        "id": 191337769,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784321
    },
    {
        "content": "<p>Hmm... such examples are certain there.</p>",
        "id": 191337883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784460
    },
    {
        "content": "<p>Q and R are both endowed with the structure of a linearly ordered field, so in particular they are additive groups</p>",
        "id": 191337890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784498
    },
    {
        "content": "<p>But <code>#eval</code> cannot compute a dimension for you</p>",
        "id": 191337898,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784516
    },
    {
        "content": "<p>(It would have to cook up a basis, etc...)</p>",
        "id": 191337915,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784531
    },
    {
        "content": "<p>My current problem is simply an inability to synthesise a typeclass instance for <code>group R</code>, for example</p>",
        "id": 191337917,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784547
    },
    {
        "content": "<p>On the other hand, there is certainly a theorem in mathlib saying that <code>K^n</code> has dimension <code>n</code> over <code>K</code>.</p>",
        "id": 191337919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784553
    },
    {
        "content": "<p>Because it's not a group. It's an <code>add_group</code>.</p>",
        "id": 191337958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784566
    },
    {
        "content": "<p>This is very unfortunate.</p>",
        "id": 191337962,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784572
    },
    {
        "content": "<p>Oh, that's very upsetting</p>",
        "id": 191337971,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784599
    },
    {
        "content": "<p>But in the current setup, we need to duplicate groups to distinguish between multiplicative and additive groups</p>",
        "id": 191337973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784603
    },
    {
        "content": "<p>If we don't do that, we cannot have nice notation.</p>",
        "id": 191337976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784613
    },
    {
        "content": "<p>On the other hand, this is mostly done completely automatically. You prove things for multiplicative groups, and you are done.</p>",
        "id": 191337985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784637
    },
    {
        "content": "<p>So you get <code>monoid R</code> and <code>add_group R</code> in your case.</p>",
        "id": 191337988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784647
    },
    {
        "content": "<p>So it's just a matter of taste whether you want to use <code>add_group</code> or <code>group</code> in a particular theory?</p>",
        "id": 191337994,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784672
    },
    {
        "content": "<p>Well, mostly yes.</p>",
        "id": 191338048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784771
    },
    {
        "content": "<p>But the machinery can turn generate an additive version of a multiplicative definition/theorem, but not the other way round.</p>",
        "id": 191338057,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784800
    },
    {
        "content": "<p>So all the generalities are developed using multiplicative notation.</p>",
        "id": 191338100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784811
    },
    {
        "content": "<p>But stuff like modules and representations assumes additive groups</p>",
        "id": 191338110,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584784825
    },
    {
        "content": "<p>Was that a mistake? Should they not use the phrasing that affords more generality, i.e. multiplicative?</p>",
        "id": 191338131,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584784892
    },
    {
        "content": "<p>No, because of the notation.</p>",
        "id": 191338362,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785238
    },
    {
        "content": "<p>If M is an R-module, you want to me able to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r \\cdot (x + y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> for <code>r : R</code> and <code>x y : M</code></p>",
        "id": 191338371,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785277
    },
    {
        "content": "<p>I agree that it's confusing. (The mathematician in me is still unhappy about it.) But in practice it works quite well.</p>",
        "id": 191338411,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785307
    },
    {
        "content": "<p>So, the magic command to make a multiplicative theorem additive is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">my_multiplicative_thm</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 191338424,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785353
    },
    {
        "content": "<p>Besides that, if <code>G</code> is a <code>group</code>, then <code>additive G</code> is an <code>add_group</code>. (The only thing this does is switch notation.)<br>\nAnalogously <code>multiplicative A</code> turns an additive group into a multiplicative one.</p>",
        "id": 191338432,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785398
    },
    {
        "content": "<p>Together, this gives a system that's quite flexible, and has nice notation.</p>",
        "id": 191338476,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584785412
    },
    {
        "content": "<p>The following code doesn't compile because I haven't defined a relation: the type is not X -&gt; X -&gt; Prop because the type of <code>is_isomorphic</code> here is <code>linear_representation _ _ V1 -&gt; linear_representation _ _ V2 -&gt; Prop</code>. I could solve this by splitting the definition into two: <code>linear_representation_over_a_specific_vector_space</code> (name TBD), and convert <code>linear_representation</code> to being instead a dependent pair of (vector space, representation on that vector space), but this seems a little sad. Can anyone see anything nicer I could do?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">linear_map</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">linear_representation</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">monoid_hom</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">general_linear_group</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- is_intertwining_map is the same as &quot;being a G-homomorphism&quot;</span>\n<span class=\"n\">def</span> <span class=\"n\">is_intertwining_map</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">linear_map</span> <span class=\"n\">F</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V1</span><span class=\"o\">),</span>\n    <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">units</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">p1</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">units</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">p2</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_isomorphism</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">linear_map</span> <span class=\"n\">F</span> <span class=\"n\">V1</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">is_intertwining_map</span> <span class=\"n\">F</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">φ</span> <span class=\"bp\">∧</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_isomorphic</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">linear_representation</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">V2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">is_isomorphism</span> <span class=\"n\">F</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">φ</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">isomorphism_rel_is_reflexive</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V1</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V2</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">F</span> <span class=\"n\">V2</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_isomorphic</span> <span class=\"n\">F</span> <span class=\"bp\">_</span> <span class=\"n\">G</span> <span class=\"bp\">_</span> <span class=\"n\">V1</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">V2</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- doesn&#39;t compile</span>\n  <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 191340607,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584788946
    },
    {
        "content": "<p>I restructured in that way and it does work, of course, although it's a bit gross</p>",
        "id": 191342638,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584792386
    },
    {
        "content": "<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>",
        "id": 191345620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584797188
    },
    {
        "content": "<p>The way this would be usually done in mathlib is that first you define a bunded <code>intertwining_map</code>, and then you would define the identity intertwining map, and a composition of intertwining maps, and you would define an isomorphism to be an intertwining map with an inverse. I don't think I understand your question about reflexive. Surely the assertion that the relation is reflexive is that V1 is isomorphic to V1, I don't see the role of V2.</p>",
        "id": 191345780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797514
    },
    {
        "content": "<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say \"if V1 is isomorphic to V2 then V2 is isomorphic to V1\" but this is less than what they mean. They <em>mean</em> \"if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse\", and you would to well to capture this stronger statement.</p>",
        "id": 191345843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797604
    },
    {
        "content": "<p>You should look at how it is set up for modules. Because a group representation is just a module for the group ring, you are just re-doing that theory anyway. <a href=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/algebra/module.lean#L165\">Here are module homomorphisms in mathlib</a>. Instead of making the predicate on a homomorphism of additive abelian groups, they bundle everything up in a structure and then define <code>id</code> and <code>comp</code> -- these are the fundamental things you need to make everything into a category.</p>",
        "id": 191346036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584797908
    },
    {
        "content": "<p>The reason that you don't see statements such as isomorphism being reflexive, symmetric etc is that everything like that is already done in some huge generality in <a href=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/dd85db0cc7b5d0849f6f75535e109fa3d6f7ac56/src/data/equiv/mul_add.lean#L73\">files like this</a>. This is a definition, not a theorem, it's the construction of the identity map and the proof that it preserves multiplication on any type with a multiplication. This is some abstract theory of \"mul-equiv\"s, which means bijections between two sets X and Y with multiplication, such that the bijection preserves the multiplication. Things like that get set up in huge generality and then the idea is that it will apply to your situation if you need it.</p>",
        "id": 191346259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584798252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345843\">said</a>:</p>\n<blockquote>\n<p>But here you don't really want to use equivalence relations anyway, because they lose track of data. A mathematician would say \"if V1 is isomorphic to V2 then V2 is isomorphic to V1\" but this is less than what they mean. They <em>mean</em> \"if you have an isomorphism V1 -&gt; V2 then I can give you an isomorphism V2 -&gt; V1, namely its inverse\", and you would to well to capture this stronger statement.</p>\n</blockquote>\n<p>Ah, again this is a habit imported from Agda, where to say that A is iso to B is to exhibit an isomorphism</p>",
        "id": 191346602,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584798721
    },
    {
        "content": "<p>There is an <em>awful</em> lot to unlearn here :P</p>",
        "id": 191346649,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584798754
    },
    {
        "content": "<p>In Lean, you say that A and B are <code>equiv</code>, which is also an explicit iso.</p>",
        "id": 191346687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584798828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> your definition of <code>is_isomorphism</code> is a <code>Prop</code>, so when you prove  the isomorphism you'll have to exhibit the map, but the moment the proof has compiled the map will be forgotten, because Lean's Prop is...umm..I think it's called impredicative.</p>",
        "id": 191347345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584799704
    },
    {
        "content": "<p>Fair enough - I just need to get much more clear about what is constructive and what isn't</p>",
        "id": 191347512,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1584799957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191347345\">said</a>:</p>\n<blockquote>\n<p>because Lean's Prop is...umm..I think it's called impredicative.</p>\n</blockquote>\n<p>No, that's not what impredicative means. <a href=\"https://en.wikipedia.org/wiki/Impredicativity\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Impredicativity\">https://en.wikipedia.org/wiki/Impredicativity</a></p>",
        "id": 191348417,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584801215
    },
    {
        "content": "<p>well, Lean's prop is forgetful</p>",
        "id": 191348469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801246
    },
    {
        "content": "<p>that would be proof irrelevance</p>",
        "id": 191348483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801272
    },
    {
        "content": "<blockquote>\n<p>There is no generally accepted precise definition of what it means to be predicative or impredicative</p>\n</blockquote>",
        "id": 191348486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801278
    },
    {
        "content": "<p>that's the last time I'm using that word. It's as bad as canonical.</p>",
        "id": 191348489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801289
    },
    {
        "content": "<p>we can say that Prop is a proof irrelevant universe</p>",
        "id": 191348491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801293
    },
    {
        "content": "<p>I don't think I agree with the wikipedia statement. The meaning of impredicativity is context dependent but precise in most places where it appears</p>",
        "id": 191348559,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801383
    },
    {
        "content": "<p>Almost all the uses you are likely to have seen are using the same meaning. Alternate meanings are mostly historical and philosophical uses like avoiding self reference in the liar's paradox</p>",
        "id": 191348594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801462
    },
    {
        "content": "<p>And this meaning is somehow orthogonal to proof irrelevance, right?</p>",
        "id": 191348668,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584801554
    },
    {
        "content": "<p>they are related by a paradox that makes one of the possible permutations inconsistent</p>",
        "id": 191348749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> , could you have a look at <a href=\"https://github.com/leanprover-community/mathlib/issues/2121\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/2121\">#2121</a>, as a \"rather bundled\" suggestion for the basics of representation theory?</p>",
        "id": 191361408,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584817848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/191345620\">said</a>:</p>\n<blockquote>\n<p>An example of an actual <code>group</code> in mathlib would be <code>units</code>. For example <code>units (zmod 42)</code> is an interesting, nontrivial and computable finite multiplicative group</p>\n</blockquote>\n<p>You can also do <code>units</code> of a general linear group to get some fun non-abelian computable groups.</p>",
        "id": 191375384,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1584842895
    },
    {
        "content": "<p>I'm planning to do some representation theory with <span class=\"user-mention\" data-user-id=\"201575\">@Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> and <span class=\"user-mention\" data-user-id=\"117987\">@Patrick Stevens</span> might be working on the same or similar stuff)?</p>",
        "id": 193803142,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1586802149
    },
    {
        "content": "<p>The basic definitions will be the same as for group cohomology. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and some of his students have done a bunch there.</p>",
        "id": 193803299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1586802271
    },
    {
        "content": "<p>The reason this never gets done is the usual (see graphs, or Cauchy's integral formula, or ...): people haven't yet decided on what the definition should be.</p>",
        "id": 193806239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586803873
    },
    {
        "content": "<p>Should one just define a representation of a group to be, by definition, a module over the group ring? Or should one make a new class of a vector space (or more generally module -- please set it up over modules over a commutative ring rather than vector spaces over a field) equipped with an action of G?</p>",
        "id": 193806389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586803938
    },
    {
        "content": "<p><a href=\"https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14\" title=\"https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14\">https://github.com/Shenyang1995/M4R/blob/66f1450f206dc05c3093bc4eaa1361309bf8633b/src/G_module/basic.lean#L10-L14</a> I need advice about whether this is the best idea. I don't have enough experience to know. Mario and I talked about this a week or two ago, I'll find the link. I'm not sure we came to any conclusions though, just like when we talk about what generality to define a contour integral in...</p>",
        "id": 193806654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586804043
    },
    {
        "content": "<p>(oh, it's just earlier in this thread)</p>",
        "id": 193807039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586804230
    },
    {
        "content": "<p>I did do a little, but got distracted trying to fix up <code>monoid_algebra</code> and its associated theorems. There's a lot still missing there.</p>",
        "id": 193840291,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825434
    },
    {
        "content": "<p>I think it's best to have separate notions for a group acting on something, and for a module for the group ring.</p>",
        "id": 193840322,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825479
    },
    {
        "content": "<p>You really need both points of view, and the ability to move between them.</p>",
        "id": 193840328,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586825491
    },
    {
        "content": "<p>I started proving this equivalence in my <code>GroupModule_2</code> (rather experimental!) branch: <a href=\"https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118\" title=\"https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118\">https://github.com/leanprover-community/mathlib/blob/519a49d74154cee3d23dc45978a4a0e9e5274f37/src/group_theory/Rep.lean#L118</a></p>",
        "id": 193843542,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1586829420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/193803142\">said</a>:</p>\n<blockquote>\n<p>I'm planning to do some representation theory with <span class=\"user-mention silent\" data-user-id=\"201575\">Michael R Douglas</span>. Do you think that is helpful, or are we then stepping on someone's toes? (<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> and <span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> might be working on the same or similar stuff)?</p>\n</blockquote>\n<p>I am certainly not devoting that much effort to it - I'm a complete Lean noob and can't really spare the time to become good at the moment!</p>",
        "id": 193854919,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1586846064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> I think this would be a good time to experiment with the <a href=\"https://github.com/leanprover-community/mathlib/projects\" title=\"https://github.com/leanprover-community/mathlib/projects\">github projects feature</a>. There is a clear path with the basic theory: (1) definition of a representation of a group on an R-module (2) Maschke's theorem (G finite, order invertible in R) (3) Uniqueness of decomposition into irreducible factors (R a field, V fin dim), Schur's Lemma etc (4) [from now on G is finite of order invertible in the alg closed field k and V is fin dim] character of a representation (5) orthonormality of irred chars, and the fact that a rep is determined by its character (6) characters are a basis for the class functions (7) induction and restriction, Frobenius reciprocity. </p>\n<p>I think we should use projects more. People come along and say \"I am an undergrad mathematician, this all looks interesting, what can I do?\" and if we can show them 5 undergraduate-level projects they might find a place to drop in.</p>",
        "id": 193906443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586874834
    },
    {
        "content": "<p>Representation theory is one of these areas where every few months someone pops up and asks if it's done, and with a project we can indicate its current state.</p>",
        "id": 193906697,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586874913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  :   a little maths question :  perhaps we can take  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mtext>Card</mtext><mo stretchy=\"false\">(</mo><mi>G</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">⟨</mo><msub><mi mathvariant=\"normal\">Φ</mi><mrow><mtext>Card</mtext><mo stretchy=\"false\">(</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\"> R[\\text{Card}(G)^{-1}] [X ] / \\langle \\Phi_{\\text{Card}(G)} (X) \\rangle  </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1693079999999998em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord text\"><span class=\"mord\">Card</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord\">Φ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">Card</span></span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">G</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mclose\">⟩</span></span></span></span> as  \" algebraic closed field \" , with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Φ</mi></mrow><annotation encoding=\"application/x-tex\"> \\Phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">Φ</span></span></span></span> the cyclotomic polynomial,    <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 193913534,
        "sender_full_name": "orlando",
        "timestamp": 1586877611
    },
    {
        "content": "<p>Maybe :-)</p>",
        "id": 193913570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586877630
    },
    {
        "content": "<p>But maybe you can only prove that after you have set up the theory? :-/</p>",
        "id": 193913618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586877655
    },
    {
        "content": "<p>That is a nice overview Kevin. It has been too long since I studied representation theory myself to remember the order to build up the theory, but I made a project by putting everything you said on a card.</p>",
        "id": 193970006,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1586907964
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>",
        "id": 194247617,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1586999325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235423\">Ashwin Iyengar</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194247617\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> ! I'd like to contribute to this if it's convenient: it seems like someone's already started defining a representation but happy to do Maschke's theorem, or character theory/class functions etc, so should I wait until the file with the definition has been uploaded to start writing code?</p>\n</blockquote>\n<p>On the other hand, if I'm treading on your toes let me know and I'll find something else to work on!</p>",
        "id": 194247936,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1586999691
    },
    {
        "content": "<p>Ashvni wants to start working on local fields :-)</p>",
        "id": 194248020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586999777
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"235423\">@Ashwin Iyengar</span>: yes, you can join. I made a very small start here: <a href=\"https://github.com/fpvandoorn/group-representations\" title=\"https://github.com/fpvandoorn/group-representations\">https://github.com/fpvandoorn/group-representations</a><br>\nWhat is your Github username, then I can give you write access.</p>",
        "id": 194261377,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1587017952
    },
    {
        "content": "<p>It seems that there are 4 interesting definitions:</p>\n<ol>\n<li><code>G →* general_linear_group R M</code></li>\n<li><code>group_module (G : Type*) [group G] (M : Type*) [add_comm_group M] extends has_scalar G M :=</code></li>\n<li><code>linear_group_module</code> like above, but with modules over <code>R</code></li>\n<li><code>module (monoid_algebra R G) M</code></li>\n</ol>\n<p>Approaches (1), (3), and (4) lead to equivalent categories, and (2) is the specialization <code>R = int</code>.<br>\nThe benefit of (3) is that it gives nice notation. It is so to speak the least bundled version.</p>",
        "id": 194265099,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587021710
    },
    {
        "content": "<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span>\n</pre></div>",
        "id": 194268608,
        "sender_full_name": "David Wärn",
        "timestamp": 1587024102
    },
    {
        "content": "<p>Yes, I think that could work.</p>",
        "id": 194269017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587024333
    },
    {
        "content": "<p>Ooh, maybe not... because <code>R</code> does not occur in <code>has_scalar G M</code>. So it will apply \"too often\".</p>",
        "id": 194269117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587024373
    },
    {
        "content": "<p>Great <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> my github name is ashwiniyengar</p>",
        "id": 194273758,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1587027105
    },
    {
        "content": "<p>Oh, I've also got something. I just made a PR as <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\" title=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> to make it public.</p>",
        "id": 194281257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031444
    },
    {
        "content": "<p>I went the route of extending <code>distrib_mul_action</code>, so it gives the <code>•</code> notation (but may suffer from the problem Johan mentions; so far I haven't seen it).</p>",
        "id": 194281323,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031490
    },
    {
        "content": "<p>My PR proves the equivalence between</p>\n<ol>\n<li><code>representation k G M</code></li>\n<li><code>G →* (M →ₗ[k] M)</code></li>\n<li><code>module (monoid_algebra k G) M</code></li>\n</ol>",
        "id": 194281363,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031516
    },
    {
        "content": "<p>but is stacked on top of <a href=\"https://github.com/leanprover-community/mathlib/issues/2366\" title=\"https://github.com/leanprover-community/mathlib/issues/2366\">#2366</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/2417\" title=\"https://github.com/leanprover-community/mathlib/issues/2417\">#2417</a>, neither of which compile at the moment ... :-)</p>",
        "id": 194281405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031544
    },
    {
        "content": "<p>(I think it's minor for both.)</p>",
        "id": 194281418,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031549
    },
    {
        "content": "<p>(hopefully all three compile now)</p>",
        "id": 194281983,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587031897
    },
    {
        "content": "<p>Yes, I'm afraid we tried enabling the <code>\\bu</code> notation before with little representation theory projects, but ran into trouble...</p>",
        "id": 194282780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1587032418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608\" title=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/194268608\">said</a>:</p>\n<blockquote>\n<p>Shouldn't (4) give the same notation  as (3) if you define something like this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"kn\">instance</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">M</span>\n</pre></div>\n\n\n</blockquote>\n<p>These two instances are likely causing looping behavior. For the second one, whenever Lean needs to find <em>any</em> <code>has_scalar A B</code> instance, is now has to look for instances <code>module (monoid_algebra ?M A) B</code>, which might cause looping because of the metavariable.</p>\n<p>Option (1) and (3) both seem good. The question is really which notation we want to use: <code>ρ g x</code> or <code>g • x</code>. <br>\nThe latter notation is nicer, but also more ambiguous. I think it makes it hard to state results about two representations of the same group in the same vector space. I think those results occur quite frequently in representation theory (right?). Or maybe that's the wrong way of stating it in Lean; maybe the Lean way is to have the representations on different (but isomorphic?) vector spaces.</p>",
        "id": 194338624,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1587057750
    },
    {
        "content": "<p>I guess that for any continuous group homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">G\\to\\mathbb{C}^\\times</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> one gets a character which traditionally would commonly be realised as a action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> on the vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span>.</p>",
        "id": 194340580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587058647
    },
    {
        "content": "<p>This whole business is going to be pretty interesting to formalise actually. One would ideally get as far as the characters of a finite group (over an alg closed field of char 0, say) as being a basis for the class functions, but I always felt like I was treating a character as \"the same as\" a representation, whereas given a character one is going to have to make some kind of choice for the representation when actually proving things about it, and perhaps if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>χ</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\chi(1)=n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">χ</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span> the natural choice for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">k^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>? Although then there's no natural choice for the action <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">\\ldots</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.12em;vertical-align:0em;\"></span><span class=\"minner\">…</span></span></span></span></p>",
        "id": 194340907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587058792
    },
    {
        "content": "<p>Characters are the decategorification of representations!</p>",
        "id": 194348267,
        "sender_full_name": "David Wärn",
        "timestamp": 1587062005
    },
    {
        "content": "<p>My standard contribution: Feit-Thompson uses representation theory so, if you are serious about formalizing it, you should at least have a look at mathcomp. Or ask <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> and <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span></p>",
        "id": 194353664,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1587064428
    },
    {
        "content": "<p>Hello, i do i little exercice with the file of <a href=\"https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean\" title=\"https://github.com/fpvandoorn/group-representations/blob/master/src/group_theory/representation/basic.lean\">here</a> of <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  !  I just try to define a sub representation when a subspace is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding=\"application/x-tex\">\\rho</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">ρ</span></span></span></span>-stable !  <a href=\"https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean\" title=\"https://github.com/Or7ando/lean/blob/master/.github/workflows/group_representation.lean\">here</a></p>",
        "id": 194520334,
        "sender_full_name": "orlando",
        "timestamp": 1587174996
    },
    {
        "content": "<p>Hi @orlando, it's a bit hard to comment on the whole thing at once, as many things are going on in your file.</p>",
        "id": 194522941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179391
    },
    {
        "content": "<p>I've also been thinking about a different approach to defining representations (and in a branch I have the outline of a proof of Maschke's theorem).</p>",
        "id": 194522998,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179419
    },
    {
        "content": "<p>It's in the PR <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\" title=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>, under the branch name <code>representation</code>.</p>",
        "id": 194523013,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179453
    },
    {
        "content": "<p>Your file has a lot of preparatory lemmas, whose purpose I'm pretty unclear on.</p>",
        "id": 194523034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1587179488
    },
    {
        "content": "<p>Hi Scott. </p>\n<p>I try to explain at the outset the definition refers to groups of units. And I would  do things by looking at linear endomophisms.  If i understand, you take endomorphism  definition ! </p>\n<p>I use the notation \\ oo for composition (and I realized that there is a notion * so <code>\\ oo</code>  is not useful I think). The preparatory lemma a just some formula to simplify a little. (and for fun <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span>). </p>\n<p>ohh ,it's cool if you have outline of Maschke Theorem !</p>\n<p>Ps : I just make : </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">new_groupe_representation</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>  <span class=\"bp\">→</span>  <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">has_coe_to</span> <span class=\"n\">ρ</span><span class=\"o\">,</span> <span class=\"n\">rmap_one</span> <span class=\"n\">ρ</span><span class=\"o\">,</span><span class=\"n\">rmap_mul</span> <span class=\"n\">ρ</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>So i thinck that glue the two definitions. But perhaps there is a quicker way to do., using <code> general_linear_equiv :  general_linear_group R M ≃* (M ≃ₗ[R] M) </code> in the  file linear algebra basic <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 194534442,
        "sender_full_name": "orlando",
        "timestamp": 1587200630
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  I redo all my stuff. </p>\n<p>I have problem with conversion <code>↑ ⇑  erw  </code> etc  i think it's more clear but not perfect and it's a good project for me to learn !  I have show just the Schur lemma from Serre book and construct some stuff.  Next step use character hum hum ! </p>\n<p>If you are some comment for a better programming ? <br>\n<a href=\"https://github.com/Or7ando/group_representation\" title=\"https://github.com/Or7ando/group_representation\">here</a></p>",
        "id": 195032307,
        "sender_full_name": "orlando",
        "timestamp": 1587631425
    },
    {
        "content": "<p>The computer scientists will tell you to change <code>[group G]</code> to <code>[monoid G]</code> in the <em>definition</em>, because you do not use inverses :-)</p>",
        "id": 195041768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587637425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> did you see <a href=\"https://github.com/leanprover-community/mathlib/projects/4\" title=\"https://github.com/leanprover-community/mathlib/projects/4\">the representation theory project</a>?</p>",
        "id": 195042867,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587638128
    },
    {
        "content": "<p>Yes Kevin, i start with the first file of <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  but i change the definition because (conversion big problem) ! </p>\n<p>I'm happy cause i understand i little more <code>rfl </code> <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 195044142,
        "sender_full_name": "orlando",
        "timestamp": 1587639176
    },
    {
        "content": "<p>With this project, I feel like the hardest part is choosing the correct initial definition.</p>",
        "id": 195044240,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1587639264
    },
    {
        "content": "<p>ooh, I didn't know we have a kanban board (or whatever the kids call it these days)</p>",
        "id": 195044503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1587639478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>   </p>\n<p>I don't know if you continue about representation. But a question :  do you have a version of the decomposition of representation in irreducible representation ? I have the  orthogonality of character (i have just a little problem with a formula  <code> trace rho g \\-1 = complex.conj trace rho g </code> i don't know if it's decisive for the moment). </p>\n<p>I think just a little about the decomposition for the moment ! So if you have a version tell me <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 197530309,
        "sender_full_name": "orlando",
        "timestamp": 1589449432
    },
    {
        "content": "<p>Wow the proof I know of that trace fact uses a lot</p>",
        "id": 197544673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459121
    },
    {
        "content": "<p>g is in a finite group so the order is finite (else it's false)</p>",
        "id": 197544757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459168
    },
    {
        "content": "<p>There is something called eigenvalues of a matrix</p>",
        "id": 197544797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459199
    },
    {
        "content": "<p>Each eigenvalue is a root of the min poly</p>",
        "id": 197544813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459215
    },
    {
        "content": "<p>Each eigenvalue is a root of unity</p>",
        "id": 197544851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459238
    },
    {
        "content": "<p>Wait</p>",
        "id": 197544869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459248
    },
    {
        "content": "<p>Perhaps what I'm missing is the theory of unitary matrices</p>",
        "id": 197544888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459264
    },
    {
        "content": "<p>Trace of inverse = trace of conjugate = conjugate of trace by <code>transport</code></p>",
        "id": 197544993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459319
    },
    {
        "content": "<p>So maybe prove that the image is in the unitary matrices wrt some R-structure made using the averaged inner form trick?</p>",
        "id": 197545065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589459384
    },
    {
        "content": "<p>hum the problem is what is easy to make in <code>lean </code> for the moment ! Perhaps the root of unity it's difficult for the moment, ???  Perhaps with unitary representation !  </p>\n<p>Yes it's the average trick !  All the basic theory is the average trick  <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 197545968,
        "sender_full_name": "orlando",
        "timestamp": 1589459933
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> You really need to start writing PRs <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 197563533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589466763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I'm really noob with git hub, i just understand <code> git add , git commit, git push </code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  so  first i finish with <code> math / lean </code> and next i try too understand   <code> PR's story </code> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 197583321,
        "sender_full_name": "orlando",
        "timestamp": 1589474570
    },
    {
        "content": "<p>Those three commands are enough (-;</p>",
        "id": 197584761,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475224
    },
    {
        "content": "<p>Ooh, maybe add <code>git checkout</code> for switching branches.</p>",
        "id": 197584883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475253
    },
    {
        "content": "<p>I really fear that otherwise you'll end up with 5000 lines of code, and it will just sit in some repo, and never get PR'd</p>",
        "id": 197584976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589475298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"270476\">@orlando</span> We're definitely not there yet. We're still working on Maschke's Theorem, but we're making good progress.</p>",
        "id": 197607720,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589485418
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Can you elaborate a bit on what you mean by Maschke's theorem for an R-module (instead of a vector space)? Given a submodule of a module, there doesn't necessarily even have to exist a complementary submodule, so if Maschke's theorem guarantees an invariant complementary submodule, then it is false. I think we can prove that <em>if</em> a submodule has a complementary submodule, it also has an invariant one.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">maschke2</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">group_representation</span> <span class=\"n\">G</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"n\">N&#39;</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">complementary</span> <span class=\"n\">N</span> <span class=\"n\">N&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hN</span> <span class=\"o\">:</span> <span class=\"n\">invariant_subspace</span> <span class=\"n\">ρ</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">N&#39;</span><span class=\"o\">,</span> <span class=\"n\">invariant_subspace</span> <span class=\"n\">ρ</span> <span class=\"n\">N&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">complementary</span> <span class=\"n\">N</span> <span class=\"n\">N&#39;</span>\n</code></pre></div>\n\n\n<p><a href=\"https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501\">https://github.com/fpvandoorn/group-representations/blob/da8dfe6c436ec15abeefb73040e31f19d197e11b/src/group_theory/representation/basic.lean#L501</a><br>\nIs this the statement you had in mind?</p>\n<p>Also, is there any source that does representation theory in modules (not in vector spaces)? We're kind of trying to figure out what holds for R-modules as we go, and sometimes have to reformulate results to only hold for vector spaces in the middle of a proof.</p>",
        "id": 197608701,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589485876
    },
    {
        "content": "<p>Yes, it seems to me that you're right, I think the theorems are the following:<br>\n1) If G is finite and 1/|G| is in R, and if there exists a complementary submodule (possibly not G-invariant) to your G-invariant one, then there exists a G-invariant complementary submodule.<br>\n2) If R is a field then there always exists a complementary submodule</p>",
        "id": 197610423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486729
    },
    {
        "content": "<p>The FLT proof contains a whole bunch of representation theory to arbitrary rings, but it doesn't need anything like Maschke, it needs representability theorems. Here is an example of a theorem that it uses (and I'm sure <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> knows about this stuff too):</p>",
        "id": 197610582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486805
    },
    {
        "content": "<p>(oh, dinner time)</p>",
        "id": 197610684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486849
    },
    {
        "content": "<p>(universal deformation rings)</p>",
        "id": 197610709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589486862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Representation.20Theory/near/197610684\">said</a>:</p>\n<blockquote>\n<p>(oh, dinner time)</p>\n</blockquote>\n<p>Yup, I know that one.</p>",
        "id": 197610781,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589486883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>  :</p>\n<p>I'm ok with you're theorem you have to put the hypothesis <code> h </code> for module. But perhaps in a first time we have to use field, for ring i think there is very complicated thing !</p>",
        "id": 197611126,
        "sender_full_name": "orlando",
        "timestamp": 1589487054
    },
    {
        "content": "<p>Ah good, we have already proven (2), using Zorn's Lemma. <br>\nThen we're going to finish this version of Maschke's Theorem.</p>",
        "id": 197620046,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1589491413
    },
    {
        "content": "<p>Hmm, I'm surprised that I couldn't find any kind of representation theory in Bourbaki with my google searches.</p>",
        "id": 197621747,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589492337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  i think it's in this volume :<a href=\"http://www.bourbaki.ens.fr/algebre8-tdm.pdf\">here</a></p>",
        "id": 197623440,
        "sender_full_name": "orlando",
        "timestamp": 1589493352
    },
    {
        "content": "<p>oh, yes! I only found Algebra I (chapters 1-3) and Algebra II (chapters 4-7)</p>",
        "id": 197623550,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589493420
    },
    {
        "content": "<p>i don't have the book <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 197623552,
        "sender_full_name": "orlando",
        "timestamp": 1589493420
    },
    {
        "content": "<p>But there is 400 page before : <code> representation lineaire sur les nombres complexes </code>  i have to learn and read i little <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 197623689,
        "sender_full_name": "orlando",
        "timestamp": 1589493502
    },
    {
        "content": "<p>I see, so this entire book of nearly 500 pages is \"chapter 8\"</p>",
        "id": 197624191,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589493854
    },
    {
        "content": "<p>I found the page on Maschke's theorem on Google Books but I don't know what the standing assumptions on \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span>\" are.</p>",
        "id": 197625144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589494478
    },
    {
        "content": "<p>I found one place that says \"if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is a field [division algebra]\" and others \"a commutative field\" though, so I assume the standing assumption is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is just a ring...</p>",
        "id": 197625313,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589494577
    },
    {
        "content": "<p>Oh thx i don't use google book, it's good !</p>",
        "id": 197626432,
        "sender_full_name": "orlando",
        "timestamp": 1589495366
    },
    {
        "content": "<p>I will try to get back to this soon, but I have a proof of Maschke's theorem in <code>Maschke</code>.</p>",
        "id": 197639091,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589506129
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 197644444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589512858
    },
    {
        "content": "<p>I made <a href=\"https://github.com/leanprover-community/mathlib/issues/2762\">#2762</a>, with my proof of Maschke's theorem. It's still a bit messy, but all the sorries are gone!</p>",
        "id": 198212467,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589987495
    },
    {
        "content": "<p>The thing that it is missing still is the fact that any <code>k</code>-linear inclusion has a retraction, but this is hopefully done somewhere in the existing linear algebra library, and I can plug it in. For now the final statement includes an extra hypothesis for this fact.</p>",
        "id": 198212743,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1589987584
    },
    {
        "content": "<p>I think that fact isn't done yet, but it should be trivial once Yury's PRs on complementary submodules are merged.</p>",
        "id": 198220677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589990848
    },
    {
        "content": "<p>Great work with Maschke's theorem. It's one of those things that every self-respecting library ought to have (-;</p>",
        "id": 198220716,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589990878
    },
    {
        "content": "<p>Scott doesn't need continuous version, and <code>projection</code> PR is already merged.</p>",
        "id": 198220817,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589990915
    },
    {
        "content": "<p>What exactly do you need?</p>",
        "id": 198220911,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589990963
    },
    {
        "content": "<p>E.g., we have <code>exists_left_inverse_of_injective</code> and <code>exists_right_inverse_of_surjective</code> in <code>linear_algebra/basis.lean</code>.</p>",
        "id": 198220974,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589991000
    },
    {
        "content": "<p>Hello, That good <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>\n<p>But for me the big step is really to make the application over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> ! </p>\n<p>For example, the decomposition of a representation in irreducible representation.</p>\n<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>",
        "id": 198297535,
        "sender_full_name": "orlando",
        "timestamp": 1590049880
    },
    {
        "content": "<p>Could we move this thread to the math stream?</p>",
        "id": 198307212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590057748
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Representation.20Theory\">#new members &gt; Representation Theory</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>",
        "id": 198341355,
        "sender_full_name": "Notification Bot",
        "timestamp": 1590077920
    },
    {
        "content": "<p>Thanks Mario.</p>",
        "id": 198346016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590079921
    },
    {
        "content": "<p>I am very new to Lean (Ive checked it in the past many years ago but I had deemed it to unwieldy to get started). I am just curious why the PR for Maschke's Thm don't define the notion of semisimplicity, and just state that k[G] is semisimple, which I think would be how most people would think Maschke's Thm actually looks like. (It unpacks the notion of semisimplicity into the notion of every submodule has a complementary subspace, which I think its equivalent?, though I only work with algebra over (commutative unital) rings, so I don't know the subtleties.)</p>",
        "id": 198419189,
        "sender_full_name": "Syx Pek",
        "timestamp": 1590137645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128818\">@Syx Pek</span> Welcome! The reason is only that the definitions are not there yet. This PR does all the \"real work\", and we can easily repackage it in a follow-up PR. I agree that this should be done. We cannot claim that it's completely done yet (-;</p>",
        "id": 198421905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590139787
    },
    {
        "content": "<p>In particular, the design decisions around \"which definition of semisimplicity should we use\" are probably harder than the actual calculation I did in that PR.</p>",
        "id": 198422199,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139975
    },
    {
        "content": "<p>There are a lot of ways to talk about semisimplicity!</p>",
        "id": 198422220,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139992
    },
    {
        "content": "<p>Yes, I think the issue will be that nobody has defined semisimple algebras yet. I wonder if this is one of those situations where mathematicians are quite happy with several definitions of the same thing but computer scientists can't have this. Is the definition of a semisimple algebra something like \"finite sum of simple algebras\" or \"its representation theory is semisimple\"? There are theorems to be proved here and nobody has got round to it yet</p>",
        "id": 198422229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590139999
    },
    {
        "content": "<p>Yeah what Scott said</p>",
        "id": 198422268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140026
    },
    {
        "content": "<p>They won't be hard</p>",
        "id": 198422340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140044
    },
    {
        "content": "<p>It's just that we are understaffed right now because the universities aren't teaching this stuff</p>",
        "id": 198422381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140083
    },
    {
        "content": "<p>Hello,</p>\n<p>I'm an incoming freshman student in California, USA, interested in mathematics and computer science. In particular, I'm interested in developing the representation theory library in mathlib. I'm looking for guidance, perhaps in the form of a summer internship, or someone who would be willing to oversee me in a project in representation theory. </p>\n<p>I was wondering if anyone here could be looking for interns or knew of such opportunities.</p>\n<p>I have experience contributing elementary results to mathlib. I'm comfortable with basic concepts in type theory, abstract algebra, and category theory. I'm not knowledgable in the fine details of representation theory, so there would be some inertia for me to contribute mathlib-level material--I would essentially be learning as I go. I know there's already a significant amount of un-PR'ed code spread out everywhere; I'm fine doing code transfer, but would prefer if I could prove something new. </p>\n<p>I'm excited to learn, and I would be happy to talk about this in more detail. Thanks for reading!</p>",
        "id": 231378582,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616444548
    },
    {
        "content": "<p>There's a ton of basic representation theory which is do-able but not done yet. You'd be welcome to join my group of students who will be meeting on Tuesdays throughout July and August.</p>",
        "id": 231378705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616444613
    },
    {
        "content": "<p>As a suggestion for source material: I like <a href=\"https://www-math.mit.edu/~etingof/repb.pdf\">Pavel Etingof's notes</a> (it's an AMS book, but also freely available from his webpage), which I think should be pretty readily formalisable.</p>",
        "id": 231389370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449390
    },
    {
        "content": "<p>I would love to see more rep th too. I did a little (the core fact of Maschke's theorem is at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.is_semisimple_module/src\">src#monoid_algebra.is_semisimple_module</a>), but it didn't seem like there were others wanting to work on it in the near future, so paused again.</p>",
        "id": 231389657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449534
    },
    {
        "content": "<p>It would be wonderful to see the proof that the character table of a finite group is square.</p>",
        "id": 231390356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616449858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thank you for the response! I would love to join your group over the summer--could I DM you on Zulip or Discord to talk about more details?</p>",
        "id": 231409432,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616462458
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_semisimple_module\">docs#is_semisimple_module</a> now. I think I see two directions from here:</p>",
        "id": 231418262,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470934
    },
    {
        "content": "<ul>\n<li>Continuing on the abstract algebra of semisimplicity towards Artin-Wedderburn (maybe the Jacobson Density Theorem first)?</li>\n</ul>",
        "id": 231418287,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470982
    },
    {
        "content": "<ul>\n<li>Defining the setoid of conjugacy (if it isn't already lurking somewhere) and its quotient, the type of conjugacy classes of a group/monoid. From there, it's probably not such a long road to the basics of character theory.</li>\n</ul>",
        "id": 231418396,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616471109
    },
    {
        "content": "<p>I'd be happy to contribute at some point especially if someone wants to collaborate towards the first bullet point. A tricky point for the second bullet point is potentially to determine the correct set of assumptions on the ground field (because presumably one doesn't want to just work over the complex numbers).</p>",
        "id": 231433809,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1616486705
    },
    {
        "content": "<p>The work I did on Mashke only assumes the characteristic doesn't divide the order of the field.</p>",
        "id": 231437287,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616488842
    },
    {
        "content": "<p>Speaking of that, I feel like eventually whole files will assume that the characteristic doesn’t divide the order of the group, so we probably want to make that a <code>fact</code> instance</p>",
        "id": 231496296,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616515484
    },
    {
        "content": "<p>Hi. I'm trying to go through the code in <a href=\"https://github.com/leanprover-community/mathlib/tree/representation\">branch#representation</a> and make it work with the current version of lean again. I've run into this universe problem which I don't really understand. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n<span class=\"c1\">-- universe levels don't match</span>\n</code></pre></div>\n<p>Clicking on each thing in the viewer window tells me that <code>restrict_scalars</code> is a function <code>Type u_1 → Type u_2 → Type u_3 → Type u_3</code>. So I think the problem has to do with the final <code>u_3</code> not matching with the universe of <code>module k M</code>, but how do I fix this?<br>\n(cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> because this is basically a copy of his code.)</p>",
        "id": 231906728,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726596
    },
    {
        "content": "<p>Oh dear, that branch is very old. :-) I wouldn't believe it's a good idea...</p>",
        "id": 231906790,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616726654
    },
    {
        "content": "<p>Oh. What's wrong with this branch? I only needed to make minor changes up to this point, and everything seemed to work pretty well.</p>",
        "id": 231906852,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726757
    },
    {
        "content": "<p>I'll have a look. Do you want to push what you have?</p>",
        "id": 231909047,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728750
    },
    {
        "content": "<p>From memory there was still significant uncertainty about how best to represent the simultaneous actions of k and G. There are potentially 3 different <code>has_smul</code> instances available: <code>k</code>, <code>G</code> and <code>monoid_algebra k G</code>.</p>",
        "id": 231909132,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728813
    },
    {
        "content": "<p>Does the existence of <code>smul_comm_class</code> help with that?</p>",
        "id": 231910802,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730413
    },
    {
        "content": "<p>Pushed here: <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a></p>",
        "id": 231911110,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730662
    },
    {
        "content": "<p>It doesn't look like that branch has any commits that aren't on master?</p>",
        "id": 231911231,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730780
    },
    {
        "content": "<p>Oops. It should be there now.</p>",
        "id": 231911428,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730910
    },
    {
        "content": "<p>This is pointed out in the docs for <code>restrict_scalars</code>, but how about using <code>module k M</code>, <code>module (monoid_algebra k G) M</code>, and <code>is_scalar_tower k (monoid_algebra k G) M</code>? Then there's a <code>smul_comm_class</code> from the tower instance. </p>\n<p>Is there anything that says if <code>A</code> is an <code>R</code>-algebra and <code>M</code> an <code>A</code>-monoid, then <code>is_scalar_tower R A M</code>?</p>",
        "id": 231912045,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616731422
    },
    {
        "content": "<p>(I think my last work on this predates <code>is_scalar_tower</code>, and I've not yet got my head around it yet...)</p>",
        "id": 231914243,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616733456
    },
    {
        "content": "<p>Yes, this probably should use both <code>is_scalar_tower</code> and <code>smul_comm_class</code></p>",
        "id": 231916578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616735773
    },
    {
        "content": "<p><code>is_scalar_tower R A M</code> requires a <code>has_scalar R M</code> instance to be used</p>",
        "id": 231932529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749204
    },
    {
        "content": "<p>So I guess your question is \"is there a pair of definitions that produce a <code>has_scalar R M</code> instance and a corresponding <code>is_scalar_tower R A M</code>?\"</p>",
        "id": 231932824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749356
    },
    {
        "content": "<p>If a group <code>G</code> acts on an abelian group <code>M</code> then this can also be viewed as a <code>k[G]</code>-module on <code>M</code>.</p>",
        "id": 231935234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750827
    },
    {
        "content": "<p>And <code>G</code> also acts on <code>k[G]</code></p>",
        "id": 231935252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750840
    },
    {
        "content": "<p>So we want <code>is_scalar_tower G (monoid_algebra k G) M</code></p>",
        "id": 231935272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750854
    },
    {
        "content": "<p>And also one for k and k[G] and M?</p>",
        "id": 231939071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616752896
    },
    {
        "content": "<p>I still don't understand the concrete problem statement, but the error originally was confusing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars\">docs#restrict_scalars</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.semimodule\">docs#restrict_scalars.semimodule</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"bp\">$</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231939945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753308
    },
    {
        "content": "<p>You also want a distrib mul action of G on M</p>",
        "id": 231940084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753383
    },
    {
        "content": "<p>This type of thing is IMO a bad idea though, and safer is to not unfold <code>restrict_scalars</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span>\n  <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 231940091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753387
    },
    {
        "content": "<p>Alternatively just make M a module for the monoid algebra and deduce the k module structure and the distrib mul action structure from that</p>",
        "id": 231940228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753438
    },
    {
        "content": "<p>I think that to talk about a representation in a flexible way, we might need 4 lines of <code>variables</code></p>",
        "id": 231940465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753564
    },
    {
        "content": "<p>To give commuting k and G actions on M is to give an action of the monoid algebra</p>",
        "id": 231940484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753576
    },
    {
        "content": "<p>Mathematicians pass freely between the two points of view</p>",
        "id": 231940528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753609
    },
    {
        "content": "<p>I think the <code>restrict_scalars</code>-free way to set this up is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753699
    },
    {
        "content": "<p>And probably an <code>is_smul_comm_class</code> for good measurer?</p>",
        "id": 231940729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753718
    },
    {
        "content": "<p>That's inferred from <code>is_scalar_tower</code> <del>I think?</del> via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower.to_smul_comm_class\">docs#is_scalar_tower.to_smul_comm_class</a></p>",
        "id": 231940753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753733
    },
    {
        "content": "<p>aah, right. So that should be fine</p>",
        "id": 231940928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753831
    },
    {
        "content": "<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>",
        "id": 231941042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753888
    },
    {
        "content": "<p>You just want to say: \"Let <code>M</code> be a <code>k</code>-linear <code>G</code>-module.\"</p>",
        "id": 231941106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753924
    },
    {
        "content": "<p>Wait, actually I think you can do that</p>",
        "id": 231942405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754553
    },
    {
        "content": "<p><del>Certainly the <code>module (monoid_algebra k G) M</code> instance is inferred already</del></p>",
        "id": 231942453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754580
    },
    {
        "content": "<p>(my orange bars conspired against me again)</p>",
        "id": 231942537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754604
    },
    {
        "content": "<p>Of course ideally we would abstract of <code>monoid_algebra k G</code>, and introduce a <code>k</code>-algebra <code>A</code> together with a predicate <code>is_monoid_algebra k G A</code>.</p>",
        "id": 231942708,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754694
    },
    {
        "content": "<p>Because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo><msub><mo>⊗</mo><mi>k</mi></msub><mi>R</mi><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G] \\otimes_k R = R[G]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>, but Lean will not believe that equality.</p>",
        "id": 231942811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754736
    },
    {
        "content": "<p>I think perhaps this instance should exist and is missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231942983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754829
    },
    {
        "content": "<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>",
        "id": 231943915,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755250
    },
    {
        "content": "<p>Maybe Eric's suggestion is better.</p>",
        "id": 231943934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755261
    },
    {
        "content": "<p>That's goes in the reverse direction to most of mathlib, so is likely to form loops</p>",
        "id": 231943976,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755276
    },
    {
        "content": "<p>In practice, I have a Galois group <code>G</code> that acts on a field <code>L</code> that is an extension of <code>K</code>, and maybe I now want to view <code>L</code> as a <code>K[G]</code>-module.</p>",
        "id": 231944044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755322
    },
    {
        "content": "<p>So I don't want to derive the action of the Galois group <code>G</code> on <code>L</code> from the <code>K[G]</code>-module on <code>L</code>.</p>",
        "id": 231944126,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755344
    },
    {
        "content": "<p>I assume the instance you want is something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">kG</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 231944939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231941042\">said</a>:</p>\n<blockquote>\n<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>\n</blockquote>\n<p>I think they hit that limit in analysis some time ago!</p>",
        "id": 231944942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616755801
    },
    {
        "content": "<p>I'm pretty sure there's a clever way to build a bundled hom in <code>smul</code> such that all the <code>sorry</code>s are as trivial as the first two proofs</p>",
        "id": 231945115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755868
    },
    {
        "content": "<p>This gets two more proofs for free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">≃+</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.comp</span>\n      <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.pi</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but needs <a href=\"https://github.com/leanprover-community/mathlib/issues/6891\">#6891</a> for the <code>g  •</code>, and a definition of <code>add_monoid_hom.pi</code> which appears to be missing.</p>",
        "id": 231949820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616758489
    },
    {
        "content": "<p>Hi, I went back to trying stuff out with this and I've written up a representation theory version of <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s Maschke's lemma. It's pushed to <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. I've also copy pasted a whole bunch of stuff from <code>submodule</code> to create API for a<code>subrepresentation</code> structure I defined. There's also a lattice isomorphism between subrepresentations and submodules of the induced monoid algebra. (The equivalence between the module/representation theoretic versions of Maschke is easy after that.)</p>\n<p>I'm not really looking to push any of this into mathlib yet, since I mostly followed my nose and copy pasted along. I could very possibly have done something terribly wrong without realizing it. So, I just wanted to ask here for thoughts and suggestions from everybody. Also, I'm willing to put a lot more effort into this, but I thought it'd be best to tell everyone here first.</p>\n<p>Anything is welcome! :)</p>",
        "id": 236115794,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619408283
    },
    {
        "content": "<p>Looks promising! Presumably we should tweak <code>maschke.lean</code> so that it uses <code>representation</code>, rather than <code>module (monoid_algebra _ _)</code>.</p>",
        "id": 236121930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414503
    },
    {
        "content": "<p>Do you see any obstacle to doing that?</p>",
        "id": 236121934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414510
    },
    {
        "content": "<p>I'm about to PR Schur's lemma in any linear category over an algebraically closed field. I really hope we can use that statement to directly infer the group theoretical statement of Schur's lemma. (And, similarly, the Lie-theoretic statement.)</p>",
        "id": 236122000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414558
    },
    {
        "content": "<p>(This is now up as <a href=\"https://github.com/leanprover-community/mathlib/issues/7366\">#7366</a>, but it has some dependent PRs so may take a little while.)</p>",
        "id": 236124815,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619417280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236121934\">said</a>:</p>\n<blockquote>\n<p>Do you see any obstacle to doing that?</p>\n</blockquote>\n<p>No, it should be pretty easy. I've started to phase the <code>monoid_algebra k G</code> out and so far the proofs look exactly the same.</p>",
        "id": 236286551,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502408
    },
    {
        "content": "<p>Since you're also working with this stuff, you can always tell me about possible conflicting work, or maybe possible converging work. I'm always happy to coordinate  :)</p>\n<p>(But I'm probably going into the finite groups, character theory direction -- I don't know much about category theory)</p>",
        "id": 236286699,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502568
    },
    {
        "content": "<p>I think character theory is a lovely direction, and I don't have anything in progress there.</p>",
        "id": 236287912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503689
    },
    {
        "content": "<p>I would like to make sure my recent general statement of Schur's lemma is actually usable in representation theory.</p>",
        "id": 236287955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503716
    },
    {
        "content": "<p>Ok. I don't really know what that connection should look like, but I can make sure to set up most of the concrete instances on the ground</p>",
        "id": 236289133,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619504791
    },
    {
        "content": "<p>Again this would be a really nice example showing that we can get theorems about concrete structures of interest from \"abstract nonsense\".</p>",
        "id": 236297404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619510301
    },
    {
        "content": "<p>I don't think Schur's lemma for linear categories exactly counts as abstract nonsense...</p>",
        "id": 236299032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619511322
    },
    {
        "content": "<p>By \"abstract nonsense\" I just mean \"any theorem about categories\"! We've already proved that categories are useful for mathematical definitions, because of schemes. The next step is to prove they're useful for theorems not in category theory and it looks like right now we have two great candidates for this (this and profinite stuff). Homological algebra will be a third.</p>",
        "id": 236312110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619518390
    },
    {
        "content": "<p>I'd love to start using the category theory stuff we have. I don't expect to get to this for some time but getting Schur's lemma for Lie modules as a dividend is just the motivation I need.</p>",
        "id": 236313520,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619519171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, I like that you're moving forward on actually defining <code>representation</code>s and <code>rep_hom</code>s, but of course I have opinions on which definition should be the basic definition.</p>",
        "id": 236365846,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539887
    },
    {
        "content": "<p>Personally, I'd choose the definition currently used in the library (a <code>module (monoid_algebra k G) V</code>), and I'm about to say why, but ultimately as long as that instance, the <code>smul_comm</code> instance, and the <code>to_monoid_hom/of_monoid_hom</code> structure are still there at the end of the day, I don't think it matters that much what the underlying definition is.</p>",
        "id": 236366039,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539957
    },
    {
        "content": "<p>I vote for <code>representation k G V</code> to be defined as an <code>abbreviation</code> of <code>module (monoid_algebra k G) V</code>, because then <code>subrepresentation</code> can be an abbreviation of <code>submodule (monoid_algebra k G) V</code> and <code>rep_hom</code> can be an abbreviation of <code>linear_map</code>, again over <code>monoid_algebra k G</code>.</p>",
        "id": 236366454,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540123
    },
    {
        "content": "<p>You have to define all of the extra structure on <code>representation, subrepresentation, rep_hom</code> one way or another, but this way you don't have to copy and paste all the basic API just to define them and get the basic instances on them.</p>",
        "id": 236366833,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540277
    },
    {
        "content": "<p>Ok. Actually I think I agree with sticking to <code>monoid_algebra k G</code>; it would prevent all the duplication I've been doing.</p>",
        "id": 236366955,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619540297
    },
    {
        "content": "<p>It is not the definition we give to undergraduates, but experience has shown us that the fewer definitions we have, the better.</p>",
        "id": 236367068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540346
    },
    {
        "content": "<p>If I had seen the \"burn <code>vector_space</code>\" PR I would have suggested that it lived on as an <code>abbreviation</code></p>",
        "id": 236367170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540397
    },
    {
        "content": "<p>If you abbreviate these things, and provide the <code>smul_comm</code> instances and so on, it should still be possible to work entirely with those other approaches (although even my undergrad class eventually switched to mostly using group-ring-modules...)</p>",
        "id": 236367383,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540466
    },
    {
        "content": "<p>As we move further into the library, it should also be possible to make <code>irreducible_representation</code> an abbreviation for <code>simple_module</code> and so on</p>",
        "id": 236367518,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540523
    },
    {
        "content": "<p>Yes, the way I was taught it was all G-actions on k-vector spaces and then suddenly this bombshell half way through that it's just R-modules for R=k[G] and about 3/4 of the lemmas we'd proved until that point were true in far greater generality</p>",
        "id": 236367562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540530
    },
    {
        "content": "<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>",
        "id": 236367787,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540643
    },
    {
        "content": "<p>It'd also be nice if there's a short-and-sweet notation that approximates the <code>ρ g</code> notation that you use when talking about the group homomorphism</p>",
        "id": 236368254,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540814
    },
    {
        "content": "<p>Perhaps as simple as <code>ρ k M g</code>...</p>",
        "id": 236368493,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236367787\">said</a>:</p>\n<blockquote>\n<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>\n</blockquote>\n<p>I think this is what I've done indirectly. <code>representation</code> extends <code>smul_comm_class</code> for the <code>G</code> and <code>k</code> actions. Then I derive a <code>module</code> instance. </p>\n<p>I could just cut out defining a <code>representation</code> and do this directly</p>",
        "id": 236368832,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541036
    },
    {
        "content": "<p>But I didn't seem to hit any problems with the type class inference after I defined the <code>module</code> instance; is there an explicit loop we should be worried about?</p>",
        "id": 236369236,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541193
    },
    {
        "content": "<p>Presumably you want to provide a <code>smul_comm_class</code> given a <code>module (monoid_algebra _ _)</code> AND vice versa, but only one can be an instance</p>",
        "id": 236371894,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619542253
    },
    {
        "content": "<p>Without having followed earlier conversation - the <code>of'</code> in <code>representation_theory/basic.lean</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>",
        "id": 236373177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619542812
    },
    {
        "content": "<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>",
        "id": 236373373,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619542877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373177\">said</a>:</p>\n<blockquote>\n<p>Without having followed earlier conversation - the <code>of'</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>\n</blockquote>\n<p>Oh oops, I missed this. But the name is so long...</p>",
        "id": 236373901,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543078
    },
    {
        "content": "<p>Well, you can always define <code>of' := monoid_algebra.single_one_ring_hom</code> and sort out the name later - but there's no need to prove it again!</p>",
        "id": 236373979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619543113
    },
    {
        "content": "<p>Yeah, that's going to be the first thing I do</p>",
        "id": 236374100,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373373\">said</a>:</p>\n<blockquote>\n<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>\n</blockquote>\n<p>If we define a representation as <code>module (monoid_algebra k G) M</code>, then whenever we want to use a representation, we'll assume <code>[representation k G M]</code> which will be equivalent to <code>[module (monoid_algebra k G) M]</code>. Once we're there, we'll sometimes want to refer directly to the <code>k</code>-action, and sometimes to the <code>G</code>-action, so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. We'll also want to know that those commute with each other and with the action of <code>monoid_algebra k G</code>, hence you'll want <code>smul_comm_class</code> and <code>is_scalar_tower</code> instances</p>",
        "id": 236377716,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619544738
    },
    {
        "content": "<blockquote>\n<p>so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. </p>\n</blockquote>\n<p>This doesn't make any sense, because you're not allowed to write <code>[representation k G M]</code> without writing <code>[module k M] [distrib_mul_action G M]</code> first</p>",
        "id": 236378169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544943
    },
    {
        "content": "<p>It's like saying you want an instance to go from <code>module k M</code> to <code>add_comm_monoid M</code></p>",
        "id": 236378228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544967
    },
    {
        "content": "<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>",
        "id": 236378299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545019
    },
    {
        "content": "<p>Ohh, I understand. I'm also realizing that all of this was basically said before in this thread, I just didn't get it before (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  even wrote down the <code>module</code> instance explicitly right above my first comment <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> )</p>",
        "id": 236378308,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545023
    },
    {
        "content": "<p>Oh, I hadn't realized this thread had older replies from me in it!</p>",
        "id": 236378451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236378299\">said</a>:</p>\n<blockquote>\n<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>\n</blockquote>\n<p>Yes, I've been suggesting that we define it as <code>module (monoid_algebra k G) M</code>, which means basically flipping everything <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span> ' been doing backwards...</p>",
        "id": 236378555,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619545163
    },
    {
        "content": "<p>That's perfectly fine with me btw -- actually less work in the long run because there's no duplication</p>",
        "id": 236378757,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545264
    },
    {
        "content": "<p>Based on the recent <code>vector_space</code> removal, I think that is a definition that belongs only in a docstring</p>",
        "id": 236379929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545729
    },
    {
        "content": "<p>Although I guess that argument applies to the definition in the branch too</p>",
        "id": 236380009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545760
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>\n</blockquote>",
        "id": 236380037,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545771
    },
    {
        "content": "<p>I think the usual way to handle this is add instances in the forwards direction (the branch), and type aliases like <code>restrict_scalars</code> in the backwards direction (that suggestion)</p>",
        "id": 236380234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545837
    },
    {
        "content": "<p>Ok. It seems like I will follow the main mathlib direction with this setup then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- a representation</span>\n</code></pre></div>\n<p>And we can go backwards with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module\">docs#restrict_scalars.module</a> and, err, hopefully <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.distrib_mul_action\">docs#restrict_scalars.distrib_mul_action</a></p>",
        "id": 236381558,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619546307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236380037\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I definitely mean this.</p>",
        "id": 236426228,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619566023
    },
    {
        "content": "<p>Looking at the branch, this instance worries me a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">has_group_scalar</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>because when <code>k = G</code> you end up with two <code>has_scalar G (monoid_algebra G G)</code> instances which have different actions.</p>",
        "id": 236488008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608148
    },
    {
        "content": "<p>Perhaps no one ever uses <code>monoid_algebra G G</code> so it doesn't really matter</p>",
        "id": 236488210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608271
    },
    {
        "content": "<p>You'll have things like <code>G = units k</code>. But <code>G = k</code> is unlikely, I think.</p>",
        "id": 236488328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619608334
    },
    {
        "content": "<p>I think I've seen <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\mathbb{Z}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">]</span></span></span></span> before, but this is the integers as an additive monoid.</p>",
        "id": 236489458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609012
    },
    {
        "content": "<p>To avoid the issue we could create a type alias and instead declare the action <code>has_scalar (foo G) (monoid_algebra k G)</code></p>",
        "id": 236489696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619609140
    },
    {
        "content": "<p>I think that in the additive setting, this is more likely to be a problem.</p>",
        "id": 236490390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609474
    },
    {
        "content": "<p>Are we trying to do representation theory of additive monoid/groups as well?</p>",
        "id": 236490426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609492
    },
    {
        "content": "<p>Otherwise Kevin's example would end up begin <code>monoid_algebra int (multiplicative int)</code> and there wouldn't be a problem anyway.</p>",
        "id": 236490505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609524
    },
    {
        "content": "<p>I am playing with <code>monoid_algebra</code> for the LTE, and I indeed suggest to avoid <code>add_monoid_algebra</code> if possible</p>",
        "id": 236490720,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609642
    },
    {
        "content": "<p>It really makes things confusing</p>",
        "id": 236490789,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609657
    },
    {
        "content": "<p>Is that a good reason to avoid it?</p>",
        "id": 236490830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609674
    },
    {
        "content": "<p>I tried to prove the Riemann hypothesis but it really got confusing</p>",
        "id": 236490918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609731
    },
    {
        "content": "<p>I mean, one can prove everything for <code>monoid_algebra</code>, and at the end translate the results for <code>add_monoid_algebra</code> using the fact that they are isomorphic</p>",
        "id": 236490955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609756
    },
    {
        "content": "<p>Yes, that's a fair point.</p>",
        "id": 236490999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609765
    },
    {
        "content": "<p>Or, if you have an additive group <code>A</code> that you want to do representation theory with, just apply the theory to <code>multiplicative A</code></p>",
        "id": 236491066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609813
    },
    {
        "content": "<p>Hi a third time,</p>\n<p>So I didn't do anything with representation theory for awhile, because I kind of sidetracked onto a project to prove the Artin-Wedderburn Theorem, which is finally coming along in <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. It took 1500 loc though, so knowing me it will probably be another while before I can clean it up fully. </p>\n<p>Just posting this out here in case anyone else is planning (or already! -- that would be awkward) working on this.</p>",
        "id": 239917151,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621736902
    },
    {
        "content": "<p>I was working toward this, but I PRed all the work I did manage. I’ll take a look at what you’ve done.</p>",
        "id": 239919422,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1621739748
    },
    {
        "content": "<p>What is the maths-statement of the version of Artin-Wedderburn you're aiming at?</p>",
        "id": 239921043,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621741926
    },
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a semi-simple ring. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes as a direct sum of simple modules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>⨁</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bigoplus_{i = 1}^k n_i S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and there is an ring isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span>. Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">M</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal M_{n} (-)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> is the ring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices. Actually we want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mtext>op</mtext></msup><mo>≃</mo><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R^\\text{op} \\simeq \\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> but I haven't thought too hard about how the <code>op</code>'s go yet.</p>\n<p>The tricky part was to figure out how to write the sum properly. Because letting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> range from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1, \\dots, k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> really means something like going through the isomorphism classes of the set of simple submodules that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes into. Furthermore, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> quantifies the number of submodules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">S&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>≃</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S&#x27; \\simeq S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is the size of each isomorphism class containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<p>In <code>direct_sum_stuff.lean</code>, <code>isomorphism_quot R R</code> is the quotient of <code>decomposition R R</code> by an isomorphism relation. Then for any <code>i : isomorphism_quot R R</code>, we define <code>quotient.class i</code> as the class of <code>i</code>'s representative. So <code>isomorphism_quot R R</code> is supposed to be <code>1,...,k</code> and <code>quotient.class i</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span> looks like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">something</span> <span class=\"o\">[</span><span class=\"n\">is_semisimple_module</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">isomorphism_quot</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n    <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">i.out</span><span class=\"o\">))</span> <span class=\"bp\">≃+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 239922346,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621743587
    },
    {
        "content": "<p>Hopefully this looks correct and understandable. (and sane?) I would be very happy to take any suggestions and/or talk about my code!</p>",
        "id": 239922692,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Thanks in advance! Sorry everything is in the wrong place right now. I will be organizing code, files, and docstrings in the next few days so it should be much clearer then</p>",
        "id": 239922994,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744352
    },
    {
        "content": "<p>Oh and it shouldn't be too hard to go from the above and prove the version where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is also an algebra over some field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.</p>",
        "id": 239923135,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744468
    },
    {
        "content": "<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>",
        "id": 239929435,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752160
    },
    {
        "content": "<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>",
        "id": 239929499,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752250
    },
    {
        "content": "<p>I think an important part of Artin-Wedderburn is that this decomposition is unique up to relabelling.</p>",
        "id": 239929519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752294
    },
    {
        "content": "<p>I had been proving this on a branch a while ago --- the version I wanted was that if you had a collection of objects so that homs between them were either zero or isomorphisms (e.g. the set of all simple objects), then decompositions into direct sums of these objects were unique (before we even come to the question of existence).</p>",
        "id": 239929606,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929435\">said</a>:</p>\n<blockquote>\n<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>\n</blockquote>\n<p>Yes, I'm just using the definition.</p>",
        "id": 239982586,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621808945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929499\">said</a>:</p>\n<blockquote>\n<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>\n</blockquote>\n<p>As for the second part, I think I agree that the two parts are really separate things. I'm very out of depth on your first sentence though. What more general objects are you talking about when you say \"nothing to do with rings and modules\"?</p>",
        "id": 239982885,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809250
    },
    {
        "content": "<p>To be honest I wasn't even thinking about the unique part but now I'm realizing that it should also be a part of the proof. It shouldn't be too hard to prove from my approach just working concretely with the modules. May I ask how you've been approaching it? I guess which way do you think is more important?</p>",
        "id": 239983496,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809977
    },
    {
        "content": "<p>So we have the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.simple/src\">src#category_theory.simple</a>, which hopefully is enough to do the endomorphism ring calculation.</p>",
        "id": 239989405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816430
    },
    {
        "content": "<p>Say you have a collection of objects <code>X i</code> in a preadditive category such that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>. Then if you have a direct sum of these objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo>⨁</mo><msub><mi>n</mi><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A = \\bigoplus n_i X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (quite how to state that hypothesis is actually the trickiest thing here), then it should be easy to provide the ring isomorphism from <code>End A</code> to the direct sum of matrices over the <code>End (X i)</code>.</p>",
        "id": 239989732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816777
    },
    {
        "content": "<p>Then the next step is to assume something a little stronger: every nonzero morphism <code>X i ⟶ X i</code> is an isomorphism (e.g. this holds if you take <code>X i</code> to be the collection of simples). (I don't think we even need Schur's lemma yet, which says that if the category is linear over an algebraically closed field then every morphisms <code>X i ⟶ X i</code> is actually a multiple of the identity.)</p>\n<p>Now you can prove inductively, by a \"Gaussian elimination\" type argument, that if you have <span class=\"tex-error\">$$\\bigoplus n_i X_i \\iso \\bigoplus m_i X_i$$</span> then in fact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i = m_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 239989939,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816952
    },
    {
        "content": "<p>I should say I haven't actually done this. I made one aborted attempt that was unnecessarily complicated, but I would like to do this at some point.</p>",
        "id": 239989975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817001
    },
    {
        "content": "<p>A final thing that would be nice to prove: </p>\n<p>Let's give a name to the two above conditions on a collection of <code>X i</code> (that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>, and any nonzero endomorphism of an <code>X i</code> is invertible), \"<code>X</code> are mutually simple\". (Notice that the <code>X</code> aren't necessarily simple in this definition!)</p>\n<p>Then you can prove that if every object <code>Z</code> is isomorphic to some direct sum of the <code>X i</code> (in fact, in a unique way by the claim above), in fact the category is semisimple, and the <code>X i</code> are a set of representatives of the isomorphism classes of simples.</p>\n<p>This approach is useful for example in quantum topology: e.g. typically any \"diagrammatic algebra\", like the Temperley-Lieb algebra underlying the Jones polynomial, is awkward to prove semisimplicity \"via algebra\", and the best approach is to produce this family of mutually simple objects first, then conclude afterwards the category is semisimple. In the quantum topology literature this approach sometimes goes by the name \"Müger semisimplicity\", as he explained how to use it.</p>",
        "id": 239990403,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817452
    },
    {
        "content": "<p>In the literature \"mutually simple\" is called a \"semibrick\". There is a related condition of a \"simple-minded collection\" in a triangulated category.</p>",
        "id": 240006782,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621832959
    },
    {
        "content": "<p>Oh, interesting, where do people use \"semibrick\"? I hadn't heard that one.</p>",
        "id": 240013032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621839170
    },
    {
        "content": "<p>In representation theory of finite dimensional algebras, most recently in a generalisation of the classical theory of tilting modules called tau-tilting theory, see e.g. <a href=\"https://arxiv.org/abs/1610.05860\">https://arxiv.org/abs/1610.05860</a></p>",
        "id": 240014896,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621840675
    },
    {
        "content": "<p>Here's a first cut at proving that morphisms between direct sums of hom-orthogonal objects can be decomposed into direct sums of matrix blocks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.biproducts</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.eq_zero</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">o</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subsingleton.elim</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finite_biproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.matrix_decomposition</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"bp\">≫</span>\n      <span class=\"n\">biproduct.components</span> <span class=\"n\">z</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">biproduct.matrix</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">k</span> <span class=\"k\">then</span>\n      <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"n\">biproduct.lift_π</span><span class=\"o\">,</span> <span class=\"n\">biproduct.ι_matrix</span><span class=\"o\">],</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">o.eq_zero</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">w.symm</span><span class=\"o\">],</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- TODO additive version? linear version?</span>\n</code></pre></div>",
        "id": 240309657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028589
    },
    {
        "content": "<p>unique decomposition in a semibrick (a <code>hom_orthogonal</code> family where each object's nonzero endomorphisms are invertible) is going to be a little bit more involved, but I'll try it soon.</p>",
        "id": 240309823,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all your replies! Since you're planning to work on this, I don't think my approach really makes sense anymore. Especially because mine seems to be strictly less general. Would you mind though if I tried to redo some of my work following your thoughts on the category theoretic version? To be clear I would like to try as more of a learning project rather than a <code>for mathlib</code> project, in case you don't want interference.</p>",
        "id": 240422417,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093831
    },
    {
        "content": "<p>Although a side effect may be that I start asking a lot of random category theory questions here.</p>",
        "id": 240422426,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093849
    },
    {
        "content": "<p>Oops, sorry, I don't mean to stop you doing anything. I've been thinking about doing this for a while but haven't actually done it, so I don't want to discourage you!</p>",
        "id": 240422498,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622093910
    },
    {
        "content": "<p>I just didn't want to wait until you had a PR to make suggestions about how to decouple AW into smaller pieces. :-)</p>",
        "id": 240422583,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094031
    },
    {
        "content": "<p>One possibility would be to clean up what I posted above and get that ready for a PR. There are obvious next steps: show the equivalence I constructed is compatible with the obvious compositions on both sides, and then deduce the ring isomorphism for an endomorphism.</p>",
        "id": 240422632,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094116
    },
    {
        "content": "<p>Would you be interested in doing that?</p>",
        "id": 240422680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094159
    },
    {
        "content": "<p>Ah, my bad for misunderstanding. I kind of read too much into what you said lol</p>",
        "id": 240422685,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094183
    },
    {
        "content": "<p>You've seen all the work I've done so far! :-)</p>",
        "id": 240422699,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094204
    },
    {
        "content": "<p>Now I'm thinking I should definitely get my original code PR out so people can actually see what I'm trying to put into mathlib</p>",
        "id": 240422707,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094227
    },
    {
        "content": "<p>I would be very interested in doing a general version of Artin-Wedderburn as a follow up!</p>",
        "id": 240422765,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094287
    },
    {
        "content": "<p>Yes -- it's also no problem I think if first versions of things in mathlib are not in maximal generality. If someone upgrades your content later with something more general, you shouldn't feel sad about it, but happy that you provoked someone into doing work. :-)</p>",
        "id": 240422772,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094304
    },
    {
        "content": "<p>I think I just have a bad habit of writing too much code without PRing any of it. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Time too clean up all of my code...</p>",
        "id": 240422876,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094424
    },
    {
        "content": "<p>I mentioned in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> wanting to add more representation theory to mathlib. While I only learned it from Fulton &amp; Harris, <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> suggested Etingof. Just starting a thread here to gather some opinions and advice.</p>",
        "id": 241665540,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622943398
    },
    {
        "content": "<p>Others have certainly been thinking about this recently: e.g. <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, myself (very slowly, sorry). I'm looking forward to more representation theory!</p>\n<p>I'm actually doing a bunch of low-level work at the moment, generalising a lot of our code about dimensions and bases to arbitrary noetherian and/or commutative rings (where previously it was just done over a field). I'm hoping this will be useful in representation theory per se soon.</p>",
        "id": 241665598,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943528
    },
    {
        "content": "<p>Higher up in this same thread there is discussion about Artin-Wedderburn.</p>",
        "id": 241665601,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943537
    },
    {
        "content": "<p>We already have Maschke's theorem (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.submodule.is_complemented/src\">src#monoid_algebra.submodule.is_complemented</a>) and Schur's lemma.</p>",
        "id": 241665653,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943623
    },
    {
        "content": "<p>Although the current statement of Maschke's theorem is the \"core\" fact, and often you see it stated in a form that also gives various corollaries, so this might be a good first step. (i.e. find all the statements of Maschke's theorem you can in books, and make sure they follow from the version of Maschke's theorem already in mathlib!)</p>",
        "id": 241665664,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943700
    },
    {
        "content": "<p>I was actually having trouble finding Schur's lemma. Could you point me to it? I was actually trying to work up to proving it myself as practice. I'm not familiar with Maschke's theorem.</p>",
        "id": 241665801,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622943906
    },
    {
        "content": "<p>We actually have two independent proofs of versions of Schur's lemma!</p>",
        "id": 241665803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943911
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.bijective_of_ne_zero/src\">src#linear_map.bijective_of_ne_zero</a>, which states that a nonzero morphism between simple R modules is bijective.</p>",
        "id": 241665808,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943944
    },
    {
        "content": "<p>(for <code>R</code> any ring)</p>",
        "id": 241665810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943960
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso_of_hom_simple/src\">src#category_theory.is_iso_of_hom_simple</a></p>",
        "id": 241665853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943998
    },
    {
        "content": "<p>which is much more general, saying that any nonzero morphism between simple objects in a preadditive category with kernels is an isomorphism.</p>",
        "id": 241665860,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944028
    },
    {
        "content": "<p>We should unify these. I hadn't realised until today that the special case theorem existed in mathlib.</p>",
        "id": 241665864,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944053
    },
    {
        "content": "<p>There there are also various stronger versions of Schur's lemma.</p>",
        "id": 241665865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944067
    },
    {
        "content": "<p>in a <code>k</code>-linear category (<code>k</code> an algebraically closed field), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.finrank_hom_simple_simple_le_one/src\">src#category_theory.finrank_hom_simple_simple_le_one</a> says the dimension of the hom space between two simples is at most one.</p>",
        "id": 241665921,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944169
    },
    {
        "content": "<p>and two lemmas immediately afterwards say that it is 1 or 0 depending on whether the simple objects are isomorphic or not.</p>",
        "id": 241665941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944202
    },
    {
        "content": "<p>(Also --- if you're having trouble finding Schur's lemma, you haven't learnt how to use the right search tools: you should have the mathlib folder open in VSCode, and in the search bar type <code>Schur</code>. You can't miss it.)</p>",
        "id": 241665984,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944276
    },
    {
        "content": "<p>I did not know there are these generalisations to Schur's lemma! As a theoretical physics person, I only know it for matrix representations.</p>",
        "id": 241666045,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622944392
    },
    {
        "content": "<p>Ah no wonder. I've been using the documentation site's search function.</p>",
        "id": 241666050,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622944440
    },
    {
        "content": "<p>I'll take a look at Etingof and compare with mathlib.</p>",
        "id": 241666149,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622944611
    },
    {
        "content": "<p>I'm working on the Artin-Wedderburn theorem (also very slowly!) with the far-away goal to prove that character tables for finite groups are square.</p>",
        "id": 241669742,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622950635
    },
    {
        "content": "<p>I wrote about 600 lines for some basic definitions and lemmas regarding representations of algebras, following the first few pages of Etingof. Would anyone like to give some advice/feedback? I'm getting stuck at defining the direct sum of representations and showing that decomposable representations are reducible.</p>",
        "id": 242457084,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623512422
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lsULBUVPUtkKrbXpHVGyKJt1/representation.lean\">representation.lean</a></p>",
        "id": 242457096,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623512486
    },
    {
        "content": "<p>The proofs are certainly not efficient, so I welcome suggestions for improvement or tricks I should know</p>",
        "id": 242457172,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623512605
    },
    {
        "content": "<p>I have some reservation regarding the notation. Currently, <code>representation</code> has a <code>coe_fn</code> from an algebra to an endomorphism of modules, which means the representation is identified with the function. Usually however, we say \"let vector space V be a representation of the algebra A\", so a representation is identified with the target space. I don't have enough experience to tell which one is better for mathlib.</p>",
        "id": 242457457,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623512910
    },
    {
        "content": "<p>Also, sorry in advance if the names don’t obey the convention</p>",
        "id": 242458440,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623514096
    },
    {
        "content": "<p>Winston, just in case you missed it (zulip doesn't mention if your topic title already exists), there is lots of discussion above your message</p>",
        "id": 242458558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514281
    },
    {
        "content": "<p>Also, rather than uploading the txt file to zulip, could you create a gist on github? I get encoding issues when trying to read your text file on Android, which won't be true of a gist</p>",
        "id": 242458642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I’ll do that in the morning (midnight here). Never done gist before</p>",
        "id": 242458947,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623514793
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span>, cool! Here are some thoughts from just looking at the file (I didn't actually run lean, so some of my suggestions might be wrong, let me know if I can clarify anything). Its easier for people to look at if you open a PR (tagged WIP for example) or at least make a git branch on mathlib so people can check the branch out more easily, let us know if you need assistance setting that up and we can help.</p>\n<ul>\n<li>If you have multiple rewrites in a row you can combine them so</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<ul>\n<li>If you just run one tactic with <code>by {simp}</code> the curly braces <code>{}</code> aren't needed.</li>\n<li>The character <code>ᾰ</code> is awkward to type on purpose, the idea is that you shouldn't use it! Instead give a name to the thing you want to refer to, for <code>has_bot</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span>\n</code></pre></div>\n<p>you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">submodule.mem_bot</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I believe.</p>\n<ul>\n<li>You apply theorems like <code>  apply linear_map.ext</code> you could likely replace this with just calling the <code>ext</code> tactic. Likewise for <code>    apply funext</code></li>\n<li>If you have multiple goals its easier to read and manage them if you separate each goal into a block with braces, so whenever you have <code>split</code> the next line should start with a brace <code>{</code> to focus the first goal only.</li>\n<li>There are some nice tactics for reducing repetition like <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#all_goals\">tactic#all_goals</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#repeat\">tactic#repeat</a>, for example you have</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span>\n</code></pre></div>\n<p>which could probably become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span> <span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li>You have a line</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>probably <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp\">tactic#dsimp</a> will do this for you</p>",
        "id": 242459381,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623515181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> those are great suggestions. Thank you!</p>",
        "id": 242459695,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623515636
    },
    {
        "content": "<p>A coule more: </p>\n<ul>\n<li>\n<p><code>Type _</code> is more usually done as <code>Type *</code>,</p>\n</li>\n<li>\n<p><code>simp</code> not at the end of the line is usually considered bad form, as it's hard to debug when you add more <code>@[simp]</code> lemmata. You should <code>squeeze_simp</code> them, or if you can put them at the end (potentially using <code>simpa</code>). You can also give <code>simp</code> bonus lemmata in the same sort of form that you pile up lemmata on <code>rw</code>, e.g. <code>simp [representation.smul_add]</code>.</p>\n</li>\n<li>\n<p>Some of your lemmas should definitely be tagged with <code>@[simp]</code>.</p>\n</li>\n<li>\n<p>You may be able to get away with reusing some lemmata from <code>linear_map</code> instead of having to re-prove them; you may have to put <code>local attribute [reducible] representation</code> in order to do this, though.</p>\n</li>\n<li>\n<p>You usually don't have to put <code>{ name . field := ... }</code> in the definitions of things; Lean will figure it out most of the time, and if it doesn't, it'll shout at you.</p>\n</li>\n<li>\n<p>I <em>think</em> the standard approach for sub-objects now is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a>.</p>\n</li>\n<li>\n<p>Lean usually prefers working backwards; proofs with a lot of <code>at this</code> tend to be a red flag that you could write it \"more idiomatically\".</p>\n</li>\n</ul>\n<p>There's some specific thoughts, too, that would be a lot easier to talk about in a github PR (e.g. the <code>rw</code> is unnecessary in <code>one_smul</code>). Have you got an invite to contribute to <code>mathlib</code>?</p>",
        "id": 242460159,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623516267
    },
    {
        "content": "<p>Not yet. I’ll try a GitHub PR in the morning and maybe get some help here</p>",
        "id": 242461842,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623518588
    },
    {
        "content": "<p>Before you go to sleep, drop your github username and maintainers should be able to give you an invite for the morning ^^</p>",
        "id": 242462375,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623519581
    },
    {
        "content": "<p>If you haven't already seen it, check out our page with tips for contributors: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>",
        "id": 242464386,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623522256
    },
    {
        "content": "<p>If somebody could invite me to GitHub: <a href=\"mailto:winstonyin@gmail.com\">winstonyin@gmail.com</a> Got too tired last night after all!</p>",
        "id": 242486001,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623552828
    },
    {
        "content": "<p>I just sent an invite to that email. You'll need to create a GitHub account if you don't already have one.</p>",
        "id": 242486534,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623553802
    },
    {
        "content": "<p>I've pushed my commit: <a href=\"https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9\">https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9</a> (&lt;---- this is a mistake)</p>",
        "id": 242497905,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623572295
    },
    {
        "content": "<p>I only added representation.lean, so I'm not sure why there are all these other changed files.</p>",
        "id": 242497913,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623572329
    },
    {
        "content": "<p>I think I see the issue. There's an existing branch called <code>representation</code>, which I've just pushed to... I'm sorry! Please help me fix this mistake, as I'm not good with git. It also looks like that branch is trying to do some of the same things I'm doing but differently.</p>",
        "id": 242498028,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623572531
    },
    {
        "content": "<p>Ok the correct branch I've just created: <a href=\"https://github.com/leanprover-community/mathlib/compare/winstonyin/representation\">https://github.com/leanprover-community/mathlib/compare/winstonyin/representation</a></p>",
        "id": 242499506,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1623575213
    },
    {
        "content": "<p>Hi,<br>\nI would like to try to contribute to the extent of my knowledge to the representation theory project in mathlib, but I am unsure where to starts since it looks like a few people are already working on this but there's not a lot in mathlib itself. I was wondering what is the state of the project right now.<br>\nI found the pull request <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>, which seems to introduce a definition of group representations and prove equivalences with other usual definitions; it seems like a good starting point, but it has been closed without merging. Why is that so, were there fundamental flaws in the approach of this PR?</p>",
        "id": 260792262,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636461998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 260792855,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636462324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Is there a particular thing in repn thy that you would like to work on?</p>",
        "id": 260796972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636464549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think that working towards orthogonality for characters of finite groups could be interesting. But I don't know if there are other things we'd need to get out of the way before working on that.</p>",
        "id": 260797537,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636464861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Sounds good. Maybe create a little mind map of the topics you would need?</p>",
        "id": 260800758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466429
    },
    {
        "content": "<p>E.g., mathlib doesn't have class functions at the moment. I guess you would want to have those</p>",
        "id": 260800793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466448
    },
    {
        "content": "<p>If you have a list of things, we can quickly tell you what is there and what is not</p>",
        "id": 260800833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466465
    },
    {
        "content": "<p>I remember from a past discussion of representation theory is that one difficulty is the variety of different ways a representation can be expressed.  As a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action\">docs#mul_action</a>, as a homomomorphism of the group into the automorphism group of the vector space, and as a module over the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra\">docs#monoid_algebra</a> of <code>G</code>.  I don't even think we have glue among these different notions.  Did we ever decide which one should be primary?</p>",
        "id": 260803019,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636467342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  Yeah, that's why I asked about <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>. The primary definition it takes is a <code>distrib_mul_action</code> such that the action of <code>G</code> commutes with that of <code>k</code> and it proves the equivalence with the two other definitions you mention. So it seems like it's already done, but have never been merged into mathlib.</p>",
        "id": 260813460,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471381
    },
    {
        "content": "<p>And yeah, I could try to create a little list of needed topics</p>",
        "id": 260813664,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471451
    },
    {
        "content": "<p>The direction mathlib has gone since is to avoid things like <code>representation</code> which bundles together both actions and their compatibility, and instead chooses to have three separate typeclasses for these facts.</p>",
        "id": 260854918,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489214
    },
    {
        "content": "<p>i.e. use the <code>smul_comm_class</code> (which quite possibly didn't even exist when I closed that PR??).</p>",
        "id": 260855034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489274
    },
    {
        "content": "<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>",
        "id": 260855176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489326
    },
    {
        "content": "<p>Personally I hope that we will also make a bundled version, perhaps as <code>Rep k G</code>, and provide a categorical API for everything, too.</p>",
        "id": 260855288,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489374
    },
    {
        "content": "<p>There are a lot of functors used early on in representation theory (induction and restriction, particularly), and it seems to me a great shame if we do not express these as functors!</p>",
        "id": 260855373,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260855176\">said</a>:</p>\n<blockquote>\n<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>\n</blockquote>\n<p>Ok, maybe I think I could try to do that first, since these equivalences seem to me like a necessary thing to get out of way before being able to work on interesting character theory.<br>\nI am not yet very comfortable with typeclasses and their subtleties, so would you mind explaining why it is a better approach to have separate typeclasses for the actions and their compatibilities? To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>",
        "id": 260874886,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636498701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 260880171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502024
    },
    {
        "content": "<p>So you'd want definitions (perhaps instances in one direction) translating between <code>[module k V] [distrib_mul_action G V] [smul_comm_class k G V]</code> and <code>[module (monoid_algebra k G) V]</code>.</p>",
        "id": 260880378,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502142
    },
    {
        "content": "<p>Some of these hopefully already exist, in the files that develop <code>monoid_algebra</code>.</p>",
        "id": 260880460,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502173
    },
    {
        "content": "<p>But then I'd also define <code>Rep k G</code> to be a structure, (parametrised also be the ring structure on <code>k</code> and the group structure on <code>G</code>), which has as fields the carrier type <code>V</code> and the remaining type classes. Then put a category instance on that.</p>",
        "id": 260880539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502239
    },
    {
        "content": "<p>Given the way we do bundled morphisms, there is not really a good way to say \"a function V to W which is both <code>k</code> linear and <code>G</code> linear\". So I suspect the <code>module (monoid_algebra k G) V</code> version is going to be important, because we <em>can</em> easily talk about a function which is <code>monoid_algebra k G</code>-linear.</p>",
        "id": 260880684,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502321
    },
    {
        "content": "<p>Thanks! So, for the backward direction (from <code>[module (monoid_algebra k G) V]</code>), would we have 3 definitions, one giving <code>[module k V]</code>, one giving <code>[distrib_mul_action G V]</code> and one giving <code>[smul_comm_class k G V]</code>, or should this be all bundled together somehow? In the first case, how would we formulate that the two parts pf the correspondence are inverses of each other?</p>",
        "id": 260886632,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636506365
    },
    {
        "content": "<p>There would be 3 definitions. (Almost surely the first one already exists.)</p>",
        "id": 260888128,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507683
    },
    {
        "content": "<p>I guess we could write an equivalence with lots of <code>letI := ...</code> statements on one side of the equivalence, to specifying explicitly using the instance that has gone back and forth through the equivalence.</p>",
        "id": 260888215,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507760
    },
    {
        "content": "<p>Another quick question : how can I make Lean figure out what the <code>distrib_mul_action</code> is in the definition of <code>[smul_comm_class k G V]</code>?<br>\nIn other words, how to avoid the error in the second definition here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_mul_action</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_has_scalar</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"o\">},</span>\n                     <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n                     <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260943866,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636517536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> One option is to use a type synonym for <code>V</code>, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span> <span class=\"kd\">def</span> <span class=\"n\">rep_space</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260944446,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518351
    },
    {
        "content": "<p>(The type synonym is when I rename <code>V</code> as <code>rep_space ρ</code>.)</p>",
        "id": 260944497,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518386
    },
    {
        "content": "<p>By the way, I rearranged your <code>distrib_mul_action_of_monoid_hom</code> a little for conciseness, but the only substantive change was from <code>def</code> to <code>instance</code>.</p>",
        "id": 260944511,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518432
    },
    {
        "content": "<p>What's the advantage of <code>instance</code> over <code>def</code>?</p>",
        "id": 260944587,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518517
    },
    {
        "content": "<p><code>instance</code> can be found by \"typeclass inference\", <code>def</code> can't.  So, for example, the fact that a metric space is in a natural way a topological space is found by typeclass inference.</p>",
        "id": 260944607,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518558
    },
    {
        "content": "<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>",
        "id": 260944624,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518599
    },
    {
        "content": "<p>Should <code>smul_comm_class_of_monoid_hom</code> also be an instance then?</p>",
        "id": 260944673,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518620
    },
    {
        "content": "<p>Yes!</p>",
        "id": 260944684,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518657
    },
    {
        "content": "<p>Btw, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is the person to talk to when it comes to scalar actions in mathlib. I'm sure he knows the best way for moving back and forth between </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and modules over <code>monoid_algebra k G</code>.</p>",
        "id": 260944760,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518743
    },
    {
        "content": "<p>He has been adding a lot of homomorphisms of the form <code>G -&gt; Aut _</code> or <code>R -&gt; End _</code> derived from scalar actions. So this might already be there.</p>",
        "id": 260944792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260944624\">said</a>:</p>\n<blockquote>\n<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>\n</blockquote>\n<p>OK, I got it working without typeclass inference (but as you can see, it's painful!).  Not even sure if I've missed some tricks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260945191,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636519316
    },
    {
        "content": "<p>Oof indeed, it seems like it's much better to use typeclass inference</p>",
        "id": 260945790,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636520075
    },
    {
        "content": "<p>Note that we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.of_End_hom\">docs#mul_action.of_End_hom</a>; so we <em>could</em> have something called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.of_add_monoid_End_hom\">docs#distrib_mul_action.of_add_monoid_End_hom</a> similar to the <code>distrib_mul_action_of_monoid_hom</code> above</p>",
        "id": 260964520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536738
    },
    {
        "content": "<p>Having said that, the implementation would just be <code>distrib_mul_action.comp_hom _ ρ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">distrib_mul_action.comp_hom</span> <span class=\"n\">_</span> <span class=\"n\">ρ</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 260964705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks! Is there a reason you used def instead of instance as Heather suggested?<br>\nAlso is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>",
        "id": 260982846,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636547941
    },
    {
        "content": "<p>The first one can't be an instance because it depends on <code>ρ</code>, while the second one already exists so you don't need it anyway</p>",
        "id": 260988228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550815
    },
    {
        "content": "<blockquote>\n<p>Also is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>\n</blockquote>\n<p>Can you give me the lean statement?</p>",
        "id": 260988265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550828
    },
    {
        "content": "<p>Is this the forward statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- are these the defining properties of the action you want?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">of_smul</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map_smul</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">algebra_map</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 260988453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550917
    },
    {
        "content": "<p>What do you think of the proposition of Heather which is to define a vector space which is just a copy of <code>V</code> and put <code>distrib_mul_action</code> and <code>smul_comm_class</code> instances on it? And yes, that would be the forward statement .</p>",
        "id": 260990340,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636551867
    },
    {
        "content": "<p>I think that's a reasonable idea</p>",
        "id": 260992095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636552720
    },
    {
        "content": "<p>Whether it's necessary depends on whether <code>V = monoid_algebra k G</code> would create ambiguity</p>",
        "id": 261003750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636557281
    },
    {
        "content": "<p>I don't think I understand what you mean, <code>V</code> is the module, not the monoid algebra</p>",
        "id": 261006106,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636558231
    },
    {
        "content": "<p>V is any type that satisfies the module axioms. <code>V = monoid_algebra k G</code> is one such type.</p>",
        "id": 261008694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559337
    },
    {
        "content": "<p>If your instance can be parameterized to give a <code>has_scalar (monoid_algebra k G) (monoid_algebra k G)</code> instance, it must definitionally satisfy <code>a • b = a * b</code> to avoid diamonds</p>",
        "id": 261008980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260874886\">said</a>:</p>\n<blockquote>\n<p>To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>\n</blockquote>\n<p>In addition to the great advice, examples already provided you could also look at some of our Lie theory, at least to see one way to set things like this up in terms of typeclasses. E.g., <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_module\">docs#lie_module</a> is the definition of a representation of a Lie algebra.</p>",
        "id": 261025294,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636565775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you know if we have the equivalence, for an algebra <code>A</code> over <code>k</code>, of <code>module A M</code> with <code>is_scalar_tower k A M</code> and algebra maps from <code>A</code> to <code>M →ₗ[k] M</code></p>",
        "id": 261293336,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636742127
    },
    {
        "content": "<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>",
        "id": 261294067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742491
    },
    {
        "content": "<p>It seems we have neither</p>",
        "id": 261294169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742526
    },
    {
        "content": "<p>Oh, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.to_linear_map\">docs#distrib_mul_action.to_linear_map</a>, if you just want <code>A → M →ₗ[R] M</code></p>",
        "id": 261294863,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742890
    },
    {
        "content": "<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">module.to_module_End_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">one_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261295133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743065
    },
    {
        "content": "<p><del>I never PR'd that because I couldn't find a good place to put it where I had all the typeclasses available</del></p>",
        "id": 261295173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261294067\">said</a>:</p>\n<blockquote>\n<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>\n</blockquote>\n<p>Actually I mostly want the other direction</p>",
        "id": 261295580,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743273
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.apply_module\">docs#linear_map.apply_module</a></p>",
        "id": 261295690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743349
    },
    {
        "content": "<p>Which probably should be renamed to <code>module.End.apply_module</code></p>",
        "id": 261295709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743362
    },
    {
        "content": "<p>Or at least, it's that if you combine it with <code>module.comp_hom f</code> where <code>f : A →+* module.End R M</code></p>",
        "id": 261295782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743395
    },
    {
        "content": "<p>Note that <code>is_scalar_tower</code> was the wrong condition, <code>smul_comm_class</code> is what you need</p>",
        "id": 261295952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743494
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 261296811,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261295133\">said</a>:</p>\n<blockquote>\n<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n</blockquote>\n<p>PR'd as <a href=\"https://github.com/leanprover-community/mathlib/issues/10300\">#10300</a></p>",
        "id": 261298706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636744879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> are you still working on this?</p>",
        "id": 265624146,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1640039878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267205\">@Nicolò Cavalleri</span>  I've put it on hold a little bit to do other stuff including some linear algebra which I felt would be needed for rep theory, but yes I have some stuff done and I have the intention to come back to it soonish.</p>",
        "id": 265624695,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1640040275
    },
    {
        "content": "<p>Hi,<br>\nI was wondering if anyone understand why the scalar action is not recognized in <code>smul_single</code>. It works with <code>of k G g</code> but not with <code>finsupp.single g 1</code>, which is quite annoying.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.trace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">monoid_algebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">representation</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">as_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">g'</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_monoid_hom_apply_apply</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">as_algebra_hom</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_def</span> <span class=\"o\">:</span>\n  <span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_algebra_hom_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">as_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">module.comp_hom</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_module_apply</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">):</span>\n  <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453119,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685146
    },
    {
        "content": "<p>Here's a hacky fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→₀</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685331
    },
    {
        "content": "<p>Even though <code>monoid_algebra k G</code> and <code>G →₀ k</code> are definitionally equal, they are not syntactically equal, and type class inference works up to syntactic equality. What is happening in <code>(finsupp.single g 1 : monoid_algebra k G)</code> is that the syntactic type of <code>finsupp.single g 1</code> is <code>G →₀ k</code>, and <code>(finsupp.single g 1 : monoid_algebra k G)</code> means \"check <code>finsupp.single g 1</code> has type <code>monoid_algebra k G</code> and then continue\" -- but it doesn't actually <em>syntactically change</em> the type, so <code>has_scalar (G →₀ k) V</code> is what Lean ends up searching for, and it can't find it. However adding that little <code>id</code> hack actually does syntactically change the type of the term to <code>monoid_algebra k G</code> and then type class inference works. The \"correct\" thing to do here would be to use the appropriate <code>monoid_algebra</code> constructor for <code>monoid_algebra k G</code> as opposed to <code>finsupp.single g 1</code> which is the <code>finsupp</code> constructor.</p>",
        "id": 274453907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685601
    },
    {
        "content": "<p>Will the simplifier still simplify <code>(finsupp.single g 1) •  v</code> to <code>g •  v</code> if I add <code>id</code>?</p>",
        "id": 274454254,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685746
    },
    {
        "content": "<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274454386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274454386\">said</a>:</p>\n<blockquote>\n<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>My first intention was to state it as <code>(of k G g) • v = g • v</code> but the linter complained that the LHS simplifies to <code>(finsupp.single g 1) •  v</code>. Won't the same problem happen with <code>of_magma</code>?</p>",
        "id": 274455018,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646686120
    },
    {
        "content": "<p>oh I see!</p>",
        "id": 274455552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686401
    },
    {
        "content": "<p>Yes you're absolutely right, the simp linter doesn't like it. I think that it's a bad idea to have <code>of = single</code> and <code>of_magma = single</code> as global <code>@[simp]</code> lemmas. I can quite understand why one might want them locally to be <code>simp</code> lemmas when making the API, but for a \"user\" like you who doesn't ever want to see <code>finsupp</code>s but still wants to use the simplifier, the strategy of making <code>of = single</code> a <code>simp</code> lemma is preventing you from doing this.</p>\n<p>I saw the same phenomenon showing up in the <a href=\"https://github.com/ImperialCollegeLondon/complex-number-game\">complex number game</a>. I wanted to make <code>complex.ext</code> a <code>simp</code> lemma, so that whenever Lean was faced with a goal <code>z = w</code> it would replace it with <code>z.re = w.re</code> and <code>z.im = w.im</code>. This worked <em>great</em> for me when I was making the API for complex numbers, because to e.g. prove that multiplication of complex numbers is associative you <em>absolutely</em> want to check this on real and imaginary parts. However when you go deeper into the theory and are developing complex analysis, the last thing you want the simplifier to do is to keep taking real and imaginary parts of things; you want this to be available to you as an option, but definitely <em>not</em> be the \"this is the only sensible way to proceed\" option, which is kind of what <code>simp</code> lemmas are.</p>\n<p>So I would suggest that (perhaps after getting the nod from one or more maintainers) that you make a PR removing the global simp tags from the lemmas which are causing the trouble and then adding them again with <code>local attribute [simp] of_eq_single</code> (or whatever it's called) so that they're there for API development of <code>monoid_algebra</code> but don't leak out.</p>",
        "id": 274456417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686810
    },
    {
        "content": "<p>In my opinion <code>monoid_algebra</code> should be irreducible and <code>finsupp.single G 1 : monoid_algebra</code> should not even typecheck. I mean, it should typecheck in the file making the API for <code>monoid_algebra</code>, and then it should stop typechecking and the simplifier should stop trying to flow in that direction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 274456898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> am I talking nonsense?</p>",
        "id": 274456955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687028
    },
    {
        "content": "<p>I've not read the whole of today's discussion, but yes, we shouldn't be writing <code>finsupp.single</code> about <code>monoid_algebra</code></p>",
        "id": 274457169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687111
    },
    {
        "content": "<p>The problem is that the alternative is copying over all the lemmas about <code>finsupp.single</code> to a new <code>monoid_algebra.single</code></p>",
        "id": 274457220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687134
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> should I make a PR to remove the global simp tag to lemmas like <code>monoid_algebra.of_apply</code>?</p>",
        "id": 274458555,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646687693
    },
    {
        "content": "<p>I'm not sure. I guess you could open one with the WIP tag and see what breaks</p>",
        "id": 274458632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687722
    },
    {
        "content": "<p>I am not convinced that there is too much stuff to be said about <code>monoid_algebra.single</code>. One could even get away with not having it, and just sticking with <code>of</code>. The big advantage of <code>single</code> over <code>of</code> is that <code>single</code> span <code>G -&gt;_0 k</code> as an abelian group so you can use simpler induction principles, but I wonder whether we ever see these in practice.</p>",
        "id": 274458657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687731
    },
    {
        "content": "<blockquote>\n<p>I am not convinced that there is too much stuff to be said about monoid_algebra.single. </p>\n</blockquote>\n<p>(edit: we would need lemmas saying what the) Behavior of 0, 1, addition, subtraction, negation, multiplication, nsmul, zsmul, pow, and maybe some stuff about summation is?</p>",
        "id": 274458855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687795
    },
    {
        "content": "<p>Also I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_algebra.of\">docs#add_monoid_algebra.of</a> is nasty due to <code>multiplicative</code></p>",
        "id": 274458925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687833
    },
    {
        "content": "<p>I don't know what you mean by all this.</p>",
        "id": 274458941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687842
    },
    {
        "content": "<p>Also <code>of</code> doesn't work on magma algebras, which is annoying</p>",
        "id": 274459054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687885
    },
    {
        "content": "<p>sure define <code>0</code> and <code>1</code> and etc in the <code>monoid_algebra.lean</code> API file using <code>single</code>, and then close it off, giving the user access to <code>of</code>, and a proof that <code>of (g * h) = of g * of h</code></p>",
        "id": 274459073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687894
    },
    {
        "content": "<p>I think if we want to remove <code>of_apply</code>, we need to unbundle <code>of</code></p>",
        "id": 274459076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687896
    },
    {
        "content": "<p>Things like addition are not about <code>of</code> or <code>single</code></p>",
        "id": 274459151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687942
    },
    {
        "content": "<p>Ah, you're talking about the \"One could even get away with not having [monoid_algebra.single]\" option, which is where we are today minus the finsupp mess</p>",
        "id": 274459163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274459151\">said</a>:</p>\n<blockquote>\n<p>Things like addition are not about <code>of</code> or <code>single</code></p>\n</blockquote>\n<p><code>single g r + single g s = single g (r + s)</code> is the type of thing I'm describing</p>",
        "id": 274459202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687967
    },
    {
        "content": "<p>But we only want <code>single x 1</code> so I'm not interested in this</p>",
        "id": 274459293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687994
    },
    {
        "content": "<p>I disagree, we need <code>single x r</code> for <code>polynomial.monomial</code></p>",
        "id": 274459403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688030
    },
    {
        "content": "<p>Unless you also want to kill <code>monomial</code> at the same time</p>",
        "id": 274459439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688048
    },
    {
        "content": "<p>I'm well aware that we need it for <code>G -&gt;0 k</code></p>",
        "id": 274459447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688053
    },
    {
        "content": "<p>I'm suggesting that we forego it only for <code>monoid_algebra</code> because to me it looks a bit useless when we're thinking about group representation theory.</p>",
        "id": 274459522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688084
    },
    {
        "content": "<p><code>polynomial</code> is <code>(add_)monoid_algebra</code> not <code>-&gt;0</code> though</p>",
        "id": 274459544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688097
    },
    {
        "content": "<p>Right. I'm suggesting we don't need <code>single</code> for <code>monoid_algebra</code> (only).</p>",
        "id": 274459644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688127
    },
    {
        "content": "<p>Are you suggesting we should have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>?</p>",
        "id": 274459712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688163
    },
    {
        "content": "<p>What I learnt when working on a multivariable polynomial project was that it's really handy to have <code>single</code> because then you can prove stuff about <code>G -&gt;_0 k</code> by checking it's true on <code>single x y</code> and then checking that the subset where it's true is a subgroup. I'm suggesting that this is not a common method of proof for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274459884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688228
    },
    {
        "content": "<p>If I call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> then you can figure out what I mean in Lean, but I mean \"the group ring\". I'm not talking about subtle differences between additive and multiplicative structures. I just mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">tg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> doesn't show up much in this theory when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">t\\not=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 274460048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688297
    },
    {
        "content": "<p>So I don't care if I not only can't coerce <code>finsupp.single x y</code> into <code>monoid_algebra</code> but that there's no substitute in monoid_algebra world, because I will just do <code>of_ring x * of_group y</code> for the appropriate <code>of</code>s (one from the ring, one from the group).</p>",
        "id": 274460260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688381
    },
    {
        "content": "<p>I think multivariate polynomials are confusing things here, since they are of type <code>add_monoid_algebra R (σ →₀ ℕ)</code> which has both things you're talking about in it</p>",
        "id": 274460395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688453
    },
    {
        "content": "<p>My polynomial remarks are about <code>polynomial R = add_monoid_algebra R ℕ</code> where <code>polynomial.monomial = add_monoid_algebra.single</code> (modulo structure eta)</p>",
        "id": 274460535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688520
    },
    {
        "content": "<p>If we forbid using <code>finsupp.single</code> with <code>add_monoid_algebra</code> and don't add a <code>add_monoid_algebra.single</code> to replace it, then we're pulling the rug out from under <code>polynomial</code>.</p>",
        "id": 274460602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688558
    },
    {
        "content": "<p>And if we have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>, then we're being inconsistent</p>",
        "id": 274460651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688589
    },
    {
        "content": "<p>I see. Do you understand <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274463333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646689946
    },
    {
        "content": "<p>Yes, but unrelated to the <code>single</code> topic, I don't yet know how to avoid the diamonds that PR creates</p>",
        "id": 274463782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690190
    },
    {
        "content": "<p>do we have any diamonds that don't get fixed with definitional eta? i've often said how little I like the current diamond-fixing approach as much as I understand it's necessary</p>",
        "id": 274464196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690383
    },
    {
        "content": "<p>Yeah, these are straight-up non-equal diamonds</p>",
        "id": 274464224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690394
    },
    {
        "content": "<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>",
        "id": 274464383,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690425
    },
    {
        "content": "<p>(there are some equal-but-not-defeq diamonds that appear in that PR too, but they're not so big a deal)</p>",
        "id": 274464426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690430
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138\">https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138</a> is the proof of the non-equal diamond</p>",
        "id": 274464525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690470
    },
    {
        "content": "<p>But it amounts to saying that the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> is ambiguous, as is the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 274464673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690523
    },
    {
        "content": "<p>(I bring up the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> example to avoid the \"well we only care about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a group\" counterargument)</p>",
        "id": 274464904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274464383\">said</a>:</p>\n<blockquote>\n<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>\n</blockquote>\n<p>I think this would solve the problem, but I suspect it will be very annoying for what Kevin wants to do.</p>",
        "id": 274465037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690692
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- If this were an instance, it would conflict with the natural</span>\n<span class=\"c1\">-- action of `k[k]` on itself given by multiplication.</span>\n</code></pre></div>\n<p>The thing is that <code>k[k]</code> doesn't happen except in pathological computer science land (edit: just seen your comment on k[k^*]). In fact if <code>R</code> is a nontrivial ring (which it always is) and <code>G</code> is a group (which it always is, except when you're making polynomials) then <code>R</code> can never be <code>G</code> because nontrivial rings can never be groups. However they can certainly be additive groups.</p>\n<p>So there is something interesting going on here with <code>monoid_algebra</code> v <code>add_monoid_algebra</code>. I claim that they are in some sense different beasts, because <code>monoid_algebra</code> eats a ring and a monoid, and <code>add_monoid_algebra</code> eats a ring and an add_monoid. Problems with scalar actions might occur with one if the ring is the monoid and with the other if the ring is the add_monoid. In particular the two problems are not \"reflected\" by <code>to_additive</code>.</p>",
        "id": 274465074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690707
    },
    {
        "content": "<p>I don't think we need to worry about <code>add_monoid_algebra k A</code> much here, since it's just <code>monoid_algebra k (multiplicative A)</code> so the same arguments apply</p>",
        "id": 274465283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690800
    },
    {
        "content": "<p>OK so it really is true that there are two distinct actions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274465293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690806
    },
    {
        "content": "<p>So we just make the important one (the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>) the instance</p>",
        "id": 274465367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690848
    },
    {
        "content": "<p>and then just use <code>of k * x</code> for the other one</p>",
        "id": 274465391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690864
    },
    {
        "content": "<p>The other action is the one that says <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-algebra though, which is also important</p>",
        "id": 274465511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690911
    },
    {
        "content": "<p>Sure, but that's the K-action not the K^*-action. Or does every R-action on a thing induce an R^*-action?</p>",
        "id": 274465571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690941
    },
    {
        "content": "<p>When this sort of thing happens in lectures, mathematicians just introduce two different notations for the two actions</p>",
        "id": 274465632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690976
    },
    {
        "content": "<blockquote>\n<p>Or does every R-action on a thing induce an R^*-action?</p>\n</blockquote>\n<p>Yes (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.mul_action\">docs#units.mul_action</a>). This turns out to be useful, because it means we can turn every monoid action into a group action if we know we're working with the units</p>",
        "id": 274465634,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690977
    },
    {
        "content": "<p>It can absolutely happen that X can act on Y in more than one way.</p>",
        "id": 274465723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691006
    },
    {
        "content": "<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>",
        "id": 274465894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691109
    },
    {
        "content": "<p>One way out of the problem is to just use <code>f : X →* perm Y</code> and <code>f x y</code> instead of <code>x • y</code></p>",
        "id": 274465952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691125
    },
    {
        "content": "<p>Or even <code>f x • y</code> if you like your <code>•</code>s, since we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.apply_mul_action\">docs#equiv.perm.apply_mul_action</a></p>",
        "id": 274465999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274465894\">said</a>:</p>\n<blockquote>\n<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>\n</blockquote>\n<p>This would be more appealing if we could tell lean to emit an error if someone tries to work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> rather than giving them rope to hang themselves with</p>",
        "id": 274466114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691240
    },
    {
        "content": "<p>That is, a means of blacklisting instances</p>",
        "id": 274466172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691254
    },
    {
        "content": "<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>",
        "id": 274472578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646694659
    },
    {
        "content": "<p>Do people ever actually think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> and/or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> in real life?</p>",
        "id": 274473440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695205
    },
    {
        "content": "<p>I once wrote a paper in a scenario where this on this sort of thing, and I did use a type synonym. I had a Lie group G and was doing representation theory over the complex numbers. An example of the Lie group could have been <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> but I called it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"true\">‾</mo></mover><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\overline{\\R}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0501em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0501em;\"><span style=\"top:-3.3418em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> because the mathematics was telling me that it was a \"different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>\" to the one in the coefficient field.</p>",
        "id": 274473445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695210
    },
    {
        "content": "<p>Adam -- yes. Representation theory of real reductive groups.</p>",
        "id": 274473465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695225
    },
    {
        "content": "<p>Ah right</p>",
        "id": 274473475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695236
    },
    {
        "content": "<p>But as I say, they're in some sense \"two different copies of the complex numbers\"; one of them is just an abstract algebraic closure of the reals (or at least it was in the paper of Langlands I was using).</p>",
        "id": 274473512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695268
    },
    {
        "content": "<p>I should say that Langlands didn't explicitly say this, it came out of me trying to make what was happening in the paper more functorial.</p>",
        "id": 274473535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695305
    },
    {
        "content": "<p>But anyway I agree with you Kevin, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> inside of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> should really be thought of as different from the scalars</p>",
        "id": 274473544,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695313
    },
    {
        "content": "<p>The correct spelling of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> should be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[\\mathbb{G}_m(K)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)]</span></span></span></span> anyway.</p>",
        "id": 274474089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274473465\">said</a>:</p>\n<blockquote>\n<p>Adam -- yes. Representation theory of real reductive groups.</p>\n</blockquote>\n<p>I'm surprised that the case I constructed to prove a point actually turns out to be a thing people care about</p>",
        "id": 274475980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274472578\">said</a>:</p>\n<blockquote>\n<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>\n</blockquote>\n<p>This seems like a reasonable argument to me as long as we're only talking about <code>K[G]</code> on groups and not monoids (which is why we probably need separate <code>group_algebra</code> and <code>monoid_algebra</code></p>",
        "id": 274476865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697615
    },
    {
        "content": "<p>I know that in Iwasawa theory people talk about the completion of the group ring <span class=\"tex-error\">$$\\Z_p{\\Z_p^\\times]$$</span> too. I would like to argue that this diamond is there independent of this whole group ring business. If we just have a group G and a field k acting on an object (which can happen independent of whether one has made the group ring) then the units of the field act on the object so if the units of the field happen to be the group then you have two actions and already this is a diamond in some sense. The fix here should be a type synonym eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><msub><mi>L</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">GL_1(R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> instead of <code>units R</code>. What I'm saying is that the monoid algebra definition is not creating any <em>new</em> diamonds, it's just bringing to the fore an issue which was already there because if we use typeclasses then we're only allowed one action of X on Y, just like we're only allowed one monoid structure on X (which is an action of X on X). So I propose we ignore this issue as I don't believe it will impede progress.  With this in mind do we still need this type synonym in the group algebra PR?</p>",
        "id": 274503456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722741
    },
    {
        "content": "<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>",
        "id": 274503631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722872
    },
    {
        "content": "<p>I agree that this is probably just a diamond that we have to live with.</p>",
        "id": 274503842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723064
    },
    {
        "content": "<p>But it would be good to record it somewhere, so that we don't forget when it exists.</p>",
        "id": 274503866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723096
    },
    {
        "content": "<p>It's because it's there in reality! The complex representation theory of real reductive groups really does give you two different actions of C^* on a vector space</p>",
        "id": 274503957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646723171
    },
    {
        "content": "<p>Sure, but the question is how to deal with it later on. This could be via a type synonym for the group, or via specialized notation to distinguish the two actions. But we can figure that out when we get there.</p>",
        "id": 274504315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723538
    },
    {
        "content": "<blockquote>\n<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>\n</blockquote>\n<p>This situation doesn't arise in mathlib though: we don't have instances that go in this direction, precisely because they would create diamonds. Instances build data for \"big\" types (like <code>G × H</code>) out of instances on the pieces, not vice versa.</p>",
        "id": 274505789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725044
    },
    {
        "content": "<p>Does <code>G</code> act on <code>G \\times H</code>? I can imagine we would have an instance for that in mathlib.</p>",
        "id": 274506085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725258
    },
    {
        "content": "<p>Well then I claim we shouldn't have an induced action of <code>units K</code> on V given an action of K on V for the same reason</p>",
        "id": 274506139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725309
    },
    {
        "content": "<p>Because <code>units K</code> is obviously smaller than K (although the type theorists are going to argue that it's bigger)</p>",
        "id": 274506205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725349
    },
    {
        "content": "<p>Yes, I mean \"big\" in the type theory sense</p>",
        "id": 274506242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> But if we have an action of <code>G</code> on <code>G \\times H</code>, and also an action of <code>H</code> on <code>G \\times H</code>, then we have a diamond. That's the same problem as we have with <code>monoid_algebra</code>.</p>",
        "id": 274506350,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725451
    },
    {
        "content": "<p>And the fix is not yet another type ascription, it's to just leave it alone and let people fix it if they run into it. Mathematicians will know if they're running into it, their Spidey senses go off if they have two actions of X on Y</p>",
        "id": 274506485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725563
    },
    {
        "content": "<p>We have no global instance for <code>has_scalar G (G × H)</code> though (unless G acts on H too, then it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar\">docs#prod.has_scalar</a>), nor would it be safe to add one</p>",
        "id": 274506493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725570
    },
    {
        "content": "<p>Oh boo</p>",
        "id": 274506508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725581
    },
    {
        "content": "<p>How about bimodules? Do we have these yet?</p>",
        "id": 274506603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725681
    },
    {
        "content": "<p>Over two different rings? Yes, <code>[module R M] [module Sᵐᵒᵖ M] [smul_comm_class R Sᵐᵒᵖ M]</code></p>",
        "id": 274506704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725801
    },
    {
        "content": "<p>Modules for group rings are a situation in real mathematics where two (generically) distinct objects act on the same side on an object. We have to support this and worry about \"what if the objects are the same\" later</p>",
        "id": 274506769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725851
    },
    {
        "content": "<p>Why don't we add an action of <code>G^mop</code> on <code>monoid_algebra K G</code>? Does that solve all our problems?</p>",
        "id": 274506782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725870
    },
    {
        "content": "<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there. But that doesn't mean that we can't develop a theory of bimodules. It just means we ignore the issue</p>",
        "id": 274506851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725923
    },
    {
        "content": "<blockquote>\n<p>Does that solve all our problems</p>\n</blockquote>\n<p>Not after <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> it doesn't, which adds the kᵐᵒᵖ action</p>",
        "id": 274506874,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725940
    },
    {
        "content": "<blockquote>\n<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there.</p>\n</blockquote>\n<p>Why can't we use the spelling above for bimodules over the same ring?</p>",
        "id": 274506961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726040
    },
    {
        "content": "<p>Fair enough. But it will certainly make the problems very tiny.</p>",
        "id": 274507002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726049
    },
    {
        "content": "<p>If we're going to use this with a type synonym like <code>mul_opposite</code>, we could also solve it with a dedicated synonym</p>",
        "id": 274507045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726100
    },
    {
        "content": "<p><code>mul_opposite</code> would be natural: On <code>k[G]</code> there is an action of <code>k</code> on the left, and an action of <code>G</code> on the right.</p>",
        "id": 274507077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726145
    },
    {
        "content": "<p>Lean forces us to accept an action of <code>k</code> on the right. But maybe <em>that</em> shouldn't be a global instance.</p>",
        "id": 274507137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726183
    },
    {
        "content": "<p>I agree that algebras are bimodules, but should that be a <code>def</code> or an <code>instance</code>?</p>",
        "id": 274507152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726206
    },
    {
        "content": "<p>It could <del>certainly</del> maybe be an instance only in a locale</p>",
        "id": 274507196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726249
    },
    {
        "content": "<p>Although if algebras must be bimodules (and therefore carry a right action), then the <code>algebra R (A →ₗ [R] A)</code> instance requires lean to find the right action on <code>A</code></p>",
        "id": 274507472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726424
    },
    {
        "content": "<p>I could still be persuaded that <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> is a bad idea, but am like 80% sure we probably want it</p>",
        "id": 274507545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726486
    },
    {
        "content": "<p>So how do you suggest we deal with the <code>G</code>-action on <code>k[G]</code>?</p>",
        "id": 274508053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726884
    },
    {
        "content": "<p>Just multiply with <code>of g</code>, where <code>of : G -&gt; k[G]</code>?</p>",
        "id": 274508072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726903
    },
    {
        "content": "<p>In representation theory you absolutely want that action because it's the regular representation. Already you have this pathological \"what if G is syntactically k^*\" question</p>",
        "id": 274508210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646727006
    },
    {
        "content": "<p>What's the downside of the <code>of g * x</code> approach? (Other than being less appealing visually)</p>",
        "id": 274509871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728374
    },
    {
        "content": "<p>Presumably there are bits of the action API you want access to; do you know which bits?</p>",
        "id": 274510006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728465
    },
    {
        "content": "<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>",
        "id": 274510759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646728987
    },
    {
        "content": "<p>For me, you saying \"well perhaps we have to completely avoid making the action because of the extremely unlikely event that G is syntactically k^*\" is like you saying \"well I think we should stop using typeclasses for groups because of the extremely unlikely event that we want two distinct groups structures on a type\"</p>",
        "id": 274510900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646729068
    },
    {
        "content": "<p>To be clear, I'm begrudgingly ok with the action as long as it's on the <code>group_algebra</code> where it's less likely to cause harm than the <code>(add_) monoid_algebra</code></p>",
        "id": 274511444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729436
    },
    {
        "content": "<p>But I'd also like to understand what actually changes in practice if we say \"let's not use • syntax for this action, let's just use a suitably bundled function\"</p>",
        "id": 274511507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>This can be phrased as how the <code>k[G]</code>-module <code>k[G]</code> over itself decomposes as sum of irreducibles.</p>",
        "id": 274511813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729718
    },
    {
        "content": "<p>Often, the action is also written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">L_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">R_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> if you want to act on the left or on the right. This could be easily mimicked by using a type synonym <code>foo G</code> for <code>G</code>, acting on whatever you want, and calling the identity map from <code>G</code> to <code>foo G</code> as <code>L</code>, and then writing <code>L g \\bu a</code> is totally non-ambiguous, diamond free, and close enough to common mathematical practice.</p>",
        "id": 274512020,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646729867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>",
        "id": 274512203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729995
    },
    {
        "content": "<p>Another solution would be a pretty way of writing \"<code>g</code> viewed as element of <code>k[G]</code>\". I'm not sure a coercion will do. In maths, it is common to write <code>[g]</code>.</p>",
        "id": 274512205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729998
    },
    {
        "content": "<p>We discussed having the quotient brackets work for free constructions like that in another thread</p>",
        "id": 274512369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730043
    },
    {
        "content": "<p>I think there was general agreement but no one volunteered to do the work</p>",
        "id": 274512400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274512203\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>\n</blockquote>\n<p>As Johan says, it should probably be a statement of the form \"The R-module R is R-isomorphic to a certain exterior direct sum\"</p>",
        "id": 274512414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730077
    },
    {
        "content": "<p>Where did R come from?</p>",
        "id": 274512446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730108
    },
    {
        "content": "<p>It's k[G]</p>",
        "id": 274512510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730128
    },
    {
        "content": "<p>It doesn't sound like the lean statement even mentions a G action then?</p>",
        "id": 274512747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730295
    },
    {
        "content": "<p>The thing is that a k-linear G-action on a k-vector space is the same thing as a k[G]-action. We already have a good theory of module actions, so if we could get the group algebra merged somehow (and right now I'm really confused about whether it needs to be different from the module algebra) then the theory of G-modules could just be developed as a theory of k[G]-modules.</p>",
        "id": 274512898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> how about making <code>monoid_algebra</code> and <code>add_monoid_algebra</code> irreducible and not making <code>group_algebra</code> at all, and disregarding the issue that G could in theory syntactically be <code>units k</code> because mathematicians are only too well aware when they have two distinct actions of A on B and will know to take evasive action via a type synonym (which can be described to them in some docstring). Does this solve the problems which started this thread and the problems with <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274513365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730706
    },
    {
        "content": "<p>The examples which have been flagged before have had <code>G</code> definitionally <code>k^*</code> but not syntactically.</p>",
        "id": 274513478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730766
    },
    {
        "content": "<p>The main problem I had that started this thread was <code>monoid_algebra.of</code> simplifying to <code>finsupp.single</code> even though that's not really wanted. I suppose this wouldn't be the case anymore if <code>monoid_algebra</code> was made irreducible?</p>",
        "id": 274618062,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646779085
    },
    {
        "content": "<p>Making <code>monoid_algebra</code> irreducible is orthogonal to your issue</p>",
        "id": 274618820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779599
    },
    {
        "content": "<p>Removing the simp lemma is enough, but right now that creates more problems that it solves</p>",
        "id": 274618851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779621
    },
    {
        "content": "<p>Because we can't choose <code>of</code> as the canonical spelling (right now) because it doesn't work on magma algebras</p>",
        "id": 274618919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779668
    },
    {
        "content": "<p>So until we introduce something better, the only suitable spelling right now is <code>finsupp.single</code>, even though that had the wrong type.</p>",
        "id": 274619026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779715
    },
    {
        "content": "<p>I see, so for now I guess I'll just make my problematic lemma use <code>of</code> but not make it a <code>simp</code> lemma</p>",
        "id": 274619862,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646780239
    },
    {
        "content": "<p>Hi! I want to define the tensor product of two representations of a monoid <code>G</code> by <code>g • (v ⊗ₜ w) = (g • v) ⊗ₜ (g • w)</code>, but I noticed that there is already <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_has_scalar\">docs#tensor_product.left_has_scalar</a> which defines the action by letting <code>G</code> act only on the left factor. What are the reasons for this definition of an action on the left only, and is it possible to define the action I want on <code>V ⊗ W</code> without ambiguity with the other definition? Do I need to use a type synonym?</p>",
        "id": 279021918,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649970897
    },
    {
        "content": "<p>I suspect the action on the left is useful when you want to consider the base-change of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> to some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, which is defined as the tensor product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">B \\otimes_A M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 279022137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649971016
    },
    {
        "content": "<p>The action on the left is the obvious one when the action is by the field of the two vector spaces (and equal to the equivalent action on the right), which is why it's the default</p>",
        "id": 279024322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972209
    },
    {
        "content": "<p>So I have to use a type synonym?</p>",
        "id": 279024399,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972273
    },
    {
        "content": "<p>If you want to use <code> •</code> notation and not something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.map\">docs#tensor_product.map</a>, yes</p>",
        "id": 279024627,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972406
    },
    {
        "content": "<p>I don't know whether it makes more sense to put the type synonym on the tensor type or the action type</p>",
        "id": 279024744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972474
    },
    {
        "content": "<p>You might be able to get away without the synonym... What would the typeclass requirements for such an action be?</p>",
        "id": 279024931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024931\">said</a>:</p>\n<blockquote>\n<p>You might be able to get away without the synonym... What would the requirements for such an action be?</p>\n</blockquote>\n<p>Something like that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 279025054,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972675
    },
    {
        "content": "<p>Is that enough for <code>distrib_mul_action G (V ⊗[R] W)</code>?</p>",
        "id": 279025205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972784
    },
    {
        "content": "<p>I think it is, yes</p>",
        "id": 279025363,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972891
    },
    {
        "content": "<p>Yeah, you definitely need a type synonym then</p>",
        "id": 279025548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973024
    },
    {
        "content": "<p>I would guess putting the type synonym on G works out better</p>",
        "id": 279025891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279025891\">said</a>:</p>\n<blockquote>\n<p>I would guess putting the type synonym on G works out better</p>\n</blockquote>\n<p>Why is that? Putting the type synonym on the tensor product seems more natural to me since otherwise we can't compare the tensor representation to other representations of <code>G</code>.</p>",
        "id": 279028773,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649975026
    },
    {
        "content": "<p>Youch. Yes both the diagonal action for a tensor product group rep and the left action for base extension are pretty important :-/</p>",
        "id": 279038375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649983229
    },
    {
        "content": "<p>shame our subscript options are so limited, or we could use  •_D and  •_L</p>",
        "id": 279043388,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989316
    },
    {
        "content": "<p>or the like</p>",
        "id": 279043389,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989317
    },
    {
        "content": "<p>It's not really a matter of notation but a matter of API. If you start using <code>•_D</code> and <code>•_L</code>, then all the lemmas about <code>•</code> don't apply anymore.</p>",
        "id": 279054053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650004755
    },
    {
        "content": "<p>Is this evidence that we should <em>not</em> define a G-representation over a field k as being definitionally a k[G]-module?</p>",
        "id": 279056734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650007797
    },
    {
        "content": "<p>I thought <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260880171\">we already decided</a> that <code>[module (monoid_algebra k G) X]</code> was definitely the wrong way to go anyway (and instead to go via the separate actions of <code>k</code> and <code>G</code>)</p>",
        "id": 279059055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010168
    },
    {
        "content": "<p>Perhaps a type alias <code>representation</code> used as <code>representation G</code> solves most of the issues</p>",
        "id": 279059110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024399\">said</a>:</p>\n<blockquote>\n<p>So I have to use a type synonym?</p>\n</blockquote>\n<p>Yes.</p>\n<p>I thought about this in some detail a while back and shared some details here: <a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a> which may or may not be useful.</p>",
        "id": 279068370,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650018517
    },
    {
        "content": "<p>I am  trying to implement the type synonym following <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>'s suggestions, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">tensor_rep</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">V</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">tensor_rep</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n<span class=\"kd\">notation</span> <span class=\"n\">v</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.tmul</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The last line is problematic because I reference <code>V</code> and <code>W</code>. This shouldn't be a problem since I think there should be a way to infer <code>V</code> and <code>W</code> as the types of <code>v</code> and <code>w</code>. Is there a way to do that?</p>",
        "id": 279115715,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650051601
    },
    {
        "content": "<p>You should define a <code>to_rep</code> function that changes a tensor product to your type</p>",
        "id": 279115876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051713
    },
    {
        "content": "<p>Like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/to_lex\">docs#to_lex</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual.to_dual\">docs#order_dual.to_dual</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/conj_act.to_conj_act\">docs#conj_act.to_conj_act</a>, etc</p>",
        "id": 279115940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051743
    },
    {
        "content": "<p>Then use that definition in your notation</p>",
        "id": 279115978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051779
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 279117268,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650052634
    },
    {
        "content": "<p>Hi! After working for a bit on representation theory, I noticed that the approach I took to define <code>k</code>-linear representations of <code>G</code> on a vector space <code>V</code> as <code>distrib_mul_action G V</code> + <code>smul_comm_class G k V</code>causes a lot of issues due to ambiguity between different actions and potential diamonds. After some discussion with <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , we came to the conclusion that it might be better to avoid entirely scalar multiplication when doing representation theory and stick with the definition <code>G →* (V →ₗ [k] V)</code>, writing <code>φ g v</code> everywhere we previously wrote <code>g • v</code>, where <code>φ </code> is the name of the representation (which is slightly less convenient, especially when  <code>φ </code> is actually a long name, but seems like the least worst solution).<br>\nBefore I start refactoring all I did so far, I was wondering what were the opinions of other people interested in representation theory in mathlib on this matter. Does anyone see downsides of this approach that we might have missed?</p>",
        "id": 279432277,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650385064
    },
    {
        "content": "<p>I think we should be able to obtain a situation similar to informal mathematics: when there is a single (or distinguished) action on a space then we can use the scalar multiplication notation. However when we are considering several actions simultaneously, and do not wish to distinguish any of them, (as happens quite a bit in representation theory) then we will be explicit and give the action a name.</p>",
        "id": 279433648,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385662
    },
    {
        "content": "<p>If you've been talking with Eric about this then it's very likely the approach you have in mind is sound.</p>",
        "id": 279433866,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385746
    },
    {
        "content": "<p>To elaborate on that idea, the outline was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">representation</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.trivial</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.tprod</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">tensor_product.map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"bp\">..</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- I have no idea what a good name is</span>\n<span class=\"kd\">def</span> <span class=\"n\">representation.on_monoid_algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- notation something like `rV →R rW` -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">representation_map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_repr</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">rW</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 279434138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385845
    },
    {
        "content": "<p>My feeling generally was that this would generate less boilerplate than the equivalent approach with type synonyms</p>",
        "id": 279434321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385923
    },
    {
        "content": "<p>I think we'll probably want both approaches eventually but I am certain that we'll want something similar to the above whatever we do.</p>",
        "id": 279435049,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650386248
    },
    {
        "content": "<p>For what it's worth, I also much prefer this approach over using <code>has_scalar</code>, there are just too many scalar actions around in this context.</p>",
        "id": 279494087,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1650425003
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a></p>",
        "id": 279695863,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650554983
    },
    {
        "content": "<p>I've defined <code>Rep k G</code>, the category of (bundled) representations of <code>G</code> over <code>k</code>. It seems to be nicely compatible with the new design.</p>",
        "id": 280033231,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872637
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></p>",
        "id": 280033274,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872646
    },
    {
        "content": "<p>I was pleased to find that verifying it has (co)limits and a natural monoidal structure was very smooth!</p>",
        "id": 280033334,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872697
    },
    {
        "content": "<p>The PR doesn't include preparing the <code>preadditive</code> and <code>abelian</code> instances, but this shouldn't be too hard now.</p>",
        "id": 280033706,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872921
    },
    {
        "content": "<p>Cool! Unfortunately you're hitting a timeout here: <a href=\"https://github.com/leanprover-community/mathlib/pull/13683/files\">https://github.com/leanprover-community/mathlib/pull/13683/files</a></p>",
        "id": 280033812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650872982
    },
    {
        "content": "<p>I'm still a bit sad that it looks like we can't use scalar multiplication in rep'n theory. But I guess that's life in lean, for now.</p>",
        "id": 280033990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650873096
    },
    {
        "content": "<p>Fixed the timeouts.</p>",
        "id": 280035459,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650873860
    },
    {
        "content": "<p>Nice, that's definitely gonna be very useful! If we prove enough properties of this category we're gonna be able to use <code>category_theory.preadditive.schur</code>, which is great since I'll need Schur's lemma to get to the orthogonality of characters.</p>",
        "id": 280088170,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650901545
    },
    {
        "content": "<p>I've added PRs</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>: <code>Rep k G</code> is symmetric monoidal</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a>: <code>Rep k G</code> is abelian</li>\n</ul>",
        "id": 280089298,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650901995
    },
    {
        "content": "<p>I guess showing that it is a <code>k</code>-linear category should be done as well (easy?), and also that it is monoidal closed (not sure).</p>",
        "id": 280089393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650902037
    },
    {
        "content": "<p>For monoidal closed, I think the internal hom should be what I called <code>lin_hom</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a>, and I don't think it should be too hard to prove that it's adjoint to the tensor product.</p>",
        "id": 280093222,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650903673
    },
    {
        "content": "<p>Another TODO:</p>\n<ul>\n<li>Equivalence with <code>Module k[G]</code>.</li>\n</ul>",
        "id": 280095000,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650904509
    },
    {
        "content": "<p>Another to-do: Tannakian?</p>",
        "id": 280144176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650930043
    },
    {
        "content": "<p>I've never really dared to say it. But Tannaka duality would be a wonderful milestone.</p>",
        "id": 280162585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650950292
    },
    {
        "content": "<p>I did the equivalence with <code>Module k[G]</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>. (Still needs some linting, and one declaration is mysteriously incredibly slow; if anyone wants to have a look at <code>counit_iso</code> in <code>src/representation_theory/Rep.lean</code>?)</p>",
        "id": 280206399,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978244
    },
    {
        "content": "<p>This is a bit painful as we have to grapple with all the different actions and fight the typeclass system as we convert between them. But it seems to work out okay.</p>",
        "id": 280206464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978273
    },
    {
        "content": "<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>",
        "id": 280206623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978350
    },
    {
        "content": "<p>More immediately important is to hook up the existing work on schur's lemma and maschke's theorem, and show <code>Rep k G</code> is semisimple when it is.</p>",
        "id": 280206726,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978380
    },
    {
        "content": "<p>I've added <code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, which acquires cheaply a rigid structure when <code>G</code> is a group.</p>",
        "id": 280332358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651056821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280206623\">said</a>:</p>\n<blockquote>\n<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>\n</blockquote>\n<p>Maybe we can actually get Tannaka <em>reconstruction</em> fairly quickly in the case of <em>finite groups</em>. After all, the general case requires algebraic groups, and I don't think we are anywhere near those.</p>",
        "id": 280333854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651057543
    },
    {
        "content": "<p>Here's a summary of the current stack of PR's on representation theory.</p>\n<ul>\n<li><del><code>Rep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></del></li>\n<li><code>Rep k G</code> is symmetric monoidal in <a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>, <del>depending on a PR about braidings in <a href=\"https://github.com/leanprover-community/mathlib/pull/13684\">#13684</a></del></li>\n<li><del><code>Rep k G</code> is abelian in <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a></del></li>\n<li><code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13738\">#13738</a> which in turn depends on two PRs about rigid structures in <del>#13736</del> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>.</li>\n<li><code>Rep k G ≌ Module (monoid_algebra k G)</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>, depending on refactoring PRs in <del>#13760</del> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a>.</li>\n</ul>",
        "id": 280580666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201005
    },
    {
        "content": "<p>In particular currently needing review are <del>#13683</del>, <del>#13689</del>, <del>#13684</del>, <del>#13736</del>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>, <del>#13760</del>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13782\">#13782</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13792\">#13792</a>.</p>",
        "id": 280580748,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all those PRs. I finally had some time to look at them. They're great.</p>",
        "id": 280583593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651204255
    },
    {
        "content": "<p>Added:</p>\n<ul>\n<li><code>Rep k G</code> is <code>k</code>-linear and <code>k</code>-linear monoidal in <a href=\"https://github.com/leanprover-community/mathlib/pull/13782\">#13782</a>, <del>waiting on <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a></del>.</li>\n<li><code>fdRep k G</code> is <code>k</code>-linear and <code>k</code>-linear monoidal, and has finite dimensional hom spaces in <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>, waiting on <del>#13689</del> <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13792\">#13792</a>.</li>\n</ul>",
        "id": 280594717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651216697
    },
    {
        "content": "<p>and</p>\n<ul>\n<li><code>FinVect k</code> has all finite limits, <a href=\"https://github.com/leanprover-community/mathlib/pull/13793\">#13793</a> depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13792\">#13792</a></li>\n<li>Schur's lemma for <code>fdRep k G</code>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a>, depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13793\">#13793</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</li>\n</ul>",
        "id": 280636687,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651240860
    },
    {
        "content": "<p>I'm very satisfied by the last one. We've had Schur's lemma in mathlib for over a year, but stated in maximal generality: it holds for any linear category over an algebraically closed field, with finite dimensional hom spaces, and kernels.</p>\n<p>Finally, <code>fdRep k G</code> satisfies those hypotheses, so we can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Verify that Schur's lemma applies out of the box.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">finrank_hom_simple_simple</span> <span class=\"o\">[</span><span class=\"n\">is_alg_closed</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">fdRep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finrank</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">≅</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">category_theory.finrank_hom_simple_simple</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n</code></pre></div>",
        "id": 280640690,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242678
    },
    {
        "content": "<p>That's wonderful! I think we're not very far from the orthogonality of characters, though there's still some linear algebra missing.</p>",
        "id": 280641174,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651242946
    },
    {
        "content": "<p>Sometime over the weekend I'll hook up Maschke's theorem with the new setup.</p>",
        "id": 280641252,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242970
    },
    {
        "content": "<p>After that, I think if I keep working on representation theory I might take an excursion into semisimple categories, and decompositions into simple objects.</p>",
        "id": 280641351,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651243028
    },
    {
        "content": "<p>For Schur's lemma applied to endomorphisms, there's a generalization due to Dixmier (and generalized further by <a href=\"https://www.ams.org/journals/proc/1969-021-01/S0002-9939-1969-0238892-4/home.html\">Quillen</a>) that if you have a simple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an algebra over an algebraically closed field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, if  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">End</mi><mo>⁡</mo></mrow><mi>A</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{End}_A(M)\\cong k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. (If you drop \"algebraically closed\" then instead the conclusion is that endomorphisms are all algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>). For example, the space of endomorphisms of a countable-dimensional simple representation of a group over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is one-dimensional.</p>\n<p>If somebody were to try to formalize this, where would be a good place for it? (still src/category_theory/preadditive/schur.lean?) Potentially it would pull in things about transcendence degree.</p>",
        "id": 280650353,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651247144
    },
    {
        "content": "<blockquote>\n<p>For example, the space of endomorphisms of a countable-dimensional simple representation of a group over \\mathbb{C}C is one-dimensional.</p>\n</blockquote>\n<p>This result is used in the basic theory of smooth admissible representations of p-adic groups, which we will have all the ingredients for when we've figured out how to do continuous representations of topological groups.</p>",
        "id": 280678849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651261068
    },
    {
        "content": "<p>This would be great to have. If it pulls in transcendence degrees then just make a new file for it.</p>",
        "id": 280698947,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272730
    },
    {
        "content": "<p>Does the proof really use that it is an A-module? I've never looked at these generalisations. Schur's lemma is usually stated for modules, but in fact this is irrelevant for the version in mathlib.</p>",
        "id": 280699162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272933
    },
    {
        "content": "<p>It seems like it's important that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module, but maybe there's some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>-linear category trick. There's a step where you give <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> the structure of a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> using the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure. You also need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> to get its dimension.</p>\n<p>Here's the proof I know: Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">f:M\\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-linear endomorphism. Suppose for sake of contradiction that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is not algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. Then by Schur's lemma, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is an isomorphism since it's not zero.  We have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over the field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> of rational functions, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> acting by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is nonzero we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></msub><mi>M</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\dim_{k(t)}M\\geq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0496em;vertical-align:-0.3552em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>M</mi><mo>≥</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\dim_k M \\geq \\dim_k k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>t</mi><mo>−</mo><mi>c</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>c</mi><mo>∈</mo><mi>k</mi><mo stretchy=\"false\">}</mo><mo>⊂</mo><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\{ (t-c)^{-1} \\mid c\\in k\\}\\subset k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> is a linearly independent set over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> (since, clearing denominators, a linear dependence would be that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>), we also have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\dim_k k(t) \\geq |k|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span></span></span></span>. But, we assumed that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, so we have a contradiction, hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>.</p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is algebraically closed, then you use the minimal polynomial to get an eigenvalue for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and do the usual algebraically closed Schur's lemma proof.</p>",
        "id": 280703983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277282
    },
    {
        "content": "<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>",
        "id": 280709008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651282823
    },
    {
        "content": "<p>This this is the proof Taylor taught me :-) I thought the 1/(t-c) trick was brilliant.</p>",
        "id": 280714084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651290267
    },
    {
        "content": "<p>That same trick is also used for what I've seen referred to as a \"quick and dirty\" proof of the Nullstellensatz.  You can see the trick in the highest scoring answer <a href=\"https://mathoverflow.net/questions/15226/elementary-interesting-proofs-of-the-nullstellensatz\">here</a>.</p>",
        "id": 280716318,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651293604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280709008\">said</a>:</p>\n<blockquote>\n<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>\n</blockquote>\n<p>Oh, yeah, that's all you need. I got confused and forgot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> was just an endomorphism, so the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure is not used. (If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> acts on the right, then I like to think of the morphisms as acting on the left since then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>x</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">fxa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">a</span></span></span></span> suggests the usual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">af(x)=f(ax)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>.  The proof only uses the left action by the category and some things about dimension.)</p>\n<p>It's interesting how this is true no matter the faithful k-linear functor. Over an algebracially closed field, is it true that there's always one that sends simple modules to 1D vector spaces? I know that's true for semisimple algebras over an algebraically closed field.</p>",
        "id": 280744646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651336872
    },
    {
        "content": "<p>Hi! I need to talk about equivalence of representations, and I was wondering if I should use for that the isomorphisms provided by the category <code>Rep k G</code> defined by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> or if I should define independently types <code>rep_hom</code> and <code>rep_equiv</code> which would extend <code>linear_map</code> and <code>linear_equiv</code>. I'm not very familiar with how category theory is used in mathlib, so I'd appreciate some advice on this.</p>",
        "id": 280875885,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651499480
    },
    {
        "content": "<p>We're potentially on new ground here... I'm tempted to suggest we try and proceed \"within\" the category theory API for now, and only bail out and define everything \"unbundled\" as necessary. But we will have to be careful trip interpret \"necessary\" liberally: the first sign of your theoretic troubles caused by using the category theory library should cause us to retreat.</p>",
        "id": 280941829,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529623
    },
    {
        "content": "<p>But this is only one opinion, and a biased one.</p>",
        "id": 280941856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529639
    },
    {
        "content": "<p>But I do like the idea of finally being able to stop defining the same basic ideas (isomorphism, etc), and using the polymorphic model provide by category theory. Worth a try, as an experiment?</p>",
        "id": 280941956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529694
    },
    {
        "content": "<p>This all said, I think most of the future work on representation theory for a while should be developing the representation theory of (finite dimensional) algebras.</p>",
        "id": 280942100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529764
    },
    {
        "content": "<p>The main representations-of-groups specific fact is already there in <code>maschke.lean</code>, and most of what is needed to hook that up to decomposition into irreducibles and character theory is true more generally.</p>",
        "id": 280942201,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529847
    },
    {
        "content": "<p>I was thinking that perhaps we should just plough through Etingof's notes on representation theory. They are a bit nonlinear, but if we just do whatever subset is on the minimal path to his treatment of representations of finite groups I think we'd get a very pretty, and appropriately generalized, treatment.</p>",
        "id": 280942370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529953
    },
    {
        "content": "<p>This is actually why I wrote my \"simple implies indecomposable\" PR last night: it was the first statement I could find in his notes that we didn't have.</p>",
        "id": 280942479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651530013
    },
    {
        "content": "<p>So far I focused on group representations because my goal was to get orthogonality of characters. I'm not really aware of how character theory generalizes to finite-dimensional algebras, is there a more general version of orthogonality of characters for finite groups?</p>",
        "id": 280943437,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651530662
    },
    {
        "content": "<p>Something that comes to mind is finite-dimensional Hopf algebras. These have a one-dimensional space of \"integrals\" that you can use to generalize averaging-over-the-group arguments.  (Group algebras are Hopf algebras, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_{g\\in G}g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is an integral.) I'm pretty sure these are all you need to get that characters of non-isomorphic simple representations are orthogonal, where you define something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">(</mo><mo>∫</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V, W\\rangle = \\operatorname{tr}_{V\\otimes W^*}(\\Delta(\\int))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1111em;vertical-align:-0.3061em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span><span class=\"mbin mtight\">⊗</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Δ</span><span class=\"mopen\">(</span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"mclose\">))</span></span></span></span> (the trace of the action of the comultiplication of the integral on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V\\otimes W^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>). That can be rewritten in terms of characters for V and W.</p>\n<p>The way that formula expands for groups using the un-scaled integral is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>V</mi></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V,W\\rangle = \\sum_{g\\in G} \\operatorname{tr}_V(g)\\operatorname{tr}_W(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2499em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, using the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><msup><mi>W</mi><mo>∗</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_{W^*}(g)=\\operatorname{tr}_{W}(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (for Hopf algebras in general, the antipode can be used to put things in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>)</p>",
        "id": 280945611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651532149
    },
    {
        "content": "<p>even if we don't go via hopf algebras, while orthogonality of characters doesn't hold generally, there are interesting statements. e.g. Theorem 3.6.2 of <a href=\"https://klein.mit.edu/~etingof/repb.pdf\">https://klein.mit.edu/~etingof/repb.pdf</a></p>\n<blockquote>\n<p>(i) Characters of (distinct) irreducible finite dimensional representations of A are linearly independent.<br>\n(ii) If A is a finite dimensional semisimple algebra, then these characters form a basis of (A/[A, A])^∗</p>\n</blockquote>",
        "id": 280949933,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535577
    },
    {
        "content": "<p>But I guess for just checking orthogonality there's no point knowing anything about the relationship with characters of algebras.</p>",
        "id": 280950147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535773
    },
    {
        "content": "<p>But the facts the characters span, and determine the representation, come from more general facts, and ideally we would deduce these facts in the Rep G setting from the more general statements.</p>",
        "id": 280950171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535822
    },
    {
        "content": "<p>but don't hesitate to do whatever work on orthogonality you like</p>",
        "id": 280950406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536003
    },
    {
        "content": "<p>if we want to relate the characters you define for G and the characters for k[G], we can retrofit that later</p>",
        "id": 280950458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536024
    },
    {
        "content": "<p>Anyway for now I've been mostly doing linear algebra and proving stuff about traces of linear maps, which will be useful both for algebras and for groups</p>",
        "id": 280950592,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536122
    },
    {
        "content": "<p>I forget -- do you need anything beyond semisimplicity to get that A/[A,A] is isomorphic to the center Z(A) as a vector space?</p>",
        "id": 280950644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651536143
    },
    {
        "content": "<p>But I'll try to get more familiar with the category theory API soon</p>",
        "id": 280950783,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> has open PRs defining several natural maps involving dual modules, contractions and traces (<a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR147-R157\">for example</a>), and I am wondering whether all this stuff (including definition of trace) should be rewritten in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact_pairing\">docs#category_theory.exact_pairing</a>. I'm not suggesting to simply adopt the categorical formalism, but at least we would like to easily convert between both formalisms. And the current definition of trace (which landed in mathlib two years ago <a href=\"https://github.com/leanprover-community/mathlib/pull/3125\">#3125</a>) only works for finite free modules, but I think we eventually want it for finite projective modules as well, for K-theory or whatever, and <code>exact_pairing</code> probably offers us greatest generality. I'd appreciate comments from <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> on this.</p>",
        "id": 280956826,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542515
    },
    {
        "content": "<p>Yes, I hope this can be aligned as closely as possible, so that \"bundling\" statements up as statements about rigid categories is as trivial as possible.</p>",
        "id": 280956912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651542631
    },
    {
        "content": "<p>Is it true that <code>dual_tensor_hom R M N</code> is an equivalence whenever <code>M</code> is a finite projective module?</p>",
        "id": 280956947,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651542685
    },
    {
        "content": "<p>I believe so. (Here is a \"reference\": <a href=\"https://mathoverflow.net/a/156274/3332\">https://mathoverflow.net/a/156274/3332</a>)</p>",
        "id": 280957013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542756
    },
    {
        "content": "<p>It seems in the module case, you can derive all isomorphisms involving duals from <code>(module.dual R M) ⊗[R] M →ₗ[R] module.End R M</code> being an isomorphism, which seems a simpler statement than exact_pairing. Is there some advanced theory that I can look into?</p>",
        "id": 280957056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542839
    },
    {
        "content": "<p>Can you derive the more general <code>(module.dual R M) ⊗[R] N →ₗ[R] (M →ₗ[R] N)</code> from this?</p>",
        "id": 280957224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543049
    },
    {
        "content": "<p>It's pretty easy to define <code>Mᵛ → M → (M → N) → Mᵛ ⊗ N</code> which <code>lift</code> to <code>Mᵛ ⊗ M → (M → N) → Mᵛ ⊗ N</code>, and if you have the canonical element in <code>Mᵛ ⊗ M</code> that corresponds to <code>1 : End M</code> then you get <code>(M → N) → Mᵛ ⊗ N</code>. (I'm using <code>ᵛ</code> to denote the dual; I think this is a common notation but forget where I saw it; Wikipedia uses <code>*</code>.)</p>",
        "id": 280957542,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651543352
    },
    {
        "content": "<p>I see, that's nice!</p>",
        "id": 280958372,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543991
    },
    {
        "content": "<p>The check notation is particularly nice for duals once you reach dagger categories and start interacting with operator algebras. At that point <code>*</code> is so massively overloaded that no one is allowed to use it. :-)</p>",
        "id": 280958856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651544440
    },
    {
        "content": "<p>It seems that the following are all equivalent:<br>\n(1) The identity is in the image of the natural map <code>Mᵛ ⊗ M → End M</code>.<br>\n(2) <code>M</code> is a <a href=\"https://en.wikipedia.org/wiki/Rigid_category\">rigid object</a> in the category of <code>R</code>-modules, with <code>M</code> and <code>Mᵛ</code> forming an exact_pairing ((1) is basically one of the \"triangle\" identities saying <code>M → M</code> is id, and the other one follows (the proof invokes extensionality, showing that two linear functionals agree on every element of <code>M</code>, and doesn't seem to follow from axioms of symmetric closed monoidal categories)).<br>\n(3) The natural map <code>Mᵛ ⊗ M → End M</code> is an isomorphism (with inverse given by the construction <code>(M → N) → Mᵛ ⊗ N</code> above (also on the Wikipedia page)).<br>\n(4) <code>M</code> is a finite projective module (finiteness is trivial; projectivity follows from <a href=\"https://en.wikipedia.org/wiki/Projective_module#Dual_basis\">https://en.wikipedia.org/wiki/Projective_module#Dual_basis</a>, <a href=\"https://math.stackexchange.com/a/22403/12932\">proof</a>).</p>\n<p>So we can just work with finite projective modules for maximal generality.<br>\nNotice that <code>M → Mᵛᵛ</code> being an isomorphism (<code>M</code> reflexive) is strictly weaker, as <code>M</code> doesn't have to be finite or projective (e.g. the direct sum of countably many Z).</p>\n<p>One may be tempted to construct all natural maps involving tensor and Hom and prove identities between them using the axioms of symmetric closed monoidal categories and rigid objects, but that's likely cumbersome (though a ramped up <code>coherence</code> tactic might help); simply using extensionality would be easier: if the identity doesn't involve the inverse of <code>Mᵛ ⊗ M → End M</code> it's probably <code>rfl</code>, but I think we need to figure out a better (and uniform) way to do <a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR159\">proofs like this</a> where the inverse is involved.</p>",
        "id": 281160272,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651673286
    },
    {
        "content": "<p>In the categorical language, when the inverse is involved can't we just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso.inv_comp_eq\">docs#category_theory.is_iso.inv_comp_eq</a> to get rid of the inverse, just as I used <code>linear_map.cancel_right</code> when doing these kinds of proofs in the linear algebra language?</p>",
        "id": 281218942,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651698120
    },
    {
        "content": "<p>Could I just ping on a few PRs on the <a href=\"https://bit.ly/3zVLgqR\">#queue</a>: <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13870\">#13870</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13908\">#13908</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13967\">#13967</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> (and hopefully <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, it's just linting now after a merge conflict)?</p>",
        "id": 281507930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651882820
    },
    {
        "content": "<p>I started trying to work with <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> 's <code>Rep k G</code> category, and one issue I noticed is that it assumes that <code>k</code> is a ring (due to <code>Module k</code> assuming a ring), while so far I've tried to only assume <code>semiring</code> when possible. Is there any reason why <code>Module k</code> isn't defined for semirings?</p>",
        "id": 281620148,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652046881
    },
    {
        "content": "<p>I don't know if there's really any interesting case in which we have a semiring which is not a ring, but if there are some things that we can state in this generality I guess that it's better to do so?</p>",
        "id": 281620224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652047019
    },
    {
        "content": "<p>Probably this can be generalized. I suspect that at the time Module was defined the library was less generalized than it is now. If you'd like to have a go at this please do, otherwise I can try soon.</p>",
        "id": 281622233,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050290
    },
    {
        "content": "<p>And yes, I think it's good if results are stated as generally as possible. It seems to pay off later in a mathlib style library. :-) Also often it's helpful for understanding proofs when the hypotheses are as weak as possible --- fewer misleading clues about wrong directions you might take!</p>",
        "id": 281622306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050396
    },
    {
        "content": "<p>I tried quickly to check what happens if I replace <code>ring</code> by <code>semiring</code> in <code>Module</code>, and the problem is that we also need to replace <code>add_comm_group</code> by <code>add_comm_monoid</code> for the underlying abelian group of the module, which causes some problems for example in <code>has_forget_to_AddCommGroup</code> since <code>M</code> doesn't have an <code>add_comm_group</code> instance anymore.</p>",
        "id": 281627211,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652057971
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.add_comm_monoid_to_add_comm_group\">docs#module.add_comm_monoid_to_add_comm_group</a> but it's a def and not an instance so I'm not sure how to use it.</p>",
        "id": 281627327,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652058055
    },
    {
        "content": "<p>Okay, I spent a while on this, and I think it is sadly impossible.</p>",
        "id": 281632116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064483
    },
    {
        "content": "<p>I can get <code>Module/basic.lean</code> to compile, but only be constructing dubious instances, which later break everything.</p>",
        "id": 281632149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064521
    },
    {
        "content": "<p>Hm, that's unfortunate...</p>",
        "id": 281632163,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652064552
    },
    {
        "content": "<p>I'd been worried that we would need a different <code>Module</code> to handle modules over <code>k</code>-algebras, but so far I can get away with just the one.</p>",
        "id": 281632281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064713
    },
    {
        "content": "<p>But this seems worse.</p>",
        "id": 281632284,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064717
    },
    {
        "content": "<p>What did you want to do over semirings? Maybe looking at a concrete statement will lead to inspiration. :-)</p>",
        "id": 281632377,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064810
    },
    {
        "content": "<p>As an example, I was thinking of restating <a href=\"https://leanprover-community.github.io/mathlib_docs/find/representation.lin_hom\">docs#representation.lin_hom</a> in the category theory language using <code>Rep k G</code>. Currently this definition works for semirings, but <code>Rep k G</code> requires a ring.</p>",
        "id": 281632572,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652065069
    },
    {
        "content": "<p>I see. It would be nice to construct the closed monoidal instance on <code>Rep k G</code>.</p>",
        "id": 281635261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068292
    },
    {
        "content": "<p>I propose that for now we just proceed with the restriction that <code>k</code> is a ring in <code>Rep k G</code>...</p>",
        "id": 281635265,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068310
    },
    {
        "content": "<p>I don't think I've ever met someone who does representation theory over semirings.</p>",
        "id": 281635321,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068345
    },
    {
        "content": "<p>Fair enough</p>",
        "id": 281635593,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652068709
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13845\">#13845</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> would like some review, and are on the \"representation theory queue\", if anyone reading here would like to take a look. :-)</p>",
        "id": 282393704,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597477
    },
    {
        "content": "<p>I'm hoping that soon I will have the equivalence of \"is a sum of simple objects\" and \"every subobject is complemented\" in any preadditive category (with a few bits and pieces), and after that the density theorem (the map <code>A ⟶ End V</code> is surjective for any irreducible f.d. representation V of a <code>k</code>-algebra A).</p>",
        "id": 282393819,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597651
    },
    {
        "content": "<p>I  see that we have a <code>right_rigid_category</code> instance for <code>fdRep k G</code>, but we don't have <code>left_rigid_category</code>. This is very annoying since we need the left version in order to get the <code>monoidal_closed</code> structure (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoidal_closed_of_left_rigid_category\">docs#monoidal_closed_of_left_rigid_category</a>). <br>\nI looked at <code>FinVect</code> and noticed that here also we weirdly only have the right rigid structure but not the left one. Is there any reason for that?  If I want to access the monoidal structure of <code>fdRep k G</code>, should I go back to <code>FinVect</code> and add the left rigid structure there, or is it available in another way that I am missing?</p>",
        "id": 283176767,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653143901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 283176870,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144034
    },
    {
        "content": "<p>I think no good reason this is missing. Maybe it would be nice to show that if you're braided one implies the other?</p>",
        "id": 283176887,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144089
    },
    {
        "content": "<p>Or just do it directly for FinVect.</p>",
        "id": 283176888,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144100
    },
    {
        "content": "<p>The PR that did this was just plugging together immediately available pieces.</p>",
        "id": 283176934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144141
    },
    {
        "content": "<p>I don't think we even have that <code>FinVect</code> is braided so for now I think the second option is simpler.</p>",
        "id": 283177291,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144629
    },
    {
        "content": "<p>Though proving braiding for <code>FinVect</code> shouldn't be too hard. The natural way to do it would be to prove it more generally for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.full_monoidal_subcategory\">docs#category_theory.monoidal_category.full_monoidal_subcategory</a>. By the way, is there a reason why this is not an instance?</p>",
        "id": 283178197,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653145772
    },
    {
        "content": "<p>Ok, so trying to prove that <code>FinVect</code> is symmetric, I figured I should probably use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.braided_category_of_fully_faithful\">docs#category_theory.braided_category_of_fully_faithful</a>, but for that I need a monoidal version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.full_subcategory_inclusion\">docs#category_theory.full_subcategory_inclusion</a>. How do I get lean to figure out the monoidal structure on <code>{X : C // P X}</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">full_monoidal_subcategory_inclusion</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_id</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h_tensor</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoidal_functor</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">//</span> <span class=\"n\">P</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 283179780,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653147933
    },
    {
        "content": "<p>I think the best approach here will be to introduce <code>monoidal_subcategory P  h_id h_tensor</code> as a synonym for <code>{X : C // P X}</code> and put a monoidal_category instance on that.</p>",
        "id": 283208421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191120
    },
    {
        "content": "<p>Perhaps even add <code>monoidal_predicate</code> which bundles together <code>P</code>, <code>h_id</code> and <code>h_tensor</code>.</p>",
        "id": 283208428,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191156
    },
    {
        "content": "<p>Does that make sense / seem plausible?</p>",
        "id": 283208487,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191177
    },
    {
        "content": "<p>Sounds good, done in <a href=\"https://github.com/leanprover-community/mathlib/pull/14311\">#14311</a>. Let me know what you think.</p>",
        "id": 283247112,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653247068
    },
    {
        "content": "<p>Left a few comments. Mostly looks promising, thanks for doing this!</p>",
        "id": 283256290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653260036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What are your thoughts on <a href=\"https://github.com/leanprover-community/mathlib/pull/14311#discussion_r878940321\">that comment</a>?</p>",
        "id": 283320796,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653313554
    },
    {
        "content": "<p>Yes, this looks good.</p>",
        "id": 283697414,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653367947
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>",
        "id": 286095492,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1655222718
    },
    {
        "content": "<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>",
        "id": 307566451,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406691
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 307566748,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/286095492\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>\n</blockquote>\n<p>(I am also a new user, so maybe I'm doing something wrong, but I think this commit is not in my local copy yet...)</p>",
        "id": 307566857,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406793
    },
    {
        "content": "<p>All those commits are on a branch (<a href=\"https://github.com/leanprover-community/mathlib/tree/orthogonality\">branch#orthogonality</a>) which is not yet merged into master so your local version of master won't have them yet.</p>",
        "id": 307567981,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407101
    },
    {
        "content": "<p>It looks like the first thing that needs to happen to get the ball rolling on these again is to fix the merge conflicts in <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> with master</p>",
        "id": 307568538,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407271
    },
    {
        "content": "<p>I just tried to fix <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> lets see if the other branches also work now</p>",
        "id": 307579089,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667410150
    },
    {
        "content": "<p>Ok and I've merged branch 'semorrison/fdRep-linear' into semorrison/fdRep-schur and it looks like it builds ok, so <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> will hopefully turn green after a while and be ready for review when the first PR is merged</p>",
        "id": 307585217,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667411915
    },
    {
        "content": "<blockquote>\n<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>\n</blockquote>\n<p>Yes, we basically have orthgonality of characters modulo the merging of these old PRs. We don't have yet that the characters span the class functions though, that would be a next natural step.</p>",
        "id": 307625238,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426292
    },
    {
        "content": "<p>Or incorporating this in a more general setting of representations of algebras.</p>",
        "id": 307625365,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426358
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> for fixing <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>. It's merged now, and I've just updated <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (Schur's lemma applies to fdRep) and it looks good. Hopefully someone can approve it shortly.</p>",
        "id": 307650969,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667445678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Oh great! Should I pick it up somewhere, or are you rolling with these representations?</p>",
        "id": 307730132,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482709
    },
    {
        "content": "<p>(Our local Lean workshop is working towards Burnside's p^aq^b theorem, so there are many other parts that I could start working on.)</p>",
        "id": 307730213,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482736
    },
    {
        "content": "<p>But I love thinking about general finite dimensional representation theory too, so I'm more than happy to dive in here as well.</p>",
        "id": 307730476,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482807
    },
    {
        "content": "<p>I haven't worked on that for a few months, so feel free to start working on any result that we don't currently have.</p>",
        "id": 307730711,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482886
    },
    {
        "content": "<p>Let me know if you have any questions on the current API.</p>",
        "id": 307731021,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482977
    },
    {
        "content": "<p>I've updated <a href=\"https://github.com/leanprover-community/mathlib/pull/16043\">#16043</a>, it's now ready to be reviewed.</p>",
        "id": 307818092,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667502388
    }
]