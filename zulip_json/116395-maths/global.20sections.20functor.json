[
    {
        "content": "<p>When working with sheaves / toposes, one really important functor is the global sections functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span>, i.e. the forwards part of the unique (up to isomorphism) geometric morphism to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Set</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Set</span></span></span></span></span>. There are two ways of constructing it that I know of, that generalise in two different directions:</p>\n<ul>\n<li>As the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">(</mo><mo>∗</mo><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Gamma(*,-)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Γ</span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> that evaluates sheaves on a terminal object. This works for sheaves valued in any category, but requires the site to have a terminal object. On topological spaces these are literally sections on the whole space, so they are nice to work with concretely and give reason to the name.</li>\n<li>As the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Hom</mtext><mo stretchy=\"false\">(</mo><mo>∗</mo><mo separator=\"true\">,</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{Hom}(*,-)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord\">∗</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> of morphisms out of the terminal sheaf/object. This works on any site, but only for sheaves valued in a category with a terminal object (since that's what's needed for there to be a terminal sheaf); it is also always a functor to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Set</mtext></mrow><annotation encoding=\"application/x-tex\">\\text{Set}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord text\"><span class=\"mord\">Set</span></span></span></span></span>, not to the category the sheaves are valued in. While more abstract, this does have the advantage of clearly only depending on the category of sheaves, not the site.</li>\n</ul>\n<p>For sheaves of types on any local site, in particular on any topological space, the two functors are naturally isomorphic. This is the case I am most interested in, but of course to formalise anything I still need to pick one (or both) of the definitions and state it, preferably in the right generality. I am thus wondering:</p>\n<ul>\n<li>Do we want to have one or both of these under some name like <code>Sheaf.Γ</code> or <code>globalSectionsFunctor</code> in mathlib? I have looked around and seen that we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/AlgebraicGeometry/Scheme.html#AlgebraicGeometry.Scheme.%CE%93\">Scheme.Γ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/RingedSpace/LocallyRingedSpace.html#AlgebraicGeometry.LocallyRingedSpace.%CE%93\">LocallyRingedSpace.Γ</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/RingedSpace/SheafedSpace.html#AlgebraicGeometry.SheafedSpace.%CE%93\">SheafedSpace.Γ</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/RingedSpace/PresheafedSpace.html#AlgebraicGeometry.PresheafedSpace.%CE%93\">PresheafedSpace.Γ</a> as special cases of the first definition, but (as far as I can see) nothing in full generality and also nothing on the second definition yet.</li>\n<li>If we do want both, how do we name them? Something short like <code>Sheaf.Γ</code> seems ideal, but then what is the second name? Or do we simply construct the second functor as <code>coyoneda.obj (op (⊤_ (Sheaf J A)))</code> on the fly whenever it comes up?</li>\n</ul>\n<p>If you want to see some code for how this could look, I do have a version of both functors and an isomorphism between them <a href=\"https://github.com/peabrainiac/lean-orbifolds/blob/fc9208f602e958f2f72eff255bf1ae87d7f2aaf4/Orbifolds/ForMathlib/ConcreteSite.lean#L114-L128\">here</a> already, albeit not in full generality because I only focused on concrete sites back then.</p>",
        "id": 502505259,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1740724594
    },
    {
        "content": "<p>Let us consider <code>Sheaf J A</code> where <code>J</code> is a Grothendieck topology on <code>C</code>, and <code>A</code> the \"coefficient\" category of the sheaves.</p>\n<ul>\n<li>When we want the sections of <code>F</code> to be a type, the best candidate I see is <code>F.1.sections</code> (which may be in a larger universe). It was not made a functor though. This is defined for <code>A := Type u</code> (and we could have a <code>AddCommGrp</code> variant easily), and for a general category <code>A</code>, we may apply this construction to the sheaf of types obtained by composing <code>F</code> with some coyoneda functor.</li>\n<li>When we want the sections of <code>F</code> to be an object in <code>A</code>, we should probably apply the right adjoint to the constant sheaf functor. This corresponds also to taking the projective limit of the underlying presheaf <code>F.1</code>. A suggestion of design could be through the introduction of a type class <code>HasGlobalSectionsFunctor J A</code> (abbrev for <code>(constantSheaf J A).IsLeftAdjoint</code>). Then, <code>Sheaf.Γ</code> and <code>Sheaf.globalSectionsFunctor</code> could be defined. (Taking Hom from the terminal object of <code>A</code> to <code>Sheaf.Γ</code> should give an equivalent type to the above construction.)</li>\n</ul>",
        "id": 502511308,
        "sender_full_name": "Joël Riou",
        "timestamp": 1740727781
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/channel/116395-maths/topic/global.20sections.20functor/near/502511308\">said</a>:</p>\n<blockquote>\n<ul>\n<li>When we want the sections of <code>F</code> to be an object in <code>A</code>, we should probably apply the right adjoint to the constant sheaf functor. This corresponds also to taking the projective limit of the underlying presheaf <code>F.1</code>. A suggestion of design could be through the introduction of a type class <code>HasGlobalSectionsFunctor J A</code> (abbrev for <code>(constantSheaf J A).IsLeftAdjoint</code>). Then, <code>Sheaf.Γ</code> and <code>Sheaf.globalSectionsFunctor</code> could be defined.</li>\n</ul>\n</blockquote>\n<p>That's a good suggestion - I knew that getting a right-adjoint to the constant sheaf functor is what we were trying to accomplish, but it didn't occur to me that we could also use that as <em>the definition</em>. I'm slightly worried that not having this functor be definitionally equal to anything useful will be troublesome, but then again, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Sites/Sheafification.html#CategoryTheory.presheafToSheaf\">CategoryTheory.presheafToSheaf</a> is defined in the same way and didn't lead to any problems that I am aware of.</p>",
        "id": 502610120,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1740758115
    },
    {
        "content": "<p>Do you happen to know conditions on <code>A</code> and <code>J</code> under which this adjoint exists, and when it is isomorphic to evaluation on the terminal object? I'll try to think about it a bit on my own too , but I don't usually work with sheaves valued in things other than sets and groups much, so it might take a while</p>",
        "id": 502611589,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1740758512
    },
    {
        "content": "<p>The global sections is a suitable limit of the sections over all objects in the site. This is often a large indexing category, so one must take some care is determining whether it exists. If the site has a terminal object, then this limit will be (canonically) isomorphic to the sections over the terminal object via the projection out of the limit</p>",
        "id": 502616404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740759869
    },
    {
        "content": "<p>So if C is the category underlying the site, and A is the category where your sheaves take their values, you will have a global sections functor whenever A has limits of shape C</p>",
        "id": 502616858,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740759979
    },
    {
        "content": "<p>(or rather C^op)</p>",
        "id": 502616908,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740759993
    },
    {
        "content": "<p>I see - that makes sense. Thanks for your input, I'll see what I can do with that.</p>",
        "id": 502617457,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1740760119
    },
    {
        "content": "<p>I haven't formalized anything in a while, and I had a few minutes before my class today to play around with Lean, so I came up with the following (under a spoiler, if you want to do the above as an exercise):</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GrothendieckTopology</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">globalSectionsFunctor</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasLimitsOfShape</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sheaf</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sheafToPresheaf</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\">  </span><span class=\"n\">lim</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">globalSectionsFunctorIsoOfIsTerminal</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasLimitsOfShape</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsTerminal</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">globalSectionsFunctor</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">sheafToPresheaf</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">⋙</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">evaluation</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsInitial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Opposite.op</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">initialOpOfTerminal</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Limits.lim</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">evaluation</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">limit.π</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">he</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatTrans.isIso_iff_isIso_app</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">isIso_π_of_isInitial</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">asIso</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">whiskerLeft</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n</div></div>",
        "id": 502629367,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1740763580
    },
    {
        "content": "<p>I have opened a PR for this now: <a href=\"https://github.com/leanprover-community/mathlib4/pull/22816\">#22816</a>. I've gone with Adam's suggestion of defining the global sections as a limit there since it seemed sufficient to me, but if there actually are examples of situations we care about where an adjoint exists despite <code>D</code> not having limits of shape <code>Cᵒᵖ</code> I suppose it might still make sense to switch to the <code>HasGlobalSectionsFunctor</code> solution instead.</p>",
        "id": 504755375,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741676040
    },
    {
        "content": "<p>I've also opened another PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/22817\">#22817</a> that builds on top of this to define the right-adjoint of <code>Γ</code> on local sites; I'm just mentioning this so you have some more context for what I'm actually using this <code>Sheaf.Γ</code> for.</p>",
        "id": 504756845,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741676615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"646363\">Ben Eltschig</span> <a href=\"#narrow/channel/116395-maths/topic/global.20sections.20functor/near/504755375\">said</a>:</p>\n<blockquote>\n<p>[...] but if there actually are examples of situations we care about where an adjoint exists despite <code>D</code> not having limits of shape <code>Cᵒᵖ</code> [...]</p>\n</blockquote>\n<p>To be clear, the reason I'm unsure about this is that asking for a right-adjoint to the constant sheaf functor only makes sense when the constant sheaf functor exists, which requires sheafification, which as far as I know already requires <code>A</code> to have certain limits too. So while I know that the definition of <code>Sheaf.Γ</code> via limits won't work on large sites, it's not clear to me whether constant sheaves  might make sense on them anyways.</p>",
        "id": 504757692,
        "sender_full_name": "Ben Eltschig",
        "timestamp": 1741676954
    },
    {
        "content": "<p>It seems to me that the sites which appear in the definition of crystalline cohomology will fit into the situation I am describing.<br>\nAssuming <code>HasSheafify</code> is not a very strong assumption: we already have situations where we can show it holds even though the underlying category of the site is large. (It may sound strange, but the \"small\" étale site of a scheme is a large category, not even essentially small, and yet it shall have suitable <code>HasSheafify</code> instances as I will show in the WIP PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/19462\">#19462</a>.)<br>\nI very much prefer we do a <em>small</em> effort now, rather than having to refactor the definitions in the future (there is an active formalization of divided powers going on...).</p>",
        "id": 505204373,
        "sender_full_name": "Joël Riou",
        "timestamp": 1741801110
    }
]