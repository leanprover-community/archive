[
    {
        "content": "<p>I'm trying to understand the definition of neighborhoods filter:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/ba7312b5aafeb13465bb9283536208f2158e6150/Mathlib/Topology/Defs/Filter.lean#L119-L123\">https://github.com/leanprover-community/mathlib4/blob/ba7312b5aafeb13465bb9283536208f2158e6150/Mathlib/Topology/Defs/Filter.lean#L119-L123</a></p>\n<p>How can I find the definition of the indexed infinitum used here?  It seems to me that to match definition with the comment preceding it, supremum should be used instead of infimum.</p>\n<p>Another question is: what does \"irreducible_def\" mean?</p>",
        "id": 485253138,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1732992941
    },
    {
        "content": "<p>For the last question, you can think of it as <code>def</code></p>",
        "id": 485253382,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732993166
    },
    {
        "content": "<p>If you think of a filter as a \"generalised set\", then the neighbourhood filter of a point s is the intersection of all the usual open sets containing s. If you think of a filter via its usual implementation as a set of sets, then on the set of sets level you are taking suprema and all of your intuitions are backwards. To talk about a simpler example, if F and G are filters then F &lt;= G in Lean means that all the sets in G are in F. The motivation is that if F=P(S) and G=P(T) are principal filters, then you want F &lt;= G to mean S \\subseteq T, so in the sets of sets model you have that a set is in G iff it contains T which implies it contains S which implies it's in F.</p>",
        "id": 485254685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732994282
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Topology</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"c1\">-- to get notation working</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nhds'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">â¨…</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">ğ“Ÿ</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">ctrl-click on the â¨… symbol (or cmd-click on a mac I think)</span>\n\n<span class=\"cm\">Get sent to</span>\n\n\n<span class=\"cm\">/-- Indexed infimum. -/</span>\n<span class=\"cm\">notation3 \"â¨… \"(...)\", \"r:60:(scoped f =&gt; iInf f) =&gt; r</span>\n\n\n<span class=\"cm\">Deduce that `â¨…` is notation for `iInf`.</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">iInf</span><span class=\"w\"> </span><span class=\"c1\">-- ctrl-click on this</span>\n\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">def iInf [InfSet Î±] (s : Î¹ â†’ Î±) : Î± :=</span>\n<span class=\"cm\">  sInf (range s)</span>\n\n\n<span class=\"cm\">So we learn that an `iInf` is something which an `InfSet` has</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- So why are filters an InfSet?</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">InfSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Filter.instInfSet</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">instInfSet</span><span class=\"w\"> </span><span class=\"c1\">-- ctrl-click on this to see the definition. It uses `Filter.sInf`,</span>\n<span class=\"c1\">-- so control-click on that to find</span>\n\n<span class=\"c\">/-</span>\n\n\n<span class=\"cm\">protected def sInf (s : Set (Filter Î±)) : Filter Î± := sSup (lowerBounds s)</span>\n\n\n<span class=\"cm\">This definition looks like a perfectly normal definition of greatest lower bound, so really</span>\n<span class=\"cm\">the question is: what is the actual *order* on `Filter X`?</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"c1\">-- ctrl-click on â‰¤ , discover it's called `LE.le`</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"c1\">-- comes from `LE` class</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Preorder.toLE</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- PartialOrder.toPreorder</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Filter.instPartialOrder</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">instPartialOrder</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">instance : PartialOrder (Filter Î±) where</span>\n<span class=\"cm\">  le f g := âˆ€ â¦ƒU : Set Î±â¦„, U âˆˆ g â†’ U âˆˆ f</span>\n<span class=\"cm\">  le_antisymm a b hâ‚ hâ‚‚ := filter_eq &lt;| Subset.antisymm hâ‚‚ hâ‚</span>\n<span class=\"cm\">  le_refl a := Subset.rfl</span>\n<span class=\"cm\">  le_trans a b c hâ‚ hâ‚‚ := Subset.trans hâ‚‚ hâ‚</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- Bingo! Indeed `f â‰¤ g` means `U âˆˆ g â†’ U âˆˆ f`</span>\n</code></pre></div>",
        "id": 485255548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732995047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> : Thanks for the explanation.  I think I found the definition of the partial order on filters:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/ba7312b5aafeb13465bb9283536208f2158e6150/Mathlib/Order/Filter/Defs.lean#L173-L177\">https://github.com/leanprover-community/mathlib4/blob/ba7312b5aafeb13465bb9283536208f2158e6150/Mathlib/Order/Filter/Defs.lean#L173-L177</a></p>\n<p>As you pointed out, it is backward w.r.t. the usual set inclusion.</p>",
        "id": 485255673,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1732995140
    },
    {
        "content": "<p>Modelling a filter as a set of sets is an implementation detail, and the implementation is misleading when it comes to inequalities. My intuition says that filters are like subsets, indeed subsets are a special case (via principal filters), and a smaller subset should correspond to a smaller filter. But with the implementation as sets of sets, if you focus on how many sets are in your set of sets, this intuition is broken. So it's the implementation leading you astray.</p>",
        "id": 485414342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732995291
    },
    {
        "content": "<p>Right.  Thinking about the principal filters is a good way to figure out the correct ordering direction.</p>",
        "id": 485414566,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1732995471
    },
    {
        "content": "<p><code>Filter X</code> is the \"pro-completion\" of <code>Set X</code>, which roughly means \"suppose you restrict yourself to just finite intersections and but still allow infinite unions from <code>Set X</code> â€”Â now generate a lattice that allows infinite intersections\". The function <code>ğ“Ÿ : Set X -&gt; Filter X</code> is the embedding into the pro-completion.</p>\n<p>It's a convenient fact that elements of the pro-completion of <code>Set X</code> can be represented as sets of sets. It turns out that for <code>f : Filter X</code>, then <code>f</code> is determined by the collection of all <code>s : Set X</code> such that <code>f â‰¤ ğ“Ÿ s</code>, so we may as well represent <code>f</code> as the collection of such <code>s</code>. (This is some sort of Yoneda presheaf thing.)</p>",
        "id": 485415356,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732996184
    },
    {
        "content": "<p>I think this gives some idea for why filters are natural for topology: topologies are closed under finite intersections and infinite unions, but if we want to at least abstractly work with infinite intersections, we can use filters rather than sets.</p>",
        "id": 485415931,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732996672
    },
    {
        "content": "<p>The neighborhood filter at a point doesn't remember the topology of the whole space, but it knows exactly what constitutes a neighborhood of <code>x</code>: <code>ğ“ x â‰¤ ğ“Ÿ s</code> iff <code>s</code> is a neighborhood of <code>x</code> (i.e., if there exists an open set <code>U</code> containing <code>x</code> such that <code>U</code> is a subset of <code>s</code>). <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mem_nhds_iff#doc\">docs#mem_nhds_iff</a></p>",
        "id": 485416200,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732996904
    },
    {
        "content": "<p>A lot of this is explained in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>.</p>",
        "id": 485416335,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1732997039
    },
    {
        "content": "<p>I was wrong: it is pointed out in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>:</p>\n<blockquote>\n<p>In other words, givenÂ <code>GÂ H:Â FilterÂ Y</code>, we haveÂ <code>GÂ â‰¤Â HÂ â†”Â âˆ€Â VÂ :Â SetÂ Y,Â VÂ âˆˆÂ HÂ â†’Â VÂ âˆˆÂ G</code>.</p>\n</blockquote>\n<p>Sorry!</p>",
        "id": 485417205,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1732997785
    }
]