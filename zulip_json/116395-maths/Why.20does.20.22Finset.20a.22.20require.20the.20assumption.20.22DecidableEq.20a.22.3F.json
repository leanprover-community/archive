[
    {
        "content": "<p>Why does \"Finset a\" require the assumption \"DecidableEq a\"?  Why doesn't \"Set a\" need it?</p>",
        "id": 482049202,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731449785
    },
    {
        "content": "<p>It's because for many operations on <code>Finset</code>, you need to be able to remove duplicates in a computable manner. Whereas with <code>Set</code> that's not an issue.</p>\n<p>If you don't care about computability then you can always get <code>DecidableEq</code> via <code>Classical.decEq</code>.</p>",
        "id": 482050427,
        "sender_full_name": "Quang Dao",
        "timestamp": 1731450331
    },
    {
        "content": "<p>Which operations on Finset need to remove duplicates?  What do you mean by \"removing duplicates\"?</p>",
        "id": 482051454,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731450817
    },
    {
        "content": "<p>For example, if you compute the union of two Finsets, it appends the underlying lists and removes the duplicates. You need a way to compute equality to remove duplicates.</p>",
        "id": 482051639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731450898
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a> alone does not require any decidability assumption. Some functions involving <code>Finset</code>s do, as others have indicated above. Like Kyle said, when you take the union, you need to remove duplicates, so you need to be able to decide whether two elements in your type are equal.</p>",
        "id": 482051870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731451004
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  But why doesn't the union of two Sets which happen to be finite also need that?</p>",
        "id": 482051922,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731451035
    },
    {
        "content": "<p><code>Set</code> doesn't compute anything</p>",
        "id": 482051964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731451058
    },
    {
        "content": "<p>A <code>Set X</code> is a predicate (remember that the definition is <code>X -&gt; Prop</code>), which has no runtime representation. A <code>Finset X</code> is an actual data structure that's backed by a <code>List</code> enumerating its elements.</p>",
        "id": 482052086,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731451102
    },
    {
        "content": "<p>Note that we also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> which might more useful for you <span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span></p>",
        "id": 482052088,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731451105
    },
    {
        "content": "<p>And in particular <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite.html#Set.Finite.union\">Set.Finite.union</a></p>",
        "id": 482052136,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731451133
    },
    {
        "content": "<p>I guess I'm really asking: why does Lean care about \"computability\" (whatever that means) at all?  Would the logic implemented by Lean become inconsistent if the computable vs non-computable distinction is completely ignored?</p>",
        "id": 482052704,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731451450
    },
    {
        "content": "<p>Lean is a programming language and a proof assistant. You can use <code>Finset</code>s to write programs.</p>",
        "id": 482052815,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731451525
    },
    {
        "content": "<p>No, the logic doesn't become inconsistent. It's just about whether you can extract runnable code, or about the likelihood of whether you can rely on definitional equality to prove things.</p>",
        "id": 482052816,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731451525
    },
    {
        "content": "<p>People use <code>classical</code> all the time to work with <code>Finset</code> without worrying about decidability. Or, better, you could work with <code>Set.Finite</code> as Adam suggested, since that keeps you in the world of <code>Set</code> and propositions.</p>",
        "id": 482052930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731451571
    },
    {
        "content": "<p>I've wanted there to be a <code>FiniteSet</code> type that's a <code>Set</code> bundled with a <code>Set.Finite</code> proof. Right now the only options are manipulating these <code>Set.Finite</code> proofs by hand, when having lattice operations would be really convenient, or working with <code>Finset</code> and manipulating <code>Decidable</code> instances, which can be awkward and requires additional skills (like knowing about <code>convert</code> when <code>exact</code> fails).</p>",
        "id": 482053087,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731451668
    },
    {
        "content": "<p>Thanks for pointing out Set.Finite.  I am working my way through \"Mathematics in Lean\" whose chapter 5 uses Finset.</p>",
        "id": 482053253,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731451744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> , I have another question: Suppose there is a FiniteSet type as you wanted.  Under the assumption that the underlying type \\alpha is DecidableEq, how does one port a theorem stated using FiniteSet \\alpha to one stated using Finset \\alpha, and vice versa?</p>",
        "id": 482055055,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731452713
    },
    {
        "content": "<p>for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a> we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.ofFinset#doc\">docs#Set.Finite.ofFinset</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.toFinset#doc\">docs#Set.Finite.toFinset</a> to go back and forth to Finsets.</p>",
        "id": 482059289,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731454939
    },
    {
        "content": "<p>Assuming someone makes a bundled <code>Set</code> with <code>Set.Finite</code> as Kyle suggests, this is how you could go back and forth between such an object and finsets. There is more API needed, of course, but it's all there, and you can read more about it in the documentation webpage for <code>Set.Finite</code>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite.html</a></p>",
        "id": 482059404,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731455027
    },
    {
        "content": "<p>Thanks for the pointer!  However, are those two maps sufficient for porting theorems from one representation to the other?  For example, consider the commutativity of intersection.  Does the commutativity of intersection on FiniteSet follow immediately from the  commutativity on Finset?  It seems not.  It seems to me that one still needs to prove two commutative diagram involving the two intersection operations and the two mappings, right?</p>",
        "id": 482060626,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731455757
    },
    {
        "content": "<p>No, they’re not sufficient. That’s why I mentioned the API. Please take a look at the page I linked for the relevant results.</p>",
        "id": 482065164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731458558
    },
    {
        "content": "<p>There are probably some results in other files as well, but the API to go back and forth is quite complete.</p>",
        "id": 482065213,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731458599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/116395-maths/topic/Why.20does.20.22Finset.20a.22.20require.20the.20assumption.20.22DecidableEq.20a.22.3F/near/482052704\">said</a>:</p>\n<blockquote>\n<p>I guess I'm really asking: why does Lean care about \"computability\" (whatever that means) at all?  Would the logic implemented by Lean become inconsistent if the computable vs non-computable distinction is completely ignored?</p>\n</blockquote>\n<p>Worth pointing out that computability can also sometimes be used to prove theorems more conveniently, by literally evaluating an expression or predicate to figure out its value</p>",
        "id": 482313000,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731562393
    },
    {
        "content": "<p>This is basically what tactics like <code>norm_num</code> or <code>decide</code> do</p>",
        "id": 482313035,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731562438
    },
    {
        "content": "<p>Well, I just tried the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>and found that it works.  Of course, such computation does not work in general on reals.  But that doesn't mean we can't compute with reals  in many useful situations.</p>",
        "id": 482320509,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731567305
    },
    {
        "content": "<p>yeah, the quote above is only half correct - <code>decide</code> uses decidability, <code>norm_num</code> uses proof term generation and is not limited to lean-computable functions</p>",
        "id": 482401910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731593748
    },
    {
        "content": "<p>If we take axes of:</p>\n<ul>\n<li>bundled / unbundled</li>\n<li>computable / non-computable</li>\n</ul>\n<p>Mathlib currently has 3 of the 2 x 2 = 4 ways that these two axes allow us to implement finite sets.</p>\n<p>Our <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a> is extremely good but I sometimes think it should be renamed to something like <code>CFinset</code> with the <code>C</code> for computable so that we could introduce a non-computable version called <code>Finset</code>, and which would not demand any of the <code>DecidableEq</code> hypotheses in its API.</p>",
        "id": 482406929,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1731595009
    },
    {
        "content": "<p><del>what would a bundled (possibly infinite) set that is not computable look like?</del><br>\nnvm i misunderstood</p>",
        "id": 482411320,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731596155
    },
    {
        "content": "<p>what is the third?</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">sets</th>\n<th style=\"text-align: center;\">bundled</th>\n<th style=\"text-align: center;\">unbundled</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">computable</td>\n<td style=\"text-align: center;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a></td>\n<td style=\"text-align: center;\">?</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">noncomputable</td>\n<td style=\"text-align: center;\">?</td>\n<td style=\"text-align: center;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">types</th>\n<th style=\"text-align: center;\">bundled</th>\n<th style=\"text-align: center;\">unbundled</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\">computable</td>\n<td style=\"text-align: center;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a></td>\n<td style=\"text-align: center;\">?</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\">noncomputable</td>\n<td style=\"text-align: center;\">?</td>\n<td style=\"text-align: center;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a></td>\n</tr>\n</tbody>\n</table>",
        "id": 482412079,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731596349
    },
    {
        "content": "<p><code>Fintype</code></p>",
        "id": 482414284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1731596919
    },
    {
        "content": "<p>what hole does that go into?</p>",
        "id": 482415088,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731597122
    },
    {
        "content": "<p>i'd say that's bundled and computable too, no?</p>",
        "id": 482415206,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731597144
    },
    {
        "content": "<p>that goes into the third dimension of set/type</p>",
        "id": 482415257,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731597162
    },
    {
        "content": "<p>or am i misinterpreting what \"bundled\" is supposed to mean?</p>",
        "id": 482416822,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731597555
    },
    {
        "content": "<p>maybe i'm making the wrong kind of table...</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: left;\">thing</th>\n<th style=\"text-align: center;\">bundled</th>\n<th style=\"text-align: center;\">data carrying</th>\n<th style=\"text-align: center;\">computable</th>\n<th style=\"text-align: center;\">set</th>\n<th style=\"text-align: center;\">type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: left;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n</tr>\n<tr>\n<td style=\"text-align: left;\"><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"cross mark\" class=\"emoji emoji-274c\" role=\"img\" title=\"cross mark\">:cross_mark:</span></td>\n<td style=\"text-align: center;\"><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></td>\n</tr>\n</tbody>\n</table>",
        "id": 482418049,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731597858
    },
    {
        "content": "<p>What does \"bundled/unbundled\" mean here?</p>",
        "id": 482491154,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731621957
    },
    {
        "content": "<p>For that matter, what does 'data carrying\" mean here?</p>",
        "id": 482491281,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731622007
    },
    {
        "content": "<p>It also seems to me that the decidability of a theory is not necessarily  related to the \"computability\" of the objects that the theory talks about.  For example, there are decidable theories of real numbers (<a href=\"https://en.wikipedia.org/wiki/Decidability_of_first-order_theories_of_the_real_numbers\">https://en.wikipedia.org/wiki/Decidability_of_first-order_theories_of_the_real_numbers</a>), but I guess the reals are not considered computable in Lean?</p>",
        "id": 482492102,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731622380
    },
    {
        "content": "<p>Yes, mathematicians like there to be only one real numbers, so we go with the classical ones in classical logic.</p>",
        "id": 482495651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731624060
    },
    {
        "content": "<p>Data carrying means that you can have two terms of type <code>Fintype X</code> and they're not definitionally equal.</p>",
        "id": 482495837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731624133
    },
    {
        "content": "<p>Could you give an example?</p>",
        "id": 482496749,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731624578
    },
    {
        "content": "<p>The theoy of real numbers might as well be \"talking about\" real algebraic numbers, since there's no first order axioms stating anything about limits. Algebraic numbers are of course computable.</p>",
        "id": 482537118,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1731649648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110637\">@Ching-Tsun Chou</span> Data carrying means that <code>Fintype X</code> is not in <code>Prop</code> but in <code>Type u</code> for some <code>u</code>. Concretely, <code>Fintype X</code> under the hood carries a list that enumerates the elements of <code>X</code>, and that list can be used for computations. Different permutations of this list will lead to different terms of type <code>Fintype X</code>. They will be propositionally equal, because we've modded out by permutations, but they still will not be definitionally equal.</p>",
        "id": 482543917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731653895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks a lot for the explanation!</p>",
        "id": 482546300,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731655193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/116395-maths/topic/Why.20does.20.22Finset.20a.22.20require.20the.20assumption.20.22DecidableEq.20a.22.3F/near/482491154\">said</a>:</p>\n<blockquote>\n<p>What does \"bundled/unbundled\" mean here?</p>\n</blockquote>\n<p>i didn't put <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a> with \"bundled\" because <code>Fintype a</code> is an additional assumption on top of <code>a:Type u</code>, compared to something like <code>a:TypeOfFiniteTypes.{u}</code></p>",
        "id": 482654517,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731689662
    },
    {
        "content": "<p>We do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a></p>",
        "id": 482656196,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731690173
    },
    {
        "content": "<p>i'd say that fits the bill, yea <span aria-label=\"idea\" class=\"emoji emoji-1f4a1\" role=\"img\" title=\"idea\">:idea:</span></p>",
        "id": 482656503,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1731690275
    },
    {
        "content": "<p>I still don't quite understand Fintype.  I understand Finite: <code>Finite(Nat)</code> is a proposition which is (and can be proved to be) false.  But what is <code>Fintype(Nat)</code>?  It is not a proposition, but it must be false in some sense, right?</p>",
        "id": 482712960,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731714803
    },
    {
        "content": "<p><code>Fintype Nat</code> is an empty type (concretely, it's equivalent to <code>Empty</code>)</p>",
        "id": 482713340,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731715033
    },
    {
        "content": "<p>You can think of elements of the <em>type</em> <code>Fintype Nat</code> as elements <code>A : Finset Nat</code> which contain every natural number. Of course there is no such <code>A</code>. In this case we would say that elements of <code>Fintype X</code> \"contain data\", namely the data of the <code>Finset X</code> which contain every element of <code>X</code>.</p>",
        "id": 482713905,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1731715341
    },
    {
        "content": "<p>I'm probably missing some theorems here, but it's not hard to create this equvialence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_nonempty_fintype_of_infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">not_finite_iff_infinite</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_nonempty_fintype_of_infinite</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nofun</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_nonempty_fintype_of_infinite</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n</code></pre></div>",
        "id": 482714083,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731715475
    },
    {
        "content": "<p>Of course there's also the following, but I sort of like seeing that <code>Fintype Nat</code> \"is\" <code>Empty</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsEmpty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isEmpty_fintype</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 482714395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731715700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/116395-maths/topic/Why.20does.20.22Finset.20a.22.20require.20the.20assumption.20.22DecidableEq.20a.22.3F/near/482712960\">said</a>:</p>\n<blockquote>\n<p>I still don't quite understand Fintype.  I understand Finite: <code>Finite(Nat)</code> is a proposition which is (and can be proved to be) false.  But what is <code>Fintype(Nat)</code>?  It is not a proposition, but it must be false in some sense, right?</p>\n</blockquote>\n<p>In these situations it often helps to use #check and #print, using check you can see Fintype and Finset have the same signature; but Finite is different:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"c1\">--Fintype.{u_4} (α : Type u_4) : Type u_4</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"c1\">-- Finset.{u_4} (α : Type u_4) : Type u_4</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"c1\">-- Finite.{u_1} (α : Sort u_1) : Prop</span>\n</code></pre></div>\n<p>Now if you print them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">class Fintype.{u_4} : Type u_4 → Type u_4</span>\n<span class=\"cm\">number of parameters: 1</span>\n<span class=\"cm\">constructor:</span>\n<span class=\"cm\">Fintype.mk : {α : Type u_4} → (elems : Finset α) → (∀ (x : α), x ∈ elems) → Fintype α</span>\n<span class=\"cm\">fields:</span>\n<span class=\"cm\">elems : Finset α</span>\n<span class=\"cm\">complete : ∀ (x : α), x ∈ Fintype.elems</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">structure Finset.{u_4} : Type u_4 → Type u_4</span>\n<span class=\"cm\">number of parameters: 1</span>\n<span class=\"cm\">constructor:</span>\n<span class=\"cm\">Finset.mk : {α : Type u_4} → (val : Multiset α) → val.Nodup → Finset α</span>\n<span class=\"cm\">fields:</span>\n<span class=\"cm\">val : Multiset α</span>\n<span class=\"cm\">nodup : self.val.Nodup</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>You can see how Finset calls nodup on Multiset, and Fintype uses Finset</p>",
        "id": 482724557,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1731723902
    },
    {
        "content": "<p>Thanks for the explanations!  I understand now.  Both <code>Finite Nat</code> and <code>Fintype Nat</code> are uninhabited types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_finite</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_finite</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The only difference is that <code>Finite Nat</code> is also a proposition, but in Lean propositions are types as well.</p>",
        "id": 482739413,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1731735238
    }
]