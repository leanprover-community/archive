[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> gave a very interesting <a href=\"https://www.math.uwo.ca/faculty/kapulkin/seminars/hottestfiles/van-Doorn-2024-10-10-HoTTEST.pdf\">recent talk</a> in the <a href=\"https://www.math.uwo.ca/faculty/kapulkin/seminars/hottest.html\">HoTTEST seminar</a>. In the Q&amp;A afterwards, I raised a <a href=\"https://youtu.be/vMEGU8fL1xM?feature=shared&amp;t=4311\">question</a> that I'd also like to ask here:</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"vMEGU8fL1xM\" href=\"https://youtu.be/vMEGU8fL1xM?feature=shared&amp;t=4311\"><img src=\"https://uploads.zulipusercontent.net/8e450d7ddb42c51b3c0f6585012b660b8695fcf8/68747470733a2f2f692e7974696d672e636f6d2f76692f764d45475538664c31784d2f64656661756c742e6a7067\"></a></div>",
        "id": 481973152,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731424708
    },
    {
        "content": "<p>What differences/difficulties have folks encountered in the translation between paper proofs (implicitly in set theory) to Lean proofs (in extensional dependent type theory)?</p>",
        "id": 481973300,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731424760
    },
    {
        "content": "<p>Floris mentioned that this hasn't proven to be a large obstacle in the formalization of Carleson's theorem, but it seems to be a much bigger deal in the projects I've been involved with. What I haven't figured out is:</p>\n<p>(a) Whether this is some inherant difficulty involving category theory in dependent type theory, or <br>\n(b) Whether I'm just bad at Lean.</p>\n<p>If (a), then are other subfields similarly affected by the foundation system?</p>\n<p>If (b), then how do I get better at formalizing category theory in Lean (and help others do the same)?</p>",
        "id": 481974015,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731424955
    },
    {
        "content": "<p>I'll give a little more detail on what might be special about category theory. </p>\n<p>On paper, category theory has a notion of \"evil,\" the primary example being categorical statements that involve equality between objects. The reason such statements are \"evil\" is that they often fail to be invariant under equivalence between categories.</p>\n<p>In Lean, it seems relatively easy to prove those \"evil\" statements that are true. But what can be more difficult is proving that two morphisms are equal because morphisms live in dependent types (over their domain and codomain objects) and if the objects are <em>provably</em> equal rather than <em>definitionally</em> equal, the morphisms belong to different types.</p>",
        "id": 481974841,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731425163
    },
    {
        "content": "<p>Another difficulty I've encountered relates to something that is also difficult conceptually. (Aside: maybe this is a third mode of proof construction: \"on paper\", \"in a proof assistant\", \"in your head\"?) Namely, the challenge of switching back and forth between category levels.</p>\n<p>Sometimes in category theory you are working <em>inside</em> the category of categories. You build some category of mathematical objects of some type and then build another category of mathematical objects of another type. Then you build a functor from the first category to the second. In Lean, we have a special notation <code>⥤</code> for functors, which makes sense from this perspective.</p>\n<p>But at other times you \"go up a category level\" and just think of Cat as an example of a category (at a larger universe level). Now functors are just morphisms in this particular category and it makes sense to use the stand morphism notation <code>⟶</code> in Lean. </p>\n<p>A big annoyance that <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and I encountered over the summer was translating back and forth between these perspectives. We were trying to build an adjunction involving Cat (treating Cat from the higher category level) but had to manually tell Lean that some result about functors had implications for the morphisms inside Cat.</p>",
        "id": 481975120,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731425239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481973300\">said</a>:</p>\n<blockquote>\n<p>What differences/difficulties have folks encountered in the translation between paper proofs (implicitly in set theory) to Lean proofs (in extensional dependent type theory)?</p>\n</blockquote>\n<p>Do you specifically mean paper proofs <em>in category theory</em>?</p>",
        "id": 481975392,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1731425291
    },
    {
        "content": "<p>No, I specifically don't exclusively mean this. My experience is with category theory but I'm curious what comes up in other areas.</p>",
        "id": 481975546,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731425333
    },
    {
        "content": "<p>I think that a good example, that you probably already know, is what happened with chain complexes (the fact that we need morphisms from <code>C_i</code> to <code>C_j</code> for all <code>i</code> and <code>j</code>). I don't think this is related to category theory, it's the fact that in writing <code>f ∘ g</code> Lean needs to understand that the codomain of <code>g</code> <em>is</em> the domain of <code>f</code> automatically (i.e. they must be definitionally equal)</p>",
        "id": 481976645,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731425579
    },
    {
        "content": "<p>I think this is an interesting question. My experience in formalising mathematics (99.9% of which was nothing to do with category theory) was that I had to do a certain amount of reorganization in my head because I was working on the assumption that subgroups were groups and that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\N\\subseteq\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>. In Lean groups are types and subgroups are terms, and invisible maps between numeric types are explicitly present.  In short I think that this realignment which I had to go through is probably present across mathematics and is really just an artifact of formalization being hard rather than it being anything to do with category theory per se, but perhaps it's even worse in category theory than in number theory? Not sure. It's definitely present though, and I think is all part of the (rather steep!) learning curve that all mathematicians have to go through when formalizing.</p>\n<p>I also suspect that this might not just be to do with dependent type theory, I wonder that even if I had learnt a set theory system instead I would have still had to do a bunch of re-learning stuff (because e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\N\\subseteq\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is probably not true in set theory either!)</p>",
        "id": 481976792,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731425615
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> I don't know about the chain complex example. Can you say more?</p>",
        "id": 481976872,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731425640
    },
    {
        "content": "<p>Oh chain complexes was a <em>great</em> example! I'll let Riccardo explain :-)</p>",
        "id": 481977158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731425707
    },
    {
        "content": "<p>Give me 1 second to find some code I've written</p>",
        "id": 481977227,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731425729
    },
    {
        "content": "<p>This was a great example of \"dependent type hell\", so probably specific to DTT (and utterly invisible on paper).</p>",
        "id": 481977631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731425824
    },
    {
        "content": "<p>(sorry, on a train)</p>",
        "id": 481977755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731425850
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 481977890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731425885
    },
    {
        "content": "<p>Here is the problem. Let's define cochain complex of abelian groups. A natural definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Complex</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">AddCommGrp</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">d_comp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>so we have the function that gives the groups, the function that gives the differentials and the assumption on the composition. So far so good. Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complex</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d_comp</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>\n<p>works well.</p>",
        "id": 481978253,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731425990
    },
    {
        "content": "<p>Now, maybe at some point you need to prove that <code>C.d (i+1) ≫ C.d (i+2) = 0</code>, where <code>i : ℤ</code> is given. You may think that <code>exact C.d_comp (i+1)</code> would work, but if you try to state</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complex</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>you see that there is an error in <em>the statement</em>. The error is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">1048</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">957</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">1048</span>\n</code></pre></div>",
        "id": 481979031,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731426186
    },
    {
        "content": "<p>The problem is that for Lean, <code>C.d (i + 2)</code> goes from <code>C.X (i + 2)</code> to <code>C.X (i + 2 + 1)</code>, not from <code>C.X (i + 1 + 1)</code> to something else. One can prove that <code>C.X (i + 2)</code> and <code>C.X (i + 1 + 1)</code> are <em>propositionally</em> equal, but Lean doesn't care about propositional equality here.</p>",
        "id": 481979527,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731426309
    },
    {
        "content": "<p>This caused a lot of headache, since to fix it you need to use the marvelous  <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom\">CategoryTheory.eqToHom</a> or maybe its friend <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\">CategoryTheory.eqToIso</a>, something it's clearly impossible to do in a complicated proof.</p>",
        "id": 481980087,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731426439
    },
    {
        "content": "<p>One partial solution is the following. Let's define a complex as (I just wrote this, so it's probably not very good, but the idea is there)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Complexbetter</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">AddCommGrp</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">d_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">d_comp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 481980847,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731426604
    },
    {
        "content": "<p>We now have a differential <code>d i j : X i ⟶ X j</code> for all <code>i</code> and <code>j</code>, and the assumption that the relevant composition is <code>0</code>. We also assume that <code>d i j = 0</code> unless <code>j = i+1</code>. Mathematically this is the same as before, but now we can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexbetter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 481981678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731426842
    },
    {
        "content": "<p>The paper I wrote with <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span>  on <a href=\"https://api.repository.cam.ac.uk/server/api/core/bitstreams/555e1a14-96d2-4f00-8417-e92f8a5c8313/content\">Graded rings in Lean</a> walks through a similar issue, instead around dealing with a multiplication <code>mul : A i → A j → A (i + j)</code> and its associativity.</p>",
        "id": 481982171,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731426970
    },
    {
        "content": "<p>Just to add: </p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>$<span class=\"w\"> </span>rg<span class=\"w\"> </span><span class=\"s1\">'omega'</span><span class=\"w\"> </span>Mathlib/Algebra/Homology<span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>wc<span class=\"w\"> </span>-l\n$<span class=\"w\"> </span><span class=\"m\">271</span>\n</code></pre></div>",
        "id": 481982695,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1731427118
    },
    {
        "content": "<p>What we actually do in mathlib is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Complexevenbetter</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">AddCommGrp</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">d_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">d_comp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"bp\">=</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">=</span><span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 481983076,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427216
    },
    {
        "content": "<p>the difference between <code>Complexbetter</code> and <code>Complexevenbetter</code> is that in the last field we say that <code>d i j ≫ d j k = 0</code> <em>if</em> <code>j=i+1</code> and <code>k=j+1</code>. Again mathematically this the same as before, but now every time we know that these conditions are satisfied (and those are <code>Prop</code>, so we don't care how we proved them) we can use <code>d_comp</code>.</p>",
        "id": 481983448,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427316
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Complexevenbetter</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">d_comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is a typical example.</p>",
        "id": 481983899,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427423
    },
    {
        "content": "<p>(if you look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Homology/HomologicalComplex.html#CochainComplex\">CochainComplex</a> you see that this is an abbreviation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Homology/HomologicalComplex.html#HomologicalComplex\">HomologicalComplex</a>, whose definition is even more complicated, but this is only to allow complexes indexed by various things, like <code>ℕ</code>, <code>ℤ</code> or <code>Fin n</code>, and allowing triangles etc)</p>",
        "id": 481984258,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427513
    },
    {
        "content": "<p>mathlib's solution is great, and everything was done, IIRC, by <span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span></p>",
        "id": 481984999,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427703
    },
    {
        "content": "<p>Very interesting. So, to summarize, the initial obstacles were circumvented by reconfiguring the definition. The DTT notion of chain complex is logically equivalent to the set theoretic notion but structurally more complicated (essentially has more explicitly structure). Have there been propagating difficulties in proofs involving chain complexes related to this?</p>",
        "id": 481985335,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731427802
    },
    {
        "content": "<p>I believe this has eliminated all the DTT issues, though it requires writing more variables (often just an underscore will do)</p>",
        "id": 481985917,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427954
    },
    {
        "content": "<p>I remember a talk by <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> about this, but I don't know how to find it</p>",
        "id": 481985997,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731427983
    },
    {
        "content": "<p>Another (much easier) difference wrt pen and paper proof is all the troubles related to natural number subtraction/division.</p>",
        "id": 481988079,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731428608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481988079\">said</a>:</p>\n<blockquote>\n<p>Another (much easier) difference wrt pen and paper proof is all the troubles related to natural number subtraction/division.</p>\n</blockquote>\n<p>Could you (or someone) elaborate on this as well? I've been warned that subtraction is bad but haven't yet encountered such issues myself.</p>",
        "id": 481990112,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1731429210
    },
    {
        "content": "<p>In paper proofs when we subtract/divide natural numbers we usually either implicitly move to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>, or we know that the result will be a natural number. In general we like homogeneous functions - we don't want someone writing <code>2 - 1</code> and getting <code>1 : ℤ</code>, and in DTT functions which take proofs are usually harder to work with.<br>\nTo resolve this we make subtraction and division truncate, and take appropriate inequality/divisibility hypotheses to theorems when required. This can be confusing at first, as <code>1 - 2 = 0</code> and <code>3 / 2 = 1</code></p>",
        "id": 481993089,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731430095
    },
    {
        "content": "<p>Also see <a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/</a></p>",
        "id": 481993603,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731430263
    },
    {
        "content": "<p>I think the subtraction on natural number is not a good example because it actually also doesn’t work in set theory. The set of natural number is <em>not</em> a subset of integers, unless you have a weird construction. The inclusion map already exist, and there is no good subtraction function on Nat × Nat.</p>",
        "id": 481995453,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1731430864
    },
    {
        "content": "<p>This is completely different from the homological algebra thing which is specific to DTT.</p>",
        "id": 481995552,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1731430900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481990112\">said</a>:</p>\n<blockquote>\n<p>Could you (or someone) elaborate on this as well? I've been warned that subtraction is bad but haven't yet encountered such issues myself.</p>\n</blockquote>\n<p>\"Strange\" operations like natural subtraction (which satisfies <code>0 - 1 = 0</code> and natural division (which satisfies <code>5 / 2 = 2</code>) are things which some computer scientists might expect, but very few mathematicians do. This has the following quite unfortunate consequence. A mathematician hears about Lean, thinks \"this is cool, I might try it\", thinks of the easiest possible thing they can prove by induction, which is often <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^ni=\\frac{n(n+1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.104em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8043em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>, tries to formalize the statement, discovers that computer scientists seem to prefer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1,2,\\ldots,n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1,2,\\ldots,n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">}</span></span></span></span>, rewrites as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mi>i</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=0}^{n-1}i=\\frac{n(n-1)}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2537em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.355em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>, and off they go on their first Lean adventure!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- base case easy</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- use sum to n+1 = last term plus sum to n</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_range_succ</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- use inductive hypothesis</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- goal now looks completely obvious</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `⊢ n * (n - 1) / 2 + n = (n + 1) * (n + 1 - 1) / 2`</span>\n<span class=\"w\">    </span><span class=\"n\">ring</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now totally stuck</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 481996090,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731431048
    },
    {
        "content": "<p>And then they come and ask here, and are informed that they are in a real mess, and sometimes people come up with arguments which finish the job from here but it's always clunky and horrible, maybe n=0 is a special case because there's an n-1 in there, you will probably have to invoke the fact that n is either even or odd to show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(n-1)/2 * 2 = n(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> and so on. It's a really disastrous introduction to formal proof verification because it turns out that the question did not say what they thought it said, as the basic symbols <code>-</code> and <code>/</code> didn't mean what they thought they meant.</p>",
        "id": 481996474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731431180
    },
    {
        "content": "<p>Sorry I am with my phone so I will let others write detailed explanations, but two more examples:</p>\n<ul>\n<li><code>PNat</code> is not included in <code>Nat</code> (something true in set theory regardless of N not included in Z).</li>\n<li>Our definition of a group includes the (unique) Z-action.</li>\n</ul>",
        "id": 481996655,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731431239
    },
    {
        "content": "<p>This is the fix I advertise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- same question but use rationals, where - and / work as</span>\n<span class=\"c1\">-- a mathematician expects</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c1\">-- base case easy</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- use sum to n+1 = last term plus sum to n</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_range_succ</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- use inductive hypothesis</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- weird up-arrows everywhere because ℕ ⊆ ℚ is false</span>\n<span class=\"w\">    </span><span class=\"n\">push_cast</span>\n<span class=\"w\">    </span><span class=\"c1\">-- but at least this now works</span>\n<span class=\"w\">    </span><span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 481997042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731431348
    },
    {
        "content": "<p>I think that the main problem here is that what you write in Lean is not what you have in mind (that is much closer to Kevin's code)</p>",
        "id": 481997630,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1731431523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481983448\">said</a>:</p>\n<blockquote>\n<p>the difference between <code>Complexbetter</code> and <code>Complexevenbetter</code> is that in the last field we say that <code>d i j ≫ d j k = 0</code> <em>if</em> <code>j=i+1</code> and <code>k=j+1</code>. Again mathematically this the same as before, but now every time we know that these conditions are satisfied (and those are <code>Prop</code>, so we don't care how we proved them) we can use <code>d_comp</code>.</p>\n</blockquote>\n<p>Also known as \"don't touch the green slime\" (unless I misunderstood the issue), as in page 4 of <a href=\"https://personal.cis.strath.ac.uk/conor.mcbride/PolyTest.pdf\">https://personal.cis.strath.ac.uk/conor.mcbride/PolyTest.pdf</a></p>",
        "id": 481998596,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1731431835
    },
    {
        "content": "<p>Here is an example coming from commutative algebra which I think you might like Emily. It is precisely an issue of set theory v type theory, and early on in my Lean journey I was quite concerned about this issue. When I started pushing Lean at Imperial and getting undergraduates involved, they wanted projects, and I wanted commutative algebra because it's the backbone of alg geom and it's nice to do in Lean, so I got them doing commutative algebra. One student was formalising a theorem in a textbook involving three rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and they realised that there were many ways to say this in Lean, because we have <code>Subring C</code> (the type of subrings of <code>C</code>, which would make A and B terms), and we also have <code>Algebra A B</code> (meaning that B is an A-algebra, i.e. A and B are types and there's a canonical ring map A -&gt; B). Every possibility the student tried led to problems. For example if <code>A</code> and <code>B</code> have type <code>Subring C</code> then we don't have <code>A : Subring  B</code>, we have <code>A &lt;= B</code>. If we have <code>Algebra A B</code> then we can't use any theorems about subrings. Most of the solutions are furthermore asymmetric, with A a term and C a type, whereas in the paper proof A and C are treated on the same footing.</p>\n<p>I had read the Coq paper on formalization of the odd order theorem, where they have the analogous problem with groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, and in that paper they made what I thought at the time was an extraordinary decision: they have some underlying \"universe group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>\", and every group they consider has type <code>Subgroup G</code>. So now at least we have the fact that all groups are being treated the same -- they're all terms, apart from this universe group which is just playing a weird role in the background. This was a design decision all the way through the project; if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> were two random groups then they would be considered as subgroups of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>:</mo><mo>=</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">G:=A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and more generally it's easy to see that given any finite collection of finite groups, you can realise them all as a subgroup of a bigger group (the product). Whilst I thought that this was a strange design decision, I figured that if it could be used to prove the odd order theorem then it could be used to do graduate commutative algebra, and for a week or so we experimented with proving theorems in ring theory via this set-up. But then to my horror a student pointed out to me that given two random rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, it was not in general <em>possible</em> to find a \"universe ring\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> as subrings, because Lean's definition of subrings (which I was very happy with as it's the convention used by Grothendieck all through alg geom) demanded that the 1 of the ring coincided with the 1 of the subring, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>:</mo><mo>=</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">R:=A\\times B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> doesn't work! Indeed it's very easy to convince yourself that there's no ring which contains both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/2\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/2</span><span class=\"mord mathbb\">Z</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>3</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/3\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/3</span><span class=\"mord mathbb\">Z</span></span></span></span> as subrings. (1/2)</p>",
        "id": 482000631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731432512
    },
    {
        "content": "<p>This is the problem that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsScalarTower#doc\">docs#IsScalarTower</a> resolves, right?</p>",
        "id": 482001763,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1731432933
    },
    {
        "content": "<p>By this point I was quite upset, because the whole idea was that doing commutative algebra in a theorem prover was supposed to be easy, and here we were wrestling not with mathematics but with the underlying axiomatic system. I became convinced that we needed a solution where all rings were treated equally, and if they can't all be terms then they were going to have to all be types. I haven't yet mentioned the problem with this set-up, but here it is: we now have <code>A B C : Type</code>, <code>[CommRing A] [CommRing B] [CommRing C]</code> and <code>[Algebra A B] [Algebra A C] [Algebra B C]</code> to indicate that each ring is a subring of the other rings later in the alphabet. What happens now is that typeclass inference is great at tracking the maps between the rings (as they're in the typeclass system with the <code>[Algebra]</code> instances), but sometimes you have an element of A which you treat as an element of B and then as an element of C, and now you're in trouble because you can also treat an element of A directly as an element of C (all the time applying these canonical maps coming from the Algebra instances) and now the typeclass system doesn't know that these two ways of getting from A to C are equal. The brilliant solution to this, discovered by Kenny Lau, was to just make another typeclass [AlgebraTower A B C], which was just the proposition saying that these maps were the same. This <em>worked</em>! After Kenny had written the API, we were able to stop worrying about foundations and just get back to the mathematics, which went back to being painless. Then people like Eric Wieser came along and realised that in fact we could even do <code>[IsScalarTower A B C]</code>, which is the axiom <code>(a • b) • c = a • (b • c)</code>, which makes sense for algebras but also makes sense in far more generality, is equivalent to the claim that the triangle commutes in the case when A-&gt;B-&gt;C are rings with A acting on B via applying the canonical ring hom and then multiplying, and which is the set-up that we use today. (2/3)</p>",
        "id": 482002334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731433119
    },
    {
        "content": "<p>The moral of the story here was that if you go ahead and try and do graduate level commutative algebra in a dependent type theory system in 2020, then you run into issues simply because nobody tried this already. And so it's on you to solve these issues! But because of the amazing community we have here, the issues were eventually solved. You are frustrated because you're also running into issues which are non-issues from a mathematical perspective but which impede the process of formalization, and it might simply be the case that what's happening is that there will be pain points when formalizing cosmoi in DTT because nobody tried it before and so nobody found the solutions. Potential solutions for your problems could perhaps come from a number of places: some trick involving typeclasses, or some bespoke tactic which does some of the work for you, or a reorganization/generalization of the material, or who knows what else. But once the community begins to understand properly what the problems are, it would not surprise me if the community is able to solve them to the point where they stop being painful. This might not happen instantly though. But the reason it's painful now might simply be that nobody ran into these issues before. You might want to try and convey your frustration to Agda experts, who might perhaps have run into this kind of question and come up with ways of solving it. However this might not help, even if they've seen analogous problems before -- for example the Coq solution which worked for groups didn't work for rings, and we needed something else.</p>",
        "id": 482003544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731433553
    },
    {
        "content": "<p>(Anyone who wants to relive my pain can see the original thread <a href=\"#narrow/channel/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/188403964\">here</a> )</p>",
        "id": 482003929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731433675
    },
    {
        "content": "<p>I think what Kevin is saying is really important. Often there are many ways to state something, and most of them are really annoying to work with, and one if them is (almost) as natural as doing it on paper. Finding this natural way of doing things is really hard work.</p>\n<p>In analysis, I've not encountered much of these problems. One minor one is working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span>-functions. It is inconvenient to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Lp#doc\">docs#MeasureTheory.Lp</a>, because it is a quotient of maps up to a.e.-equality, and so properties like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(f + g)(x) = f(x) + g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> don't hold everywhere, only almost everywhere. It is much nicer to just work with functions directly, and require conditions on them almost everywhere.</p>\n<p>In differential geometry, working with manifolds (in explicit charts) is still quite painful, which suggest to me that we haven't found the best way to work with them yet. Or maybe we just need better automation to prove properties like \"this point lies in this chart\". <code>mfld_set_tac</code> is a tactic that tries to do this, but is quite limited.</p>",
        "id": 482007798,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1731434880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481974841\">said</a>:</p>\n<blockquote>\n<p>I'll give a little more detail on what might be special about category theory. </p>\n<p>On paper, category theory has a notion of \"evil,\" the primary example being categorical statements that involve equality between objects. The reason such statements are \"evil\" is that they often fail to be invariant under equivalence between categories.</p>\n<p>In Lean, it seems relatively easy to prove those \"evil\" statements that are true. But what can be more difficult is proving that two morphisms are equal because morphisms live in dependent types (over their domain and codomain objects) and if the objects are <em>provably</em> equal rather than <em>definitionally</em> equal, the morphisms belong to different types.</p>\n</blockquote>\n<p>I spent quite a lot of time doing category theory and topos theory in Lean a couple of years ago, and I agree there's frustrating when you can't prove those two morphisms are equal. But eventually I got into the habit of doing something like this: if A = A' and B = B', and I have morphisms f : A -&gt; B and g : A' -&gt; B', then where I'd informally write f = g, in Lean I'll say <code>f &gt;&gt; eqToHom _ = eqToHom _ &gt;&gt; g</code>, and now I have a nice commutative square. And this works pretty well, you can combine these pretty easily and (in my experience) everything came out quite nicely (when I get two eqToHom next to each other, they can combine, and if I thereby end up with <code>eqToHom (_ : A = A)</code> then by proof irrel it vanishes). But I can also imagine there's a distinction when you're in 1-category land like I was, and when you're in higher categories, so maybe my experience isn't transferrable to your context</p>",
        "id": 482012250,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731436520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/116395-maths/topic/challenges.20in.20the.20translation.20from.20a.20set.20proof.20to.20DTT.3F/near/481975120\">said</a>:</p>\n<blockquote>\n<p>maybe this is a third mode of proof construction: \"on paper\", \"in a proof assistant\", \"in your head\"</p>\n</blockquote>\n<p>(On this note, I've always viewed formalisation as not paper -&gt; proof assistant, but two distinct processes paper -&gt; head then head -&gt; proof assistant. And sometimes the second one goes quite a bit smoother if I intentionally leave a time gap between the two)</p>",
        "id": 482012467,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1731436597
    },
    {
        "content": "<p>What I've been doing in Lean is much more elementary than most of what is being discussed here.  In <a href=\"https://djvelleman.github.io/HTPIwL/\">How To Prove It with Lean</a>, I was writing for undergraduates who are learning to write proofs.  My goal was to use Lean as a tool to teach proof writing, not to teach Lean, so I used only the simplest tactics and the simplest definitions and theorems from Mathlib.</p>\n<p>One challenge I ran into was in the last chapter, which is on cardinality.  I wanted to be able to talk about cardinalities of <em>sets</em>, not types.  I could have converted sets to subtypes and then talked about bijections, but I didn't need subtypes anywhere else in the book, and I wasn't sure it was worth it to introduce them.  And using subtypes causes some awkwardness.  For example, one theorem I wanted to prove is that if a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> elements and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a \\in A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∖</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A \\setminus \\{a\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">}</span></span></span></span> has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> elements.  (I needed this for proofs about finite sets by induction on the number of elements in the set.)  Every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>∖</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">A \\setminus \\{a\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">}</span></span></span></span> is an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, but if you convert them to subtypes then the correspondence between them is more complicated.  I worried that, for my audience, those complications would just be a distraction.  In the end, I defined two sets to be equinumerous if there is a <em>relation</em> pairing up their elements one-to-one (no need for subtypes).  That made a few things harder--for example, to prove that \"equinumerous\" is a transitive relation, I couldn't just quote a theorem about the composition of bijections being a bijection.  But for the most part things worked out OK.</p>",
        "id": 482034185,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1731443603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span> I guess I'm not quite following your point; would you not use Set.ncard or Set.encard in such a situation?</p>",
        "id": 482034923,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1731443897
    },
    {
        "content": "<p>I was trying to develop the theory from scratch as an illustration for students, rather than using theorems in Mathlib.  Also, I was doing both finite and infinite cardinalities.</p>",
        "id": 482035879,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1731444353
    },
    {
        "content": "<p>(Thanks, Emily, for asking such a great question, and everyone for their interesting answers! Even having lived through it all, I really appreciated reading this recap.)</p>",
        "id": 482036794,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731444714
    }
]