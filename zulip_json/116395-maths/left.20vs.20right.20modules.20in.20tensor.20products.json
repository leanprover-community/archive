[
    {
        "content": "<p>Any opinions on changing <code>compatible_smul</code> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_tmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>in the long run, given we make sure that <code>op r</code> properly simplifies to <code>r</code> in the case of commutative rings?</p>",
        "id": 259727782,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635596246
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.compatible_smul\">docs#tensor_product.compatible_smul</a> for reference</p>",
        "id": 259730014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599231
    },
    {
        "content": "<p>Presumably once we start thinking about tensor products of bimodules, we first need to change <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.eqv.of_smul\">docs#tensor_product.eqv.of_smul</a> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">of_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">eqv</span>\n    <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and have tensor products require <code>[module Rᵒᵖ M] [module R N]</code></p>",
        "id": 259730118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599377
    },
    {
        "content": "<p>Or do I have the convention backwards? It seems natural to me to put the scalar in the middle so that <code>(m &lt;• r) ⊗ₜ n = m ⊗ₜ[R] (r •&gt; n)</code> where <code>r : R</code>, but convention wins over my personal opinion of what is natural</p>",
        "id": 259730228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599480
    },
    {
        "content": "<p>Hmm, I think we have a problem here. In the bimodule world where <code>M</code> is an <code>S-R</code> bimodule and <code>N</code> is an <code>R-T</code> bimodule, we presumably want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span>\n<span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>       <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, the latter case matches the former case with <code>s = op t</code>, and while probably gives a propositionally equal action in the cases where typeclasses match, certainly does not give a definitionally equal one.</p>",
        "id": 259731253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635600648
    },
    {
        "content": "<p>I don't necessaily need bimodules, just the tensor product for modules on non-commutative rings, even if it doesn't bear an <code>R</code>-action itself</p>",
        "id": 259733947,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259730118\">said</a>:</p>\n<blockquote>\n<p>Presumably once we start thinking about tensor products of bimodules, we first need to change <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.eqv.of_smul\">docs#tensor_product.eqv.of_smul</a> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">of_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">eqv</span>\n    <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and have tensor products require <code>[module Rᵒᵖ M] [module R N]</code></p>\n</blockquote>\n<p>Yes, that's a change I also did locally</p>",
        "id": 259733961,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604282
    },
    {
        "content": "<p>The issue is that in the commutative case we have everything cluttered with <code>op</code> and <code>ᵒᵖ</code> then <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 259734109,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604407
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 259737851,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635609401
    },
    {
        "content": "<p>I think this issue is part of a bigger one: How do we reconcile commutative algebraic structures with their <code>op</code>s? Since <code>opposite</code> is irreducible we can't state <code>r = opposite.op r</code> without a cast... And we probably don't want to switch to <code>attribute [reducible] opposite</code> just if we have one commutative ring around..</p>",
        "id": 259748457,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635623440
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">comm_op</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">comm_op</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opposite.op</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">comm_op</span>\n</code></pre></div>\n<p>This seems to be a way?</p>",
        "id": 259749718,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635625378
    },
    {
        "content": "<p>That's solving the wrong problem</p>",
        "id": 259752346,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629165
    },
    {
        "content": "<p>You want lean to know that <code>op r • m = r • m</code></p>",
        "id": 259752353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629182
    },
    {
        "content": "<p>Rewriting <code>op r</code> to <code>r</code> just makes things worse, because your statement was originally</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">opposite.has_scalar</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>but your lemma turns it into the very wrong</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">opposite.has_scalar</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>which is using <code>R</code>, but the action from <code>opposite R</code></p>",
        "id": 259752433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629300
    },
    {
        "content": "<p>We need a typeclass that says the left and right actions are the same</p>",
        "id": 259752437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629313
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n<li><code>is_symmetric_smul R (prod A B)</code> when <code>is_symmetric_smul R A</code> and <code>is_symmetric_smul R B</code></li>\n<li><code>pi</code></li>\n<li><code>ulift</code></li>\n<li>...</li>\n<li>probably most of the things we currently have <code>has_scalar</code> instances for.</li>\n</ul>",
        "id": 259752553,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629506
    },
    {
        "content": "<p>Do you think it's still reasonable to have both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul_op</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_tmul_op</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_tmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>with <code>is_symmetric_smul</code> present?</p>",
        "id": 259778794,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635672205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259752553\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n</ul>\n</blockquote>\n<p>You mean what we need is the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>But then at this point we do need a (low priority? local?) instance for<code>has_scalar (opposite R) α</code></p>",
        "id": 259782218,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635677887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259752553\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n</ul>\n</blockquote>\n<p>You mean what we need is the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>But then at this point we do need a (low priority? local? we want to keep the option of having a right action that's different from the left action, even if <code>R</code> is commutative, right?) instance for<code>has_scalar (opposite R) α</code></p>",
        "id": 259782241,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635677952
    },
    {
        "content": "<p>I'm not sure we need both, I'd focus on adding the first one and then reassess</p>",
        "id": 259782716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678616
    },
    {
        "content": "<p>The <code>is_symmetric_smul R α</code> instance you suggest doesn't type check, there's no <code>has_scalar Rᵒᵖ α</code> for it to be about</p>",
        "id": 259782737,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678668
    },
    {
        "content": "<p>Which is why I said you only want the <code>R R</code> instance</p>",
        "id": 259782740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259782737\">said</a>:</p>\n<blockquote>\n<p>The <code>is_symmetric_smul R α</code> instance you suggest doesn't type check, there's no <code>has_scalar Rᵒᵖ α</code> for it to be about</p>\n</blockquote>\n<p>Yes, an instance for <code>has_scalar Rᵒᵖ α</code> given <code>has_scalar R α</code> what I suggested adding...</p>",
        "id": 259782966,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635679049
    },
    {
        "content": "<p>Oh, we do not need that instance</p>",
        "id": 259783051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679202
    },
    {
        "content": "<p><code>has_scalar Rᵒᵖ R</code> is enough, and we already have that</p>",
        "id": 259783091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679227
    },
    {
        "content": "<p>For instance, <code>has_scalar Rᵒᵖ (fin 3 → R)</code> can be found today via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 259783101,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259733947\">said</a>:</p>\n<blockquote>\n<p>I don't necessaily need bimodules, just the tensor product for modules on non-commutative rings, even if it doesn't bear an <code>R</code>-action itself</p>\n</blockquote>\n<p>Right, just like for linear maps. Even when the scalars are non-commuative we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.add_comm_monoid\">docs#linear_map.add_comm_monoid</a> but we need some form of commutativity for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.module\">docs#linear_map.module</a></p>",
        "id": 259783353,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1635679654
    },
    {
        "content": "<p>I haven't studied this thread carefully enough to understand your objectives beyond noting you want tensor product with non-commutative scalars (which I too would love to have) but this old thread of mine might also be food for thought:<br>\n<a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a></p>",
        "id": 259783472,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1635679844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783091\">said</a>:</p>\n<blockquote>\n<p><code>has_scalar Rᵒᵖ R</code> is enough, and we already have that</p>\n</blockquote>\n<p>I think I don't quite get the connection yet. Does this involve defining <code>op r • m</code> by <code>(op r • (1 : R)) • m</code>?</p>",
        "id": 259783526,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635679968
    },
    {
        "content": "<p>No, what I said above doesn't; but we can use that to almost get away without <code>is_symmetric_smul</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.opposites</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.prod</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">comm_semigroup.op_is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">opposite.rec</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">mul_right_comm</span> <span class=\"n\">b</span> <span class=\"n\">a'</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- this works around a typeclass bug in pi types</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comm_monoid.op_is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">comm_semigroup.op_is_scalar_tower</span>\n\n<span class=\"c1\">-- we were able to prove this without `is_symmetric_smul`</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_assoc</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"c1\">-- needs the workaround above</span>\n</code></pre></div>\n<p>we still need it if we want to talk about actions by non-monoids</p>",
        "id": 259783586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680099
    },
    {
        "content": "<blockquote>\n<p>I think I don't quite get the connection yet</p>\n</blockquote>\n<p>Can you give me an example of something that doesn't have a right action today, but should?</p>",
        "id": 259783599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680124
    },
    {
        "content": "<p>My claim is that the instance you suggest would just conflict with ones we already have, and there's no situation that you need it anyway</p>",
        "id": 259783603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783599\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think I don't quite get the connection yet</p>\n</blockquote>\n<p>Can you give me an example of something that doesn't have a right action today, but should?</p>\n</blockquote>\n<p>No I was just saying that I don't quite understand yet how the <code>has_scalar Rᵒᵖ R</code> instance actually helps making sense of <code>op r • m</code></p>",
        "id": 259783679,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680276
    },
    {
        "content": "<p>Because for almost every choice of <code>m</code> you make, there's already an action<code>has_scalar Rᵒᵖ M</code> defined in terms of <code>has_scalar Rᵒᵖ R</code></p>",
        "id": 259783723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680311
    },
    {
        "content": "<p>Where is it defined?</p>",
        "id": 259783733,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680366
    },
    {
        "content": "<p>In the same place as <code>has_scalar R M</code></p>",
        "id": 259783744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680389
    },
    {
        "content": "<p>The location of which depends on your choice of <code>M</code>. See for instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar\">docs#prod.has_scalar</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 259783746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680394
    },
    {
        "content": "<p>I'm completely lost.</p>",
        "id": 259783840,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680533
    },
    {
        "content": "<p>Pick a concrete example of R and M and I can show you</p>",
        "id": 259783847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680553
    },
    {
        "content": "<p>What do you mean by concrete? I want to <code>M</code> to be an arbitrary <code>R</code>-module</p>",
        "id": 259784082,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680785
    },
    {
        "content": "<p>I just don't get what <code>has_scalar Rᵒᵖ R</code> has to do with this if we don't have a full <code>scalar_tower Rᵒᵖ R M</code></p>",
        "id": 259784092,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680862
    },
    {
        "content": "<p>By concrete I mean <code>M = R × R</code>, <code>M = polynomial R</code> etc. I don't understand the question you're asking</p>",
        "id": 259784214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681084
    },
    {
        "content": "<p>Under the original proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">comm_semigroup.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">prod.ext</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">pi.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- hack that hopefully lean4 doesn't need</span>\n<span class=\"kd\">instance</span> <span class=\"n\">function.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">pi.is_symmetric_smul</span>\n</code></pre></div>\n<p>Any lemma about a symmetric bimodule would be stated as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">some_lemma</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 259784279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681178
    },
    {
        "content": "<p>You don't need to worry about where <code>module Rᵒᵖ M</code> comes from, that's the caller's problem</p>",
        "id": 259784292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681236
    },
    {
        "content": "<p>And the caller either:</p>\n<ol>\n<li>Is working with a concrete type, and so has the instance available</li>\n<li>Is working on a variable type, so passes the obligation on to <em>their</em> caller</li>\n</ol>",
        "id": 259784338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681278
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 259784346,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681299
    },
    {
        "content": "<p>I thought you meant that in order to have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>instead of adding an argument <code>has_scalar Rᵒᵖ α</code>, an argument <code>has_scalar Rᵒᵖ R</code> would be enough.</p>",
        "id": 259784411,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681449
    },
    {
        "content": "<p>But I guess you said we shouldn't have that instance at all? So everyone using tensor products as before would have to supply the <code>is_symmetric_smul</code>?</p>",
        "id": 259784483,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681595
    },
    {
        "content": "<p>You don't need <code>is_symmetric_smul</code> to use <code>tensor_product</code>; only the lemmas that require it</p>",
        "id": 259784605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681674
    },
    {
        "content": "<p>Okay, I guess now I get it. I'll see how much need for refactoring this causes outside of <code>linear_algebra.tensor_product</code>...</p>",
        "id": 259784651,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681726
    },
    {
        "content": "<p>Unfortunately there's <a href=\"#narrow/stream/113488-general/topic/instance.20lookup.20on.20function.20types/near/259784151\">a nasty typeclass issue</a> that looks like it makes both <code>is_symmetric_smul</code> and <code>[is_scalar_tower Rᵒᵖ R M]</code> <del>non-viable</del> quite annoying (until lean4)</p>",
        "id": 259784728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681908
    },
    {
        "content": "<p>I edited the message above with some <code>is_symmetric_smul</code> instances to get you started</p>",
        "id": 259784793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635682017
    },
    {
        "content": "<p>Thanks for all the help!</p>",
        "id": 259843662,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635759942
    },
    {
        "content": "<p>One thing that's not obvious to me is how to fix the following: The current construction of <code>compatible_smul.is_scalar_tower</code> now needs the following instance to go through:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">has_scalar_op_op</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r'</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">opposite.unop</span> <span class=\"n\">r'</span> <span class=\"bp\">•</span> <span class=\"n\">opposite.unop</span> <span class=\"n\">r</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>It fails if the instance of <code>has_scalar R'ᵒᵖ Rᵒᵖ</code> is anything other than this, because we need <code>op (r • b) = op r • op b</code>. But then,  <code>compatible_smul.is_scalar_tower</code> doesn't generalise to <code>compatible_smul R R M N</code> anymore because <code>mul_action.is_scalar_tower.left</code> uses an instance of <code>has_scalar Rᵒᵖ Rᵒᵖ</code> which is not defeq to <code>has_scalar_op_op</code>. I solved this by just adding a manual <code>compatible_smul.self : compatible_smul R R M N</code>, but the previous construction was obviously a bit nicer...</p>",
        "id": 259844105,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635760256
    },
    {
        "content": "<p>Your <code>has_scalar_op_op</code> instance looks dangerous to me</p>",
        "id": 259857909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635769956
    },
    {
        "content": "<p>Well it's needed to make sense of <code>is_scalar_tower R'ᵒᵖ Rᵒᵖ N</code> in this context. But maybe we should keep it local?</p>",
        "id": 259861521,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635772403
    },
    {
        "content": "<p>My hunch is that you probably should take <code>[has_scalar R'ᵒᵖ R ]</code> as an argument there too; and if you need it to satisfy <code>op (r • b) = op r • op b</code>, then work out a way to express that with typeclasses</p>",
        "id": 259882663,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635782701
    },
    {
        "content": "<p>Adding <code>compatible_smul.self</code> seems like a much more conservative bet than adding your instance</p>",
        "id": 259882826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635782770
    },
    {
        "content": "<blockquote>\n<p>then work out a way to express that with typeclasses</p>\n</blockquote>\n<p>Here's that way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- you need this instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">unop_injective</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">r</span> <span class=\"n\">m.unop</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">op</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">m</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 259883823,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635783237
    },
    {
        "content": "<p>Perhaps it's worth pointing out the difference between your \"add an instance\" and my \"add an instance\"; you're adding data instances which can introduce diamonds and incompatible actions, my instances are only proofs, so can't introduce these things.</p>",
        "id": 259884025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635783341
    },
    {
        "content": "<p>That's a neat idea.</p>",
        "id": 259890542,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635786080
    },
    {
        "content": "<p>It does away with the need for the double-op instance. I doesn't solve the issue of needing a separate <code>compatible_smul.self : compatible_smul R R M N</code>, though since that would require <code>is_symmetric_smul R R</code> which sounds like a bad idea for non-commutative rings</p>",
        "id": 259891672,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635786590
    },
    {
        "content": "<p><code>is_symmetric_smul R R</code> isn't true on non-commutative rings</p>",
        "id": 259898913,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790202
    },
    {
        "content": "<p>And I don't think <code>compatible_smul R R M N</code> is either, although I don't know what your new definition of <code>compatible_smul</code> is</p>",
        "id": 259899030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790241
    },
    {
        "content": "<p>Do you have a branch you're working on this in?</p>",
        "id": 259899601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790531
    },
    {
        "content": "<p>Not yet, I'll push it later on</p>",
        "id": 259904007,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635792510
    },
    {
        "content": "<p>I pushed my state of things <a href=\"https://github.com/javra/mathlib/tree/noncomm_tensor_product\">here</a>, but there's so much left do be done, and I haven't even started to check where things break in other files</p>",
        "id": 260111791,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635934109
    },
    {
        "content": "<p>Ah, I just noticed it's more canonical to assume that <code>R</code> operates on the right on <code>M</code> and not on <code>N</code>, so I made some bad choices here...</p>",
        "id": 260262759,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636029197
    },
    {
        "content": "<p>I thought that was what you had?</p>",
        "id": 260271828,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636033923
    },
    {
        "content": "<p>Ah nevermind, you fixed it in <a href=\"https://github.com/javra/mathlib/commit/efea1e30f00a9237590e134bb029ee2d67a5d75b\">https://github.com/javra/mathlib/commit/efea1e30f00a9237590e134bb029ee2d67a5d75b</a></p>",
        "id": 260271939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636033970
    },
    {
        "content": "<p>Now for <code>add_comm_monoid</code> we'd need a right action of <code>ℕ</code> on <code>M</code>, that doesen't seems unnatural either <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span></p>",
        "id": 260279337,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636037094
    },
    {
        "content": "<p>Will this create yet another diamond in case <code>M = nat</code>?</p>",
        "id": 260317672,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052110
    },
    {
        "content": "<p>Because we already have an action of <code>opposite nat</code> on <code>nat</code>.</p>",
        "id": 260317697,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052123
    },
    {
        "content": "<p>I wonder if there is a way to deal with these diamonds without adding lots of fields to <code>monoid</code>.</p>",
        "id": 260318544,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/260317672\">said</a>:</p>\n<blockquote>\n<p>Will this create yet another diamond in case <code>M = nat</code>?</p>\n</blockquote>\n<p>I think they both reduce to the inverted multiplication, so should be definitionally equal</p>",
        "id": 260319443,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636052824
    },
    {
        "content": "<p>How do you define the new action?</p>",
        "id": 260319924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636053098
    },
    {
        "content": "<p>Isn't it just <code>nsmul</code>?</p>",
        "id": 260319939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636053107
    },
    {
        "content": "<p>Good question. That _does_ yield the wrong operation on <code>M = nat</code>...</p>",
        "id": 260320387,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636053329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259731253\">said</a>:</p>\n<blockquote>\n<p>Hmm, I think we have a problem here. In the bimodule world where <code>M</code> is an <code>S-R</code> bimodule and <code>N</code> is an <code>R-T</code> bimodule, we presumably want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span>\n<span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>       <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, the latter case matches the former case with <code>s = op t</code>, and while probably gives a propositionally equal action in the cases where typeclasses match, certainly does not give a definitionally equal one.</p>\n</blockquote>\n<p>I think my message above was describing a more general case of this diamond?</p>\n<p>Edit: nevermind, but this is another diamond to worry about.</p>",
        "id": 260321763,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636054042
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/right.20actions.20by.20nat\">#general &gt; right actions by nat</a></p>",
        "id": 260325187,
        "sender_full_name": "Notification Bot",
        "timestamp": 1636055656
    },
    {
        "content": "<p>(to clarify, just the nat diamond bit was)</p>",
        "id": 260327299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636056566
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 260327536,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636056672
    },
    {
        "content": "<p>It's still super hard to adapt that file. The annoying thing is that the most general conditions for the tensor product having a left action and having a right action are so asymmetric. There's one of the actions on <code>M</code> and <code>N</code> thats requirted to be a <code>distrib_mul_action</code> while the other one can be an arbitrary <code>has_scalar</code>, depending on whether it comes from <code>tensor_product.left_has_scalar</code> or from <code>tensor_product.right_has_scalar</code>, and these are of course not separated well in the current state of the file <span aria-label=\"tired\" class=\"emoji emoji-1f614\" role=\"img\" title=\"tired\">:tired:</span></p>",
        "id": 260327728,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636056749
    },
    {
        "content": "<p>Currently thinking of just splitting the files. I had to separate <code>linear_algebra.tensor_product</code> and <code>linear_algebra.tensor_product_basis</code> a while ago anyway due to cyclic dependencies, might as well make a folder with a file for the defn, the left module structure coming from the left module <code>N</code>, the right module structure coming from the right module <code>M</code></p>",
        "id": 260340068,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636062928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/260327728\">said</a>:</p>\n<blockquote>\n<p>It's still super hard to adapt that file. The annoying thing is that the most general conditions for the tensor product having a left action and having a right action are so asymmetric. There's one of the actions on <code>M</code> and <code>N</code> thats requirted to be a <code>distrib_mul_action</code> while the other one can be an arbitrary <code>has_scalar</code>, depending on whether it comes from <code>tensor_product.left_has_scalar</code> or from <code>tensor_product.right_has_scalar</code>, and these are of course not separated well in the current state of the file <span aria-label=\"tired\" class=\"emoji emoji-1f614\" role=\"img\" title=\"tired\">:tired:</span></p>\n</blockquote>\n<p>Oh right, that's exactly the diamond you were talking about, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 260382404,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636104756
    },
    {
        "content": "<p>The overlap <em>could</em> be solved in the manner we solved additive vs multiplicative operations. Stating lemmas for <code>smul</code> explicitely and transfer them automatically to lemmas about <code>rsmul</code>...</p>",
        "id": 260382605,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636104879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783051\">said</a>:</p>\n<blockquote>\n<p>Oh, we do not need that instance</p>\n</blockquote>\n<p>Are you sure about that? I still think in the commutative algebra world such an instance should be at least inferrable since user will not want to worry about which side of a module a commutative ring acts on?</p>",
        "id": 260775165,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636451725
    },
    {
        "content": "<p>Yes, I'm pretty sure, because having that instance would create diamonds. Can you give an <code>example</code> of a case you're thinking of?</p>",
        "id": 260781428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636455567
    },
    {
        "content": "<p>I meant from a user point of view where the current approach would be to require <code>[has_scalar R M] [has_scalar (opposite R) M] [is_symmetric_smul R M]</code> every time, which does seem unwieldy. This would e.g. pop up every time one wants <code>(r • m) ⊗ₜ n = m ⊗ₜ (r • m)</code> instead of <code>(m &lt;• r) ⊗ₜ n = m ⊗ₜ (r • m)</code>. I'm not depp into commutative algebra, but I think that's what they want?</p>",
        "id": 260782821,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636456457
    },
    {
        "content": "<p>Yes, they would indeed need to do that when working over an arbitrary R and M</p>",
        "id": 260786404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636458598
    },
    {
        "content": "<p>Maybe collecting the three instances into <code>has_symmetric_scalar R M</code> could be an option. It's just a use case that pops up a lot in mathlib</p>",
        "id": 260790658,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636461143
    },
    {
        "content": "<p>That would be super annoying, because you'd then need <code>has_symmetric_mul_action</code>, <code>has_symmetric_distrib_mul_action</code>, <code>has_symmetric_module</code>, ...</p>",
        "id": 260791088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636461375
    },
    {
        "content": "<p>Hm, you're right</p>",
        "id": 260791550,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636461615
    },
    {
        "content": "<p>Maybe all that users really care about is <code>has_symmetric_module</code>, but if we had that we'd still end up stating the lemmas in mathlib about <code>is_symmetric_smul</code> to be maximally general</p>",
        "id": 260793960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636462963
    },
    {
        "content": "<p>This is probably quite a useful instance, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">is_scalar_tower.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 260982849,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636547945
    },
    {
        "content": "<p>Do you think it's okay for users who use right scalars to be confronted with the fact that if they want to prove something about all <code>r : Rᵒᵖ</code>, they'll be confronted with left scalars instead until they rewrite along <code>←op_unop</code>?</p>",
        "id": 260983091,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636548083
    },
    {
        "content": "<p>I'm not sure; is it also true in the other direction?</p>",
        "id": 261003257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636557049
    },
    {
        "content": "<p>Only in the commutative case</p>",
        "id": 261017439,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636562768
    },
    {
        "content": "<p>Are all the other assumptions equally strong, or can some be weakened?</p>",
        "id": 261017548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636562819
    },
    {
        "content": "<p>I think we need them all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">is_symmetric_smul.is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r'</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">unop_smul_eq_smul</span> <span class=\"n\">r'</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">smul_smul</span><span class=\"o\">],</span>\n                <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 261018373,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636563143
    },
    {
        "content": "<p>Then it sounds like the first instance is harmless, but I'm not sure how useful it is</p>",
        "id": 261019919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636563686
    },
    {
        "content": "<p>It wasn't harmless <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 261144462,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643100
    },
    {
        "content": "<p>I'm slowly making progress. One thing I'm not too happy about is that <code>tensor_product.left_has_scalar</code> in the commutative case automatically induces an action of <code>opposite R</code> (a right action on the tensor product by a right action on <code>M</code>), while it only induces a left action if <code>M</code> is really a bimodule. I think that's a bit confusing.</p>",
        "id": 261145160,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643443
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative, do people still want asymmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodules?</p>",
        "id": 261145432,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643579
    },
    {
        "content": "<p>Probably not, but remember you need to not create instance diamonds in places where you don't know if R is commutative</p>",
        "id": 261145772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636643721
    },
    {
        "content": "<p>Well, this is about deleting instances, not adding some...</p>",
        "id": 261147176,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644380
    },
    {
        "content": "<p>Which instance are you considering deleting?</p>",
        "id": 261148224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636644891
    },
    {
        "content": "<p><code>smul_comm_class R R M</code> for commutative <code>R</code>, that would solve the issue...</p>",
        "id": 261148310,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644929
    },
    {
        "content": "<p>...but probably cause other issues</p>",
        "id": 261148430,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644973
    },
    {
        "content": "<p>The alternative is to just make all the constructions in the commutative case depend on an instance <code>[is_symmetric_smul R M]</code>, which prevents us from ending up in the confusing situation I described above</p>",
        "id": 261148665,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636645090
    },
    {
        "content": "<p>Regarding the question whether one wants asymmetric actions for R-R-bimodules even if R is commutative, definitely yes for some people. A typical example I'm not an expert on, but have seen is if R is a field of characteristic p and the right action is given by twisting with the Frobenius <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> while the left action is regular. Another example I am more familiar with is to consider k-linear categories with finitely many objects as monoid objects in the category of L-L-bimodules where L is a product of fields, as many as objects in the category. Also the action here is not central.</p>",
        "id": 261162994,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1636651929
    },
    {
        "content": "<p>Okay, I now did some changes based on the following situation:</p>\n<ul>\n<li>In some situations, even when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative, we want a left action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a potentially asymmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule.</li>\n<li>In other cases we want to have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r (m \\otimes n) = (rm) \\otimes n (= (mr) \\otimes n) = m \\otimes (rn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, this is encapsulated in the fact that we have an instance of <code>is_symmetric_smul</code> on the tensor product whenever we have one on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</li>\n</ul>\n<p>I do think this accomodates all users, but since some constructions might need a lot of <code>is_symmetric_smul</code> assumptions (one for every factor that appears on the left side of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span>.<br>\nWhat's your thoughts on this?</p>",
        "id": 261236482,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636714262
    },
    {
        "content": "<p>So the current state is <a href=\"https://github.com/javra/mathlib/tree/noncomm_tensor_product/src/linear_algebra/tensor_product\">this</a>. There's just one lemma missing from the old file, which requires me to come up with a good solution on how to derive <code>has_scalar (opposite (units S)) M</code> from <code>has_scalar (opposite S) M</code>(probably can't avoid to do it manually)...</p>\n<p>Do you think I should PR this already to get more people to look at it? I'm afraid of already putting too much time in this...</p>",
        "id": 261620446,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> I see you're working from a fork. Are you aware that you can request permission to create branches on the Mathlib repo and save yourself the overhead of managing a fork?</p>",
        "id": 261620641,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058182
    },
    {
        "content": "<p>Glancing at your work, I see it already comprises over 1000 lines. The code looks great so I'm sure we'll be able to get this merged but this is a large amount of code so the sooner you start PRing the better. For example the results about bases of tensor products (which I actually wanted for something else recently) look like a PR on their own.</p>",
        "id": 261621034,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058435
    },
    {
        "content": "<p>Yes, I do have the permission</p>",
        "id": 261621037,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058436
    },
    {
        "content": "<p>OK cool, if you prefer a fork then that's fine too!</p>",
        "id": 261621053,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261621034\">said</a>:</p>\n<blockquote>\n<p>Glancing at your work, I see it already comprises over 1000 lines. The code looks great so I'm sure we'll be able to get this merged but this is a large amount of code so the sooner you start PRing the better. For example the results about bases of tensor products (which I actually wanted for something else recently) look like a PR on their own.</p>\n</blockquote>\n<p>None of this is new, it's just the old <code>linear_algebra.tensor_product</code> and <code>linear_algebra.tensor_product_basis</code> reorganized and partly generalised to non-commutative rings. Some proofs had to be adapted by most of it is just copied over.</p>",
        "id": 261621172,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058519
    },
    {
        "content": "<p>Ah OK I see. I couldn't easily figure out how to get a diff and made the wrong assumption.</p>",
        "id": 261621275,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058602
    },
    {
        "content": "<p>Incidentally since we're finally talking seriously about tensor products over non-commutative rings, is anyone thinking about the corresponding results for linear maps?</p>",
        "id": 261621370,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058640
    },
    {
        "content": "<p>E.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails because `R` not commutative!</span>\n</code></pre></div>",
        "id": 261621400,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058652
    },
    {
        "content": "<p>I wondered if this would come up as part of the tensor product work. Did it?</p>",
        "id": 261621444,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058681
    },
    {
        "content": "<p>The fact that these are missing actually prevents some generalisations!</p>",
        "id": 261621903,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058972
    },
    {
        "content": "<p>The current implementation doesn't really depend on <code>R</code> being commutative, but having a commutative action on <code>N</code>.</p>",
        "id": 261622764,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637059503
    },
    {
        "content": "<p>Yes but if <code>R</code> is not commutative the definition will not provide a linear map.</p>",
        "id": 261622833,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637059548
    },
    {
        "content": "<p>Oh sorry, misread your remark.</p>",
        "id": 261622854,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637059560
    },
    {
        "content": "<p>Made <a href=\"https://github.com/leanprover-community/mathlib/pull/10345\">a pull request</a>.</p>",
        "id": 261623472,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637059930
    },
    {
        "content": "<p>Mathematically, if <code>R</code>, <code>S</code>, <code>T</code> are rings, <code>M</code> is an <code>(R, S)</code>-bimodule, and <code>N</code> is an <code>(R, T)</code>-bimodule then we can speak of <code>R</code>-linear maps <code>M → N</code> and these are an <code>(S, T)</code>-bimodule. I'd love to have this in Mathlib.</p>",
        "id": 261623550,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261623472\">said</a>:</p>\n<blockquote>\n<p>Made <a href=\"https://github.com/leanprover-community/mathlib/pull/10345\">a pull request</a>.</p>\n</blockquote>\n<p>Thanks! I'll review this evening.</p>",
        "id": 261623648,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261623550\">said</a>:</p>\n<blockquote>\n<p>Mathematically, if <code>R</code>, <code>S</code>, <code>T</code> are rings, <code>M</code> is an <code>(R, S)</code>-bimodule, and <code>N</code> is an <code>(R, T)</code>-bimodule then we can speak of <code>R</code>-linear maps <code>M → N</code> and these are an <code>(S, T)</code>-bimodule. I'd love to have this in Mathlib.</p>\n</blockquote>\n<p>Isn't this <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/module/linear_map.lean#L607\">here</a>?</p>",
        "id": 261623855,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060201
    },
    {
        "content": "<p>Ah, nevermind, that's weaker than what you said.</p>",
        "id": 261623959,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060266
    },
    {
        "content": "<p>I'm definitely a bit of out date as I haven't touched this stuff in ages. We might be much closer to this than I realise.</p>",
        "id": 261624081,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060320
    },
    {
        "content": "<p>Staring at it a bit more it does use the left action on both the domain and the codomain, which prevents your generalisation, it's roughly the same problem as with the tensor product.</p>",
        "id": 261624520,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060513
    },
    {
        "content": "<p>(Which I guess shouldn't be surprising with them being adjoints and all...)</p>",
        "id": 261624598,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060527
    },
    {
        "content": "<p>I suspected this might be a prerequisite for tensor products but perhaps not.</p>",
        "id": 261624728,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060594
    },
    {
        "content": "<p>I guess it's a prerequesite from freeing the lemmas which mix tensor products and linear maps from the commutativity presumption, which I haven't done. Maybe it should be done and both go in the same huge PR <span aria-label=\"scared\" class=\"emoji emoji-1f628\" role=\"img\" title=\"scared\">:scared:</span></p>",
        "id": 261624980,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060699
    },
    {
        "content": "<p>Huge PRs should be a last resort. I've often been surprised at how easy it is to package up something like this into smaller pieces.</p>",
        "id": 261625256,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060824
    },
    {
        "content": "<p>Btw this generalisation is well worth fighting for and very valuable. I suspect many people here are quite excited about the theory of bimodules coming to life.</p>",
        "id": 261625353,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060866
    },
    {
        "content": "<p>Thanks for the encouragement! this actually came out of me wanting to teach Lean to some non-commutative algebraists, and I was a bit suprised about how much of mathlib relies on commutativity.</p>",
        "id": 261626255,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637061310
    },
    {
        "content": "<p>In order to fix the files depending on the tensor product: Is there a way to get a list of all files that depend on a certain file by transitivity?</p>",
        "id": 261627874,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637062177
    },
    {
        "content": "<p>This is probably possible with <a href=\"https://github.com/leanprover-community/leancrawler\">https://github.com/leanprover-community/leancrawler</a> but I think you'll probably end up with a far bigger list than you want because if one little lemma in a file low down in the dependency tree uses tensor products you'll get a huge chunk of Mathlib.</p>",
        "id": 261628226,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637062386
    },
    {
        "content": "<p>You can also use leanproject for this and run some tools on the output of <a href=\"https://leanprover-community.github.io/leanproject.html#import-graphs\">https://leanprover-community.github.io/leanproject.html#import-graphs</a></p>",
        "id": 261628606,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637062653
    },
    {
        "content": "<p>If you tell me a specific list of filenames I can do this for you too fairly easily, me and Johan have some WIP tools that will help with this, and I'm happy to run them</p>",
        "id": 261628882,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637062836
    },
    {
        "content": "<p>It's just <code>linear_algebra.tensor_product</code> on the current master branch</p>",
        "id": 261633894,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637066206
    },
    {
        "content": "<p>I think that list is way too big to do anything useful with, there are 590 files there</p>",
        "id": 261634425,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066547
    },
    {
        "content": "<p>I can't even paste it into a zulip message</p>",
        "id": 261634440,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066559
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/pc9IqOI8iJ5ZTNUvYzxpjraj/tensorlist\">tensorlist</a></p>",
        "id": 261634539,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066626
    },
    {
        "content": "<p>Probably you're best off just letting <code>lean --make src</code> or CI tell you what breaks</p>",
        "id": 261634621,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066669
    },
    {
        "content": "<p>That's what would have been my plan otherwise. I guess it does trigger a lot of big recompilations to just start at at random spot, though. Maybe the best heuristic is to start with the direct descendants and hope that most of the indirect imports don't break.</p>",
        "id": 261635435,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637067132
    },
    {
        "content": "<p>Those are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">linear_algebra.direct_sum.tensor_product</span><span class=\"o\">,</span>\n <span class=\"n\">algebra.category.Module.monoidal</span><span class=\"o\">,</span>\n <span class=\"n\">topology.algebra.affine</span><span class=\"o\">,</span>\n <span class=\"n\">linear_algebra.affine_space.affine_equiv</span><span class=\"o\">,</span>\n <span class=\"n\">algebra.algebra.bilinear</span><span class=\"o\">,</span>\n <span class=\"n\">topology.algebra.continuous_affine_map</span><span class=\"o\">,</span>\n <span class=\"n\">linear_algebra.multilinear.tensor_product</span>\n</code></pre></div>\n<p>I guess grep can also find this list though!</p>",
        "id": 261635726,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637067296
    },
    {
        "content": "<p>The mathlibs docs show them as well :)</p>",
        "id": 261635989,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637067416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261626255\">said</a>:</p>\n<blockquote>\n<p>Thanks for the encouragement! this actually came out of me wanting to teach Lean to some non-commutative algebraists, and I was a bit suprised about how much of mathlib relies on commutativity.</p>\n</blockquote>\n<p>Certain people wandering around on zulip, pretending they've never met a noncommutative ring...</p>",
        "id": 261702246,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637094575
    },
    {
        "content": "<p>One thing I noticed is that at many points it would be more elegant to separate the lemmas about commutative rings from the non-commutative ones, if e.g. instead of <code>semiring R</code> we would assume <code>comm_semigroup R</code> and <code>the_other_ring_axioms R</code> separately, with the drawback that this would make usage more verbose.<br>\n<span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> mentioned that in Lean 4 it should be possible to infer one of these from the other <strong>and vice versa</strong> which seems to make separating the assumptions more attractive...</p>",
        "id": 261706956,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637096879
    },
    {
        "content": "<p>Commutative ring theory has been one of the success stories of mathlib.</p>",
        "id": 261709445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098143
    },
    {
        "content": "<p>I wonder whether this would have been the case if we'd tried to take the noncommutative story into account at the time. Historically what happened was that very early on I was pushing for schemes, a story where we needed a lot of commutative ring stuff, and there was nobody arguing for the noncommutative case at the time so me and my minions just defined ideals of commutative rings and then prime ideals etc etc and just kept PRing stuff</p>",
        "id": 261709786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098320
    },
    {
        "content": "<p>It was pointed out that there would be trouble ahead but I could never get straight from the noncommutative people whether ideal was supposed to mean left ideal or bi-ideal so I just kept pushing the commutative story, and then other people showed up and joined in (Justus Springer, Devon Tuma, the Berkeley graduate students, others I've forgotten, and now the new crowd doing products of schemes) and the commutative story just kept growing</p>",
        "id": 261710097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098448
    },
    {
        "content": "<p>Kevin has a good point. I think a great way to build a good library is to build an extremely tall and pointy lopsided one, and then hope that people come along to stop it from falling over. :-)</p>",
        "id": 261711463,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099219
    },
    {
        "content": "<p>Happily in mathlib that happens.</p>",
        "id": 261711523,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099255
    },
    {
        "content": "<p>This happens only if the tower builders PR to mathlib... <span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span></p>",
        "id": 261711700,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637099358
    },
    {
        "content": "<p>I do genuinely feel guilty that this approach has caused trouble down the line, especially as I was warned that this would happen, but ultimately as Scott says we made some really tall stuff and that has had advantages because it got us noticed.</p>",
        "id": 261711714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637099367
    },
    {
        "content": "<p>(I wasn't even counting non-mathlib stuff as part of the tower. They are just ephemeral dreams. :-)</p>",
        "id": 261712061,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099537
    },
    {
        "content": "<p>I know, I was only trying to remind the perfectoid spaces projects authors that they should feel guilty.</p>",
        "id": 261712145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637099586
    },
    {
        "content": "<p>But I also feel very attacked with my two 5k lines branches.</p>",
        "id": 261712202,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637099618
    },
    {
        "content": "<p>Hopefully \"attacked\" in the most constructive and loving way. :-) Otherwise, sorry!</p>",
        "id": 261712404,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261710097\">said</a>:</p>\n<blockquote>\n<p>It was pointed out that there would be trouble ahead but I could never get straight from the noncommutative people whether ideal was supposed to mean left ideal or bi-ideal so I just kept pushing the commutative story, and then other people showed up and joined in (Justus Springer, Devon Tuma, the Berkeley graduate students, others I've forgotten, and now the new crowd doing products of schemes) and the commutative story just kept growing</p>\n</blockquote>\n<p>I will definitvely quiz additional non-commutative people on their customs :D</p>",
        "id": 261713251,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637100088
    },
    {
        "content": "<p>Oh thanks!</p>",
        "id": 261713482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637100202
    },
    {
        "content": "<p>I need to write a version of the bundled <code>Module</code> with a symmetric action (i.e. <code>Module</code> extended by an <code>is_symmetric_smul</code>). Any naming ideas?</p>",
        "id": 261794895,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637160859
    },
    {
        "content": "<p><code>SymmetricBiModule</code>?</p>",
        "id": 261797532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637161967
    },
    {
        "content": "<p>How about this: I shelve the current PR for now and do the following PRs separately and in order:</p>\n<ol>\n<li>Create a PR fixing the use of modules towards more compatibility with non-comm algebra, meaning replacing occurrences of <code>module R M</code> by a symmetric  <code>R</code>-<code>R</code>-action or (weaker) an <code>R</code>-<code>R</code>-bimodule wherever the non-comm generalisation would currently require it.</li>\n<li>Generalise the module structure on linear maps in the way <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> proposed it above.</li>\n<li>Generalise the tensor product (the current PR).</li>\n</ol>",
        "id": 261943834,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637249961
    },
    {
        "content": "<p>Will this mean that whenever an undergraduate wants to talk about a vector space they'll have to say a k-k-bimodule?</p>",
        "id": 261944352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637250157
    },
    {
        "content": "<p>This sounds like a very good plan to me except that I don't have a clear picture of what you have in mind for 1. Is there a simple example of such a fix?</p>",
        "id": 261944355,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250159
    },
    {
        "content": "<p>(Or rather of such a situation, requiring a fix.)</p>",
        "id": 261944379,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944352\">said</a>:</p>\n<blockquote>\n<p>Will this mean that whenever an undergraduate wants to talk about a vector space they'll have to say a k-k-bimodule?</p>\n</blockquote>\n<p>Would <code>symm_module k V</code> be acceptable?</p>",
        "id": 261944531,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250234
    },
    {
        "content": "<p>I presume we could have typeclass instances that provide <code>symm_module k V</code> from <code>module k V</code> + <code>comm_ring k</code>?</p>",
        "id": 261944766,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944379\">said</a>:</p>\n<blockquote>\n<p>(Or rather of such a situation, requiring a fix.)</p>\n</blockquote>\n<p>Well a good part of this entire thread is about such a situation: Every point where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r (m \\otimes n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> would mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(r m) \\otimes n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(m r) \\otimes n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, for example, and by exension any situation which requires the tensor product of two <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules to be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module.</p>",
        "id": 261945130,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944766\">said</a>:</p>\n<blockquote>\n<p>I presume we could have typeclass instances that provide <code>symm_module k V</code> from <code>module k V</code> + <code>comm_ring k</code>?</p>\n</blockquote>\n<p>It would be a great help in the usage if we could have such an instance. <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> above said, that we might have situations, even with commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, where the canonical left and right action don't coincide. So if at all, we'd make your proposed instance low priority?</p>",
        "id": 261945363,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261945363\">said</a>:</p>\n<blockquote>\n<p>It would be a great help in the usage if we could have such an instance. <span class=\"user-mention silent\" data-user-id=\"317890\">Julian Külshammer</span> above said, that we might have situations, even with commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, where the canonical left and right action don't coincide. So if at all, we'd make your proposed instance low priority?</p>\n</blockquote>\n<p>Hmm this is a good point. I'm less confident we could do this and it would indeed require some care with priorities.</p>",
        "id": 261945818,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250722
    },
    {
        "content": "<p>(It would make all the fixes needed for the current tensor product PR tremendously easier ;))</p>",
        "id": 261945930,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250770
    },
    {
        "content": "<p>(And the usage by people like <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s linear algebra students, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is commutative)</p>",
        "id": 261946531,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250985
    },
    {
        "content": "<p>Wait though, why won't we still have just plain left modules still?</p>",
        "id": 261946696,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251060
    },
    {
        "content": "<p>We will, we just don't have the instance of their tensor product or the space of linear maps being a plain left module.</p>",
        "id": 261947432,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251280
    },
    {
        "content": "<p>Right!</p>",
        "id": 261947452,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251286
    },
    {
        "content": "<p>OK so the problem to be solved should only be at the level of the instances and not at the types.</p>",
        "id": 261947606,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251337
    },
    {
        "content": "<p>I think this should work, subject to carefully-chosen instance priorities.</p>",
        "id": 261947850,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251431
    },
    {
        "content": "<p>The core of the problem is that we have two different conventions in the commutative and the non-commutative world, and the best way to solve the dilemma seems to be to say \"okay, let's assume the commutative case as a special situation of bimodules where needed\"</p>",
        "id": 261948061,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261947850\">said</a>:</p>\n<blockquote>\n<p>I think this should work, subject to carefully-chosen instance priorities.</p>\n</blockquote>\n<p>Do you mean the whole thing or the symmetry-instance in the commutative case?</p>",
        "id": 261948120,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251514
    },
    {
        "content": "<p>I meant the whole thing but of course it's hard to really be sure.</p>",
        "id": 261948199,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251548
    },
    {
        "content": "<p>Something concrete that needs to be made symmetric in order for the changes <code>linear_algebra.tensor_product</code> to go through is to have the <code>ℤ</code> action on a module to be symmetric, since otherwise <code>compatible_smul.int</code> and thus the <code>ℤ</code> action on the tensor product doesn't work.</p>",
        "id": 261948757,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251734
    },
    {
        "content": "<p>I'm not precisely sure what this means. If <code>m</code>, <code>n</code> are elements of additive groups <code>M</code>, <code>N</code>, then there are three different things that are all mathematically equal:</p>\n<ul>\n<li><code>m ⊗ₜ n + m ⊗ₜ n + ... + m ⊗ₜ n</code></li>\n<li><code>m ⊗ₜ (n + n + ... + n)</code></li>\n<li><code>(m + m + ... + m) ⊗ₜ n</code></li>\n</ul>\n<p>and at most two of these can be definitionally equal. Is this related to your remark?</p>",
        "id": 261949811,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637252141
    },
    {
        "content": "<p>Not entirely. The definitional equality will always be between the first and the third term. It's just that this equality comes out of the general statement of \"if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module\", so we need <code>ℤ</code> to play the role of both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and thus act symmetrically on the left and on the right of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 261950606,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252460
    },
    {
        "content": "<p>I haven't been following this discussion closely but it seems like this encoding using <code>opposite</code> is causing a lot of trouble, how about having <code>left_module</code>, <code>right_module</code> with separate operations, <code>bimodule</code>, and then <code>module R M</code> extends <code>bimodule R R M</code> with the \"symmetry\" compatibility law?</p>",
        "id": 261950851,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252559
    },
    {
        "content": "<p>this is a slightly weird definition in the commutative case but it's similar to \"a metric space has a metric and a topology that agree\"</p>",
        "id": 261951107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252650
    },
    {
        "content": "<p>The intuitive argument against that for me was that it is a way bigger change. But maybe that's not a good argument.</p>",
        "id": 261951441,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252781
    },
    {
        "content": "<p>The annoying thing then is: <code>module R M</code> and <code>left_module R M</code> are equivalent and differ only by notation. For which one do we proof all the lemmas about arbitrary modules?</p>",
        "id": 261951575,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252849
    },
    {
        "content": "<p><code>module</code> would be only for commutative rings</p>",
        "id": 261951710,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252899
    },
    {
        "content": "<p>That then complicates the cases <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> mentions above, where we do want differeent left and right actions even if the ring is commutative.</p>",
        "id": 261951909,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252988
    },
    {
        "content": "<p>I don't think so, they'd just be <code>bimodule</code>s.</p>",
        "id": 261952005,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637253013
    },
    {
        "content": "<p>I didn't really answer your question but my intended answer would be something like \"if you're doing commutative algebra, use <code>module</code> otherwise use <code>left_module</code>\"</p>",
        "id": 261952247,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253118
    },
    {
        "content": "<p>There's probably problems with this idea because I haven't thought this through at all</p>",
        "id": 261952447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952005\">said</a>:</p>\n<blockquote>\n<p>I don't think so, they'd just be <code>bimodule</code>s.</p>\n</blockquote>\n<p>But if both the left and the right action are somewhat canonical structures on some <code>M</code>, each will make <code>M</code> a module and to get the desired bimodule, we'll have to locally downgrade them to a <code>left_module</code> and a <code>right_module</code> respectively, right?</p>",
        "id": 261952567,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952447\">said</a>:</p>\n<blockquote>\n<p>There's probably problems with this idea because I haven't thought this through at all</p>\n</blockquote>\n<p>I think it would be the preferred idea if there was less overlap between non-commutative and commutative algebra. The overlap, I guess, is where things can go wrong.</p>",
        "id": 261952724,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952447\">said</a>:</p>\n<blockquote>\n<p>There's probably problems with this idea because I haven't thought this through at all</p>\n</blockquote>\n<p>I think it's very hard / impossible to foresee what problems any approach may encounter. Your suggestion has the very tempting sociological advantage that it's how most / all of us actually think about this.</p>",
        "id": 261952750,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637253336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261950851\">said</a>:</p>\n<blockquote>\n<p>I haven't been following this discussion closely but it seems like this encoding using <code>opposite</code> is causing a lot of trouble, how about having <code>left_module</code>, <code>right_module</code> with separate operations, <code>bimodule</code>, and then <code>module R M</code> extends <code>bimodule R R M</code> with the \"symmetry\" compatibility law?</p>\n</blockquote>\n<p>This raises the question on whether we'd need a transfer command to create <code>right_module</code> lemmas from left module lemmas?</p>",
        "id": 261952953,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253427
    },
    {
        "content": "<p>Maybe I should head over to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4\">#mathlib4</a> and ask whether <code>to_additive</code> has been ported already...</p>",
        "id": 261953425,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952005\">said</a>:</p>\n<blockquote>\n<p>I don't think so, they'd just be <code>bimodule</code>s.</p>\n</blockquote>\n<p>But if both the left and the right action are somewhat canonical structures on some <code>M</code>, each will make <code>M</code> a module and to get the desired bimodule, we'll have to locally downgrade them to a <code>left_module</code> and a <code>right_module</code> respectively, right?</p>\n</blockquote>\n<p>I don't think this one is a problem in practice, basically because the math situation is the same. You just won't define a <code>module</code> structure for one or both of the actions</p>",
        "id": 261953645,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261953645\">said</a>:</p>\n<blockquote>\n<p>I don't think this one is a problem in practice, basically because the math situation is the same. You just won't define a <code>module</code> structure for one or both of the actions</p>\n</blockquote>\n<p>If it's not already there. Maybe you first want to tread each action separately and happily use <code>module</code> before, in a more specialised setting, wanting to use both. But yes, there are ways around this and it might be a super rare occasion anyway.</p>",
        "id": 261954114,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253960
    },
    {
        "content": "<p><code>M</code> would be something you just created to describe this specific object, though.</p>",
        "id": 261954257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254013
    },
    {
        "content": "<p>So the instances aren't there</p>",
        "id": 261954277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254022
    },
    {
        "content": "<p>Like one construction is you have a complex vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and you let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> act by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> on the left and by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>z</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6306em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> on the right. You need a new name for this guy no matter what, and that's what gets the <code>bimodule</code> instance</p>",
        "id": 261954442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"317890\">Julian Külshammer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261162994\">said</a>:</p>\n<blockquote>\n<p>A typical example I'm not an expert on, but have seen is if R is a field of characteristic p and the right action is given by twisting with the Frobenius <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> while the left action is regular.</p>\n</blockquote>\n<p>Here maybe the left action is the one that's already a full module already, right?</p>",
        "id": 261954712,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637254190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261954442\">said</a>:</p>\n<blockquote>\n<p>Like one construction is you have a complex vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and you let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> act by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> on the left and by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>z</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6306em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> on the right. You need a new name for this guy no matter what, and that's what gets the <code>bimodule</code> instance</p>\n</blockquote>\n<p>Ah, okay, yes, changing the name of the carrier is a good solution.</p>",
        "id": 261954895,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637254243
    },
    {
        "content": "<p>On a slight tangent, am I the only one who thinks that <code>smul_comm_class</code> is a really bad name? We usually dont include \"class\" in the name of a type class?</p>",
        "id": 261973992,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262286
    },
    {
        "content": "<p>I agree. But the lemma is already called <code>smul_comm</code>. So we need another name for the class. Suggestions welcome!</p>",
        "id": 261974245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637262399
    },
    {
        "content": "<p>To be fair, I much more regret <code>is_scalar_tower</code>. I'd be happy to have them called <code>smul_comm_class</code> and <code>smul_assoc_class</code>. But if you want to get rid of the <code>_class</code> we can go for <code>is_smul_comm</code>/<code>is_comm_smul</code> and <code>is_smul_assoc</code>/<code>is_assoc_smul</code>.</p>",
        "id": 261974400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637262470
    },
    {
        "content": "<p>It follows the principle that Prop-valued classes should be called <code>is_</code>.</p>",
        "id": 261974851,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637262565
    },
    {
        "content": "<p>Isn't it <code>is_scalar_tower</code>?</p>",
        "id": 261975053,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262617
    },
    {
        "content": "<p>Since it's <code>has_scalar</code>, maybe <code>scalar_comm</code> could be a name for the class, while <code>smul_comm</code> is the lemma?</p>",
        "id": 261975161,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262670
    },
    {
        "content": "<p>I think we should rename <code>has_scalar</code> to <code>has_smul</code>. It's <code>has_add</code>, not <code>has_addition</code>.</p>",
        "id": 261976176,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637263095
    },
    {
        "content": "<p>I think \"rename all the typeclasses\" is reasonable, but probably deserves it's own thread</p>",
        "id": 261981655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265359
    },
    {
        "content": "<p>Also it will mean my scalar actions paper refers to things that no longer exist!</p>",
        "id": 261981750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265399
    },
    {
        "content": "<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>",
        "id": 261985036,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637266919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261981750\">said</a>:</p>\n<blockquote>\n<p>Also it will mean my scalar actions paper refers to things that no longer exist!</p>\n</blockquote>\n<p>Paper rot <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 261988077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637268330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261985036\">said</a>:</p>\n<blockquote>\n<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>\n</blockquote>\n<p>Sounds reasonable</p>",
        "id": 261988425,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637268499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261985036\">said</a>:</p>\n<blockquote>\n<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>\n</blockquote>\n<p>Before embarking on such a change, I'd recommend collecting the rationale for doing so into a chunk of prose and making a github issue about it.</p>",
        "id": 261989178,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637268860
    },
    {
        "content": "<p>(my current stance is mild opposition, mainly because I think we need a clear argument for it being useful before doubling the amount of work we do)</p>",
        "id": 261989328,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637268949
    },
    {
        "content": "<p>I'd also be tempted to go ahead and PR the <code>is_symmetric_smul</code> stuff, since I found a number of other places where I wanted it</p>",
        "id": 261989514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637269057
    },
    {
        "content": "<p>Did you read the thread above? What's your opinion in changing the current definition of <code>module</code>?</p>",
        "id": 261989745,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637269188
    },
    {
        "content": "<p>Are you actually suggesting changing <code>module</code>, or just renaming it to <code>left_module</code> and creating something new to replace <code>module</code>?</p>",
        "id": 261991473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637269957
    },
    {
        "content": "<p>Well it was <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>'s suggestion at first, but I tend to agree with it the more I think about where I'd otherwise need to plug in <code>is_symmetric_smul R M</code>. Make <code>module R M</code> mean symmetric <code>R</code>-<code>R</code>-bimodule, and derive an instance for it from <code>left_module R M</code> whenever <code>R</code> is commutative.</p>",
        "id": 261992399,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637270402
    },
    {
        "content": "<p>Surely we want to derive a <code>left_module</code> instance from <code>module</code> though too (<code>module.to_left_module</code>), since all bi-modules are unimodules? We can't have both directions.</p>",
        "id": 261996837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637272575
    },
    {
        "content": "<p>Ah, damn, you're right. Sounds pretty promising that in Lean 4 we will be able to have both...</p>",
        "id": 261997687,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272927
    },
    {
        "content": "<p>But then maybe we should stick to the previous plan and lazily add <code>is_symmetric_smul</code> where needed?</p>",
        "id": 261997752,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261989514\">said</a>:</p>\n<blockquote>\n<p>I'd also be tempted to go ahead and PR the <code>is_symmetric_smul</code> stuff, since I found a number of other places where I wanted it</p>\n</blockquote>\n<p>What other places for example?</p>",
        "id": 261997795,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272979
    },
    {
        "content": "<p>But I'd be happy for you to PR it, happy for everything that breaks my PR into smaller pieces ^^</p>",
        "id": 261998082,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637273121
    },
    {
        "content": "<p>There's a few additional closure properties in <a href=\"https://github.com/leanprover-community/mathlib/blob/53172fa65edafc41d08ff451ed023d8a46b01b32/src/group_theory/group_action/symmetric.lean\">here</a></p>",
        "id": 261998526,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637273348
    },
    {
        "content": "<blockquote>\n<p>what other places for example?</p>\n</blockquote>\n<p>IMO <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_module\">docs#star_module</a> should be stated in terms of a right action on one side, but that's annoying in commutative actions without <code>is_symmetric_smul</code></p>",
        "id": 261999943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637273972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261999943\">said</a>:</p>\n<blockquote>\n<p>IMO <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_module\">docs#star_module</a> should be stated in terms of a right action on one side, but that's annoying in commutative actions without <code>is_symmetric_smul</code></p>\n</blockquote>\n<p>Oh, does that also contain the potential of having  issues <code>opposite (opposite R)</code>when applied twice? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 262000629,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637274346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/262000629\">said</a>:</p>\n<blockquote>\n<p>Oh, does that also contain the potential of having  issues <code>opposite (opposite R)</code>when applied twice? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>Let me advertise two theories for a refactor that could deal with this:</p>\n<ul>\n<li><a href=\"#narrow/stream/113488-general/topic/with_top.20irreducible/near/260803354\">eta for structures</a></li>\n<li>some class <a href=\"https://github.com/leanprover-community/mathlib/pull/9840#discussion_r738695610\"><code>is_opposite R S</code></a> packaging an isomorphism between <code>Rᵒᵖ</code> and <code>S</code></li>\n</ul>",
        "id": 262001227,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637274665
    },
    {
        "content": "<p>Ah, thanks. is \"eta for structures\" really a solution? We won't have eta for structures in Lean 4 either</p>",
        "id": 262001983,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637275161
    },
    {
        "content": "<p>I think it was under consideration?<br>\n<a href=\"https://github.com/leanprover/lean4/issues/777#issuecomment-964207928\">https://github.com/leanprover/lean4/issues/777#issuecomment-964207928</a></p>",
        "id": 262002104,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637275219
    },
    {
        "content": "<p>Oh cool :) I proposed it to Sebastian a while ago, and he didn't sound like Leo and him liked it</p>",
        "id": 262038593,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637310121
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> What's your proposal then? \"Use left modules everywhere, except if you intend to use it on the left side of a tensor product, then use symmetric ones\" still sounds weird to me</p>",
        "id": 262056350,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637322422
    },
    {
        "content": "<p>I'm afraid that the length of this thread has gotten to the point where I'm no longer certain which problem we're trying to solve any more</p>",
        "id": 262056935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637322899
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262056965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637322917
    },
    {
        "content": "<p>Oh, you mean \"using a <em>type</em> <code>M</code> on the left side of a tensor product means it needs a right-action by <code>R</code>\"?</p>",
        "id": 262057029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637322963
    },
    {
        "content": "<p>The underlying problem is that we don't have a good theory of non-commutative algebra, and it's getting to the point where we are really going to need this (e.g. we want to do some representation theory), and I would actively encourage <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> to work on this important problem and thank them for initiating the discussion! Maybe Reid's suggestion about just going with <code>left_module</code> and <code>right_module</code> is worth trying?</p>",
        "id": 262057217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637323115
    },
    {
        "content": "<p>I agree, it's great that <span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> is thinking hard about this</p>",
        "id": 262057439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323233
    },
    {
        "content": "<p>(Oh, also I remembered the other place where I wanted symmetric actions; I wanted to generalize <a href=\"https://leanprover-community.github.io/mathlib_docs/find/derivation\">docs#derivation</a> so that I could use it on square matrices, without breaking all the existing commutative uses)</p>",
        "id": 262057483,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261998082\">said</a>:</p>\n<blockquote>\n<p>But I'd be happy for you to PR it, happy for everything that breaks my PR into smaller pieces ^^</p>\n</blockquote>\n<p>I plan to do this once <a href=\"https://github.com/leanprover-community/mathlib/issues/10302\">#10302</a> has gone through</p>",
        "id": 262057580,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323326
    },
    {
        "content": "<p>And then we can use the current <code>module</code> + the  <code>is_symmetric_smul</code> from that future PR to compare the other proposals in this thread against.</p>",
        "id": 262057641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323382
    },
    {
        "content": "<p>Yes, let me recap the problem again, how do I move a huge chunk of messages to a new topic? This is still called \"ideals in non-comm rings\" which is a bit misleading ^^'</p>",
        "id": 262058009,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637323577
    },
    {
        "content": "<p>If you can find the message that you think changed the topic, you can edit the topic for that message, and every message after it will change too</p>",
        "id": 262058266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323744
    },
    {
        "content": "<p>If there are individual message that end up in the wrong place after that, you can PM me or another maintainer to move them using our zulip powers</p>",
        "id": 262058295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323772
    },
    {
        "content": "<p>I think the discussions never went back to being about ideals :D</p>",
        "id": 262058429,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637323848
    },
    {
        "content": "<p>Ideal</p>",
        "id": 262058495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323882
    },
    {
        "content": "<p>So to recap: </p>\n<ul>\n<li>Commutative algebraists want to have \"If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules, so is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(rm) \\otimes n = m \\otimes (rn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> is part of the definition of the tensor product\".</li>\n<li>On the other hand non-commutative algebraists want \"If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is a left <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module and the defn of the tensor product includes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mi>r</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(mr) \\otimes n = m \\otimes rn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span></span></span></span>.</li>\n<li>The current implementation satisfies the first version, but not the second one. One way to change this is to remove the commutativity requirement and (to get) the equation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(rm) \\otimes n = m \\otimes (rn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, which is used a lot all over mathlib, require that in many cases <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not just an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module but a symmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule. But this means we have to add an instance of <code>module (opposite R) M</code> whenever we want to talk about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> module. Which is quite often.</li>\n<li>As <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> mentions, the whole dilemma doubles pretty analogously in with the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-linear maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\to N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>.</li>\n<li>Several people now have told me that it's more common to use the term \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module\" meaning \"symmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule\" in general, even if we only write the $$r$$s on the left. It's definitely more intuitive than needing to provide two extra instances whenever we want to plug in a module in a tensor product.</li>\n</ul>",
        "id": 262059841,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637324833
    },
    {
        "content": "<p>To give another good example: We get the category of <code>Module R</code>s but can't get the <em>monoidal</em> category of <code>Module R</code>s even if <code>R</code> is commutative.</p>",
        "id": 262062265,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637326443
    },
    {
        "content": "<p>How far does the following get us:</p>\n<ul>\n<li>Rename <code>module</code> to <code>left_module</code></li>\n<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module\">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>\n<li>Do the above for the other typeclasses like <code>mul_action</code> too</li>\n<li>Define <code>class module (R M) extends left_module R M, right_module R M, is_symmetric_smul R Rᵒᵖ M</code></li>\n</ul>",
        "id": 262062767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637326762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262059841\">said</a>:</p>\n<blockquote>\n<p>\"[...] also <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(rm) \\otimes n = m \\otimes (rn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> is part of the definition of the tensor product\"</p>\n</blockquote>\n<p>I use this formula all the time. But I've never considered it <em>part of the definition</em>. The definition uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>r</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mr ⊗ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. And the formula is obtained in the special case that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a symmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule.</p>",
        "id": 262062791,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637326776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> If there are no instances of <code>right_module</code>, how would notation for right actions work?</p>",
        "id": 262063202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637326956
    },
    {
        "content": "<p>Well it just finds instances of <code>left_module (opposite R) M</code> because it's an abbreviation</p>",
        "id": 262063238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637326989
    },
    {
        "content": "<p>And <code>m &lt;• r</code> would be notation for <code>(to_opposite r) • m</code>, or something like that?</p>",
        "id": 262063344,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637327045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062791\">said</a>:</p>\n<blockquote>\n<p>I use this formula all the time. But I've never considered it <em>part of the definition</em>. The definition uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>r</mi><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">mr ⊗ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>. And the formula is obtained in the special case that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a symmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule.</p>\n</blockquote>\n<p>Okay, thanks. That's in line with my PR then. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> Unfortunately it's at odds with a good chunk of mathlib.</p>",
        "id": 262063544,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637327184
    },
    {
        "content": "<p>Yes, so I would assume symm R-R-bimod everywhere, in a first refactor PR.</p>",
        "id": 262063786,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637327328
    },
    {
        "content": "<p>Later PRs can then weaken those assumptions, by flipping the sides of some actions.</p>",
        "id": 262063817,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637327354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062767\">said</a>:</p>\n<blockquote>\n<p>How far does the following get us:</p>\n<ul>\n<li>Rename <code>module</code> to <code>left_module</code></li>\n<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module\">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>\n<li>Do the above for the other typeclasses like <code>mul_action</code> too</li>\n<li>Define <code>class module (R M) extends left_module R M, right_module R M, is_symmetric_smul R Rᵒᵖ M</code></li>\n</ul>\n</blockquote>\n<p>That's roughly what Reid suggested. IIRC the issue you mentioned is that we will have lots of lemmas/construction about <code>left_module R M</code> which will not automatically carry over to <code>module R M</code> in the case where <code>R</code> is commutative, do you think that's a problem?</p>",
        "id": 262063992,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637327472
    },
    {
        "content": "<p>Why wouldn't they carry over?</p>",
        "id": 262064014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327488
    },
    {
        "content": "<p>There'd be a <code>module.to_left_module</code> instance</p>",
        "id": 262064034,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327501
    },
    {
        "content": "<p><code>[module R M]</code> would be nothing but a shorthand for <code>[left_module R M] [left_module (opposite R) M] [is_symmetric_smul R M]</code></p>",
        "id": 262064113,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327530
    },
    {
        "content": "<p>Oh right, yes. Thanks. I flipped the directions around in my head. So we will make sure we prove as little as possible about <code>module</code> and as much as possible about <code>left_module</code>...</p>",
        "id": 262064148,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637327554
    },
    {
        "content": "<p>Yes, exactly; it's the same as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_domain\">docs#is_domain</a> vs <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nontrivial\">docs#nontrivial</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/no_zero_divisors\">docs#no_zero_divisors</a></p>",
        "id": 262064184,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327576
    },
    {
        "content": "<p>Where the former exists only because the latter is an annoying spelling</p>",
        "id": 262064224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327603
    },
    {
        "content": "<p>I would probably recommend doing the rename separately from the tensor product refactor</p>",
        "id": 262064258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327625
    },
    {
        "content": "<p>Perhaps afterwards</p>",
        "id": 262064267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637327635
    },
    {
        "content": "<p>Doing it afterwards has the advantage of knowing exactly where we have to assume the symmetry. So I'll just continue and add <code>module (opposite R) M</code> and <code>is_symmetric_smul R M</code> where needed, ok?</p>",
        "id": 262064413,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637327713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262062767\">said</a>:</p>\n<blockquote>\n<p>How far does the following get us:</p>\n<ul>\n<li>Define <code>abbreviation right_module := left_module (Rᵒᵖ) M</code>. We won't make any instances of this (beyond <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semiring.to_opposite_module\">docs#semiring.to_opposite_module</a>), but it's good for a human reader</li>\n</ul>\n</blockquote>\n<p>So the advantage of using this encoding is we don't have to duplicate a lot of definitions/lemmas, but I suspect we would need to do some work anyways to make sure the encoding does not \"leak\", e.g., we will need a lemma that says <code>(m &lt;• r) &lt;• s = m &lt;• (r * s)</code> without any mention of <code>opposite</code>.</p>\n<p>Though I can't think of any examples where this would happen, there's also the possibility that someone might want to consider an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mrow><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R^{\\mathrm{op}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">op</span></span></span></span></span></span></span></span></span></span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule, which seems very difficult with this encoding. That's why I would tend to prefer a more \"nominal\" distinction between left and right actions.</p>",
        "id": 262067704,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637329627
    },
    {
        "content": "<p>I guess it will happen, but maybe not often. E.g., at some point you want to relate K-theory of <code>Rᵒᵖ</code> with K-theory of <code>R</code>. Things like that.</p>",
        "id": 262067964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637329766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262067704\">said</a>:</p>\n<blockquote>\n<p>which seems very difficult with this encoding</p>\n</blockquote>\n<p>Why?</p>",
        "id": 262068520,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637330047
    },
    {
        "content": "<p>Because it means you have to reason about two different instances of <code>left_module (Rᵒᵖ) M</code> at once, right?</p>",
        "id": 262068592,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637330100
    },
    {
        "content": "<p>Ah right, it might work to make an irreducible definition for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>:</mo><mo>=</mo><msup><mi>R</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R&#x27; := R^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span> in this case</p>",
        "id": 262068864,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637330229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262067704\">said</a>:</p>\n<blockquote>\n<p>we will need a lemma that says <code>(m &lt;• r) &lt;• s = m &lt;• (r * s)</code> without any mention of <code>opposite</code></p>\n</blockquote>\n<p><code>smul_smul</code> would still be the right lemma, it might just be that the naming for some lemmas is off because they don't read from left to right anymore.</p>",
        "id": 262069052,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637330312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262068592\">said</a>:</p>\n<blockquote>\n<p>Because it means you have to reason about two different instances of <code>left_module (Rᵒᵖ) M</code> at once, right?</p>\n</blockquote>\n<p>Sounds like a job for another type synonym.</p>",
        "id": 262069154,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637330385
    },
    {
        "content": "<p>But that's not really satisfactory because <code>Rᵒᵖ</code> was something that already existed and we might want to prove things about. e.g. continuing Johan's suggestion, two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order). Now <code>Rᵒᵖ</code> sometimes is Morita equivalent to <code>R</code> (e.g. for <code>R</code> commutative) and sometimes isn't; for example I randomly found <a href=\"https://arxiv.org/abs/1305.5139\">https://arxiv.org/abs/1305.5139</a> which is about this question.</p>\n<p><strong>If</strong> it's impractical to talk about Morita equivalence of <code>Rᵒᵖ</code> and <code>R</code> (because <code>Rᵒᵖ</code> was \"used up\" by <code>right_module</code>; I am not sure whether this would really be a problem in practice), then it's not really satisfactory to say \"welp, let's just phrase this theorem in terms of <code>Rᵒᵖ'</code> instead\".</p>",
        "id": 262070238,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637330890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070238\">said</a>:</p>\n<blockquote>\n<p>two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order).</p>\n</blockquote>\n<p>Are we anywhere close to being able to state this anyway? Does \"yields\" mean \"isomorphic as a module\"?</p>",
        "id": 262070568,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637331030
    },
    {
        "content": "<p>And what if<code>right_module</code> is the one consuming the new <code>op</code>-like type synonym?</p>",
        "id": 262070583,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637331037
    },
    {
        "content": "<p>I would lean towards just going ahead with \"using up\" opposite in this way, for the sake of:</p>\n<blockquote>\n<p>So the advantage of using this encoding is we don't have to duplicate a lot of definitions/lemmas</p>\n</blockquote>\n<p>and then revaluate once we have a working implementation to see what the problems look like</p>",
        "id": 262071074,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637331275
    },
    {
        "content": "<p>I think that once we have a definition of the tensor product in the non-commutative setting, then defining Morita equivalence is easy.<br>\nSo in that sense, we are just as close to stating Morita equivalence as to solving the problems in this thread <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 262071075,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637331275
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070583\">said</a>:</p>\n<blockquote>\n<p>And what if<code>right_module</code> is the one consuming the new <code>op</code>-like type synonym?</p>\n</blockquote>\n<p>Then you don't have this problem, but you might have to do more work to relate right modules over <code>R</code> to left modules over <code>Rᵒᵖ</code> instead, I guess?</p>",
        "id": 262071170,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637331340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070568\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262070238\">said</a>:</p>\n<blockquote>\n<p>two rings <code>R</code> and <code>S</code> are Morita equivalent if there is an <code>R</code>-<code>S</code>-bimodule and an <code>S</code>-<code>R</code>-bimodule such that tensoring them together yields <code>R</code> or <code>S</code> (depending on the order).</p>\n</blockquote>\n<p>Are we anywhere close to being able to state this anyway? Does \"yields\" mean \"isomorphic as a module\"?</p>\n</blockquote>\n<p>e.g. \"yields <code>R</code>\" means \"is isomorphic to <code>R</code> as an <code>R</code>-<code>R</code>-bimodule\"</p>",
        "id": 262071205,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637331360
    },
    {
        "content": "<p>\"<code>N</code> is isomorphic to <code>M</code> as an <code>R</code>-<code>S</code>-bimodule\" feels like something we're quite a way from being able to state</p>",
        "id": 262071308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637331404
    },
    {
        "content": "<p>We'd need maps that are linear over multiple rings</p>",
        "id": 262071331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637331417
    },
    {
        "content": "<p>Unless we phrase it as \"<code>N</code> is isomorphic to <code>M</code> as an <code>R ⊗[nat] S</code>-module\", assuming that makes any sense</p>",
        "id": 262071505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637331491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262071331\">said</a>:</p>\n<blockquote>\n<p>We'd need maps that are linear over multiple rings</p>\n</blockquote>\n<p>Not \"multiple\" rings. Two rings! There are only two places where a ring can act, the left and the right</p>",
        "id": 262071942,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637331702
    },
    {
        "content": "<p>Nevertheless. We just had a pretty impressive refactor that gave us semi-linear maps. I don't know what Lean will think of us if we start explaining it about bi-semi-linear maps. If we want to keep it readable, we'll put quite some strain on the system, I fear.</p>",
        "id": 262072135,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637331789
    },
    {
        "content": "<p>Anyways I think the more important question is whether it actually helps to use this encoding of right modules as left modules over the opposite ring at all</p>",
        "id": 262072353,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637331901
    },
    {
        "content": "<p>I guess it only solves part of the problem anyways because right modules over <code>Rᵒᵖ</code> will be left modules over<code>(Rᵒᵖ)ᵒᵖ</code> which is not what we want</p>",
        "id": 262072545,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637331982
    },
    {
        "content": "<p>I don't know what's best, but the point I wanted to make is it's not a \"free win\" to use the encoding with <code>opposite</code></p>",
        "id": 262073058,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637332241
    },
    {
        "content": "<p>Dumb question, why \"left and \"right\"? Does it never happen to consider more than two actions?</p>",
        "id": 262073799,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637332631
    },
    {
        "content": "<p>Either its <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mi>m</mi><mo>=</mo><mi>r</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(rs)m=r(sm)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">rs</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> or it's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mi>s</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">m(rs)=(mr)s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">rs</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">s</span></span></span></span>, so there are only two ways mulitplication and action can associate.</p>",
        "id": 262074275,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637332823
    },
    {
        "content": "<p>Number theorists love count the number of embeddings of a number field into the real / complex numbers so this gives multiple (left) actions of the same ring on the same target but I can't think of a situation where we'd want to regard anything like this as a module.</p>",
        "id": 262074731,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637333045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262072353\">said</a>:</p>\n<blockquote>\n<p>Anyways I think the more important question is whether it actually helps to use this encoding of right modules as left modules over the opposite ring at all</p>\n</blockquote>\n<p>We should keep in mind that in Lean 4</p>\n<ul>\n<li>We can write the feature providing <code>to_additive</code> in a more general way which could auto-generate <code>rsmul</code>-lemmas from <code>smul</code>-lemmas.</li>\n<li>We can have cycles in the type class system, so we <em>will</em> be able to have <code>instance [comm_ring R] [left_module R M] : symmetric_module R M</code>.</li>\n</ul>",
        "id": 262074738,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637333048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  It's like how the ring of a x a matrices acts on the left on the vector space of a x b matrices, and the ring of b x b matrices acts on the right.</p>",
        "id": 262074863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637333106
    },
    {
        "content": "<blockquote>\n<p>We can have cycles in the type class system, so we will be able to have <code>instance [comm_ring R] [left_module R M] : symmetric_module R M</code>.</p>\n</blockquote>\n<p>This isn't true, that instance constructs data in a way that will almost certainly create diamonds</p>",
        "id": 262074880,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637333115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262074863\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span>  It's like how the ring of a x a matrices acts on the left on the vector space of a x b matrices, and the ring of b x b matrices acts on the right.</p>\n</blockquote>\n<p>Do we have that instance? If not, that sounds like an easy undergrad warmup project</p>",
        "id": 262074941,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637333147
    },
    {
        "content": "<p>Ah so it's stemming the fact that multplication is binary?</p>",
        "id": 262075024,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637333169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262074880\">said</a>:</p>\n<blockquote>\n<p>This isn't true, that instance constructs data in a way that will almost certainly create diamonds</p>\n</blockquote>\n<p>Well, diamonds would appear exactly in the cases where we had a <code>right_module R M</code> beforehand?</p>",
        "id": 262075112,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637333227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075024\">said</a>:</p>\n<blockquote>\n<p>Ah so it's stemming the fact that multplication is binary?</p>\n</blockquote>\n<p>Fundamentally there are four types of instance in mathlib:</p>\n<ul>\n<li>Instances that derive from left-multiplication, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_mul.to_has_scalar\">docs#has_mul.to_has_scalar</a></li>\n<li>Instances that derive from right-multiplication, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_mul.to_has_opposite_scalar\">docs#has_mul.to_has_opposite_scalar</a></li>\n<li>Instances that derive from application, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.End.apply_mul_action\">docs#function.End.apply_mul_action</a></li>\n<li>weird special cases that don't really fit with the rest of the picture</li>\n</ul>\n<p>By \"derive\" I mean \"products get this elementwise, polynomials get this coefficient-wise, functions get this codomain-wise, ...\"</p>",
        "id": 262075154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637333267
    },
    {
        "content": "<p>What I meant is that there are exactly two <em>ways</em> in which a (noncommutative) ring can act, from the left or from the right. I guess you could also consider something with multiple compatible left actions (presumably by different rings to avoid confusion).</p>",
        "id": 262075233,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637333295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075024\">said</a>:</p>\n<blockquote>\n<p>Ah so it's stemming the fact that multplication is binary?</p>\n</blockquote>\n<p>It's ultimately because multiplication in a noncommutative ring is multiplication of a sequence of elements <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">abc...xyz</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mord mathnormal\">c</span><span class=\"mord\">...</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">yz</span></span></span></span>, and this sequence has two ends (a left end and a right end) where you could put a module instead.</p>",
        "id": 262075349,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637333356
    },
    {
        "content": "<p>In the commutative case you just multiply an unordered collection of elements together and so there's only one \"place\" to put an element of a module, so there is only one kind of module over a commutative ring</p>",
        "id": 262075480,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637333404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262075112\">said</a>:</p>\n<blockquote>\n<p>Well, diamonds would appear exactly in the cases where we had a <code>right_module R M</code> beforehand?</p>\n</blockquote>\n<p>Yes, but for any sort of composite type there will likely always be a <code>right_module R M</code> instance available; If <code>M</code> is a product type, the instance will exist that derives the instance from a right action on each half of the product.</p>\n<p>That instance will be incompatible with the instance that derives a <code>right_module</code> from a <code>symm_module</code>, and derives a <code>symm_module</code> from each half, because even in a commutative ring <code>a * b = b * a</code> is not defeq</p>",
        "id": 262075589,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637333460
    },
    {
        "content": "<p>Thanks, good point.</p>",
        "id": 262075902,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637333612
    },
    {
        "content": "<p>Usually the way to avoid this type of diamond is to avoid ever constructing new data when inferring <code>foo A</code> from <code>bar A</code></p>",
        "id": 262076058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637333669
    },
    {
        "content": "<p>I was just fixing a file which requires a symmetric version of <code>[algebra R A]</code>. It's probably sufficient to do it with <code>[algebra R A] [has_scalar (opposite R) A] [is_symmetric_smul R A]</code>  and derive an instance <code>[algebra (opposite R) A]</code> instead of creating a new class for the symmetry of algebras...</p>",
        "id": 262332281,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637594234
    },
    {
        "content": "<blockquote>\n<p>and derive an instance <code>[algebra (opposite R) A]</code> </p>\n</blockquote>\n<p>This instance should already exist in the places you need it</p>",
        "id": 262333216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637594643
    },
    {
        "content": "<p>That is, you should be using <code>[algebra R A] [algebra (opposite R) A] [is_symmetric_smul R A]</code></p>",
        "id": 262333293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637594665
    },
    {
        "content": "<p>But doesn't that introduce maps <code>f : R →+* A</code> and <code>g : (opposite R) →+* A</code> which have no connection with each other?</p>",
        "id": 262333595,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637594820
    },
    {
        "content": "<p><code>is_symmetric_smul</code> only matches up the scalar part, not the ring hom</p>",
        "id": 262333658,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637594847
    },
    {
        "content": "<p>Sure, but you can prove the ring_homs are equal via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.smul_def\">docs#algebra.smul_def</a>; it already is fully defined by the scalar part</p>",
        "id": 262335124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637595437
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">distrib_mul_action</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>Any ideas on this? Probably worth first tranferring various classes of actions along equivalences...</p>",
        "id": 262594488,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637763663
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.distrib_mul_action\">docs#units.distrib_mul_action</a>?</p>",
        "id": 262597186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637764983
    },
    {
        "content": "<p>Combined with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.distrib_mul_action\">docs#mul_opposite.distrib_mul_action</a></p>",
        "id": 262597253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765024
    },
    {
        "content": "<p>Are you missing an import of <code>group_theory.group_action.opposite</code>?</p>",
        "id": 262597325,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597253\">said</a>:</p>\n<blockquote>\n<p>Combined with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.distrib_mul_action\">docs#mul_opposite.distrib_mul_action</a></p>\n</blockquote>\n<p>That's taking the opposite on the type that's operated on.</p>",
        "id": 262597856,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597325\">said</a>:</p>\n<blockquote>\n<p>Are you missing an import of <code>group_theory.group_action.opposite</code>?</p>\n</blockquote>\n<p>Do you mean <code>algebra.opposites</code>? That's the file I'm working in</p>",
        "id": 262597910,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765312
    },
    {
        "content": "<p><code>algebra.opposites</code> was split in <del>two</del> three, you must be behind master</p>",
        "id": 262597957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765340
    },
    {
        "content": "<p>Ouch, okay, I'll rebase</p>",
        "id": 262597983,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765354
    },
    {
        "content": "<p>(Though the question still stands)</p>",
        "id": 262598036,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765384
    },
    {
        "content": "<p>I assume <code>distrib_mul_action (units Rᵒᵖ) N</code> works fine?</p>",
        "id": 262598049,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262598049\">said</a>:</p>\n<blockquote>\n<p>I assume <code>distrib_mul_action (units Rᵒᵖ) N</code> works fine?</p>\n</blockquote>\n<p>Yes, and we have an equivalence between <code>units Rᵒᵖ</code> and <code>(units R)ᵒᵖ</code>...</p>",
        "id": 262598133,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765421
    },
    {
        "content": "<p>Yeah, I think the instance is missing and needs to be added manually, and can't be reasonably inferred transitively</p>",
        "id": 262598185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765451
    },
    {
        "content": "<p>There are probably quite some of these that might pop up...</p>",
        "id": 262598245,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765480
    },
    {
        "content": "<p>I think I have a local unsaved buffer with the relevant code in it...</p>",
        "id": 262598288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765504
    },
    {
        "content": "<p>Yep</p>",
        "id": 262598397,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765529
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.opposites</span>\n\n<span class=\"c1\">-- turn off the bad instance we're tring to fix</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">units.mul_action'</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">units</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Right actions on units - I can't think if a good way to inherit these from anything we already</span>\n<span class=\"cm\">have -/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">units.op_has_scalar</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">um</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">um.unop</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">units.op_mul_action</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">um</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">um.unop</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">um</span> <span class=\"n\">un</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">um.unop</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">un.unop</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)),</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Notation just to make the intent behind the sorried lemma clear. -/</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">g</span><span class=\"bp\">`</span> <span class=\"bp\">•&gt;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">73</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"mi\">72</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">m</span>\n<span class=\"kd\">notation</span> <span class=\"n\">m</span><span class=\"bp\">`</span> <span class=\"bp\">&lt;•</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">73</span> <span class=\"n\">g</span><span class=\"o\">:</span><span class=\"mi\">72</span> <span class=\"o\">:=</span> <span class=\"n\">opposite.op</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_mul_inv_smul</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">smul_assoc</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">op_smul_eq_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">op_smul_eq_mul</span><span class=\"o\">],</span>\n    <span class=\"gr\">sorry</span> <span class=\"c1\">-- we need `is_scalar_tower` for right actions</span>\n    <span class=\"o\">}</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">units.mul_inv</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">•&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- `smul_comm_class` is too strong here</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_right_inv</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inv_smul_mul_smul</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">opposite.op_injective</span> <span class=\"bp\">$</span> <span class=\"n\">smul_mul_inv_smul</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">units.op_equiv.symm</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">m</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- A fixed version of `units.mul_action'`. -/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">better_mul_action'</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">•&gt;</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">smul_mul_inv_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inv_smul_mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">units.ext</span> <span class=\"bp\">$</span> <span class=\"n\">one_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g₁</span> <span class=\"n\">g₂</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">units.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- note: now only needs monoid not comm_monoid!</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">units.better_mul_action'</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">monoid.to_mul_action</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span> <span class=\"c1\">-- ok, no diamond any more</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">units</span>\n</code></pre></div>",
        "id": 262598408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765533
    },
    {
        "content": "<p>I guess that was in response to some thread about <code>units.mul_action'</code> being bad</p>",
        "id": 262598491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637765580
    },
    {
        "content": "<p>Ah, okay, <code>units.mul_action'</code> should not interfere with the PR</p>",
        "id": 262598672,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637765667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262597983\">said</a>:</p>\n<blockquote>\n<p>Ouch, okay, I'll rebase</p>\n</blockquote>\n<p>That's one messy rebase <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 262612313,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637772017
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262617076,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637774176
    },
    {
        "content": "<p>A merge would likely be a lot easier</p>",
        "id": 262635983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637785110
    },
    {
        "content": "<p>If you rebase n commits you can end up solving n conflicts, with a merge there's just one conflict.</p>",
        "id": 262636050,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637785154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262635983\">said</a>:</p>\n<blockquote>\n<p>A merge would likely be a lot easier</p>\n</blockquote>\n<p>I don't think it made a difference, it's mostly the renamings from <code>opposite</code> to <code>mul_opposite</code>...</p>",
        "id": 262679132,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637829890
    },
    {
        "content": "<p>Made some progress today, but <code>linear_algebra.alternating</code> is still a bit stubborn. There is something wrong with a type class in there, but the issue seems so just have been patched over before. <a href=\"https://github.com/leanprover-community/mathlib/blob/noncomm_tensor_product/src/linear_algebra/alternating.lean#L594\">Here</a> is one of the problematic lines, the other is were it fails at the bottom of the file...</p>",
        "id": 262712406,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637850810
    },
    {
        "content": "<p>FWIW the trace of the problematic search is <a href=\"https://gist.github.com/javra/9f5f8b3f3b255fd00d72f00c22759db4\">here</a></p>",
        "id": 262716429,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637852785
    },
    {
        "content": "<p>The message at the bottom looks more like a diamond, but I'm not sure what's going on there either</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">tensor_product.tmul_smul</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">units.is_symmetric_smul</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units.has_scalar</span> <span class=\"n\">ℤ</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"n\">int.monoid</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units.op_has_scalar</span> <span class=\"n\">ℤ</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"n\">int.monoid</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">group.to_div_inv_monoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units.group</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)))</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">div_inv_monoid.to_monoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">group.to_div_inv_monoid</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">units.group</span> <span class=\"n\">ℤ</span> <span class=\"n\">int.monoid</span><span class=\"o\">)))</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_comm_monoid.to_add_monoid</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span><span class=\"o\">)</span>\n          <span class=\"bp\">?</span><span class=\"n\">m_3</span><span class=\"o\">))</span>\n    <span class=\"bp\">?</span><span class=\"n\">m_4</span>\n</code></pre></div>",
        "id": 262718604,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637853906
    },
    {
        "content": "<p>These are the typeclasses need for <code>algebra_tensor_module.assoc</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">comm_semiring</span> <span class=\"n\">R</span>\n<span class=\"n\">_inst_2</span><span class=\"o\">:</span> <span class=\"n\">comm_semiring</span> <span class=\"n\">A</span>\n<span class=\"n\">_inst_3</span><span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n<span class=\"n\">_inst_4</span><span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span>\n<span class=\"n\">_inst_5</span><span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">A</span>\n<span class=\"n\">_inst_6</span><span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_7</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_8</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_9</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_10</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_11</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_12</span><span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">A</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_13</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_14</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_15</span><span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span>\n<span class=\"n\">_inst_16</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span>\n<span class=\"n\">_inst_17</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">N</span>\n<span class=\"n\">_inst_18</span><span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">N</span>\n<span class=\"n\">_inst_19</span><span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_20</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_21</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_22</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_23</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_24</span><span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_25</span><span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">A</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span>\n<span class=\"n\">_inst_26</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">A</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_27</span><span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_28</span><span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">A</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_29</span><span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">P</span>\n<span class=\"n\">_inst_30</span><span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">A</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 262804509,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637937835
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262804924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637938079
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra_tensor_module.assoc\">docs#algebra_tensor_module.assoc</a></p>",
        "id": 262805089,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637938196
    },
    {
        "content": "<p>Some of these might be made into instances, certain combination if <code>is_scalar_tower</code> and <code>is_symmetric_smul</code> especially.</p>",
        "id": 262805141,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637938205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262805089\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra_tensor_module.assoc\">docs#algebra_tensor_module.assoc</a></p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.algebra_tensor_module.assoc\">docs#tensor_product.algebra_tensor_module.assoc</a></p>",
        "id": 262805228,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637938256
    },
    {
        "content": "<p>I think we need <a href=\"https://github.com/javra/mathlib/blob/noncomm_tensor_product/src/linear_algebra/tensor_product/left_action.lean\">tensor_product.left_action</a> to be accompanied by a second file about the respective right action. <code>ring_theory.tensor_product</code> is missing this at some points</p>",
        "id": 262806578,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637939015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/262806578\">said</a>:</p>\n<blockquote>\n<p>I think we need <a href=\"https://github.com/javra/mathlib/blob/noncomm_tensor_product/src/linear_algebra/tensor_product/left_action.lean\">tensor_product.left_action</a> to be accompanied by a second file about the respective right action. <code>ring_theory.tensor_product</code> is missing this at some points</p>\n</blockquote>\n<p>Okay, the next issue is that these things overlap: We want the right action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> to come from a right action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and the left action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> to come from a left action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. But if for example <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-bimodule, there's already the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">S^{op}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span> action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that induces an action on the tensor product, that is because right actions are defined as a special case of left actions.</p>\n<p>Any ideas on how to deal with this?</p>",
        "id": 262997768,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638186673
    },
    {
        "content": "<p>Yes, this was the problem I was describing much earlier, and I'm not sure how to solve it</p>",
        "id": 263006547,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638191864
    },
    {
        "content": "<p>Having separate <code>right_mul R</code> and <code>left_mul R</code> types instead of <code>opposite R</code> and <code>R</code> would work, but I suspect that would be very painful</p>",
        "id": 263006739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638191946
    },
    {
        "content": "<p>My suspicion is that when such a case arises in practice the two actions are equal anyway propositionally, and to just accept the definitional typeclass diamond for now</p>",
        "id": 263006905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638192009
    },
    {
        "content": "<p>We only have an instance <code>algebra R (A ⊗[R] B)</code> but need one for the \"right algebra\" (do people actually consider those?), too. So I guess we should find a good generalisation of <code>algebra.tensor_product.tensor_product.algebra</code> (that name...) that captures both</p>",
        "id": 263009733,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638193505
    },
    {
        "content": "<p>I guess the problem would be solved if we completely uncouple left and right actions. But that would mean a lot of duplication.</p>",
        "id": 263010966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638194207
    },
    {
        "content": "<p>AFAIK \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra\" only ever makes sense when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative</p>",
        "id": 263010992,
        "sender_full_name": "Reid Barton",
        "timestamp": 1638194230
    },
    {
        "content": "<p>To comment on Reid's point: \"R-algebra\" indeed requires R to be commutative and furthermore that the action of R is central in the algebra, i.e. the image of R is in the center of the algebra. There is the more general notion, sometimes called an R-ring, where R can be non-commutative (a reformulation is that an R-ring is a monoid object in the category of R-R-bimodules.</p>",
        "id": 263012457,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1638194882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010992\">said</a>:</p>\n<blockquote>\n<p>AFAIK \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra\" only ever makes sense when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative</p>\n</blockquote>\n<p>Sure, but right now that's decoupled from the question of whether the scalar can act on the right. So with the current approach of my PR, we need <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code></p>",
        "id": 263012611,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638194946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010966\">said</a>:</p>\n<blockquote>\n<p>I guess the problem would be solved if we completely uncouple left and right actions. But that would mean a lot of duplication.</p>\n</blockquote>\n<p>Hm, I'm not sure if I should continue the current PR until there's a decision on this :(</p>",
        "id": 263012736,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638195015
    },
    {
        "content": "<p>(The tensor product algebra issue is an issue dependent on this, though, sorry for brining both points up at once ^^)</p>",
        "id": 263012857,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638195083
    },
    {
        "content": "<p>Completely uncoupling only seems feasible if there is a tactic <code>@[to_right_action]</code> that autogenerates all the duplicate lemmas.</p>",
        "id": 263013130,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638195238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263012611\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263010992\">said</a>:</p>\n<blockquote>\n<p>AFAIK \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra\" only ever makes sense when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative</p>\n</blockquote>\n<p>Sure, but right now that's decoupled from the question of whether the scalar can act on the right. So with the current approach of my PR, we need <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code></p>\n</blockquote>\n<p>It always acts on the right too, by the same action (because R is central).</p>",
        "id": 263014447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1638195860
    },
    {
        "content": "<p>So, generally speaking, <code>algebra R A</code> should induce <code>algebra Rᵐᵒᵖ A</code>, even if <code>A</code> is not commutative?</p>",
        "id": 263018345,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638197657
    },
    {
        "content": "<p>Ah, I guess that makes sense if the action is central...</p>",
        "id": 263018499,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638197744
    },
    {
        "content": "<p>An R-algebra is a monoid in R-modules taken in the commutative sense, where there is no \"left\" or \"right\".</p>",
        "id": 263020025,
        "sender_full_name": "Reid Barton",
        "timestamp": 1638198395
    },
    {
        "content": "<p>In the current hierarchy where it extends <code>module</code>,  it inherits a sense of \"left\" and \"right\"</p>",
        "id": 263022542,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638199526
    },
    {
        "content": "<p>But yea, if there's no conceivable scenario where there's a distinction, we should just have an instance adding the symmetric action</p>",
        "id": 263022986,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638199715
    },
    {
        "content": "<p>It's not safe today to add that instance, we already discussed why much earlier in the thread</p>",
        "id": 263027035,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638201368
    },
    {
        "content": "<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>",
        "id": 263027189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638201441
    },
    {
        "content": "<p>How many <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra\">docs#algebra</a> instances would that mean we have to fix?</p>",
        "id": 263028123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638201768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027035\">said</a>:</p>\n<blockquote>\n<p>It's not safe today to add that instance, we already discussed why much earlier in the thread</p>\n</blockquote>\n<p>Sorry, I keep forgetting about that issue...</p>",
        "id": 263030105,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638202555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027189\">said</a>:</p>\n<blockquote>\n<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>\n</blockquote>\n<p>That would mean that <code>algebra R A</code> implies an instance of both <code>module R A</code>, <code>module (opposite R) A</code> and <code>is_symmetric_smul R A</code>, right?</p>",
        "id": 263030608,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638202767
    },
    {
        "content": "<p>Yes, exactly</p>",
        "id": 263031771,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638203185
    },
    {
        "content": "<p>And <code>smul_comm_class R Rᵒᵖ A</code> too</p>",
        "id": 263031906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638203238
    },
    {
        "content": "<p>It probably being enough to constitute another PR, I'll nevertheless go ahead and just add an  instance for <code>algebra Rᵐᵒᵖ (A ⊗[R] B)</code> as a workaround until then...</p>",
        "id": 263071693,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638222198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263013130\">said</a>:</p>\n<blockquote>\n<p>Completely uncoupling only seems feasible if there is a tactic <code>@[to_right_action]</code> that autogenerates all the duplicate lemmas.</p>\n</blockquote>\n<p>Uncoupling would also solve the issue about \"usability\". The way it is now, we have variables <code>r : opposite R</code>, which we have to rewrite backwards <code>op_unop</code> to really get the notation on the right side we'd expect....</p>",
        "id": 263080502,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638227334
    },
    {
        "content": "<p>I just made a spinoff PR (<a href=\"https://github.com/leanprover-community/mathlib/issues/10543\">#10543</a>) that defines <code>is_symmetric_smul</code>, but with all the instances as early as possible instead of all in one place</p>",
        "id": 263082026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638228338
    },
    {
        "content": "<p>Just fixed to spots where <code>apply @tensor_product.ext_threefold R</code> gave a timeout but <code>apply @tensor_product.ext_threefold R _</code> works fine <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 263141470,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1638277973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks for that PR. I guess there is no harm in merging it, even if we later decide that completely uncoupling left and right actions is the way to go. Right?</p>",
        "id": 263544323,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1638516990
    },
    {
        "content": "<p>Even if we uncouple we'll still want a class for that compatibility</p>",
        "id": 263544477,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1638517143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/263027189\">said</a>:</p>\n<blockquote>\n<p>Probably the way to go here is to add an <code>op_smul_def</code> and <code>op_smul</code> field to algebras, so that they can decay to either left or right modules with the right definitional equality</p>\n</blockquote>\n<p>I started having a go at this in <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a></p>",
        "id": 264561819,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639227930
    },
    {
        "content": "<p>Did the search and replace now, but I guess for everything else, <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> should be merged first</p>",
        "id": 265569885,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1640010442
    },
    {
        "content": "<p>The diamonds from <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> probably will not be a problem for the time being.</p>",
        "id": 265570088,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640010580
    },
    {
        "content": "<p>Still, I wonder if we should find a once-and-for-all solution to these problems. Making <code>add_comm_monoid</code> bigger and bigger all the time doesn't seem like the correct solution to me.</p>",
        "id": 265570194,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640010622
    },
    {
        "content": "<p>Or maybe it is?</p>",
        "id": 265570205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640010631
    },
    {
        "content": "<p>I showed one of my kids the definition yesterday and they said \"oh cool you can override powers, you can use that to make exponentiation more computationally efficient\"</p>",
        "id": 265571619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640011421
    },
    {
        "content": "<p>And you replied: \"but we want it to be more efficient for <em>proving</em>!\" <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 265571744,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1640011489
    },
    {
        "content": "<p>but we have the API for that!</p>",
        "id": 265572228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640011722
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265570088\">said</a>:</p>\n<blockquote>\n<p>The diamonds from <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> probably will not be a problem for the time being.</p>\n</blockquote>\n<p>Yes, but all algebras being central will save me lots of edits...</p>",
        "id": 265572519,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1640011857
    },
    {
        "content": "<p>Maybe now is a good time to define central simple algebras?</p>",
        "id": 265572680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640011931
    },
    {
        "content": "<p>I would be very happy to see these generalisations merged. I think they are very important to get (different flavours of) non-commutative algebra going.</p>",
        "id": 265572911,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640012047
    },
    {
        "content": "<p>I don't know what's the status of <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a>. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> ?</p>",
        "id": 265573604,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1640012364
    },
    {
        "content": "<p>It needed a few other dependent PRs first I think</p>",
        "id": 265576254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013513
    },
    {
        "content": "<p>And generally working through all 70 instances of <code>algebra</code></p>",
        "id": 265576287,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013535
    },
    {
        "content": "<p>I think I'm through about 25 of them</p>",
        "id": 265576302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013544
    },
    {
        "content": "<p>The most annoying part of the change seems to be that <code>module.End R M</code> is now only an algebra when <code>M</code> is a bimodule</p>",
        "id": 265576465,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013613
    },
    {
        "content": "<p>But mathematically the distinction is meaningless given R is commutative anyway, so it's nothing more than an annoyance</p>",
        "id": 265576914,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013811
    },
    {
        "content": "<p>I share Johan's view that the new diamonds are unlikely to cause any trouble any time soon.</p>",
        "id": 265577237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640013940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265576465\">said</a>:</p>\n<blockquote>\n<p>The most annoying part of the change seems to be that <code>module.End R M</code> is now only an algebra when <code>M</code> is a bimodule</p>\n</blockquote>\n<p>This makes sense to me as Hom_R(M,N) has the structure of an S-T-bimodule if M is an R-S-bimodule and N is an R-T-bimodule. You should have to assume an instance <code>is_central_scalar</code> to get an algebra structure on End R M.</p>",
        "id": 265579253,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640014913
    },
    {
        "content": "<p>That comment worries me, as it seems to describe a <code>S</code> action on <code>f : M →ₗ[R] N</code> that comes from <code>M</code> alone. Is that action<code>(s • f) m = f (m &lt;• s)</code>? We don't have any actions like that in mathlib right now, and if we did we'd have some troubling diamonds with the <code>(s • f) m = s • f m</code> instance that we do have</p>",
        "id": 265682437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640091758
    },
    {
        "content": "<p>That is the action, but it is a right action. Why it is a problem for Hom and not for the tensor product? There the analogue is that if M is an R-S-bimodule and N is an S-T-bimodule, then M\\otimes N is an R-T-bimodule. (The standard convention is that when saying R-S-bimodule, the R-action is from the left while the S-action is from the right.)</p>",
        "id": 265683251,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640092332
    },
    {
        "content": "<p>We have a lot of precedent for function-like types that says \"actions operate on the codomain\", where actions includes left and right actions. We don't have much precedent for tensor products to worry about in comparison.</p>",
        "id": 265684093,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640092961
    },
    {
        "content": "<p>(I tried to edit the above to reflect the correct right/left-ness of the actions)</p>",
        "id": 265684384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640093176
    },
    {
        "content": "<p>Do you have some proposal what to do about that? Non-commutative algebraists definitely want to take about both actions, an action on Hom_R(M,N) induced by a right action on M as well as an action induced by a left action on N. And in general they are different.</p>",
        "id": 265686567,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640094524
    },
    {
        "content": "<p>The only suggestion I can think of is a <code>dom_act</code> type alias to force the action to apply to the domain</p>",
        "id": 265687624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640095095
    },
    {
        "content": "<p>But even that doesn't work very well if we want to apply to the second argument of a bilinear function, unless we also have <code>cod_act</code></p>",
        "id": 265687682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640095130
    },
    {
        "content": "<p>If we go down that route, then scaling of <code>fin 3 -&gt; R</code> ends up being written as <code>cod_act r • v</code> which is pretty unpleasant</p>",
        "id": 265687746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640095179
    },
    {
        "content": "<p>There is an important difference between the arrows here (again informally speaking, I don't know how easy it would be for lean to figure out the difference): If you talk about the undecorated arrow <code>fin 3 -&gt; R</code>, then the (left) action on <code>R</code> should come from a (left) action on <code>R</code>. On the other hand, when talking about an action on the decorated arrow <code>M \\to_l [R] N</code>, then the (left) <code>R</code>-action is, loosely speaking, already used, so any left action on this space should come from a right action on <code>M</code> whereas any right action should come from a right action on <code>N</code>.</p>",
        "id": 265695953,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640099810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> is right of course: in the special case of linear maps (between compatible bimodules) all is well, at least mathematically, because the space of maps carries just one left action and one right action.</p>",
        "id": 265950524,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291157
    },
    {
        "content": "<p>But we still have the problem that Mathlib cannot talk about the scalar actions (contravariantly) induced from actions on the domain for general classes of functions. To take a concrete example, I might well want to formalise something about the regular representation of a finite subgroup of non-zero complex numbers.</p>",
        "id": 265950620,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291250
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group.units</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">subgroup</span> <span class=\"o\">(</span><span class=\"n\">units</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> OK so now what does `z • f` mean?</span>\n\n<span class=\"cm\">Informally I might be talking about the (left) regular representation or</span>\n<span class=\"cm\">I might be talking about a pi action, regarding `z` as an element of `ℂ`.</span>\n\n<span class=\"cm\">Because we have so many diamonds (all fortunately defeq) it's not even easy</span>\n<span class=\"cm\">to \"switch off\" the unwanted action locally. E.g., uncomment any one of these</span>\n<span class=\"cm\">`local attribute [-instance]` statements and the `example` below succeeds. -/</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">pi.has_scalar</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">pi.mul_action</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">pi.mul_action_with_zero</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">pi.module</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">pi.algebra</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">•</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 265950742,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291366
    },
    {
        "content": "<p>Of course what we really have above is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>×</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G × G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">G \\to ℂ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">C</span></span></span></span> and in Mathlib we single out the first (covariant) factor for priority. More generally:</p>",
        "id": 265950907,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291501
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.pi</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_opposite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Give M left `A` and right `B` action, aka (A, B)-biaction</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">B</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Give N left `C` and right `D` action, aka (C, D)-biaction</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">C</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">D</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- What we really have is a (B × C, A × D)-biaction.</span>\n<span class=\"kd\">instance</span> <span class=\"n\">pi.mul_action_prod</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">bc</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">bc.snd</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"o\">((</span><span class=\"n\">op</span> <span class=\"n\">bc.fst</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- needed because `Aᵐᵒᵖᵐᵒᵖ ≠ A` so have missing `[mul_action Aᵐᵒᵖᵐᵒᵖ M]` issue</span>\n<span class=\"kd\">instance</span> <span class=\"n\">pi.mul_action_prod_op</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"bp\">×</span> <span class=\"n\">D</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ad</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ad.snd</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">ad.fst.unop</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 265950920,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291512
    },
    {
        "content": "<p>I also cannot think of a way to solve this problem except by means of a type synonym for the contravariantly-induced actions.</p>",
        "id": 265951011,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291568
    },
    {
        "content": "<p>I think we can avoid facing up to this for bimodules but we'll have to confront it eventually.</p>",
        "id": 265951174,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640291668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> Just to have an example in this conversation: In what area of maths is your more general situation needed?</p>",
        "id": 265961217,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640300604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> how about the example I gave above of the regular representation of a finite group, or more generally the permutation representation associated to the action of a group <code>G</code> on a set <code>X</code>? Given this data one can pick some scalars <code>k</code> and study the representation of <code>G</code> induced on <code>X → k</code>.</p>",
        "id": 266120746,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640542883
    },
    {
        "content": "<p>I gave the example where <code>G</code> is a finite subgroup of <code>ℂ*</code> acting on itself by multiplication and the scalars <code>ℂ</code>  above to show that even informally there can be ambiguity.</p>",
        "id": 266120834,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640542975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>  Thanks for the examples, but as far as I understand, this seems to be a general pattern for group actions: That there is often more than one you can consider. I remember there being an extensive discussion whether the regular action of a group on itself should be an instance in light of there also being the conjugation action, etc. Do you see an issue with going ahead with the bimodule case?</p>",
        "id": 266249492,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640688772
    },
    {
        "content": "<p>I don't see an issue with bimodules for the reason you highlighted: restricting to the left/right-linear  maps cuts out two of the group actions so the ambiguity vanishes on these maps.</p>",
        "id": 266249559,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640688840
    },
    {
        "content": "<p>We'll probably just keep putting off issues like this until we are forced to solve / work around them.</p>",
        "id": 266249681,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640688935
    },
    {
        "content": "<p>As I said above, there is even ambiguity when working informally. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant=\"normal\">C</mi><mo>∗</mo></msup><mo>→</mo><mi mathvariant=\"normal\">C</mi></mrow><annotation encoding=\"application/x-tex\">f : ℂ^* → ℂ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">C</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mo>∈</mo><msup><mi mathvariant=\"normal\">C</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">z ∈ ℂ^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord amsrm\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> then what do I mean by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi><mtext>•</mtext><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">z • f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord\">•</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>?</p>",
        "id": 266249887,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640689081
    },
    {
        "content": "<p>Certainly if G acts on A and B and we have f:A-&gt;B then sometimes (gf)(a) means  g(f(a)) and sometimes g(f(g^{-1}a)). Empirically I think that the former is common when f is known to be G-equivariant (because then the latter action is trivial) and conversely the latter is common when f is just an abelian group homomorphism (in which case the G-equivariant homs are the fixed points under the latter action)</p>",
        "id": 266260253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640699114
    },
    {
        "content": "<p>So it seems that there is agreement that no action should be preferred for maps f:A-&gt;B but that there is no harm registering an action on f:M-&gt;[R] N for bimodules M and N.</p>",
        "id": 266264596,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1640702574
    },
    {
        "content": "<p>Yes, to the second clause (about registering an action on linear maps between bimodules) but no to the first clause since we already have a preferred action registered, namely <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 266264701,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640702673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/265573604\">said</a>:</p>\n<blockquote>\n<p>I don't know what's the status of <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a>. <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> ?</p>\n</blockquote>\n<p>I made some more progress, but am now concluding that <code>normed_space</code> and <code>seminormed_space</code> probably want to be two-sided too. That refactor would be twice as easy if <a href=\"https://github.com/leanprover-community/mathlib/pull/8218\">#8218</a> weren't hitting problems</p>",
        "id": 267768742,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642013312
    },
    {
        "content": "<p>A status update on <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a>: I was able to get past the <code>normed_space</code> and <code>seminormed_space</code> problems, and am back to finding random types that are missing <code>is_central_scalar</code> instances (next up: <code>continuous_linear_map</code>,<code>affine_map</code>, <code>continuous_map</code>)</p>",
        "id": 271591736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644593050
    },
    {
        "content": "<p>Next up is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smooth_map.algebra\">docs#smooth_map.algebra</a> (<code>: algebra 𝕜 C^∞⟮I, N; 𝓘(𝕜, A), A⟯</code>), which is well beyond my paygrade. What's missing is the fact that this currently requires <code>𝕜</code>-multiplication to be smooth in values of <code>k</code>, even though that's obviously not necessary as the smooth functions are a <code>nat</code>-algebra (and I assume this doesn't count as smooth).</p>\n<p>To express that, I'd need a <code>smooth_const_smul</code> variant of <code>smooth_smul</code> with much weaker requirements on <code>𝕜</code>.</p>",
        "id": 272747746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645489544
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I can try to help here but I don't understand what you're asking -- what do you mean by \"the smooth functions are a <code>nat</code>-algebra\"?</p>",
        "id": 272760434,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645505628
    },
    {
        "content": "<p>Sorry, my statement was a little murky and <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>'d there. The actual missing piece is a <code>module 𝕜ᵐᵒᵖ C^∞⟮I, N; 𝓘(𝕜, A), A⟯</code> instance. It's easy to write that instance specifically, but it would be nice if it fell out as a specialization of a more general <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smooth_map.has_scalar\">docs#smooth_map.has_scalar</a> like it does on most other types.</p>",
        "id": 272779498,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645522820
    },
    {
        "content": "<p>The nat comment was simply a remark that \"the generalized version would optimistically work for nat-actions too\"</p>",
        "id": 272779702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645522939
    },
    {
        "content": "<p>Update: <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> now builds! Unfortunately the <code>fails_quickly</code> linter is unhappy, but I suspect that's just because a bunch of typeclass searches got longer.</p>",
        "id": 273260841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645811139
    },
    {
        "content": "<p>(I've got it building again and resolved conflicts, but the <code>fails_quickly</code> problem remains)</p>",
        "id": 280210515,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650980160
    },
    {
        "content": "<p>CI is fully green <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 281470628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651858537
    },
    {
        "content": "<p>Thanks for that massive effort. I would be happy to merge this asap. But it would be good if some others also take a look.</p>",
        "id": 281471907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651859156
    },
    {
        "content": "<p>From the PR message:</p>\n<blockquote>\n<p>This changes the definition of <code>algebra</code> to include a right action, such that <code>algebra R A</code> automatically implies a compatible left- and right- R-module structure.</p>\n<p>The <code>module ℕᵐᵒᵖ R</code> and <code>module ℤᵐᵒᵖ R</code> instances this introduces create diamonds when <code>R=ℕ</code> and <code>R=ℤ</code> with <code>semiring.to_opposite_module</code> (since <code>mul_comm</code> is not true definitionally), but fixing those would require adding an <code>op_nsmul</code> field to <code>add_comm_monoid</code> which would make this PR huge!</p>\n<p>The same change that is made to <code>algebra R A</code> also ends up being made to <code>lie_algebra R L</code>, although this is less in the way since <code>lie_algebra R L</code> already extends <code>module R L</code>, unlike <code>algebra R A</code> which does not directly extend <code>module R A</code>.</p>\n<p>Most of the extra typeclass arguments that are needed in various places stem from <code>module.End R M</code> now only being an <code>R</code>-algebra if <code>M</code> is an <code>R</code>-bimodule.</p>\n</blockquote>",
        "id": 281471948,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651859166
    },
    {
        "content": "<p>Having a look.</p>",
        "id": 281473948,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651860116
    },
    {
        "content": "<p>I am only a little bit worried that now we often have to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_central_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to mean that <code>M</code> is a <code>R</code> module (even if <code>R</code> is commutative), but I don't see a simpler way of avoiding this.</p>",
        "id": 281475390,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1651860787
    },
    {
        "content": "<p>I'm happy to split the PR into two if necessary - the merge conflicts are usually straightforward, and I don't envisage any similar timeouts</p>",
        "id": 281476704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861475
    },
    {
        "content": "<p>(the split would be; add random missing right actions, then do the actual titular change)</p>",
        "id": 281476730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/281475390\">said</a>:</p>\n<blockquote>\n<p>I am only a little bit worried that now we often have to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_central_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>to mean that <code>M</code> is a <code>R</code> module (even if <code>R</code> is commutative), but I don't see a simpler way of avoiding this.</p>\n</blockquote>\n<p>In lean4 we can have <code>class really_a_module extends module R M, module Rᵐᵒᵖ M, is_central_scalar R M</code> and things should work out ok</p>",
        "id": 281476814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861551
    },
    {
        "content": "<p>(c.f.<code>my_sql_real_escape_string</code>, the version of <code>my_sql_escape_string</code> that ... actually escapes the string. /s)</p>",
        "id": 281476918,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861595
    },
    {
        "content": "<p>In lean 3 if we want to do that we have to add a new (trivial) instance next to every <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module\">docs#module</a> instance (there are 133 of them); which is certainly doable, but annoying.</p>",
        "id": 281477029,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861659
    },
    {
        "content": "<p>(I guess in practice it would just be next to the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_central_scalar\">docs#is_central_scalar</a> instances, of which there are only 52)</p>",
        "id": 281477158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651861720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/281476704\">said</a>:</p>\n<blockquote>\n<p>I'm happy to split the PR into two if necessary - the merge conflicts are usually straightforward, and I don't envisage any similar timeouts</p>\n</blockquote>\n<p>Two easy splits: <a href=\"https://github.com/leanprover-community/mathlib/pull/13995\">#13995</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13996\">#13996</a></p>",
        "id": 281483307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1651865105
    },
    {
        "content": "<p>The first of those is merged, but <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> expressed some hesitation on the second</p>",
        "id": 282033518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652306319
    },
    {
        "content": "<p>27 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"144837\" href=\"/#narrow/stream/144837-PR-reviews/topic/.2313996.20right.20actions.20on.20restrict_scalars\">#PR reviews &gt; #13996 right actions on restrict_scalars</a> by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.</p>",
        "id": 282433832,
        "sender_full_name": "Notification Bot",
        "timestamp": 1652656251
    },
    {
        "content": "<p>Both are now merged and <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> is green again; I'd appreciate any suggestions for further splits</p>",
        "id": 284812076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654208048
    },
    {
        "content": "<p>Wow, happy to see this finally done <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 285026067,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1654419343
    },
    {
        "content": "<p>Ok, I was perhaps wrong about it being easy to keep up to date with master. It's green once more</p>",
        "id": 289842707,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657998260
    }
]