[
    {
        "content": "<p>Hi! We (me, Martin Winter and Georg Loho) are Berlin/Leipzig based discrete geometry enthusiasts interested in adding basics of polytope theory (including polyhedral cones, polyhedra and polytopes) to mathlib. That could mean figuring out good definitions and proving some standard results:</p>\n<ul>\n<li>the Minkowski-Weyl theorem</li>\n<li>faces + basic theorems (faces are polytopes, face of face is face, etc)</li>\n<li>face lattice + combinatorial equivalence + basic theorems (face lattice is graded, intervals are face lattices, etc)</li>\n<li>polar duality + basic theorems (polarity is an involution, flips face lattice)</li>\n<li>normals, normal fan, normal equivalence</li>\n<li>basic operations yield polytopes: product, direct sum, join, Minkowski sum, projections, sections, convex hull</li>\n<li>standard polytopes: simplex, cube, crosspolytope</li>\n<li>polytope classes: simple, simplicial, centrally symmetric, zonotope, lattice, etc</li>\n<li>edge graph + basic theorems (connected, degree &gt;= d)</li>\n<li>trivial classification in dimensions 0,1,2</li>\n</ul>\n<p>Since this topic has come up now and again (<a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Main.20Theorem.20of.20Polytope.20Theory/with/482207185\">#Is there code for X? &gt; Main Theorem of Polytope Theory</a>, <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Minkowski-Weyl.20theorem.20and.20convexity/with/470169859\">#mathlib4 &gt; Minkowski-Weyl theorem and convexity</a>), we'd like to discuss people's ideas and needs regarding this.</p>\n<p>Some thoughts we had:</p>\n<ul>\n<li>We'd like the definition and theorems to be as general as possible and avoid inner products, norms or topologies as long as possible. It should be possible to talk about polyhedra over infinite dimensional spaces or spaces with unusual structure (Puiseux series, tropical semiring, hyperfields, lattices). Let us know if you have applications in mind that might be relevant to consider!</li>\n<li>Many interesting structural properties, like the existence of faces, face lattice and duality, can be proven for cones and then derived for polyhedra by projectivizing. This is usually done in the literature, because it makes the proofs much nicer. Since convex cones already exist in mathlib (and polyhedral cones apparently on the way? <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span>), this seems like a reasonable approach. It might be possible to get some of the results in an even more general setting (\"abstract\" convexity with no useful notion of projectivization), but the cone approach should cover the generalizations mentioned above. We'd like to hear your opinions on this!</li>\n<li>It is useful for polytopes/polyhedra to live in affine space, e.g. since proofs from discrete geometry often consider subsets of polyhedra that are again polyhedra in some subspace of the original domain, without a natural way to assign an origin. However, convexity is not (yet) defined for affine spaces in mathlib, and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> considers doing so to entail a significant amount of work to do properly. If we follow the cone approach above first, we will have some time to discuss and see what can be done about this.</li>\n</ul>",
        "id": 535715801,
        "sender_full_name": "ooovi",
        "timestamp": 1755879371
    },
    {
        "content": "<p>+1 for trying to avoid inner products and topology! That's what I've been trying to do for polyhedral cones in the Toric project. The main thing I did there was show that \"finitely generated = polyhedral\" in a completely algebraic setting, i.e. over linearly ordered fields. You need the order to speak about positivity and hence cones of course. You can find it <a href=\"https://github.com/YaelDillies/Toric/blob/master/Toric/Mathlib/Geometry/Convex/Cone/Polyhedral.lean\">here</a> but I have not upstreamed it to mathlib. Also, some work on faces (face of face is a face, face lattice...) has been done by <span class=\"user-mention\" data-user-id=\"431177\">@Giacomo Maletto</span> on a separate branch.</p>",
        "id": 535719596,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755880689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"883884\">@Matthew Johnson</span> and I worked out a naïve version of polytopes in <a href=\"https://github.com/leanprover-community/mathlib4/pull/23940\">#23940</a> and proved that they were preserved under a few basic operations like the Minkowski sum. Feel free to review the PR! For example, I don't know whether we should have two predicates: <code>IsVPolytope</code> and <code>IsHPolytope</code>, that agree only in finite dimensions.</p>",
        "id": 535719980,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755880838
    },
    {
        "content": "<p>By the way, do you have good references/books that treat cones and polytopes in the generality you're aiming for? I was struggling to find good ones, the ones I was looking at either omit proofs for the convex geometry stuff, or they do everything over the reals and start with hyperplane separation in euclidean space.</p>",
        "id": 535721173,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755881356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span>  I don't, and my feeling is we won't find any because most of convex/polyheral geometry cares deeply about real numbers. I am somewhat confident that proofs in polyhedral geometry will transfer without much effort to general linearly ordered fields. Beyond that we first need to clarify what generality we are aiming for. I believe Georg Loho mentioned a proof of Minkowski-Weyl in some tropical context, which works over a linearly ordered semiring, so some generalization might be possible.</p>",
        "id": 535755185,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755896357
    },
    {
        "content": "<p>Any chance we could get abstract polytopes somewhere along the line? That's actually the reason I started using Lean (before ordinals completely won me over...)</p>",
        "id": 535758537,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755898218
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"950805\">@Martin Winter</span> I agree most proofs should work for linearly odered fields. The best reference I could find was actually <a href=\"https://www.math.uni-tuebingen.de/user/hausen/KonvexePolyeder/konvexe-polyeder.pdf\">lecture notes by my supervisor</a> (in German). There he sets up the basic theory of polyhedral cones over general fields and the proofs are all algebraic. But it's pretty limited in scope. Maybe I should ask him if he knows better references.</p>",
        "id": 535759469,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755898741
    },
    {
        "content": "<p>I don't know what you mean by \"abstract convexity with no useful notion of projectivization\". Can you elaborate?</p>",
        "id": 535759685,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755898906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> One could define abstract polytopes independently as special types of lattices and later show that face lattices of convex polytopes are instances of abstract polytopes.</p>",
        "id": 535760009,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755899120
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> That's a great reference! Can you say what \"scope\" it lacks in your opinion?</p>",
        "id": 535760535,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755899468
    },
    {
        "content": "<p>I just mean it's not the most extensive reference depending on what your goals are, as it's basically an undergraduate course. But it does cover the basics quite well.</p>",
        "id": 535761068,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755899827
    },
    {
        "content": "<p>One reason I'm pushing for this algebraic approach is that I believe convex geometry should be an area where one could use Lean not only for formal proofs but also as a programming language for actual computations. So the theory should at least work over the rationals, which is where computations tend to work in.</p>",
        "id": 535761580,
        "sender_full_name": "Justus Springer",
        "timestamp": 1755900142
    },
    {
        "content": "<p>Also if a result doesn't hold over all ordered fields, maybe it holds over all real closed fields :)</p>",
        "id": 535777327,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1755917574
    },
    {
        "content": "<p>Surreal polyhedra sound both incredibly cursed and incredibly mundane</p>",
        "id": 535779890,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755921746
    },
    {
        "content": "<p>(in fact, is every convex polyhedron over a real-closed field isomorphic to one over ℝ?)</p>",
        "id": 535783894,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1755927423
    },
    {
        "content": "<p>Violeta and I wrote quite a fair bit of code about abstract polytopes in Lean 3. I could fetch that code when necessary.</p>",
        "id": 535784970,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755928812
    },
    {
        "content": "<p>To get the ball rolling, let me formulate my stance on what generality we should be aiming for. I have not much experience with the standards of mathlib, so I am happy to be educated on this.</p>\n<p>First, I do not insist in generality for its own sake. I think we should implement what is of obvious interest to the working mathematicians that uses polyhedra/polytopes, and then make it maximally general without the need to invent new mathematics. For example, polyhedral geometry over R is standard, and if it needs little effort to generalize to affine spaces over linearly ordered field without inner products or topoloy (which I believe is the case), then this is a lower bound of what we should go for. Some generality that is currently there and that bothers me a bit is that, say, the convex hull <code>convexHull k S</code> takes the field <code>k</code> as an explicit parameter. In my experience this generates friction, and I have never seen any use of this, either in mathlib or real life maths.</p>\n<p>Now, I am aware already from inside my own community that people care about settings that go beyond the above generality, e.g. tropical polytopes. Moreover, I personally also care about polytopes in spherical/hyperbolic space, and I don't yet know what would be the right setup that allows us to include those. Perhaps some sort of synthestic geometry backbone would be useful, where one can talk about hyperplanes, halfspaces, angles etc abstractly, and show that affine/spherical/hyperbolic polytopes are instances thereof. </p>\n<p>In any case, I think polyhedral cones are the first thing we should get right in the right generality. I hope we can collect here what is/can be interesting to the mathematician working with these concepts, and then figure out what is the right common generalization.</p>",
        "id": 535807315,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755956424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/535807315\">said</a>:</p>\n<blockquote>\n<p>Some generality that is currently there and that bothers me a bit is that, say, the convex hull <code>convexHull k S</code> takes the field <code>k</code> as an explicit parameter. In my experience this generates friction, and I have never seen any use of this, either in mathlib or real life maths.</p>\n</blockquote>\n<p>Interesting... I was the one to make that change several years. Isn't it necessary to consider <code>ℚ</code>-convex hulls sometimes? I also know that <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> wanted to do convex geometry over a space of germs (IIRC?) in sphere-eversion.</p>",
        "id": 535808371,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755957738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I though about precisely this when I first encountered the implementation. I could not think of a good reason to consider a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>-convex hull unless <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is already in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">Q</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\Bbb Q^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0158em;vertical-align:-0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span>. I can imagine someone working with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">Q</mi><mi>d</mi></msup><mo>∩</mo><mi mathvariant=\"normal\">conv</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Bbb Q^d\\cap \\operatorname{conv}(S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0158em;vertical-align:-0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">conv</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span>, but this is something different (unless <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><msup><mi mathvariant=\"double-struck\">Q</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">S\\subseteq\\Bbb Q^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0158em;vertical-align:-0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span>). Of course I cannot claim to have a complete overview of all potential usecases, but at least to me it feels unnatural to call this a convex hull since it has \"holes\" from the perspective of the ambient space.</p>",
        "id": 535815450,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755965655
    },
    {
        "content": "<p>I think your surprise/confusion might come from the assumption that a space in Lean \"knows\" what scalars it is a module over. This is very false, as eg all abelian groups are <code>ℤ</code>-modules, even the ones that already are <code>ℝ</code>-modules.</p>",
        "id": 535815591,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755965845
    },
    {
        "content": "<p>It isn't possible to write a <code>convexHull</code> function that somehow infers what scalars one should be talking about. The only option would be to fix the scalars once and for all, which was indeed the case before: scalars were fixed to be <code>ℝ</code> and one could not talk about the convex hull of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><msup><mi mathvariant=\"double-struck\">Q</mi><mi>d</mi></msup></mrow><annotation encoding=\"application/x-tex\">S \\subseteq \\mathbb Q^d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0158em;vertical-align:-0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 535815679,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755965968
    },
    {
        "content": "<p>But isn't this also just a design decision? For example, for my personal projects I defined a <code>VectorSpace</code> that \"knows\" its ground field and I defined convex hulls for sets in this <code>VectorSpace</code> which  then did no longer need the explicit reference to the field. I guess I also always wondered why a modul does not \"know\" its ring, even though they seem to do in everyday math. But then again, I personally don't really work with modules - but I work with vector spaces, and there it's true ;)</p>",
        "id": 535815684,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755965970
    },
    {
        "content": "<p>In commutative algebra, it is very often the case that one has <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module, and then it is very useful/necessary to view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module. This would be impossible with your design without jumping a few hoops.</p>",
        "id": 535816169,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1755966698
    },
    {
        "content": "<p>I can imagine that this was already discusse somewhere else: is it intended/necessary to carry this complexity over into parts of math that are increasingly distant from algebra? Would it be bad to define a <code>VectorSpace</code> (or some other bundled structure) and build geometry (convexity, polyhedra, etc) on that?</p>",
        "id": 535816970,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755967717
    },
    {
        "content": "<p>The burden of typing <code>ℚ</code> or <code>ℝ</code> is very low. This is what we need in order to develop a consistent mathematical library for all purposes. (Note that in mathlib, we also have categories of modules over a given ring <code>R</code>, <code>ModuleCat R</code>, and each <code>M : ModuleCat R</code> \"knows\" that it is a module over <code>R</code>. However, most of the developments about these bundled objects are based on the corresponding unbundled API for types equipped with structures, using the typeclass system, as <code>{M : Type*} [AddCommGroup M] [Module R M]</code>.)</p>",
        "id": 535857563,
        "sender_full_name": "Joël Riou",
        "timestamp": 1755974869
    },
    {
        "content": "<p>You can sometimes use custom or local notation to reduce cumbersome notation. \"Under the hood\", Lean still sees the extra argument, but you can avoid typing it.</p>",
        "id": 535863515,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1755982890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span> Is there some place in mathlib that does it this way? I would like to see how to do this properly.</p>",
        "id": 535866152,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755986834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> The burden might be low, but as far as my limited understanding goes right now, it might also be avoidable. Also, we want to have convexity on affine spaces next, and so I was hoping for bundled affine spaces as well, as otherwise we would need to write <code>convexHull k V A</code> I believe. And eventually all this complexity will be forwarded to polytopes, so we would need to write <code>Polytope k V A</code> rather than <code>Polytope A</code>.</p>\n<p>So would it be possible to develop geometry on <code>ModuleCat R</code>? It does not seem to be a typeclass, so maybe not what I was hoping for.</p>",
        "id": 535866488,
        "sender_full_name": "Martin Winter",
        "timestamp": 1755987435
    },
    {
        "content": "<p>I have at one point doing something polyhedron-related wanted to restrict scalars from <code>ℝ</code>-module to <code>NNReal</code>-module</p>",
        "id": 535867459,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755989059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Polyhedra.20in.20mathlib/near/535808371\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/535807315\">said</a>:</p>\n<blockquote>\n<p>Some generality that is currently there and that bothers me a bit is that, say, the convex hull <code>convexHull k S</code> takes the field <code>k</code> as an explicit parameter. In my experience this generates friction, and I have never seen any use of this, either in mathlib or real life maths.</p>\n</blockquote>\n<p>Interesting... I was the one to make that change several years. Isn't it necessary to consider <code>ℚ</code>-convex hulls sometimes? I also know that <span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> wanted to do convex geometry over a space of germs (IIRC?) in sphere-eversion.</p>\n</blockquote>\n<p>Yes talking about convex hulls is very natural when using partitions of unity and the ring of scalars is either a ring of functions or germs of functions. In particular it is an ordered ring that is not linearly ordered and does not embed in a field.</p>",
        "id": 535871959,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755996369
    },
    {
        "content": "<p>More generally I hope it is obvious that the notion of convexity is useful in areas of mathematics that have nothing to do with polyedras, so we should keep this in mind here.</p>",
        "id": 535872019,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755996481
    },
    {
        "content": "<p>About the extra parameters, we can always use custom elaborators if they become too annoying.</p>",
        "id": 535872050,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1755996529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  Thanks for the interesting use case. Since I don't understand the details I need to ask: do you use a <code>convexHull k S</code> where <code>k</code> is not the ground field of the module in which <code>S</code> lives?</p>",
        "id": 535874147,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756000434
    },
    {
        "content": "<p>As explained earlier in this thread, there is nothing like \"<em>the</em> ground field of the module in which S lives\". In my case it could be either real numbers or functions taking values in real numbers, or rational numbers or integers...</p>",
        "id": 535876383,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1756004036
    },
    {
        "content": "<p>I was about to mention custom elaborators: Patrick and I wrote one for differential geometry, in <a href=\"https://github.com/leanprover-community/mathlib4/pull/27021\">#27021</a>. This allows shortening e.g. <code>mfderiv I J f x</code> to <code>mfderiv f x</code> --- as I and J can be inferred from the types of f and x and the local context (without invoking typeclass inference too hard, i.e. in a manner that's not too slow).</p>",
        "id": 535889830,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756024650
    },
    {
        "content": "<p>Though the ground <em>field</em> probably isn't going to be the integers!</p>",
        "id": 535890893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756026208
    },
    {
        "content": "<p>Okay, here is my understanding so far. We keep explicit scalars in <code>convexHull k S</code> because we actually want them and there is not really a feasible way around them anyway. By extension, we will likely have explicit scalars in <code>PolyhedralCone k S</code> (and explicit scalars and vector spaces in <code>Polytope k V A</code> etc.). I don't see a use for these explicit parameters at this point, so here the reason is mainly the lack of a good alternative implementation.</p>\n<p>For ease of use one then provides a custom elaborator that makes the scalars (etc) implicit and infers them from the context somehow. Since this will need to be done for a lof of definitions, and since the usefulness is not specific to polyhedral/convex geometry, one should perhaps implement this more generally?</p>",
        "id": 535895603,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756033320
    },
    {
        "content": "<p>I understand where you're coming from --- but the elaborator itself is necessarily domain-specific. To write the model with corners one, you need to know which ones can be inferred sensibly (and which ones cannot, i.e. some understanding of the domain), and which part of the local context to get this from.</p>\n<p>There may be some common logic, but these data will be domain-specific.</p>",
        "id": 535895679,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756033497
    },
    {
        "content": "<p>I'm all ears for more general conveniences for everybody. But I don't see how this can be done without any domain knowledge.</p>",
        "id": 535895693,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756033528
    },
    {
        "content": "<p>(The diffgeo elaborators are also fairly short, so this is not a lot of code that would be duplicated.)</p>",
        "id": 535895705,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1756033547
    },
    {
        "content": "<p>Thanks for all the comments! :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/535719596\">said</a>:</p>\n<blockquote>\n<p>You can find it <a href=\"https://github.com/YaelDillies/Toric/blob/master/Toric/Mathlib/Geometry/Convex/Cone/Polyhedral.lean\">here</a> but I have not upstreamed it to mathlib.</p>\n</blockquote>\n<p>That looks like a great starting point for us! What is the course of action? Would it make sense to make it into a mathlib PR next, so we can use it in both our projects?</p>\n<blockquote>\n<p>Also, some work on faces (face of face is a face, face lattice...) has been done by <span class=\"user-mention silent\" data-user-id=\"431177\">Giacomo Maletto</span> on a separate branch.</p>\n</blockquote>\n<p>I can't seem to find this. Could you point me there maybe?</p>",
        "id": 536275689,
        "sender_full_name": "ooovi",
        "timestamp": 1756226163
    },
    {
        "content": "<p>Olivia and me went through <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span>'s implementation of polyhedral cones. I collect here some thoughts and questions:</p>\n<ol>\n<li>\n<p>Currently the code defines <code>IsPolyhedral p C</code>. I would really like to also have a bundled structure <code>PolyhedralCone R N p</code>, e.g. defined as <code>{C : PointedCone R N // IsPolyhedral p C}</code>. This would enable us to later work with polyhedral cones very naturally. For example, we could have the lattice of polyhedral cones, or if <code>C D : PolyhedralCone R N p</code> then <code>C ∩ D</code> and <code>C + D</code> are automatically treated as polyhedral cones as well.</p>\n</li>\n<li>\n<p>More generally, I was hoping to eventually have a very geometric language to work with. That is I would like to also have structures <code>Halfspace</code>, <code>Hyperplane</code>, <code>Ray</code>, etc rather than to always work with the underlying linear algebra. This would also help to unify concepts between Euclidean/spherical/hyperbolic space. One question is then how early one should start working with these structures. In my own implementation I first implemented <code>Halfspace R M p</code> and defined a polyhedral cone as the intersection of such.</p>\n</li>\n<li>\n<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  asked whether we eventually need both V and H polytopes as separate concepts. I tend to say no. Once V=H is established we know that we are dealing with a single notion of polytope and the V- and H-representations are only properties of them. There are people proving theorems about the relation and conversion between these representations, but I believe an interface that hides the implementation and allows access to both representations should still be totally sufficient. Problems may arise if one cares about cones/polytopes/polyhedra in settings where V=H does not hold. I don't, so I can't say much about this.</p>\n</li>\n<li>\n<p>More tangential, but is there any plan or opposition to implement bilinear pairings using type classes? I am thinking of something like <code>has_inner</code> but for pairs of modules, that is <code>has_bilinear_pairing</code> or so. I see modules with a bilinear pairing as a precursor to inner product spaces and normed spaces, which are treated using type classes. I don't know what is already implemented, but I imagine we eventually want that an inner product space is considered (via type class inference) to have a bilinear pairing with itself, don't we?</p>\n</li>\n</ol>",
        "id": 536285500,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756230192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"768262\">ooovi</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536275689\">said</a>:</p>\n<blockquote>\n<p>I can't seem to find this. Could you point me there maybe?</p>\n</blockquote>\n<p><a href=\"https://github.com/YaelDillies/Toric/blob/faces/Toric/Mathlib/Geometry/Convex/Cone/Faces.lean\">This file</a> can be a starting point. I have a feeling some of those proofs could be simplified though.</p>",
        "id": 536286996,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756230860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"950805\">@Martin Winter</span> </p>\n<ol>\n<li>Yes I think that makes sense.</li>\n<li>Agree. Note that the current definition of <code>IsPolyhedral</code> basically says the same thing as being the intersection of finitely many halfspaces. After all, a halfspace is just the dual of singleton set, so most API for halfspaces should probably be phrased more generally for duals. If we still want <code>Halfspace</code>, maybe as an <code>abbrev</code>?</li>\n<li>If I understand correctly, V=H is basically the polytope version of the statement that's already there for cones, namely that, finitely generated = polyhedral. The idea should be basically the same right? Namely some version of Fourier-Motzkin elimination. I agree an interface that hides the implementation would be sufficient for now. Down the line we could have a computational version of Fourier Motzkin that actually translates between V- and H-representations but that should be a different project from just getting the proof that there exists a way to translate between them.</li>\n<li>Maybe Yael has more to say about this, I think there was some concern mentioned about a possibly problematic instance <code>has_inner N M -&gt; has_inner M N</code>? Note that mathlib already has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PerfectPairing#doc\">docs#PerfectPairing</a>. This is a bit stronger as it already requires that the pairing is injective in both arguments.</li>\n</ol>",
        "id": 536289409,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756231850
    },
    {
        "content": "<p>I'm sorry I have left things in a bit of messy state. I never properly incorporated Giacomo's work on faces and never finished the new blueprint for the convex geometry part of Toric. You can find fragments of my blueprint work on <a href=\"https://github.com/YaelDillies/Toric/tree/justus/blueprint_convex\">this branch</a>, if you are interested. I'm in the middle of finishing my PhD thesis right now, so I won't be able to contribute much until that's done. After that, depending on my career position by then, I will either have very much time doing Lean, or no time at all. In the former case, I'd be very happy to do more on convex geometry.</p>",
        "id": 536290766,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756232397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"768262\">ooovi</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536275689\">said</a>:</p>\n<blockquote>\n<p>That looks like a great starting point for us! What is the course of action? Would it make sense to make it into a mathlib PR next, so we can use it in both our projects?</p>\n</blockquote>\n<p>As shown on <a href=\"https://yaeldillies.github.io/Toric/file_deps.pdf\">https://yaeldillies.github.io/Toric/file_deps.pdf</a>, there are some prerequisites before we can upstream <code>IsPolyhedral</code>. The current prerequisite PR is <a href=\"https://github.com/leanprover-community/mathlib4/pull/28140\">#28140</a>; feel free to review!</p>",
        "id": 536300512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756236957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536285500\">said</a>:</p>\n<blockquote>\n<p>is there any plan or opposition to implement bilinear pairings using type classes? I am thinking of something like <code>has_inner</code> but for pairs of modules, that is <code>has_bilinear_pairing</code> or so.</p>\n</blockquote>\n<p>This is not exactly what you were looking for, but as of recently we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.IsPerfPair#doc\">docs#LinearMap.IsPerfPair</a>, and this is what you should be using. The difference with what you're asking for is that we are not assuming that there is a single canonical bilinear pairing between <code>M</code> and <code>N</code>, and instead you should declare that such an already-declared pairing is perfect.</p>",
        "id": 536301126,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756237188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> </p>\n<blockquote>\n<p>Agree. Note that the current definition of <code>IsPolyhedral</code> basically says the same thing as being the intersection of finitely many halfspaces. </p>\n</blockquote>\n<p>Yes, mathematically it is equivalent, but ...<br>\nI do find it a bit awkward that <code>isPolyhedral</code> (and  therefore a <code>PolyhedralCone</code> defined on it) takes a bilinear pairing as an argument. There is another way: we can define a <code>Halfspace</code> as the preimage of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0,\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> under a non-constant linear form (and I actually  think there is a good reason to allow constant linear forms as well). This requires no pairing. And so a polyhedral cone defined as the intersection of such halfspaces also requires  no pairing. We should then be able to prove all the things you proved, getting a pairings involved only when we explicitly say something about duality.</p>",
        "id": 536308694,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756240670
    },
    {
        "content": "<p>Okay but the preimage of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0,\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> under a linear form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi><mo>:</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi : N \\to \\mathbb{K}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">K</span></span></span></span> is by definition the same as the dual of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>φ</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{\\varphi\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">φ</span><span class=\"mclose\">}</span></span></span></span>, where we view <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>φ</mi></mrow><annotation encoding=\"application/x-tex\">\\varphi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">φ</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> and take the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>φ</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mi>φ</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N^* \\times N \\to \\mathbb{K}, (\\varphi, v) \\mapsto \\varphi(v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">φ</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">φ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span>. Working with an arbitrary pairing is more flexible, as it also works in situations where the two vector spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> are dual to each other, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not defeq to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> for instance.</p>",
        "id": 536311317,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756241856
    },
    {
        "content": "<p>Of course, it is true that the predicate <code>IsPolyhedral</code> does not depend on the pairing, which is evident by the fact that it's shown to be equivalent to <code>Submodule.FG</code>, which doesn't depend on it. So you could simply define your structure <code>PolyhedralCone</code> by using <code>Submodule.FG</code> and then there is no pairing any more.</p>",
        "id": 536312514,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756242432
    },
    {
        "content": "<p>Now that I think about it, maybe for the predicate <code>IsPolyhedral</code>, it's okay to define it with respect to the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi></mrow><annotation encoding=\"application/x-tex\">N^* \\times N \\to \\mathbb{K}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">K</span></span></span></span> only. For the <code>dual</code> function (as well as <code>Halfspace</code>, being a special case), I still think we should allow more flexibility by having an arbitrary pairing as input.</p>",
        "id": 536313010,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756242657
    },
    {
        "content": "<p>I tend to agree that <code>dual</code> should have this flexibility.</p>\n<p>I am not so sure about <code>Halfspace</code>. Using linear forms, the statement whether a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">S\\subseteq M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a halfspace is of the form <em>\"there exists a linear form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">\\phi:M\\to\\Bbb k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span> so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><msup><mi>ϕ</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S=\\phi^{-1}([0,\\infty))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ϕ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">([</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">))</span></span></span></span>\"</em>. If I want to express this using general pairings, the analogue would be <em>\"there exists a module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, a pairing between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo>:</mo><mi>N</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\phi:N\\to (M\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>, and a point <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">x\\in N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> so that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S=(\\phi(x))^{-1}([0,\\infty))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">([</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">))</span></span></span></span>\"</em>. So the pairing is still not a parameter of a halfspace, but the statement just became more complicated.</p>",
        "id": 536316629,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756244654
    },
    {
        "content": "<p>I think I understand now that we may have different intentions for what <code>Halfspace</code> expresses. For me a halfspace is a particular kind of subset of space, whereas you seem to see it as a subset of the paired space bundled with the primal point it is constructed from. This would be in contrast to how you defined polyhedral cones, which don't \"remember\" the points that generate them. Or am I misunderstanding something?</p>",
        "id": 536318131,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756245637
    },
    {
        "content": "<p>I am now wondering what we actually gain by letting <code>dual</code> depend on a pairing.<br>\nLet the <em>canonical dual</em> be the dual w.r.t. the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>p</mi><mo>~</mo></mover><mo>:</mo><mi>N</mi><mo>→</mo><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mo>∗</mo></msup><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tilde p:N\\to (N^*\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6679em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">p</span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">~</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>. It is a cone in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>=</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">N^*=N\\to\\Bbb k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span>. Now, if we take a different pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>N</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p:N\\to (M\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>, then I think I just conviced myself that the dual w.r.t. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> (which is a cone in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>) is just the preimage of the canonical dual under the flipped pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mo>∗</mo></msup><mo>:</mo><mi>M</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p^*:M\\to (N\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8831em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>. So we don't gain any extra generality by including the pairing, but we now have to carry around this extra parameter.</p>",
        "id": 536327499,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756251752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536313010\">said</a>:</p>\n<blockquote>\n<p>Now that I think about it, maybe for the predicate <code>IsPolyhedral</code>, it's okay to define it with respect to the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi></mrow><annotation encoding=\"application/x-tex\">N^* \\times N \\to \\mathbb{K}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">K</span></span></span></span> only. For the <code>dual</code> function (as well as <code>Halfspace</code>, being a special case), I still think we should allow more flexibility by having an arbitrary pairing as input.</p>\n</blockquote>\n<p>Perfectly agreed <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span></p>",
        "id": 536351799,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756274500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536327499\">said</a>:</p>\n<blockquote>\n<p>Let the <em>canonical dual</em> be the dual w.r.t. the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>p</mi><mo>~</mo></mover><mo>:</mo><mi>N</mi><mo>→</mo><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mo>∗</mo></msup><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tilde p:N\\to (N^*\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6679em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">p</span></span><span style=\"top:-3.35em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">~</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>. It is a cone in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>=</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi></mrow><annotation encoding=\"application/x-tex\">N^*=N\\to\\Bbb k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">k</span></span></span></span>. Now, if we take a different pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>N</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p:N\\to (M\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>, then I think I just conviced myself that the dual w.r.t. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> (which is a cone in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>) is just the preimage of the canonical dual under the flipped pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>p</mi><mo>∗</mo></msup><mo>:</mo><mi>M</mi><mo>→</mo><mo stretchy=\"false\">(</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p^*:M\\to (N\\to\\Bbb k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8831em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">k</span><span class=\"mclose\">)</span></span></span></span>. So we don't gain any extra generality by including the pairing, but we now have to carry around this extra parameter.</p>\n</blockquote>\n<p>The point is that for example you can now talk about the double dual cone as a subset of the original space, while the double <em>canonical</em> dual cone would live in the double dual.</p>",
        "id": 536351938,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756274584
    },
    {
        "content": "<p>It's true we don't gain any generality in a mathematical sense. After all, for any pair of vector spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> with a perfect pairing, we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>≅</mo><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">M \\cong N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. But we gain flexibility in Lean, as it might happen that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not definitionally equal to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. If we only allow the \"canonical\" dual, we would then have to carry around the isomorphism all the time, as in the example with the double dual Yael mentions.</p>",
        "id": 536353155,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756275332
    },
    {
        "content": "<p>Another example comes from toric geometry: To an algebraic torus <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, one associates the lattices <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>→</mo><msup><mi mathvariant=\"double-struck\">K</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">T \\to \\mathbb{K}^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">K</mi><mo>∗</mo></msup><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{K}^* \\to T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> (characters and one-parameter subgroups). These are dual to each other, but one is not <em>definitionally equal</em> to the dual of the other. But we still would like to be able to say that the dual of a cone in the characters lattice lives in the lattice of one-parameter subgroups, without carrying around an isomorphism.</p>",
        "id": 536353672,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756275693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> In my understanding the double-dual cone should really live in the double-dual space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mrow><mo>∗</mo><mo>∗</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">N^{**}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗∗</span></span></span></span></span></span></span></span></span></span></span></span>. Considering it as a cone in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is a trick we can pull if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>≅</mo><msup><mi>N</mi><mrow><mo>∗</mo><mo>∗</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">N\\cong N^{**}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗∗</span></span></span></span></span></span></span></span></span></span></span></span>. So yes, by default the dual is not an involution, but why should it be if duality on the space itself is not an involution. And if there is a perfect pairing we get the double-dual in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> by post-composing with the canonical isomorphism <code>p</code>.<br>\nSo for example, if you want to express</p>\n<p><code>dual p.flip (dual p C) = C</code></p>\n<p>you now instead write:</p>\n<p><code>dual (dual C) = p C</code></p>",
        "id": 536371956,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756283734
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> Regarding carriying around additional isomorphisms: yes, if you want your cone to live not in the canonical dual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> but a space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that is (non-canonically) isomorphic to it, you have to carry around this isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>≅</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">N^*\\cong M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>. But you have to do this anyway in the form of a pairing. And the only difference is that now we also have to state the pairing explicitly even if we only care about the canonical dual.</p>",
        "id": 536371985,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756283742
    },
    {
        "content": "<p>I might be missing the real usecase here, but so far I am not conviced. My feeling is that by including the pairing in <code>dual</code> we incorporate functionality that is really external to it for the cost of convoluting the interface. </p>\n<p>Let me stress my point by compare it to something obviously ridiculous: the inverse of a bijection <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> lives (canonically) in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>. But maybe we want to work instead with a space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> non-canonically isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">B\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> via an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>M</mi><mo>≃</mo><mo stretchy=\"false\">(</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">p: M\\simeq (B\\to A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>. To me the current situation reads like you want to include <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> as a parameter to <code>Function.invFun</code> because it is useful sometimes and more convenient than just post-composing with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>.</p>",
        "id": 536372006,
        "sender_full_name": "Martin Winter",
        "timestamp": 1756283749
    },
    {
        "content": "<p>Probably an useless remark, but I wish to mention that duality can work in both directions: a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">M^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> both an orthogonal in the bidual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo>∗</mo><mo>∗</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{**}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∗∗</span></span></span></span></span></span></span></span></span></span></span></span> and a pre-orthogonal in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 536387056,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1756289188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"950805\">@Martin Winter</span> it's kind of a \"formalisation philosophy\" that one should have as many types as possible, and predicates relating them, rather than sticking to concrete constructions. For example we had <code>Localization R S</code> in commutative algebra to localise a commutative ring R by a multiplicative subset S (a concrete construction) and then when we tried to prove that an affine scheme was a scheme (i.e. that O_X was a sheaf on Spec(R)) we ran into all sorts of unexpected problems, documented in the <a href=\"https://www.tandfonline.com/doi/full/10.1080/10586458.2021.1983489\">Schemes in Lean</a> paper. The fix was to introduce another type A and a predicate <code>IsLocalization R S A</code> saying that A was isomorphic to R[1/S] and then things were much better. In formalization in general, more general seems to be more helpful. Although I haven't read this thread carefully, it seems to be another instance of the same phenomenon.</p>",
        "id": 536431550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756304357
    },
    {
        "content": "<p>To your ridiculous example, let me counter that with a non-ridiculous one: In commutative algebra, Mathlib uses a predicate <code>IsLocalization (M : Submonoid R) S</code> to express the fact that <code>S</code> is isomorphic to the localization of <code>R</code> at <code>M</code>. Of course, one could instead just work with the \"canonical model\" of localization, which can be constructed explicitly as a subring of the field of fractions etc... So you might say, why do we need the predicate since it doesn't add any generality and we could just work with the canonical model instead. It turned out that with the way <code>IsLocalization</code> is defined (it's three very explicit properties of the algebra map) makes it a lot more convenient to work with, as you don't have to worry about composing with the correct isomorphisms everywhere. Instead, you apply all the localization API directly to any user-provided <code>R</code>-algebra, provided you show it satisfies the <code>IsLocalization</code> property. Kevin likes to tell this story a lot.</p>\n<p>Now, the situation for us is of course a bit different: First, our pairing is <em>data</em> and not a predicate (I don't know how much of a difference that makes, but it's a difference). Second, having a perfect pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>:</mo><mi>N</mi><mo>×</mo><mi>M</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi></mrow><annotation encoding=\"application/x-tex\">p : N \\times M \\to \\mathbb{K}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">K</span></span></span></span> is much closer to having the actual isomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>≅</mo><msup><mi>M</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">N \\cong M^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>≅</mo><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">M \\cong N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> already (it's just a matter of currying and swapping the arguments of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>). This was different to the <code>IsLocalization</code> predicate, where the three axioms do imply the existence of such an isomorphism, but the way to get there is arguably a bit more complicated. In particular, checking the axioms tend to be easier than constructing the isomorphism, hence reduces complexity for the user.</p>\n<p>But I would still argue that there is <em>some</em> difference between having a pairing and having an isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>≅</mo><msup><mi>N</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">M \\cong N^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>. Namely, a pairing feels a lot more symmetric than the isomorphism. With a pairing, you don't have a bias towards one lattice or the other. With an isomorphism, you tend to view one lattice as your \"actual\" lattice whose elements are points, and the other one as its dual, whose elements are linear maps. I would like to have a world where we treat them both equally. And this is indeed what a lot of informal references tend to do as well when they say \"Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be mutually dual lattices/vector spaces\". Specifically in toric geometry, some people prefer to view certain concepts in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>-lattice, and others in the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>-lattice.</p>\n<p>Of course, once you leave finite dimension, duality is no longer an involution as you say, and some people will still want to do convex geometry in this setting. I'm under the impression that these people are more likely to come from an analysis/functional analysis background, where they work over the reals again and do Hahn-Banach hyperplane separation and what not. So in a sense, I think this should be a different theory and there has been some discussion over how to provide a common interface for both. Right now, this is also the theory that's predominant in Mathlib. In my world, I only care about polyhedral cones and polytopes in finite dimensional vector spaces and this is the setting I would like to have an algebraic theory for, which would then be amenable for computations.</p>",
        "id": 536431680,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756304387
    },
    {
        "content": "<p>I was literally just about to post this and Kevin posted a second earlier <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 536431801,
        "sender_full_name": "Justus Springer",
        "timestamp": 1756304416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536431680\">said</a>:</p>\n<blockquote>\n<p>Kevin likes to tell this story a lot.</p>\n</blockquote>\n<p>You're not wrong!</p>",
        "id": 536450733,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756309777
    },
    {
        "content": "<p>(it's a good story)</p>",
        "id": 536452180,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1756310261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536431680\">said</a>:</p>\n<blockquote>\n<p>Now, the situation for us is of course a bit different: First, our pairing is <em>data</em> and not a predicate (I don't know how much of a difference that makes, but it's a difference).</p>\n</blockquote>\n<p>For another analogy: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IsAdjoinRoot.html#IsAdjoinRoot\"><code>IsAdjoinRoot S (f : R[X])</code></a>, which just means <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><msub><mo>≅</mo><mi>R</mi></msub><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">S\\cong_RR[X]/(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≅</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span>,  is data and not just a predicate -- it contains the data of where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> goes.</p>",
        "id": 536453312,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1756310629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/536313010\">said</a>:</p>\n<blockquote>\n<p>Now that I think about it, maybe for the predicate <code>IsPolyhedral</code>, it's okay to define it with respect to the canonical pairing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>N</mi><mo>∗</mo></msup><mo>×</mo><mi>N</mi><mo>→</mo><mi mathvariant=\"double-struck\">K</mi></mrow><annotation encoding=\"application/x-tex\">N^* \\times N \\to \\mathbb{K}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.772em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">K</span></span></span></span> only.</p>\n</blockquote>\n<p>I have just changed <code>IsPolyhedral</code> accordingly in Toric: <a href=\"https://github.com/YaelDillies/Toric/commit/3f53c491fce2b6f0651f46653ecd2ea17e53d706\">https://github.com/YaelDillies/Toric/commit/3f53c491fce2b6f0651f46653ecd2ea17e53d706</a></p>",
        "id": 536570029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756374336
    },
    {
        "content": "<p>Since our last messages here Olivia and me made significant progress on polyhedral cones. A particular problem came up that I hope someone can help with.</p>\n<p>Our current theory is developed <em>explicitly</em> without the assumumption of finite dimension. The reason is that there are many interesting things that can (and should) be said in this generality. Consider for example the statements <code>(C ⊓ D).FG</code> or <code>dual p.flip (dual p C)) = C</code> for when <code>C</code> and <code>D</code> are finitely generated cones. Previously this was proven under the assumption <code>Module.Finite</code>, which felt off. This is now no longer necessary.</p>\n<p>Now the problem: for <code>dual p.flip (dual p C)) = C</code> we currently assume <code>p.IsPerfPair</code>. But this defies the purpose, since it implies that we are in finite dimensions after all. If you look closely, the proof only needs <code>Surjective p.flip</code>. This is especially problematic for <code>(C ⊓ D).FG</code> which does not even mention a bilinear pairing; yet, the proof works via duality, hence needs to choose one. This particular proof (and also the rest of the theory) works fine with choosing <code>p := Dual.eval R M</code>, for which <code>p.flip</code> is indeed surjective, but not a perfect pairing in general.</p>\n<p>To fix this I could replace <code>[p.IsPerfPair]</code> by  <code>(hp : Surjective p.flip)</code> everywhere. But my impression was that <code>IsPerfPair</code> was introduced as a typeclass precisely for the reason so that we do not have to carry around the bijectivity assumotions explicitly all the time. </p>\n<p><strong>My question:</strong> can we have surjectivity (in the case for bilinear pairing) as a typeclass as well, or how else would you resolve the situation above?</p>",
        "id": 544532577,
        "sender_full_name": "Martin Winter",
        "timestamp": 1760356836
    },
    {
        "content": "<p>what is the type of <code>p.flip</code>?</p>",
        "id": 544534207,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760357185
    },
    {
        "content": "<p><code>p : N →ₗ[R] M →ₗ[R] R</code> for some modules <code>M</code> and <code>N</code> over <code>R</code>.</p>",
        "id": 544534404,
        "sender_full_name": "Martin Winter",
        "timestamp": 1760357238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/544532577\">said</a>:</p>\n<blockquote>\n<p>can we have surjectivity (in the case for bilinear pairing) as a typeclass as well</p>\n</blockquote>\n<p><code>[Fact (Function.Surjective p.flip)]</code> if you really need it</p>",
        "id": 544534670,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760357310
    },
    {
        "content": "<p>don't use Fact for everything, that's the only warning label that comes with it</p>",
        "id": 544534723,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760357324
    },
    {
        "content": "<p>Interesting! I have to ask: is this a good longer-term solution or should I see this as a temporary fix? </p>\n<p>I also need this \"Fact\" to be inferred from certain assumptions automatically. For example, from <code>IsPerfPair</code>, or from <code>p := Dual R M</code>. I will then go on to implement the corresponding instances with it, alright?</p>",
        "id": 544534955,
        "sender_full_name": "Martin Winter",
        "timestamp": 1760357396
    },
    {
        "content": "<p>yeah</p>",
        "id": 544539638,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760358582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950805\">Martin Winter</span> <a href=\"#narrow/channel/116395-maths/topic/Polyhedra.20in.20mathlib/near/544534955\">said</a>:</p>\n<blockquote>\n<p>is this a good longer-term solution or should I see this as a temporary fix?</p>\n</blockquote>\n<p>as long as that is the only thing you put inside Fact and you don't expand its scope then it's fine</p>",
        "id": 544539728,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760358606
    },
    {
        "content": "<p>What do people think about renaming <code>PointedCone.span</code> to <code>PointedCone.hull</code> (or something like this) to distinguish from <code>Submodule.span</code> which is still very important in the theory of cones and can get confusing if both are used.</p>",
        "id": 546427339,
        "sender_full_name": "Martin Winter",
        "timestamp": 1761131346
    },
    {
        "content": "<p>I am not against it</p>",
        "id": 546436655,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1761133669
    },
    {
        "content": "<p>I should note: we still want to use lemmas named with <code>span</code> for statements about <code>hull</code>, which we can but is harder to look up. Is this a concern?</p>",
        "id": 546437140,
        "sender_full_name": "Martin Winter",
        "timestamp": 1761133809
    },
    {
        "content": "<p>As a quick update: we now have a working definition of polyhedral cone in vector spaces over general fields, with no assumption of topology, and in potentially infinite dimensional space. Some non-trivial results that are already proven include that polyhedral cones are closed under intersection and duality.</p>",
        "id": 554933383,
        "sender_full_name": "Martin Winter",
        "timestamp": 1762873163
    },
    {
        "content": "<p>We also built some theory of faces of general pointed cones (see also <a href=\"#narrow/channel/116395-maths/topic/Faces.20of.20Cones/with/554135179\">here</a>), and one of the next tasks is to show that polyhedral cones have finitely many faces and that their faces are again polyhedral and form a lattice with nice properties. This will likely also involve proving some Krein-Milman version for polyhedral cones.</p>",
        "id": 554934117,
        "sender_full_name": "Martin Winter",
        "timestamp": 1762873331
    },
    {
        "content": "<p>This means it is also time to check in how far our code works well with the abstract polytopes code by <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> and <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>. That is, the goal would be to show that our face lattice is an abstract polytope in this sense.</p>",
        "id": 554935745,
        "sender_full_name": "Martin Winter",
        "timestamp": 1762873757
    },
    {
        "content": "<p>I don't believe we ever really finished that much code? I'd be willing to come back to this project, but it has been quite a long while since I last worked with this.</p>",
        "id": 556650327,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1763259338
    },
    {
        "content": "<p>I replied in DMs with Martin that the abstract polytope stuff that was high enough quality for mathlib has already been PRed, and that the rest should probably be redone</p>",
        "id": 556664188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1763276492
    },
    {
        "content": "<p>we just opened the first mathlib PR, adding the face lattice of a pointed cone :D<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/33664\">https://github.com/leanprover-community/mathlib4/pull/33664</a></p>",
        "id": 566539482,
        "sender_full_name": "ooovi",
        "timestamp": 1767704523
    },
    {
        "content": "<p>We are slowly PRing towards duality theory. I just finished the first two substantial PRs:</p>\n<ul>\n<li>\n<p>co-finitely generated submodules: <br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/34006\">https://github.com/leanprover-community/mathlib4/pull/34006</a></p>\n</li>\n<li>\n<p>duality operator for submodule: <br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/34007\">https://github.com/leanprover-community/mathlib4/pull/34007</a></p>\n</li>\n</ul>\n<p>And there are more auxiliary PRs that will be needed later on:</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33901\">https://github.com/leanprover-community/mathlib4/pull/33901</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33924\">https://github.com/leanprover-community/mathlib4/pull/33924</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33980\">https://github.com/leanprover-community/mathlib4/pull/33980</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33986\">https://github.com/leanprover-community/mathlib4/pull/33986</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33993\">https://github.com/leanprover-community/mathlib4/pull/33993</a></li>\n</ul>",
        "id": 568310859,
        "sender_full_name": "Martin Winter",
        "timestamp": 1768510852
    },
    {
        "content": "<ul>\n<li>co-finitely generated submodules: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34006\">#34006</a></li>\n</ul>",
        "id": 568368212,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546549
    },
    {
        "content": "<ul>\n<li>duality operator for submodule: <a href=\"https://github.com/leanprover-community/mathlib4/pull/34007\">#34007</a></li>\n</ul>",
        "id": 568368238,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546560
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33901\">#33901</a></li>\n</ul>",
        "id": 568368264,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546575
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33924\">#33924</a></li>\n</ul>",
        "id": 568368304,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546587
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33980\">#33980</a></li>\n</ul>",
        "id": 568368317,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546591
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33986\">#33986</a></li>\n</ul>",
        "id": 568368324,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546595
    },
    {
        "content": "<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib4/pull/33993\">#33993</a></li>\n</ul>",
        "id": 568368332,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546600
    },
    {
        "content": "<p>This way, the emoji reacts can be useful</p>",
        "id": 568368365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1768546619
    },
    {
        "content": "<p>Next steps require some further typeclass support for bilinear forms. This PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/34487\">#34487</a>) is a draft. I would appreciate input <a href=\"#narrow/channel/287929-mathlib4/topic/Typeclass.20instances.20for.20separating.20bilinear.20forms/with/570348517\">here</a>. Let me know if you like to see more background on why this is needed.</p>",
        "id": 570349218,
        "sender_full_name": "Martin Winter",
        "timestamp": 1769527338
    },
    {
        "content": "<p>The current bottleneck is <code>Submodule.dual</code>. I appreciate feedback at <a href=\"#narrow/channel/287929-mathlib4/topic/Unifying.20.60Submodule.2Edual.60.20and.20.60Submodule.2EorthogonalBilin.60\">#mathlib4 &gt; Unifying &#96;Submodule.dual&#96; and &#96;Submodule.orthogonalBilin&#96;</a>.</p>",
        "id": 571291442,
        "sender_full_name": "Martin Winter",
        "timestamp": 1769956686
    },
    {
        "content": "<ul>\n<li>coercion <code>Submodule</code> --&gt; <code>PointedCone</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35308\">#35308</a></li>\n</ul>",
        "id": 573982536,
        "sender_full_name": "Martin Winter",
        "timestamp": 1771167576
    },
    {
        "content": "<ul>\n<li>useful lemmas for <code>PointedCone.dual</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/35323\">#35323</a></li>\n</ul>",
        "id": 573982556,
        "sender_full_name": "Martin Winter",
        "timestamp": 1771167595
    }
]