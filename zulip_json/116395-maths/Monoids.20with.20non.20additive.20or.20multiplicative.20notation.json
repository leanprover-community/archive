[
    {
        "content": "<p>Is there anyway to use monoid theorems and lemmas for a monoid that doesn't use additive or multiplicative notation or does everything need to be reproved? </p>\n<p>My specific use case is that the SFinite measures on a monoid should form a monoid under measure convolution (defined <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Group/Convolution.html#MeasureTheory.Measure.mconv\">here</a>). Note that additive notation is taken by setwise sum of measures. </p>\n<p>I would like to be able to define notation for the equivalent of <code>Finset.prod</code> and then use all the results for it.</p>",
        "id": 522991590,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749405564
    },
    {
        "content": "<p>You can make a local instance of monoid</p>",
        "id": 522991702,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749405679
    },
    {
        "content": "<p>How have you decided to talk about the <em>type</em> of s-finite measures?</p>",
        "id": 522991819,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749405777
    },
    {
        "content": "<p>That's a good point. I hadn't thought of this detail. For my purposes it would suffice to define this on the type <code>ProbabilityMeasure</code> but this doesn't seem ideal. </p>\n<p>I don't yet have a very good intuition for these type theory considerations. Perhaps to be even more specific if I want to state and prove facts like: the convolution of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> Gaussians is a Gaussian or the law of the sum of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> independent random variables is the convolution of their laws, how would I best go about this?</p>",
        "id": 522992443,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749406454
    },
    {
        "content": "<p>Naïvely, I think you want to define an analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.prod#doc\">docs#Finset.prod</a> for the convolution. The approach you envision of reusing <code>Finset.prod</code> would only work if you were working on a type of measures where all convolutions make sense. This goes against the basic design decision we've made in measure theory to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure#doc\">docs#MeasureTheory.Measure</a> as much as possible.</p>",
        "id": 522992583,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749406626
    },
    {
        "content": "<p>Well its convolution is always defined, its just not a monoid (and infact I just realized that <a href=\"http://Finset.prod\">Finset.prod</a> assumes its a CommMonoid which I did not realize previously). How does one state theorems like this in a non commutative monoid even?</p>",
        "id": 522992898,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749407086
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.noncommProd#doc\">docs#Finset.noncommProd</a>, which is somewhat unwieldy as it requires you to pass around a proof that the elements you take a product over all commute</p>",
        "id": 522992976,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749407181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/522992898\">said</a>:</p>\n<blockquote>\n<p>I just realized that <a href=\"http://finset.prod/\">Finset.prod</a> assumes its a CommMonoid</p>\n</blockquote>\n<p>Indeed, that's the whole issue: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.mconv_comm#doc\">docs#MeasureTheory.Measure.mconv_comm</a> only holds for s-finite measures</p>",
        "id": 522993112,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749407334
    },
    {
        "content": "<p>Well associativity as well but I didn't even want to assume even commutative. </p>\n<p>As an application (way down the line) if you want to study random walks on groups you use the fact the distribution of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">X_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is given by the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> convolution power of the step distribution.</p>",
        "id": 522993715,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749407964
    },
    {
        "content": "<p>Ah I realized I am being imprecise and need to take something ordered instead  of <code>finset</code> for that to make sense</p>",
        "id": 522993974,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749408311
    },
    {
        "content": "<p>So if I have <code>X : Fin n → M</code> where <code>M</code> is a non-commutative monoid is there a concise way to express <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>X</mi><mn>1</mn></msub><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><msub><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">X_0 * X_1 ... X_{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">...</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span> currently?</p>",
        "id": 522994099,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749408480
    },
    {
        "content": "<p>Do a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.prod#doc\">docs#List.prod</a> with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.finRange#doc\">docs#List.finRange</a></p>",
        "id": 522994115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749408503
    },
    {
        "content": "<p>via Lists</p>",
        "id": 522994116,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749408503
    },
    {
        "content": "<p>So I guess perhaps the best approach is to define <code>List.conv</code>? And you say for example the law of the product of a list of random variables is equal to <code>List.conv</code> of their laws?</p>",
        "id": 522994332,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749408781
    },
    {
        "content": "<p>But are you going to take the convolution of non s-finite measures?</p>",
        "id": 522994472,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749408936
    },
    {
        "content": "<p>This is what I had in mind.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mconv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ₁</span><span class=\"w\"> </span><span class=\"n\">μ₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Measure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">μ₁</span><span class=\"w\"> </span><span class=\"bp\">∗ₘ</span><span class=\"w\"> </span><span class=\"n\">μ₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It won't be well-behaved for non s-Finite measures but its defined.</p>",
        "id": 522994903,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749409414
    },
    {
        "content": "<p>I strongly advise you take <code>s : Finset ι</code> + <code>μ : ι → Measure Ω</code> in instead of <code>l : List (Measure Ω)</code> (you can recover <code>l</code> as <code>s.toList.map μ</code>, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.toList#doc\">docs#Finset.toList</a>). This is much more ergonomic in practice</p>",
        "id": 522995253,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749409910
    },
    {
        "content": "<p>Sorry I am confused. Are you suggesting I essentially do just define an analogue of <code>Finset.prod</code> that works for convolution from scratch? Or just define this as an API on top of the <code>List.mconv</code> definition? The former doesn't work if I want to include non commutative monoids.</p>",
        "id": 522995841,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749410616
    },
    {
        "content": "<p>I just (for the first time) looked at the definition of <code>Finset.prod</code> and it appears to reduce down to folding on lists too anyway. So I guess you just mean there should be an API for Finsets?</p>",
        "id": 522995930,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749410724
    },
    {
        "content": "<p>Oh I see, you really care about non-commutative monoids. In that case yes you should use lists</p>",
        "id": 522996147,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1749410945
    },
    {
        "content": "<p>maybe you could write a type synonym</p>",
        "id": 523007204,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749426967
    },
    {
        "content": "<p>Is it common to take elementwise products and convolutive products at the same time? Is it common to take elementwise products and convolutive products at the same time?</p>",
        "id": 523007285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749427108
    },
    {
        "content": "<p>We solve this elsewhere by having Finsupp for pointwise multiplication vs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidAlgebra#doc\">docs#AddMonoidAlgebra</a> to enable multiplication-as-convolution, since it's very rare to have both in the same statement.</p>",
        "id": 523007308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749427141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/523007285\">said</a>:</p>\n<blockquote>\n<p>Is it common to take elementwise products and convolutive products at the same time? Is it common to take elementwise products and convolutive products at the same time?</p>\n</blockquote>\n<p>Most likely no so this seems promising to me (it will take me sometime to understand whats going on here though).</p>",
        "id": 523077922,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749470597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/523007285\">said</a>:</p>\n<blockquote>\n<p>Is it common to take elementwise products and convolutive products at the same time? Is it common to take elementwise products and convolutive products at the same time?</p>\n</blockquote>\n<p>What about  the Fourier transform of a convolution product of two integrable functions , which is the product of their Fourier transforms?</p>",
        "id": 523274116,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1749556876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/523274116\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/523007285\">said</a>:</p>\n<blockquote>\n<p>Is it common to take elementwise products and convolutive products at the same time? Is it common to take elementwise products and convolutive products at the same time?</p>\n</blockquote>\n<p>What about  the Fourier transform of a convolution product of two integrable functions , which is the product of their Fourier transforms?</p>\n</blockquote>\n<p>For my purposes here this is not  an issue since I want to take convolution of measures and their Fourier Transforms are functions. If you want to do the same thing for functions it may be problematic.</p>",
        "id": 523277551,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749557930
    },
    {
        "content": "<p>I think there may still however be cases where this comes up, say convolution with a mixture distribution. However I assume they are relatively rare.</p>",
        "id": 523278756,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1749558301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"223948\">David Ledvinka</span> <a href=\"#narrow/channel/116395-maths/topic/Monoids.20with.20non.20additive.20or.20multiplicative.20notation/near/523277551\">said</a>:</p>\n<blockquote>\n<p>If you want to do the same thing for functions it may be problematic.</p>\n</blockquote>\n<p>Some people might want to do this, yes…</p>",
        "id": 523292340,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1749562134
    }
]