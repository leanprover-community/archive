[
    {
        "content": "<p>Is it in fact true that <code>Quiv.{v, u}</code> -- the category of graphs with vertices in <code>Type u</code> and hom-types all in <code>Type v</code>, i.e. \"<code>u</code>-small and locally <code>v</code>-small\", with <code>v</code> not necessarily equal to <code>u</code> -- has all colimits? </p>\n<p>Let's name the property \"<code>u</code>-small  and locally <code>v</code>-small\" as <code>EssentiallySmall.{v, u}</code>. (Whether or not we should actually change <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.EssentiallySmall#doc\">docs#CategoryTheory.EssentiallySmall</a> is a separate question, I just need a short name.) Let's describe <code>Quiv.{v, u}</code> as a full subcategory of the functor category from the usual underlying site to <code>Type max v u</code>; we shall refer to that site as <code>Quiv₀</code>.</p>\n<p>Then <code>Quiv.{v, u}</code> has all limits of size <code>min v u</code> (if such a universe level existed, alas), by the following argument: </p>\n<ol>\n<li>Note that products of size <code>w</code> result in a <code>Quiv.{max w v, max w u}</code>, so the property <code>EssentiallySmall.{v, u}</code> is closed under <code>min u v</code>-sized products</li>\n<li>Note that the arrow from an arbitary <code>min u v</code>-sized limit to the product on the same diagram is mono</li>\n<li>Note that in <strong>Quiv</strong>, a prefunctor <code>F</code> is mono iff both <code>F.obj</code> and <code>F.map</code> are injective as functions</li>\n<li>Injective functions into a small type prove the domain are small; thus <code>EssentiallySmall.{v, u}</code> is closed under arbitrary <code>min v u</code>-sized limits</li>\n<li>The functor category <code>Quiv₀ ⥤ Type max v u</code> has all <code>min v u</code>-sized limits; thus the full subcategory of such functors that are <code>EssentiallySmall.{v, u}</code> has all such limits as well; this latter subcategory is equivalent to <code>Quiv.{v, u}</code>; QED.</li>\n</ol>\n<p>This proof has already been implemented in Lean. I was intending to repeat this proof dually for colimits -- <code>EssentiallySmall.{v, u}</code> is also closed under coproducts of size <code>u</code>; the arrow from a coproduct to a colimit is epi; a prefunctor is epi iff both <code>F.obj</code> and <code>F.map</code> are surjective as functions; surjective functions from a small type prove the codomain is small, thus...</p>\n<p>... nothing, because if that arrow from the coproduct to the colimit identifies enough vertices and <em>doesn't</em> identify the corresponding edges, then <em>a priori</em> your locally <code>v</code>-small coproduct might still produce a hom-type of size as much as <code>max v u</code> in the colimit.</p>\n<p>I guess I'm asking for a second opinion/sanity check: is there some subtler reason why this can't happen? Or do I need to include a <code>[UnivLE.{u, v}]</code> assumption in my <code>HasColimitsOfSize</code> instance?</p>",
        "id": 506607483,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742344586
    },
    {
        "content": "<p>Indeed you do need <code>UnivLE</code> as the following example shows. Start from a quiver consisting of a lot of disjoint copies of the walking arrow. This has a large type of objects but small homsets. Then collapse all objects so you just have one object. This can be described as a pushout (of the discrete quiver on your objects, and the terminal quiver). In the end you get a lot of morphisms all in the same homset</p>",
        "id": 506645344,
        "sender_full_name": "David Wärn",
        "timestamp": 1742366257
    },
    {
        "content": "<p>Hm, okay. Thanks for the nice clear counterexample!</p>",
        "id": 506853510,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1742431123
    }
]