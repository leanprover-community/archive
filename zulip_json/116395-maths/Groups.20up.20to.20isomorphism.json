[
    {
        "content": "<p>I thought I would try writing down a definition of <a href=\"https://oeis.org/A000001\">OEIS's A000001</a>. Here's my attempt. Could I possibly get advice on whether this is formalization is correct, and -- since I'm sure there <em>has</em> to be -- a cleaner way of formalizing it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">groups_are_isomorphic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">MulEquiv</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">toMul</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">toMul</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">⟨</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">instNonemptyOfInhabited</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨@</span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">toMul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">τ</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨@</span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">toMul</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">toMul</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">GroupUpToIso</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">groups_are_isomorphic</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A000001</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">GroupUpToIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 455248457,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722385395
    },
    {
        "content": "<p>In particular dealing with two separate group instances on the same type seems to have made a mess of typeclasses. Hence the abundant manual arguments to things, to say which Group structure to use where. (I also think that the inference could be smarter; <code>σ.symm</code> and <code>σ.trans</code> could have worked on their own, if the resolution had been slightly smarter about it!)</p>",
        "id": 455248615,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722385488
    },
    {
        "content": "<p>I did think about something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">groups_are_isomorphic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Setoid</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">T1</span><span class=\"o\">,</span><span class=\"n\">G</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">T2</span><span class=\"o\">,</span><span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">⟨</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">instNonemptyOfInhabited</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">σ</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">GroupUpToIso</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">groups_are_isomorphic</span>\n</code></pre></div>\n<p>instead, but that leads to other type inference errors :P</p>",
        "id": 455249287,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722385835
    },
    {
        "content": "<p>Are you sure you want to use multiple group structures on the same type?</p>",
        "id": 455249639,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722386033
    },
    {
        "content": "<p>No, I'm not. If there's a better way to express \"the type of groups up to isomorphism\" I would greatly prefer that. :)</p>",
        "id": 455249734,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722386076
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Grp#doc\">docs#Grp</a> for bundled groups. Let me see if we have the quotient by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso#doc\">docs#CategoryTheory.Iso</a></p>",
        "id": 455249930,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722386206
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.isomorphismClasses#doc\">docs#CategoryTheory.isomorphismClasses</a></p>",
        "id": 455250568,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722386605
    },
    {
        "content": "<p>Of course, this way you have to rely on category theory. If you want to go with your second definition, I suggest that you add <code>instance (G : Σ T, Group T) : Group G.1 := G.2</code>, then use <code>fun G H ↦ Nonempty (G.1 ≃* H.1)</code> for the relation.</p>",
        "id": 455250861,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722386763
    },
    {
        "content": "<p>Using <code>⟨T1,G⟩ ⟨T2,H⟩</code> makes it use <code>match</code> which may make it more difficult for Lean to deal with defeq.</p>",
        "id": 455250925,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722386811
    },
    {
        "content": "<p>With category theory, it should be possible to define the sequence using the preimage of the one-element set <code>{Quot.mk _ (Fin n)}</code> under <code>isomorphismClasses.map (forget Grp)</code>.</p>",
        "id": 455251522,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722387164
    },
    {
        "content": "<p>BTW, we don't have an equivalence between <code>isomorphismClasses.obj (Type u)</code> and <code>Cardinal.{u}</code> yet.</p>",
        "id": 455251745,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722387303
    },
    {
        "content": "<p>Of course, the category theory approach is highly non-computable while your first approach is computable (not sure about the second one).</p>",
        "id": 455251805,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722387355
    },
    {
        "content": "<p>Well. Relatively \"computable\". :) <br>\nWithout even knowing that the number of groups is finite, I think it's pretty far from computable.<br>\nMaybe if I show that the GroupsUpToIso is Finite for any Finite T, it could actually become computable. (Albeit quite slow.) Hmmm.</p>",
        "id": 455256821,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722390503
    },
    {
        "content": "<p>I think I will stay away from the category theory if possible. ;) Although maybe bundling somehow fixes my issues, without getting too categorical.</p>",
        "id": 455256883,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1722390540
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Grp#doc\">docs#Grp</a> is exactly a pair of a type and a group structure on it.</p>",
        "id": 455258943,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722391784
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid\">CategoryTheory.isIsomorphicSetoid</a> is the right setoid on this type.</p>",
        "id": 455259021,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722391822
    },
    {
        "content": "<p>So, unless you want to use multiple <code>Group</code> structures on the same type, it's easier to work with <code>Grp</code> rather than a custom bundled type.</p>",
        "id": 455259113,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722391899
    },
    {
        "content": "<p>Using <code>Grp</code> does involve a quantification over the universe. I don't particularly care. But of course this function <code>Nat -&gt; Nat</code> can avoid it, as Alex demonstrated.</p>",
        "id": 455294102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1722407134
    },
    {
        "content": "<p>Personally, I think having the \"ugly\" definition that uses multiple structures on <code>Fin n</code> is totally fine.<br>\nThere should just be a bunch of API around it so that you can prove that <code>A000001 4 = 2</code> without having to use <code>Fin 4</code>.</p>",
        "id": 455294340,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1722407204
    },
    {
        "content": "<p>If you're okay with invoking Cayley's theorem, you can try to enumerate transitive order <code>n</code> subgroups of permutations on <code>n</code> letters up to isomorphism.  This at least gives you finiteness.</p>",
        "id": 455295666,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1722407868
    }
]