[
    {
        "content": "<p>Does the following have a name or a better description?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n\n<span class=\"sd\">/-- A set `U` of `S` is compact open covered by a family of maps `X i → S`,</span>\n<span class=\"sd\">if it is the finite union of images of compact and open sets of the `X i`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompactOpenCovered</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">IsCompact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span>\n</code></pre></div>\n<p>For context: I am defining the <a href=\"https://stacks.math.columbia.edu/tag/022B\">fpqc topology</a> on schemes. For this I defined a predicate <code>Cover.QuasiCompact</code> on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.Scheme.Cover#doc\">docs#AlgebraicGeometry.Scheme.Cover</a> where the condition is that every compact open is <code>IsCompactOpenCovered</code> by the maps of the cover (this is equivalent to the stacks project definition linked above, because affine opens form a basis).</p>",
        "id": 516727275,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746637278
    },
    {
        "content": "<p>If your <code>U</code> is compact, then you can probably drop <code>s</code> and demand one <code>V</code> on each <code>ι</code>?</p>",
        "id": 516731305,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746638638
    },
    {
        "content": "<p>No, because the <code>f i</code> might not be open maps (in fact, in the fpqc case, they won't be).</p>",
        "id": 516731489,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746638691
    },
    {
        "content": "<p>(<code>IsCompactOpenCovered U</code> is even automatic for <code>U</code> compact open if all the <code>f i</code> are open maps)</p>",
        "id": 516731936,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746638820
    },
    {
        "content": "<p>I wonder if it is easier to say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⨿</mo><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">\\amalg X_i =: X \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\">⨿</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is fpqc, i.e. every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x \\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> has a compact neighborhood whose image is affine.</p>",
        "id": 516733485,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746639321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/116395-maths/topic/Compact.20open.20covered.20sets/near/516733485\">said</a>:</p>\n<blockquote>\n<p>I wonder if it is easier to say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⨿</mo><msub><mi>X</mi><mi>i</mi></msub><mo>=</mo><mo>:</mo><mi>X</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">\\amalg X_i =: X \\to S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\">⨿</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is fpqc, i.e. every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">x \\in X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> has a compact neighborhood whose image is affine.</p>\n</blockquote>\n<p>My plan is to get this as an equivalent description and my guess is that we want both characterizations anyway.</p>",
        "id": 516733831,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746639435
    },
    {
        "content": "<p>I feel like the \"better description\" you are looking for is a topological version of the above (replace coprod with disjoint union and affine with compact and some more modifications)</p>",
        "id": 516735330,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746639995
    },
    {
        "content": "<p>So you are suggesting this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsCompactOpenCovered'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Opens</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">IsCompact</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">U</span>\n</code></pre></div>",
        "id": 516744855,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746643471
    },
    {
        "content": "<p>I guess the question I should ask is: do you really need a family of covers when you are developing api for it or is it enough to consider the cover with one component?</p>",
        "id": 516749401,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746645146
    },
    {
        "content": "<p>It would be useful to have them as characterizations to apply to actual covers in practice but for the abstract theory do you need anything more?</p>",
        "id": 516749554,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1746645219
    },
    {
        "content": "<p>We need a definition of \"quasicompact\" for arbitrary covers, because we need to be able to talk about fpqc covers that are not given by a single morphism (e.g. Zariski covers). And also to develop the basic API for how quasicompact behaves under pullback, refinement etc. we need the statements for arbitrary covers.</p>",
        "id": 516769211,
        "sender_full_name": "Christian Merten",
        "timestamp": 1746653477
    }
]