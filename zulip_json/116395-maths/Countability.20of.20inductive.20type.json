[
    {
        "content": "<p>I'm working with the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The ordinal `0` -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The ordinal `oadd e n a = ω ^ e * n + a` -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">oadd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span>\n</code></pre></div>\n<p>It seems clear to me that this type must be countable. Specifically, one can subdivide the type into \"layers\" based on the number of applications of the constructor <code>oadd</code>. The cardinality <code>c (n + 1)</code> of layer <code>n + 1</code> is equal to <code>c n * ℵ₀ * c n</code>, which through a simple induction implies <code>c n = ℵ₀</code> and thus that the entire type is countable.</p>\n<p>It seems like this argument should follow in more generality, however. Specifically, any inductive type <code>α</code> whose constructors <code>β₁ → β₂ → ... → α</code> refer only to <code>α</code> and other countable types should be countable. Is there some sort of machinery already in Mathlib formalizing these sorts of arguments?</p>",
        "id": 479790761,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730339175
    },
    {
        "content": "<p>I'm reminded of the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WType#doc\">docs#WType</a> API, but I don't understand <code>WType</code> enough to know whether this is an instance of it or not</p>",
        "id": 479790779,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730339196
    },
    {
        "content": "<p>I think this can be injected into a <code>WType</code> where the possible labels are in <code>Option ℕ</code>, with <code>0</code> representing <code>zero</code>, other natural numbers representing themselves, and <code>none</code> representing the <code>oadd</code> constructor</p>",
        "id": 479792637,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730340764
    },
    {
        "content": "<p>Ideally we would have <code>deriving Countable</code> for this.</p>\n<p>An idea I've played around with before is to define a type simpler than <code>WType</code> specifically for doing <code>Countable</code> arguments. Basically, once you have that <code>S</code> is <code>Countable</code> in the following, it becomes fairly easy to implement the <code>deriving Countable</code> handler.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The ordinal `0` -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The ordinal `oadd e n a = ω ^ e * n + a` -/</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">oadd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PNat</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PNat</span><span class=\"bp\">.</span><span class=\"n\">toS_injective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">PNat</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">contextual</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toS</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">oadd</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"bp\">.</span><span class=\"n\">toS_injective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">PreCantor</span><span class=\"bp\">.</span><span class=\"n\">toS</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_|_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toS</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">oadd</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">ihx</span><span class=\"w\"> </span><span class=\"n\">ihy</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_|_</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toS</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toS</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ihx</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ihy</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">PNat</span><span class=\"bp\">.</span><span class=\"n\">toS_injective</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 479794121,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730341921
    },
    {
        "content": "<p>You don't need a <code>toS</code> function for each type that appears inside the inductive definition, like I did for PNat here. Instead, you use choice to extract an injective function to Nat from the Countable proof.</p>",
        "id": 479794207,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730341966
    },
    {
        "content": "<p>Proving <code>S</code> is countable should be easy. You can construct a function to Nat directly, using that Nat pairing function in mathlib</p>",
        "id": 479794302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730342042
    },
    {
        "content": "<p>I'd be happy to help make this Countable deriving handler :-) If you write the <code>Countable</code> proof for <code>S</code>, I'll look into the next steps.</p>",
        "id": 479794752,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730342382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/116395-maths/topic/Countability.20of.20inductive.20type/near/479794752\">said</a>:</p>\n<blockquote>\n<p>I'd be happy to help make this Countable deriving handler :-) If you write the <code>Countable</code> proof for <code>S</code>, I'll look into the next steps.</p>\n</blockquote>\n<p>Easy!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat_injective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">toNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pair_eq_pair</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_left_inj</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat_injective</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat_injective</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">toNat_injective</span><span class=\"bp\">.</span><span class=\"n\">countable</span>\n</code></pre></div>",
        "id": 479795073,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730342629
    },
    {
        "content": "<p>You idea to use <code>Nat.pair</code> was really clever, my own idea was trying to inject <code>S</code> into a <code>WType</code></p>",
        "id": 479795148,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730342672
    },
    {
        "content": "<p>Have you looked at <code>Data.W.Basic</code>? There's an <code>encodable</code>instance there. You could prove it's isomorphic to the corresponding <code>WType</code>and use the instance.</p>",
        "id": 479962087,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1730410281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/channel/116395-maths/topic/Countability.20of.20inductive.20type/near/479792637\">said</a>:</p>\n<blockquote>\n<p>I think this can be injected into a <code>WType</code> where the possible labels are in <code>Option ℕ</code>, with <code>0</code> representing <code>zero</code>, other natural numbers representing themselves, and <code>none</code> representing the <code>oadd</code> constructor</p>\n</blockquote>\n<p>I did think about this, but Kyle's approach seems simpler</p>",
        "id": 479963696,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730411234
    },
    {
        "content": "<p>Is Kyle's approach above sensible for implementing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Encodable#doc\">docs#Encodable</a> too?</p>",
        "id": 479988231,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730430026
    },
    {
        "content": "<p>It should be, I think. The explicit encoding would look something like <code>x.toS.toNat</code>, and building the inverse should be easy as long as we can show S itself is encodable.</p>",
        "id": 479988397,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730430170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span>, it is done: <a href=\"https://github.com/leanprover-community/mathlib4/pull/18557\">#18557</a></p>",
        "id": 480241740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730573182
    },
    {
        "content": "<p>It turned out to be a easier to not go through any auxiliary types. I spent time looking at your <code>S.toNat_injective</code> and figured out how to generalize it for automation. If you want to see the details, there's an example expansion in a module docstring in the DeriveCountable file.</p>",
        "id": 480241809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730573266
    },
    {
        "content": "<p>I tried working out the theory of how to go about making an Encodable deriving handler. It was really painful (and I failed) trying to use <code>Nat.pair</code> directly, and the intermediate <code>S</code> type was helpful.</p>\n<p>It seems like it's a promising approach though</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">encode</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair_lt_2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pairEquiv</span><span class=\"bp\">.</span><span class=\"n\">surjective</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pairEquiv_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">uncurry_apply_pair</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">unpair_pair</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pair</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">nlinarith</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair_left_le</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">unpair_lt_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">encode</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">encode</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">encode</span>\n<span class=\"w\">  </span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">encodek</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Example:</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">encode</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Encodable</span><span class=\"bp\">.</span><span class=\"n\">decode</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode</span>\n<span class=\"w\">  </span><span class=\"n\">encodek</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">decode_encode</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 480248701,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730579976
    },
    {
        "content": "<p>S is <code>FreeMagma Nat</code>, right?</p>",
        "id": 480257138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730588609
    },
    {
        "content": "<p>(though maybe that's not a helpful tool to use!)</p>",
        "id": 480257144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730588621
    },
    {
        "content": "<p>Here are <code>Encodable</code> derived handlers too: <a href=\"https://github.com/leanprover-community/mathlib4/pull/18564\">#18564</a></p>",
        "id": 480260504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592087
    },
    {
        "content": "<p>It doesn't support indexed inductive types. That'll be some extra work; the issue is in the decoding function. I think what you'd do is have it use DecidableEq to do equality tests with the indices, and use those successful tests to rewrite the indices.</p>",
        "id": 480260665,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592218
    },
    {
        "content": "<p>(I'm not sure how observing that binary trees of natural numbers is the same as <code>FreeMagma Nat</code> helps here <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, sorry)</p>",
        "id": 480260736,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592270
    },
    {
        "content": "<p>Nice!</p>",
        "id": 480260795,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592338
    },
    {
        "content": "<p>Doesn't this subsume the <code>Countable</code> handler, though?</p>",
        "id": 480260811,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592354
    },
    {
        "content": "<p>If you have e.g. <code>Encodable a -&gt; Encodable (List a)</code> then you can derive <code>Countable a -&gt; Countable (List a)</code> by nonconstructively building an <code>Encodable</code> instance, which then gives you the <code>Countable</code> instance you want</p>",
        "id": 480260938,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592470
    },
    {
        "content": "<p>No, because this needs Encodable instances for its parameters</p>",
        "id": 480260939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592472
    },
    {
        "content": "<p>You can derive that, but it's not automatic with typeclass synthesis</p>",
        "id": 480260997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592489
    },
    {
        "content": "<p>Yeah, that's what I mean</p>",
        "id": 480261002,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592505
    },
    {
        "content": "<p>This is why it doesn't subsume it</p>",
        "id": 480261018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592527
    },
    {
        "content": "<p>Perhaps \"simplify\" is the correct word then</p>",
        "id": 480261025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592540
    },
    {
        "content": "<p>The stronger reason at the moment is that the Countable handler can deal with indexed inductive types</p>",
        "id": 480261045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592563
    },
    {
        "content": "<p>Oh, alright</p>",
        "id": 480261057,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592578
    },
    {
        "content": "<p>The Countable handler is also simpler and quicker-to-elaborate</p>",
        "id": 480261069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730592597
    },
    {
        "content": "<p><del>Perhaps this can be left as a TODO then?</del> or maybe not if the difference in performance is significant</p>",
        "id": 480261070,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592597
    },
    {
        "content": "<p>Hope I'm not coming off as nitpicky, this is really cool in any case</p>",
        "id": 480261158,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730592658
    },
    {
        "content": "<p>I don't think it's really necessary, it's not like in the math library where generalization is good, where everything can be type-checked for mathematical correctness. Meta code is only as correct as the testing we do. I feel that some of the automation in the Encoding handler for the proofs is sketchier than the Countable one.</p>\n<p>I think making the Countable handler be in terms of the Encodable handler would make it more complicated and harder-to-maintain overall. This also frees us from needing to design it with any consideration for computability.</p>",
        "id": 480261571,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730593071
    },
    {
        "content": "<p>It would be neat to re-use some of the Countable handler code for a Finite handler though. The idea would be to use the fact that if you have an injection to Nat from a Finite type, the function is bounded, and then in all the <code>Nat.pair</code> constructions, we can deduce that the constructed function is bounded as well.</p>\n<p>Or there's reusing the Fintype deriving handler machinery, which would work fine too, though that doesn't handle indexed inductives.</p>",
        "id": 480262016,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730593490
    },
    {
        "content": "<p>Fair enough. I think these were just my math instincts kicking in <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 480262126,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730593578
    },
    {
        "content": "<p>In another direction, it might be interesting having an <code>Infinite</code> derive handler that creates one or more instances that would prove the type is infinite, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Infinite</span>\n\n<span class=\"c1\">-- creates</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 480262418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730593832
    },
    {
        "content": "<p>Would be nice. I think this handler is perhaps lower priority, since it's usually not too difficult to build something like an injection from N.</p>",
        "id": 480262547,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730593950
    },
    {
        "content": "<p>(in fact, many types have a preferred injection!)</p>",
        "id": 480262697,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730594128
    },
    {
        "content": "<p>You'd also need assumptions about <code>Nonempty</code> for this example, but that does seem like an interesting idea</p>",
        "id": 480290562,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730623417
    },
    {
        "content": "<p>Btw, is there a good resource for writing derive handlers? I think I'd like to get more familiar with this part of lean...</p>",
        "id": 480290679,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730623521
    },
    {
        "content": "<p>also, does it make sense to adapt this to derive <code>Primcodable</code> instances?</p>",
        "id": 480300053,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730633130
    },
    {
        "content": "<p>(because from what i can tell, this should be doable)</p>",
        "id": 480300973,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730634022
    },
    {
        "content": "<p>from the looks of it, we'd need a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Enumerable.ofLeftInjective#doc\">docs#Enumerable.ofLeftInjective</a> for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Primcodable#doc\">docs#Primcodable</a> ...</p>",
        "id": 480307154,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1730640207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> Hints:</p>\n<ul>\n<li>Most deriving handlers are basically macros. They construct command syntax using knowledge of the inductive types and then ask the command elaborator to do the rest. A minority create definitions from scratch and add them to the environment directly.</li>\n<li>The <code>Deriving</code> namespace has some functions that are convenient for certain types of deriving handlers, but don't expect them to do everything you want. You may need to copy functions into your deriving handler and modify them to suit your needs. (The <code>Countable</code> deriving handler had to do this with the <code>instance</code>-creation function for example.)</li>\n<li>There's no documentation about any of this really. You can try to find a pre-existing deriving handler that is similar to what you want to do. You'll need to read some core source code in this <code>Deriving</code> namespace and try to figure out what it does and what it's for.</li>\n<li>Don't try writing a handler from scratch, start with a related one. With <code>Countable</code>, I copy/pasted relevant bits from the <code>DecidableEq</code> and <code>Repr</code> handlers, probably some others too, and then hammered it into shape. For this one, I needed to generate additional names for auxiliary declarations and thread these around since the Deriving.Context assumes you only need a single kind of aux declaration. (It would probably be cleaner to abandon the Deriving namespace at this point and make something custom for <code>Countable</code>!)</li>\n</ul>",
        "id": 480315764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730647982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/116395-maths/topic/Countability.20of.20inductive.20type/near/480262418\">said</a>:</p>\n<blockquote>\n<p>In another direction, it might be interesting having an <code>Infinite</code> derive handler that creates one or more instances that would prove the type is infinite, like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Infinite</span>\n\n<span class=\"c1\">-- creates</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Just noting the existing PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/3610\">#3610</a> from <span class=\"user-mention\" data-user-id=\"572003\">@Timothy Gu</span>.</p>",
        "id": 480550275,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730765747
    }
]