[
    {
        "content": "<p>I've been thinking about giving someone a short project over the summer to establish the spectral theorem for normal endomorphisms over a finite dimensional inner product space.</p>\n<p>In outlining the work, I ran into several problems that are not present for the spectral theorem for symmetric operators.</p>\n<ol>\n<li>We have a definition of symmetric operators that can be used for both <code>LinearMap</code> and <code>ContinuousLinearMap</code> (since the latter has a coercion to the former), and the type class assumptions are minimal. This is useful.</li>\n<li>One cannot do a similar  thing for normal endomorphisms, because one must reference the <code>adjoint</code> (or <code>star</code>, whichever), but there are no common type class assumptions giving the user access to that (e.g., for <code>E â†’â‚—[ğ•œ] E</code> we need <code>FiniteDimensional ğ•œ E</code>, but for <code>E â†’L[ğ•œ] E</code> we need <code>CompleteSpace E</code>).</li>\n<li>As an example of the problems caused by (2), consider that the following statement is true for linear maps on a finite dimensional space as well, but we would need to duplicate the proof. </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">adjoint_apply_eq_zero_iff</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">IsStarNormal</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">adjoint</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<ol start=\"4\">\n<li>In fact, all the results at the beginning of <a href=\"https://tqft.net/mathlib4files/Analysis/InnerProductSpace/Spectrum\">file#Analysis/InnerProductSpace/Spectrum</a> (except the one that says eigenvalues are real) generalize to normal endomorphisms. BUT, we would need them in triplicate: one for <em>symmetric</em> linear maps, one for <em>normal</em> continuous linear maps on a <em>complete</em> space, and one for <em>normal</em> linear maps on a <em>finite dimensional</em> space ... gross.</li>\n<li>Moreover, there's really nothing about (4) which needs separate assumptions other than the existence of a suitable adjoint.</li>\n</ol>\n<p>I'm happy to solicit solutions to these sorts of problems. One idea I considered was to have a <code>LinearAdjoint</code> class which supplies an adjoint for the appropriate space of endomorphisms. Some downsides: it's subject to the same problems as all of our hom classes: we can't talk about identity maps or composition. A draft implementation:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>LinearAdjoint</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">AdjointClass</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">LinearAdjoint</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Hâ‚</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Hâ‚‚</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">Hâ‚</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">Hâ‚</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">Hâ‚‚</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">Hâ‚‚</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">Hâ‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">Hâ‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">adjoint</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span> <span class=\"bp\">â‰ƒâ‚—â‹†</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">Hâ‚‚</span>\n  <span class=\"n\">is_adjoint</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">âŸª</span><span class=\"n\">adjoint</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">LinearMap.instLinearAdjoint</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">LinearAdjoint</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">â†’â‚—</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">adjoint</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.adjoint</span>\n  <span class=\"n\">is_adjoint</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.adjoint_inner_left</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">ContinuousLinearMap.instLinearAdjoint</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">LinearAdjoint</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">â†’</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">adjoint</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousLinearMap.adjoint.toLinearEquiv</span>\n  <span class=\"n\">is_adjoint</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousLinearMap.adjoint_inner_left</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">LinearAdjoint</span> <span class=\"o\">(</span><span class=\"n\">adjoint</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LinearAdjoint</span>\n\n<span class=\"n\">scoped</span><span class=\"o\">[</span><span class=\"n\">LinearAdjoint</span><span class=\"o\">]</span> <span class=\"kd\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"s2\">\"â€ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">adjoint</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">Hâ‚</span> <span class=\"n\">Hâ‚‚</span> <span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">Hâ‚</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">Hâ‚</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">Hâ‚‚</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">Hâ‚‚</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">Hâ‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">Hâ‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">LinearAdjoint</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"n\">Hâ‚</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearAdjoint</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"n\">Hâ‚‚</span> <span class=\"n\">Hâ‚</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The fundamental property of the adjoint. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">adjoint_inner_left</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">âŸª</span><span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">is_adjoint</span> <span class=\"n\">A</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"sd\">/-- The fundamental property of the adjoint. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">adjoint_inner_right</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">âŸª</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"n\">y</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">inner_conj_symm</span><span class=\"o\">,</span> <span class=\"n\">adjoint_inner_left</span><span class=\"o\">,</span> <span class=\"n\">inner_conj_symm</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The adjoint is involutive. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">adjoint_adjoint</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">â€ â€ </span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n  <span class=\"n\">DFunLike.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">â†¦</span> <span class=\"n\">ext_inner_left</span> <span class=\"bp\">ğ•œ</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">â†¦</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adjoint_inner_right</span><span class=\"o\">,</span> <span class=\"n\">adjoint_inner_left</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">RCLike</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">apply_norm_sq_eq_inner_adjoint_left</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">â€–</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"bp\">â€–</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">re</span> <span class=\"bp\">âŸª</span><span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adjoint_inner_left</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">inner_self_eq_norm_sq</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">apply_norm_eq_sqrt_inner_adjoint_left</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">â€–</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"bp\">â€–</span> <span class=\"bp\">=</span> <span class=\"bp\">âˆš</span><span class=\"o\">(</span><span class=\"n\">re</span> <span class=\"bp\">âŸª</span><span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">apply_norm_sq_eq_inner_adjoint_left</span><span class=\"o\">,</span> <span class=\"n\">Real.sqrt_sq</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">apply_norm_sq_eq_inner_adjoint_right</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">â€–</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"bp\">â€–</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">re</span> <span class=\"bp\">âŸª</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adjoint_inner_right</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">inner_self_eq_norm_sq</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">apply_norm_eq_sqrt_inner_adjoint_right</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">â€–</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"bp\">â€–</span> <span class=\"bp\">=</span> <span class=\"bp\">âˆš</span><span class=\"o\">(</span><span class=\"n\">re</span> <span class=\"bp\">âŸª</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">apply_norm_sq_eq_inner_adjoint_right</span><span class=\"o\">,</span> <span class=\"n\">Real.sqrt_sq</span> <span class=\"o\">(</span><span class=\"n\">norm_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)]</span>\n\n<span class=\"sd\">/-- The adjoint is unique: a map `A` is the adjoint of `B` iff it satisfies `âŸªA x, yâŸ« = âŸªx, B yâŸ«`</span>\n<span class=\"sd\">for all `x` and `y`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">eq_adjoint_iff</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Hâ‚‚</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"bp\">â€ </span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">âŸª</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">y</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">âŸ¨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">adjoint_inner_left</span><span class=\"o\">],</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span><span class=\"o\">âŸ©</span>\n  <span class=\"n\">apply</span> <span class=\"n\">DFunLike.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">â†¦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ext_inner_right</span> <span class=\"bp\">ğ•œ</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">adjoint_inner_left</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LinearAdjoint</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">H</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">H</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearAdjoint</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">E</span> <span class=\"n\">H</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LinearAdjoint.IsNormal</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">adjoint</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">adjoint</span> <span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LinearAdjoint.IsNormal</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adjoint_self_apply_comm</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">IsNormal</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">â€ </span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">hA</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adjoint_apply_eq_zero_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsNormal</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f</span><span class=\"bp\">â€ </span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">â†”</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">norm_eq_zero</span> <span class=\"o\">,</span> <span class=\"n\">norm_eq_sqrt_inner</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"o\">:=</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">),</span> <span class=\"n\">adjoint_inner_left</span><span class=\"o\">,</span>\n    <span class=\"bp\">â†</span> <span class=\"n\">hf.adjoint_self_apply_comm</span><span class=\"o\">,</span> <span class=\"n\">adjoint_inner_right</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">norm_eq_sqrt_inner</span><span class=\"o\">,</span> <span class=\"n\">norm_eq_zero</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>\n<p>Of course, this doesn't help with <code>LinearPMap</code> at all, but right now I consider it hopeless to unify that too.</p>",
        "id": 433582046,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713292069
    },
    {
        "content": "<p>The idea would be that <code>LinearAdjoint.adjoint</code> (or just <code>adjoint</code> if we export it) would become the default spelling of both the existing <code>LinearMap.adjoint</code> and <code>ContinuousLinearMap.adjoint</code>. Of course,  we would still need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.adjoint#doc\">docs#ContinuousLinearMap.adjoint</a> since that's also isometric, but we would try to avoid using it in statements.</p>\n<p>Even with this proposed class, there still doesn't seem to be a way to unify the symmetric and normal versions of the results at the top of <a href=\"https://tqft.net/mathlib4files/LinearAlgebra/InnerProductSpace/Spectrum\">file#LinearAlgebra/InnerProductSpace/Spectrum</a>, because the normal versions will still require additional type class assumptions.</p>",
        "id": 433584329,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713293072
    },
    {
        "content": "<p>Wouldn't it be enough to have a prop typeclass <code>IsReasonableStar</code> (or something :-) ) that contains the properties of <code>star</code> that we need for all of this?</p>",
        "id": 433584745,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713293277
    },
    {
        "content": "<p>No, you need the interaction with the inner product.</p>",
        "id": 433584808,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713293294
    },
    {
        "content": "<p>Can't that be baked in? i.e. having an inner product is a necessary prerequisite for <code>IsReasonableStar</code>, along with the properties.</p>",
        "id": 433584960,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713293342
    },
    {
        "content": "<p>I suppose.</p>",
        "id": 433585096,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713293388
    },
    {
        "content": "<p>Another possible solution is to define the collection of adjointable operators, and define an adjoint operation on those. In the case of complete spaces or finite dimensional spaces, every operator is adjointable.</p>",
        "id": 433585211,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713293420
    },
    {
        "content": "<p>The <code>IsReasonableStar</code> approach still doesn't allow you to unify the <code>IsStarNormal</code> results with the <code>IsSymmetric</code>, because the former needs <code>IsReasonableStar</code>, but the <code>IsSymmetric</code> results hold even in the presence of an unreasonable star. I think this is acceptable though, and I prefer the approach to not create new data.</p>",
        "id": 433587553,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713294341
    },
    {
        "content": "<p>Yeah, I'm not very enthusiastic at the prospect of creating a second version of <code>star</code>...</p>",
        "id": 433591318,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713295855
    },
    {
        "content": "<p>Even <code>IsReasonableStar</code> (which I called <code>StarAdjoint</code>) seems doomed to failure. In order for it to be useful, we would have to know that all the operations on this type with a <code>LinearMapClass</code> instance occur pointwise. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">StarAdjoint</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarRing</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">H</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">H</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">star_is_adjoint</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">âŸª</span><span class=\"n\">star</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span>\n  <span class=\"n\">mul_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But we would also need the <code>add_apply</code>, <code>sub_apply</code>, etc. as well.</p>",
        "id": 433599767,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713299347
    },
    {
        "content": "<p>This is also a problem with my proposed <code>LinearAdjoint</code> class too, I just hadn't realized it yet.</p>",
        "id": 433599871,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713299400
    },
    {
        "content": "<p>I'm leaning towards just accepting the triplicated theorems.</p>",
        "id": 433600036,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713299438
    },
    {
        "content": "<p>Is it so bad to have the <code>add_apply</code> and friends?</p>",
        "id": 433606646,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713301358
    },
    {
        "content": "<p>It makes me feel like I'm doing it wrong. And I suspect I'm just going to keep running into other issues. Maybe I'm wrong.</p>",
        "id": 433606786,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713301415
    },
    {
        "content": "<p>Hard to tell without really trying it I guess.</p>",
        "id": 433607100,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713301551
    },
    {
        "content": "<p>There's also the issue that all the <code>eigenspace</code> and related material is about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End#doc\">docs#Module.End</a>, which means that all my statements involving this generic <code>StarAdjoint</code> type (<code>H</code> in the code above) would have to be coerced to a linear map in the statements.</p>",
        "id": 433607201,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713301593
    },
    {
        "content": "<p>Admittedly, that's a problem for <code>ContinuousLinearMap</code> too. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 433607237,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713301611
    },
    {
        "content": "<p>Is that related to <a href=\"https://github.com/leanprover-community/mathlib/pull/16351\">!3#16351</a> ?</p>",
        "id": 433608049,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1713301955
    },
    {
        "content": "<p>you mean the pointwise action stuff? Maybe a bit, but I'm not entirely sure how to make any of the proposed solutions there work here (aside from just copying the <code>*_apply</code> fields into the class).</p>",
        "id": 433609262,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713302475
    },
    {
        "content": "<p>Yeah, is that an unreasonable solution?</p>",
        "id": 433611277,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1713303341
    },
    {
        "content": "<p>As I said above, it made me feel like I was doing things wrong, because I just kept needing to add things to say \"this really is a linear map, please treat it as such\". But maybe these are the only facts I need.</p>",
        "id": 433611547,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713303460
    },
    {
        "content": "<p>Eigenspaces should be defined for LinearMapClass, shouldn't they?</p>",
        "id": 433663777,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713331903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/spectral.20theorem.20for.20normal.20endomorphisms.20and.20related.20pain/near/433663777\">said</a>:</p>\n<blockquote>\n<p>Eigenspaces should be defined for LinearMapClass, shouldn't they?</p>\n</blockquote>\n<p>This has been on my todo list since forever!</p>",
        "id": 433696584,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713341044
    },
    {
        "content": "<p>Suggestion: this kind of stuff should be added to the relevant file, in hope that somebody finds the courage to do it, with some specific enough format that one can gather them automatically to one big informative Todo list.</p>",
        "id": 433728328,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713351880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">FrÃ©dÃ©ric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/spectral.20theorem.20for.20normal.20endomorphisms.20and.20related.20pain/near/433696584\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/spectral.20theorem.20for.20normal.20endomorphisms.20and.20related.20pain/near/433663777\">said</a>:</p>\n<blockquote>\n<p>Eigenspaces should be defined for LinearMapClass, shouldn't they?</p>\n</blockquote>\n<p>This has been on my todo list since forever!</p>\n</blockquote>\n<p>I think there are <em>two</em> problems with doing this:</p>\n<ol>\n<li>You have the issue that has come up with other <code>FunLike</code> things of this kind: The eigenvalues / eigenvectors of some element of a <code>LinearMapClass</code> are not defeq to those of it's coercion to a linear map. If you have some lemmas to show they are the same, then it's not so bad, but it is a bit of an annoyance.</li>\n<li>More importantly, there's no <code>LinearMap.id</code> for elements in a <code>LinearMapClass</code>, which gets pretty annoying when you want to work with <code>f x = Î¼ x</code> and you want to write it like <code>(f - Î¼ â€¢ LinearMap.id) x = 0</code>. Even <code>(f - algebraMap ğ•œ F Î¼) x = 0</code> is probably not valid for most <code>LinearMapClass</code>es <code>F</code>, and you would still need to apply it to <code>x</code>.</li>\n</ol>",
        "id": 433755677,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713360187
    },
    {
        "content": "<p>You can do <code>(â†‘f - Î¼ â€¢ LinearMap.id) x = 0</code> but then you're back to coercing.</p>",
        "id": 433755988,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713360275
    },
    {
        "content": "<p>Sure, there are some downsides, but surely this can't be worse than having to coerce all the time when talking about continuous linear maps!</p>",
        "id": 433845643,
        "sender_full_name": "FrÃ©dÃ©ric Dupuis",
        "timestamp": 1713377114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/spectral.20theorem.20for.20normal.20endomorphisms.20and.20related.20pain/near/433599767\">said</a>:</p>\n<blockquote>\n<p>Even <code>IsReasonableStar</code> (which I called <code>StarAdjoint</code>) seems doomed to failure. In order for it to be useful, we would have to know that all the operations on this type with a <code>LinearMapClass</code> instance occur pointwise. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">StarAdjoint</span> <span class=\"o\">(</span><span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">outParam</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ğ•œ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarRing</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FunLike</span> <span class=\"n\">H</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">LinearMapClass</span> <span class=\"n\">H</span> <span class=\"bp\">ğ•œ</span> <span class=\"n\">E</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">star_is_adjoint</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">âŸª</span><span class=\"n\">star</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span> <span class=\"bp\">=</span> <span class=\"bp\">âŸª</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">âŸ«</span><span class=\"n\">_</span><span class=\"bp\">ğ•œ</span>\n  <span class=\"n\">mul_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But we would also need the <code>add_apply</code>, <code>sub_apply</code>, etc. as well.</p>\n</blockquote>\n<p>Does <code>AddMonoidHomClass</code> deal with the <code>add</code> and <code>sub</code> lemmas?</p>",
        "id": 433858959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713381651
    },
    {
        "content": "<p>No, <code>AddMonoidHomClass H E E</code> would tell you that for any <code>f : H</code> and any <code>x y : E</code>, that <code>f (x + y) = f x + f y</code>, but it's not going to tell you that for any <code>f g : H</code> and any <code>x : E</code>, that <code>(f + g) x = f x + g x</code>.</p>",
        "id": 433859356,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713381803
    },
    {
        "content": "<p>Isn't it a way to add <code>id</code> to all these classes (when possible), and turning them into kind of categories?</p>",
        "id": 433859557,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713381881
    },
    {
        "content": "<p>Did you mean \"Does there exist a way ...\"? Not currently. The issue is composition. Given <code>HomClass F X Y</code>, <code>HomClass G Y Z</code> Lean has trouble inferring the <code>?H</code> in <code>HomClass ?H X Z</code>.</p>",
        "id": 433860438,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713382203
    },
    {
        "content": "<p>Indeed, a single <code>F</code> could imply many more <code>HomClass</code>es between <code>X</code> and <code>Y</code>.</p>",
        "id": 433860647,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713382282
    },
    {
        "content": "<p>There's this issue <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a></p>",
        "id": 433861456,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1713382578
    }
]