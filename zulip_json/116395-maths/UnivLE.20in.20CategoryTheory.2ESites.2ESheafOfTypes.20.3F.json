[
    {
        "content": "<p>Now we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UnivLE#doc\">docs#UnivLE</a> I thought I'd try and get it working in a use case coming from <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> , but I've failed to. Here's an overview of what is going on in master right now.</p>\n<p>In <code>CategoryTheory.Sites.Sheaf</code> we have a fully universe-polymorphic definition of a sheaf. More precisely we have our base category <code>{C : Type u₁} [Category.{v₁} C] (J : GrothendieckTopology C)</code> with a topology, that we're going to put a sheaf on, and this sheaf is going to be a sheaf of <code>A</code>s, where (for much of the file) <code>{A : Type u₂} [Category.{v₂} A]</code> is another category. </p>\n<p>However later on in this file we roll back on <code>A</code> a bit, and on line 457 we have a new <code>A</code>, with <code>variable {A : Type u₂} [Category.{max v₁ u₁} A]</code>, so now we have lost a degree of freedom (<code>v₂</code>). We're still working with sheaves of <code>A</code>s on category <code>C</code> but now we only have three universe variables to play with, not four. If you change that <code>max v₁ u₁</code> to a general <code>v₂</code> then you start to get errors later on in the file. What's going on here? The issue is that we're applying intermediate lemmas which have <code>max v₁ u₁</code> built into them. If you chase everything back then you get to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equalizer.FirstObj#doc\">docs#CategoryTheory.Equalizer.FirstObj</a> in <code>CategoryTheory.Sites.SheafOfTypes</code>, which mathematically is the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_{i\\in I}\\mathcal{F}(U_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> in the displayed equation <a href=\"https://stacks.math.columbia.edu/tag/00VM\">here</a> on the Stacks project. We're taking a product in <code>A</code> indexed by a set called <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> in Stacks, and in Lean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> is a union of a bunch of morphisms in <code>C</code>, indexed over a bunch of objects in <code>C</code>, so has type <code>max v₁ u₁</code> in Lean. We need to ensure that we can manipulate objects of this size in <code>A</code> and the current practice (written before <code>UnivLE</code>) was just to put an explicit restriction on the morphism universe to make everything work.</p>\n<p>The point of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> is to show that we went too far in this approach, and some lemmas where <code>A</code> had morphism universe <code>max v₁ u₁</code> can be relaxed back to morphism universe <code>v₂</code>; in particular the function which I wanted to use to do a universe bump in my application, now is sufficiently universe polymorphic in <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a>. The PR has been delegated so I could just merge what I have. However the PR was written before <code>UnivLE</code> existed, and Oliver raised the question of whether one could now do better. Instead of having <code>max v₁ u₁</code> everywhere, can I move back to <code>v₂</code> under some inequality hypotheses? I thought I'd give it a try, and basically edit <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> if I can get it working, and just merge it if I can't. </p>\n<p>Currently I can't, so I thought I'd ask before I gave up (note that I don't need this generalisation; the point of <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> was to observe that we can remove some of these restrictions for free -- they're just not needed at all). </p>\n<p>Probably the place to start is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Equalizer.FirstObj#doc\">docs#CategoryTheory.Equalizer.FirstObj</a> , in <code>SheafOfTypes</code>. Just before that declaration we have <code>(P : Cᵒᵖ ⥤ Type max v₁ u₁)</code> which should probably now be taking values in <code>Type v₂</code>. Now we also change <code>FirstObj</code> to be in <code>Type v₂</code> and Lean (correctly) starts complaining that it can't unify universes. We fix this with e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">UnivLE.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">,</span><span class=\"n\">v₂</span><span class=\"o\">}]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">UnivLE.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"n\">v₂</span><span class=\"o\">}]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">UnivLE.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u₁</span> <span class=\"n\">v₁</span><span class=\"o\">,</span><span class=\"n\">v₂</span><span class=\"o\">}]</span>\n</code></pre></div>\n<p>which we were expecting, but then unfortunately the file doesn't compile. The first error is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">solve</span> <span class=\"kd\">universe</span> <span class=\"n\">constraint</span>\n  <span class=\"n\">v₂</span> <span class=\"bp\">=?=</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">u.175258</span> <span class=\"bp\">?</span><span class=\"n\">u.175259</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">u.175260</span>\n<span class=\"n\">while</span> <span class=\"n\">trying</span> <span class=\"n\">to</span> <span class=\"n\">unify</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">with</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u₁</span> <span class=\"n\">v₂</span><span class=\"o\">)</span> <span class=\"n\">v₁</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u₁</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Now my understanding is that Lean's universe logic is not strong enough to deduce that max a b is either a or b, and without this assumption I don't think we have a hope of unifying <code>v₂</code> with <code>max (max u₁ v₂) v₁</code> because in theory it could be bigger than both (in the sense that there might be model of Lean's universes where this max max really is bigger than <code>v₂</code>). So am I now stuck? Is there a way around this? Let me again stress that this is not blocking anything, it is just idle thoughts about whether I can make <a href=\"https://github.com/leanprover-community/mathlib4/pull/5659\">#5659</a> better.</p>",
        "id": 380295399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690801715
    },
    {
        "content": "<p>I haven't looked at the code at all, but just from reading your messages it seems you're using <code>UnivLE</code> \"wrong\" (or at least expecting more of it than I'd planend).</p>\n<p>The rule should be: when you used to write <code>X : Type u</code> <code>Y : Type (max u v)</code>, now write <code>X : Type u</code> <code>Y : Type v</code> <code>[UnivLE.{u,v}]</code>.</p>\n<p>Instead you're introducing a whole new universe <code>v₂</code>, replacing <code>max v₁ u₁</code>.</p>\n<p>Does that make sense? If not I better look at the code. :-)</p>",
        "id": 380302576,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690803015
    },
    {
        "content": "<p>In my example v2 was max(v1,u1) + 1. I wanted to use a certain function to bump a universe level up from u to u+1 and v2 was literally not equal to max(v1,u1). But maybe you're right and I need to rethink. A short answer to your message is that your u is my max(v1,u1) and your v is my v2.</p>",
        "id": 380316345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690805509
    },
    {
        "content": "<p>I am confused by seeing that you have introduced <em>three</em> <code>UnivLE</code> hypotheses. That is new! :-)</p>",
        "id": 380318261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690805866
    },
    {
        "content": "<p>and one of them mentions a <code>max</code>.</p>",
        "id": 380318516,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1690805912
    },
    {
        "content": "<p>I (think I) want to say \"v2 is &gt;= both u1 and v1\", because I want to say \"some construction in the theory of sheaves works\", and the construction involves (1) making an object of size max(u1,v1) and then (2) doing something in <code>A</code> with this object which implies that the morphisms of A live in a universe big enough to contain this object.</p>",
        "id": 380329423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690807782
    },
    {
        "content": "<p>The three hypotheses were all the ways I could think of to say \"v2 is bigger than both u1 and v1\"</p>",
        "id": 380329582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690807805
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Presieve</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">Y</span><span class=\"o\">⦄,</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>has type <code>Type (max u₁ v₁)</code> (a collection of sets of morphisms, indexed over a set of objects), and that is my \"small\" universe.</p>",
        "id": 380330877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690808031
    }
]