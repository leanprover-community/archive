[
    {
        "content": "<p>Hello everyone!</p>\n<p>We are a group of undergraduate students working on a summer research project, and we're hoping to get some advice from the community.</p>\n<ul>\n<li>\n<p><strong>Our Project:</strong> Our goal is to formalize the basics of <strong>Grid Homology</strong>, based on the combinatorial definition given in the <a href=\"https://arxiv.org/abs/2402.07558\">recent lecture notes by Wong and Zampa</a> and Chapter 3 and Chapter 4 on the book <a href=\"https://web.math.princeton.edu/~petero/GridHomologyBook.pdf\">Grid Homology for Knots and Links</a>. We plan to tackle the simplest case: the \"tilde\" or \"hat\" version of the chain complex (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mrow><mi>G</mi><mi>C</mi></mrow><mo>~</mo></mover><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\tilde{GC}(\\mathbb{G})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1702em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9202em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">GC</span></span></span><span style=\"top:-3.6023em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.25em;\"><span class=\"mord\">~</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">G</span><span class=\"mclose\">)</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mrow><mi>G</mi><mi>C</mi></mrow><mo>^</mo></mover><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\hat{GC}(\\mathbb{G})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1968em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9468em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">GC</span></span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.25em;\"><span class=\"mord\">^</span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">G</span><span class=\"mclose\">)</span></span></span></span>) over the field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Our plan is</p>\n<ol>\n<li>Define a grid diagram as a combinatorial object in Lean. (as a double-permutation) </li>\n<li>Define the chain complex generators as bijections of horizontal and vertical circles given by a toroidal grid diagram</li>\n<li>Define the differential <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∂</mi></mrow><annotation encoding=\"application/x-tex\">\\partial</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span></span></span></span> by counting \"empty rectangles\" between two generators.</li>\n<li>Prove that  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">∂</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\partial^2 = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, which is the core of the project.</li>\n<li>Define the resulting homology .</li>\n</ol>\n</li>\n<li>\n<p><strong>Our Situation:</strong> I have some basic experience in Lean but my collaborators are new to Lean  and are actively learning the basics now. Our supervisor is a topologist who is very supportive of the project but does not have prior experience with Lean, so we're all learning the practical side of formalization together.</p>\n</li>\n<li><strong>Our Initial Assessment:</strong> Based on our research, it seems the algebraic infrastructure we need (chain complexes, homology, vector spaces over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> ) is already very well-supported in Mathlib. The main challenge appears to be the combinatorial proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">∂</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\partial^2 = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, which is the Proposition 1.4 in the <a href=\"https://arxiv.org/abs/2402.07558\">notes</a>. The proof in the notes is visual, based on a double counting argument for how rectangles can be combined . Our idea is to translate this visual argument into a formal proof by translating into combinatorial language (phrased in terms of permutations and coordinates on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><msup><mo stretchy=\"false\">}</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\{0,...,n-1\\}^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>)</li>\n<li>\n<p><strong>Our Questions:</strong></p>\n<ol>\n<li>Does this project appear feasible and appropriately scoped for a team of beginners to accomplish over the course of a summer (approximately 2 months)? Additionally, is it worthwhile and advisable to formalize this project?</li>\n<li>Are there any major \"gotchas\" or tricky parts in formalizing this kind of combinatorial pairing argument that we might be underestimating?</li>\n<li>Are there any existing projects in Mathlib or elsewhere that formalize similar \"counting arguments for a differential\" that we could study as a good example?</li>\n</ol>\n</li>\n</ul>\n<p>Thanks so much for any advice or insights you can offer!</p>",
        "id": 526449895,
        "sender_full_name": "WHY",
        "timestamp": 1751304605
    },
    {
        "content": "<p>I would feel more confident about this if you had at least one member of the team who was a Lean expert (whether or not they knew anything about the mathematics) or had easy access to such a person. </p>\n<p>Formalization is an art. There will be an art to formalizing the proof of 1.4. I feel almost like 1.4 is cheating and the correct thing to formalize is Remark 1.5, because the correct approch to formalisation is to formalise the right theorem the first time around, as opposed to corollaries of it, because someone somewhere will need the right theorem at some point. For example Heegaard Floer homology is mentioned in recent serious papers in the Annals and if one wants to formalize the statements of those papers one wants to have the foundational theory done in the correct generality. However if this is only a one-off undergraduate project then of course you can formalize what you like. It would be a shame to miss this opportunity to get Heegaard Floer homology into mathlib. However you can regard your experiment as something which teaches the community what does and doesn't work.</p>\n<p>Other than finding someone who is really good at Lean and prepared to work with you (which is my number 1 piece of advice and might well be necessary to stop the project fro failing) I think my main suggestion would be to really understand why 1.4 is true before you write any Lean code at all. Write down a super-detailed proof in LaTeX (as part of your blueprint -- every project needs a blueprint) and make sure that there are absolutely no parts of it which are vague in any way. If it comes out to ten pages for something which takes 1 page in the pdf then so be it. Can you simplify your proof? Try and find several proofs in the literature. Think about the right generality. Are those rows and colums really indexed by {1,2,..,n}? Would an arbitrary totally ordered finite set work? Or is no ordering needed -- would Z/nZ work? An arbitrary non-ordered finite set? What is the correct level of generality of all the constructions? What the heck does \"a matching is a one-to-one correspondence between the vertical and horizontal circles.\" (p3) mean? I personally don't have a clue -- what ever is a vertical circle? do you understand this? did you read [31]? Does it help? Did you read the original papers where this was defined, rather than the first thing you found on the internet? The original sources for an idea often contain insights which get forgotten later. What is the <em>correct abstraction</em>? Someone with some Lean experience might really be able to help you here, which is why I am a bit nervous -- you seem to be full of enthusiasm and have many mathematicians available, but where is the person who will explain to you the right way to think about Lean?</p>",
        "id": 526495182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751322517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Feasibility.20of.20formalizing.20Grid.20Homology.20for.20summer.20project/near/526495182\">said</a>:</p>\n<blockquote>\n<p>I would feel more confident about this if you had at least one member of the team who was a Lean expert (whether or not they knew anything about the mathematics) or had easy access to such a person. </p>\n<p>Formalization is an art. There will be an art to formalizing the proof of 1.4. I feel almost like 1.4 is cheating and the correct thing to formalize is Remark 1.5, because the correct approch to formalisation is to formalise the right theorem the first time around, as opposed to corollaries of it, because someone somewhere will need the right theorem at some point. For example Heegaard Floer homology is mentioned in recent serious papers in the Annals and if one wants to formalize the statements of those papers one wants to have the foundational theory done in the correct generality. However if this is only a one-off undergraduate project then of course you can formalize what you like. It would be a shame to miss this opportunity to get Heegaard Floer homology into mathlib. However you can regard your experiment as something which teaches the community what does and doesn't work.</p>\n<p>Other than finding someone who is really good at Lean and prepared to work with you (which is my number 1 piece of advice and might well be necessary to stop the project fro failing) I think my main suggestion would be to really understand why 1.4 is true before you write any Lean code at all. Write down a super-detailed proof in LaTeX (as part of your blueprint -- every project needs a blueprint) and make sure that there are absolutely no parts of it which are vague in any way. If it comes out to ten pages for something which takes 1 page in the pdf then so be it. Can you simplify your proof? Try and find several proofs in the literature. Think about the right generality. Are those rows and colums really indexed by {1,2,..,n}? Would an arbitrary totally ordered finite set work? Or is no ordering needed -- would Z/nZ work? An arbitrary non-ordered finite set? What is the correct level of generality of all the constructions? What the heck does \"a matching is a one-to-one correspondence between the vertical and horizontal circles.\" (p3) mean? I personally don't have a clue -- what ever is a vertical circle? do you understand this? did you read [31]? Does it help? Did you read the original papers where this was defined, rather than the first thing you found on the internet? The original sources for an idea often contain insights which get forgotten later. What is the <em>correct abstraction</em>? Someone with some Lean experience might really be able to help you here, which is why I am a bit nervous -- you seem to be full of enthusiasm and have many mathematicians available, but where is the person who will explain to you the right way to think about Lean?</p>\n</blockquote>\n<p>Thank you for your detailed suggestions, Prof. Buzzard. Your feedback are very helpful and valuable for us!</p>\n<p>When my supervisor proposed this topic, I was uncertain if formalizing this specific result aligned with the philosophy of Mathlib. While the proof is combinatorial, my own exploration led me to believe the formalization would be extremely difficult and perhaps not the most necessary target.</p>\n<p>I will follow your advice and discuss finding a Lean expert with my supervisors. I will also raise these concerns to our supervisors and if we agree the project is not the right fit, I hope we can switch topics. Thank you again!</p>",
        "id": 526516021,
        "sender_full_name": "WHY",
        "timestamp": 1751339041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"769513\">WHY</span> has marked this topic as resolved.</p>",
        "id": 526516070,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751339063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/.E2.9C.94.20Feasibility.20of.20formalizing.20Grid.20Homology.20for.20summer.20pro.2E.2E.2E/near/526495182\">said</a>:</p>\n<blockquote>\n<p>It would be a shame to miss this opportunity to get Heegaard Floer homology into mathlib. </p>\n</blockquote>\n<p>At the current rate of progress, Mathlib is hundreds of years away from getting Heegaard Floer homology. Fortunately, this is not what we are discussing here.</p>",
        "id": 526547376,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751356715
    },
    {
        "content": "<p>Even just the <em>definition</em>?</p>",
        "id": 526557608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751359805
    },
    {
        "content": "<p>Oh yes.</p>",
        "id": 526558994,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1751360212
    },
    {
        "content": "<p>I should emphasize that \"at the current rate of progress\" is load-bearing here: I dearly hope this changes.</p>",
        "id": 526567186,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1751362827
    },
    {
        "content": "<p>Formalizing the combinatorics of grid diagrams and grid link homology would be valuable.</p>\n<p>It might come from deeper geometry <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, but this stuff can stand on its own. Someone could calculate some invariants of some concrete knots and formally prove it.</p>\n<p>It's ambitious for two months, but getting the combinatorics going and sketching out a blueprint seems doable.</p>\n<p>You're right Kevin about ordered sets. I think technically \"pointed cyclic orders\" (made that terminology up) is the right setting, since the diagrams are sort of on a torus with a distinguished fundamental domain.</p>",
        "id": 526586173,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751369254
    },
    {
        "content": "<p>Yeah, reading the article again it seemed that order <em>was</em> important (because of crossings) but conversely they were emphasizing that it should be thought of as a torus!</p>",
        "id": 526594954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751372303
    },
    {
        "content": "<p>Thank everyone for the suggestions and comments!</p>",
        "id": 526856459,
        "sender_full_name": "WHY",
        "timestamp": 1751480062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"769513\">WHY</span> has marked this topic as unresolved.</p>",
        "id": 528419649,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752279235
    },
    {
        "content": "<p>Hello everyone,</p>\n<p>We have an update on our project and some new questions.</p>\n<p>First, we are currently working on the blueprint to understand the combinatorics involved and are not writing much Lean code yet, aside from some basic definitions that we may revise later. So far, we have tried three ways to formulate the grid diagrams:</p>\n<p>(1) Permutations on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, ..., n-1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>.</p>\n<p>(2) Permutations on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/ n\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span> with the natural order defined.</p>\n<p>(3) A \"double cover\" approach, extending the grid to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mi>n</mi><mo>×</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">2n \\times 2n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span></span></span></span>, but define the states as coordinates.</p>\n<p>Our experience has been that approach (1) leads to a large number of cases for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">∂</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\partial^2= 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> proof, which are hard to formalize even in natural language as they are often distinguished visually by drawing graphs. Approach (2) was very similar and did not significantly simplify the case analysis.  (We do not delve deeply into (2), as it closely resembles (1). Perhaps this approach with some motification is more suitable.)</p>\n<p>We are now focusing on (3), the double cover, which has been more promising. It seems to reduce the number of basic cases to 8 with more combined cases of basic cases. We have developed an algorithmic proof for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">∂</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\partial^2  = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> that constructs the required pairing. However, we are still working on issues with its well-definedness, such as proving that our construction is consistent across the four quadrants of the larger grid.</p>\n<p>We have a few questions:</p>\n<ol>\n<li>\n<p>Has anyone tried to formalize the combinatorial arguments for the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">∂</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\partial^2 = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord\" style=\"margin-right:0.05556em;\">∂</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> proof before, even just in a detailed natural language paper?</p>\n</li>\n<li>\n<p>The original papers describe this proof as \"elementary checking\" without any detail. Does there exists a better and smarter abstraction that captures the symmetries in the case analysis to reduce the amount of manual work?</p>\n</li>\n<li>\n<p>If we cannot find a better abstraction, how well does Lean handle a very constructive, algorithmic proof that involves a large number of cases checking (e.g., over 30)?</p>\n</li>\n</ol>\n<p>Thank you for your time and any suggestions!</p>",
        "id": 529711363,
        "sender_full_name": "WHY",
        "timestamp": 1753043640
    },
    {
        "content": "<p>Not a concrete suggestion but I remember once falling into a similar trap with group cohomology. I had a Masters student define group cohomology as ker(d)/im(d) where d was a map between spaces of inhomogeneous cochains, and to prove that this definition made sense we had to prove <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^2=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> which was a real mess. Later on we realised that had we defined it using homogeneous cochains instead then the proof of d^2=0 was easy and we could have then checked that the square with the homogeneous and inhomogeneous d's in the rows and the isomorphism of homogeneous and inhomogeneous cochains in the columns commuted and deduced that d^2=0 for inhomogeneous cochains for free. So it's definitely worth trying to find the right abstraction because there might be something which makes it all easy.</p>",
        "id": 529712688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1753045266
    }
]