[
    {
        "content": "<p>So, I am finally mostly done with my project to provide converters in both directions between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Topology.RelCWComplex#doc\">docs#Topology.RelCWComplex</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopCat.RelativeCWComplex#doc\">docs#TopCat.RelativeCWComplex</a>. However, I am finding that the current design of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HomotopicalAlgebra.AttachCells#doc\">docs#HomotopicalAlgebra.AttachCells</a> makes it very difficult to make subcomplexes. </p>\n<p>The issue is primarily one of internal dependencies: there are three types/objects (<code>Œπ</code> and the points of the two cofans) internal to <code>AttachCells</code> that are then used in the types of other components of the structure (<code>œÄ</code>, <code>g‚ÇÅ</code>, <code>g‚ÇÇ</code>), which are then heavily used in the external API to <code>RelativeCellComplex</code>. Thus, a naive implementation of, say, a truncation of a CW complex to a finite subcomplex has to engage heavily with conditionals on the entire <code>AttachCells</code> structure; the internal dependencies then make it difficult to 'transpose' these statements into individual conditionals about each projection without heavy use of casts; and the direct coupling with external API expose the resulting tangled casts to the rest of the library.</p>\n<p>This certainly <em>can</em> be worked around -- I'm currently in the process of refactoring my subcomplex to use more computable conditionals that can be matched on -- but I still think this is a pretty big footgun that I'd prefer to fix. As such, I propose that we replace both <code>cofan</code>s and <code>isColimit</code>s with <code>HasCoproduct</code> typeclass parameters, and move <code>Œπ</code> out of the <code>AttachCells</code> substructure into the main <code>RelativeCellComplex</code> structure. The remaining data  <code>œÄ</code>, <code>g‚ÇÅ</code>, <code>g‚ÇÇ</code> is now non-dependent, in that no projection appears in the type of another projection.</p>\n<p>Is this a reasonable change? <span class=\"user-mention\" data-user-id=\"459699\">@Jo√´l Riou</span> , you're probably the one who would be most affected by this; what are your thoughts?</p>",
        "id": 531086969,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753601829
    },
    {
        "content": "<p>Replacing general cofans by the chosen coproduct does not seem reasonable to me. The field <code>Œπ</code> <em>may</em> be made a parameter, but I am not sure I undertstand how this would help the study of subcomplexes.</p>",
        "id": 531091466,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753603706
    },
    {
        "content": "<p>Whyever not? It's mathematically equivalent and cuts the necessary data required to make the structure in half, so it's quite appealing even aside from the issue of dependencies. And without that, you end up with a fundamentally internally dependent structure that cannot be easily transported across <code>RelativeCellComplex</code>es, especially ones where the relavent type parameters don't line up 'on the nose'.</p>",
        "id": 531091809,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753603853
    },
    {
        "content": "<p><code>Œπ</code> needs to be a parameter because otherwise, <code>œÄ</code> is of type <code>(ùìô.attachCells ...).Œπ ‚Üí ...</code>. Suppose that we wish to study a finite truncation of a complex; we may naively attempt to do so by reusing the existing <code>AttachCells</code>, but replacing all structures above a certain <code>n</code> by a trivial structure with <code>Œπ</code> empty.</p>",
        "id": 531092299,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753604049
    },
    {
        "content": "<p>Having done so, we run into a problem: <code>œÄ k</code> is now of type, say, <code>(if k &lt; j then (ùìô.attachCells ...) else trivialCell).Œπ ‚Üí ...</code>. \"Transposing\" this definition, writing a simp lemma that says <code>if k &lt; j then œÄ k = ... else œÄ k = ...</code>, now requires embedding multiple casts into the lemmas.</p>",
        "id": 531092737,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753604214
    },
    {
        "content": "<p>Certainly, we can just not do that; as noted, I'm currently rewriting this structure to split the linear order into a sum of an Iio and an Ici, so that I can computably match on the structure and write defeq simp lemmas. But that requires a nontrivial amount of extra infrastructure, some of which would have to be repeated every time I wanted to make a subcomplex of this type. I'd prefer to simply make the original structure non-dependent, with as much as possible referencing static externally-defined types like the <code>HasCoproduct</code> API and any remaining dependencies handled at the level of the full <code>RelativeCellComplex</code> structure.</p>",
        "id": 531093244,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753604418
    },
    {
        "content": "<p>I understand that there are dependent theory issues. Similar issues may appear if for example one wants to extend a functor from <code>Fin (n + 1)</code> to a functor from <code>Fin (n + 2)</code> by \"adding one more arrow\". In that case, one may relate both chunks of the glued functor by providing isomorphisms.<br>\nAn approach in order to relate different <code>AttachCells</code> would be, maybe not to define a category, but to express that if <code>f : X ‚ü∂ Y</code> and <code>g : X' ‚ü∂ Y'</code> are both equiped with two <code>AttachCells</code> structure, we may have morphisms <code>X ‚ü∂ X'</code> and <code>Y ‚ü∂ Y'</code> which makes the square commute, as well as an (injective?) map between the indices <code>Œπ</code> which makes a certain cube commute. Developing an API around this may be useful to solve some of your issues.</p>",
        "id": 531097338,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753606045
    },
    {
        "content": "<p>I mean, for now, that is in fact the approach I've taken; I have a bunch of API around equivalent <code>AttachCells</code> on the same morphism, plus a custom recursor that allows me to work with the <code>AttachCells</code> structure with the <code>HasCoproduct API</code> + an equivalence between motives given an equivalence between <code>AttachCells</code>, and now I'm adding yet more API to build <code>AttachCells</code> on prop-eq morphisms</p>",
        "id": 531098072,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753606330
    },
    {
        "content": "<p>But that makes a few extra thousand lines of code, and while some of that scales quite a lot of it doesn't; every time we want to build such a derived structure we're going to end up writing yet more API around the cast.</p>",
        "id": 531098428,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753606482
    },
    {
        "content": "<p>Why do you say it's unreasonable to replace general cofans with an abstractly defined coproduct?</p>",
        "id": 531098480,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753606499
    },
    {
        "content": "<p>Part of the problem is that the <code>HasCoproduct</code> would also be a dependent one.</p>",
        "id": 531099493,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753606907
    },
    {
        "content": "<p><code>HasCoproduct</code> is a <code>Prop</code>, so having it be dependent is a much lesser burden than having dependent  data in <code>Type</code>. </p>\n<p>Assuming you want to preserve maximal generality (i.e. not just using <code>HasColimitsOfShape (Discrete Œπ) C</code>), we can write something like...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">MorphismProperty</span><span class=\"bp\">.</span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">w'</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">t'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">HomotopicalAlgebra</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àÄ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">X‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">X‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X‚ÇÅ</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X‚ÇÇ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AttachCells</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œπ</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"w\">  </span><span class=\"n\">hasCoproduct‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasCoproduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">  </span><span class=\"n\">hasCoproduct‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasCoproduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">  </span><span class=\"n\">g‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àê</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X‚ÇÅ</span>\n<span class=\"w\">  </span><span class=\"n\">g‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚àê</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">‚ü∂</span><span class=\"w\"> </span><span class=\"n\">X‚ÇÇ</span>\n<span class=\"w\">  </span><span class=\"n\">isPushout</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPushout</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Sigma</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">œÄ</span><span class=\"w\"> </span><span class=\"bp\">¬∑</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g‚ÇÇ</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">AttachCells</span><span class=\"bp\">.</span><span class=\"n\">hasCoproduct‚ÇÅ</span><span class=\"w\"> </span><span class=\"n\">AttachCells</span><span class=\"bp\">.</span><span class=\"n\">hasCoproduct‚ÇÇ</span>\n</code></pre></div>\n<p>Now, while there are still internal dependencies, they're much less visible from outside the structure; the <code>HasCoproduct</code> instances are technically dependent, but as <code>Prop</code>-valued typeclasses they don't complicate further usage of the structure; invoking, say, <code>g‚ÇÇ</code> just references the statically-defined <code>sigmaObj</code> type and it doesn't really matter that the instance proving that that usage is valid happens to be dependent.</p>",
        "id": 531101970,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753607865
    },
    {
        "content": "<p>We still have the <code>œÄ</code> in   <code>‚àê (A &lt;| œÄ ¬∑)</code>, which I missed when I was sketching this out in my head earlier, but I think the existing <code>eqToHom</code> machinery can mostly handle cases like that when they appear as morphisms in a category.</p>",
        "id": 531102241,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753607982
    },
    {
        "content": "<p>In any case, the cleaner approach is what I have suggested above.</p>",
        "id": 531102909,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753608240
    },
    {
        "content": "<p>That is absolutely not the cleaner approach, though? As noted, that's a thousand additional lines of code.</p>",
        "id": 531102999,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753608272
    },
    {
        "content": "<p>I would be curious to know where you think using the HasCoproduct API will meaningfully complicate your use of this structure?</p>",
        "id": 531103154,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753608332
    },
    {
        "content": "<p>Using <code>eqToHom</code> would only solve one type of issue. What I suggested would also allow to study CW-complexes whose cells are \"subsets\" of cells of a large CW-complex, etc.<br>\nIt would be possible to use <code>HasCoproduct</code> instead, but I am not at all convinced that it would solve any dependent type issue. Doing this and putting <code>Œπ</code> outside would allow to give a reasonable mathematical meaning to the notion of equality between two <code>AttachCells</code> structures, but I do not think it is a good idea to follow this way, as it seems much more interesting to <em>relate</em> <code>AttachCells</code> structures for two different maps through commutative squares as I have suggested above.</p>",
        "id": 531106211,
        "sender_full_name": "Jo√´l Riou",
        "timestamp": 1753609574
    },
    {
        "content": "<p>Mm. I suppose my response then, is: why should we be attempting to relate <code>AttachCells</code> structures at all? As far as I can tell, they're just convenient packaging that have turned out to be less than convenient; I have much less issue with writing useful API for <code>RelativeCellComplex</code> itself, which is the level I expect to be actually working with these structures. </p>\n<p>In fact, my issues precisely derive from the fact that I can relatively easily come up with categorical representations of all the other data of a sub-<code>RelativeCellComplex</code>, before being bogged down in DTT hell when engaging with <code>AttachCells</code>; or, equivalently, that there is quite a lot of existing API with which to work with <code>TransfiniteCompositionOfShape</code> (which, ultimately, is just a bundled functor + isomorphism + some instances), but everything for <code>AttachCells</code> would have to be bespoke. The suggestion I outlined above makes it much easier to, say, turn a natural isomorphism between <code>TransfiniteCompositionOfShape</code>s into one between <code>RelativeCellComplex</code>es; it would also make it easier to make precisely that sort of subtyped-subcomplex you're describing, as with <code>Œπ</code> outside I can directly put constraints on a natural transformation between the underlying functors that require the cell attachment index types to be subtypes, rather than having to subtype the entire <code>AttachCell</code> structure or add an equivalent interface layer.</p>",
        "id": 531107682,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753610144
    }
]