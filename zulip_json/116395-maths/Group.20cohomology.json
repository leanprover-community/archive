[
    {
        "content": "<p>So I'm embarking on group cohomology with an MSc student <span class=\"user-mention\" data-user-id=\"243895\">@Shenyang Wu</span> and we're defining <code>d</code> on cochains. As part of the definition we have these \"contraction\" maps <code>F (n : nat) (j : fin (n + 1)) (g : fin (n + 1) -&gt; G) : fin n -&gt; G</code> with definition <code>lam k, if k &lt; j then g k else if k = j then (g j) * (g (j + 1)) else g (k + 1)</code> and we'll need a lemma of the form F n k \\circ F (n + 1) j = something like F n j \\circ F (n + 1) k except that depending on whether j&lt;k or k&lt;j some j should be a j-1 or maybe some k should be a k-1. This is all no doubt some fundamental construction in some category of simplicial sets or something. <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is what we need already in mathlib or available somewhere else, so we're not re-inventing the wheel? We need to understand <code>F</code> to prove d^2=0.</p>",
        "id": 180126655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573129459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> proved that the chain complex of a simplicial abelian group is a complex (d^2 = 0)</p>",
        "id": 180180118,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163468
    },
    {
        "content": "<p>There is another way to set this up, where <code>F (n : nat) (j : fin (n + 1)) (g : fin (n + 1) -&gt; G) : fin n -&gt; G</code> just drops the j'th term</p>",
        "id": 180180135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573163495
    },
    {
        "content": "<p>However depending on how you set things up, you might have some difficulty showing that you have a simplicial object</p>",
        "id": 180180148,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163503
    },
    {
        "content": "<p>Yes, that way will be a lot easier, I think.</p>",
        "id": 180180169,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163512
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 180180267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573163542
    },
    {
        "content": "<p>At least, if you want to connect to Johan's work. Because you already have a simplicial object more or less by definition (a simplicial operator just acts by precomposition).</p>",
        "id": 180180283,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163547
    },
    {
        "content": "<p>I think Johan's work might have been in a PR that was never merged, let me see if I can find it</p>",
        "id": 180180357,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163599
    },
    {
        "content": "<p>Well I found <a href=\"https://github.com/leanprover-community/mathlib/issues/144\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/144\">#144</a>, but I think there may have been a second attempt</p>",
        "id": 180180495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163709
    },
    {
        "content": "<p>Hmm, maybe there is only <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/category_theory/simplex.lean\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/category_theory/simplex.lean\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/category_theory/simplex.lean</a></p>",
        "id": 180180683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573163854
    },
    {
        "content": "<p>Do you have any intention of PR'ing all that stuff?</p>",
        "id": 180180816,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573163933
    },
    {
        "content": "<p>I want to make group cohomology in Lean and I'm pretty sure that some of those tools are going to be useful for setting up the basics.</p>",
        "id": 180180861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573163962
    },
    {
        "content": "<p>I have too big a backlog of things to PR...</p>",
        "id": 180181015,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164042
    },
    {
        "content": "<p>But this file doesn't depend on anything else in lean-homotopy-theory at least</p>",
        "id": 180181041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164060
    },
    {
        "content": "<p>In your second setup, are you planning to mod out <code>fin (n + 1) -&gt; G</code> by the diagonal action of G?</p>",
        "id": 180181089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164086
    },
    {
        "content": "<p>I'm wondering whether I can get away with not doing it.</p>",
        "id": 180181170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164128
    },
    {
        "content": "<p>The alternative is to require that <code>0</code> is mapped to the identity of G but then the first face map will have a funny formula</p>",
        "id": 180181186,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164146
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/questions/6950/why-is-the-standard-definition-of-cocycle-the-one-that-always-comes-up\" target=\"_blank\" title=\"https://mathoverflow.net/questions/6950/why-is-the-standard-definition-of-cocycle-the-one-that-always-comes-up\">https://mathoverflow.net/questions/6950/why-is-the-standard-definition-of-cocycle-the-one-that-always-comes-up</a></p>",
        "id": 180181187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164147
    },
    {
        "content": "<p>I started by telling <span class=\"user-mention\" data-user-id=\"243895\">@Shenyang Wu</span> to use <code>(fin n -&gt; G) -&gt; M</code> and using the \"twisted\" d, which involves those maps <code>F</code> I mentioned earlier</p>",
        "id": 180181239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164191
    },
    {
        "content": "<p>and then I realised that working with <code>fin (n + 1) -&gt; G</code> might be easier because the d^2=0 proof looked much easier</p>",
        "id": 180181268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164216
    },
    {
        "content": "<p>but then you have to work around this quotient issue</p>",
        "id": 180181368,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164272
    },
    {
        "content": "<p>As one of the answers observed, rather than actually form a quotient, you could then take only G-equivariant functions out of it</p>",
        "id": 180181417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164304
    },
    {
        "content": "<p>G-equivariant functions from <code>fin (n + 1) -&gt; G</code> to <code>M</code></p>",
        "id": 180181459,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164337
    },
    {
        "content": "<p>Actually I guess you have to do it that way maybe?</p>",
        "id": 180181517,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164363
    },
    {
        "content": "<p>when M has nontrivial action</p>",
        "id": 180181538,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164379
    },
    {
        "content": "<p>Oh, it's even in your question.</p>",
        "id": 180181561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164396
    },
    {
        "content": "<p>I should probably read that question at some point</p>",
        "id": 180181654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164479
    },
    {
        "content": "<p>I'm a little surprised I didn't answer this question</p>",
        "id": 180181921,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164616
    },
    {
        "content": "<p>do you know the answer? I remember being not too convinced by any of the topologists' suggestions.</p>",
        "id": 180181982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164651
    },
    {
        "content": "<p>Let me try to give what I think is a better answer</p>",
        "id": 180182000,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164662
    },
    {
        "content": "<p>I see cocycles coming up in all sorts of calculations in group theory</p>",
        "id": 180182012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573164667
    },
    {
        "content": "<p>I'm not sure exactly how well this will go, but anyways</p>",
        "id": 180182371,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164875
    },
    {
        "content": "<p>You should start with the category EG, which has one object for each element of G, and a unique morphism between any pair of objects</p>",
        "id": 180182380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164891
    },
    {
        "content": "<p>This is a \"resolution\" of the category with one object and one morphism (we know maps out of this are G-fixed points, so this has something to do with group cohomology) as something on which G acts freely, by left multiplication, say</p>",
        "id": 180182549,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573164993
    },
    {
        "content": "<p>Let's look at the orbits of EG under the action of G</p>",
        "id": 180182616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165045
    },
    {
        "content": "<p>There's obviously just one orbit of objects. For morphisms, if we have a morphism from x to y, give it the label x^{-1} y. Then g sends it to a morphism from gx to gy with the same label (gx)^{-1} gy = x^{-1} y. It's easy to see morphisms with the same label make up the orbits.</p>",
        "id": 180182796,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165140
    },
    {
        "content": "<p>Moreover if we compose a morphism with label x^{-1} y with a morphism with label y^{-1} z we get a morphism with label x^{-1} z = (x^{-1} y) (y^{-1} z), so labels multiply under composition</p>",
        "id": 180182919,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165208
    },
    {
        "content": "<p>So if we form the quotient EG/G, we get the category BG with one object and one morphism for each element of G, where composition of morphisms corresponds to multiplication in G.</p>",
        "id": 180182942,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165233
    },
    {
        "content": "<p>Now, let's look at simplices of the nerve of EG. An n-simplex of the nerve of EG is a functor from [n] = the category {0 -&gt; 1 -&gt; ... -&gt; n} to EG.</p>",
        "id": 180182984,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165266
    },
    {
        "content": "<p>But in EG there's a unique morphism between any two objects, so this is just given by a function from {0, 1, ..., n} to G.</p>",
        "id": 180183018,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165287
    },
    {
        "content": "<p>The image of this simplex under the projection EG -&gt; BG is now a functor from [n] to BG. In BG, there is just one object so the only interesting information is where the n morphisms 0 -&gt; 1, 1 -&gt; 2, ..., (n-1) -&gt; n go. For each one I have to give an element of G.</p>",
        "id": 180183177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165359
    },
    {
        "content": "<p>If my original simplex was described by (x_0, ..., x_n) then its image in BG is described by (x_0^{-1} x_1, ..., x_{n-1}^{-1} x_n).</p>",
        "id": 180183239,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165398
    },
    {
        "content": "<p>In the other direction, if I have a simplex in BG (g_1, ..., g_n), then one of the simplices that it is the image of is (1, g_1, g_1 g_2, g_1 g_2 g_3, ..., g_1 ... g_n), and the others are given by left multiplication by any g in G.</p>",
        "id": 180183339,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165451
    },
    {
        "content": "<p>So that is where the formula you were asking about comes from.</p>",
        "id": 180183357,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165461
    },
    {
        "content": "<p>I'll need some time to digest this, but thanks (I'm trying to do some topology)</p>",
        "id": 180183410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573165504
    },
    {
        "content": "<p>If M has trivial G-action, then H^*(G, M) is the cohomology of this simplicial set BG = EG/G with coefficients in M. The complex that computes this has C^n = functions from n-simplices of EG/G to M, or from n-simplices of BG to M. Correspondingly this gives functions defined on <code>(fin (n+1) -&gt; G) / G</code> or <code>fin n -&gt; G</code>, with the above rule for translating between these representations. In this case, because M has trivial action, the former can also be thought of as G-equivariant functions from <code>fin (n+1) -&gt; G</code> to M.<br>\nIf M has nontrivial G-action, then I guess you need to say something about local systems and it's not quite as easy to relate group cohomology to simplicial cohomology.</p>",
        "id": 180184023,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573165922
    },
    {
        "content": "<p>For the purpose of formalization, the EG description makes it trivial to show that you've got a simplicial set. The simplicial structure maps are just given by composing <code>fin (m + 1) -&gt; fin (n + 1) -&gt; G</code></p>",
        "id": 180184166,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573166043
    },
    {
        "content": "<p>I've been meaning to return to the simplicial stuff for quite a while. But there are too many other things on my todo list... and it will require some coordination to get a flexible API.</p>",
        "id": 180206646,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573195273
    },
    {
        "content": "<p>Sorry to hijack your thread, but I've been meaning to do (or get a student to do) some group cohomology in HoTT, but I'm not exactly sure which theorems to aim for. I guess as a start, I'd prove that the two descriptions, in terms of homotopy theory (cohomology of BG with coefficients in M : BG -&gt; Ab) and combinatorics (cohomology of some cochain complex), are equal. What would be a good test after that do you think?</p>",
        "id": 180219636,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573210779
    },
    {
        "content": "<p>I was not going to do anything topological (reflecting my background I guess). My plan was: (1) definition of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(G,M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> (2) proof that it's a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>-modules to abelian groups (3) long exact sequence of group cohomology (4) [probably won't get there] spectral sequence (5) [probably won't get there] some sort of uniqueness statement -- it's some universal delta-functor.</p>",
        "id": 180221916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573213152
    },
    {
        "content": "<p>OK, thanks. Because we already have the long exact sequence and Serre spectral sequence in the HoTT libraries, we'd get the LES (3) and L-H-S spectral sequence (4) (sans multiplicative structure) for group cohomology as corollaries. I don't know if (5) would follow as well – maybe that would require a theory of module spectra (which we don't know how to do)?</p>",
        "id": 180222635,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573213985
    },
    {
        "content": "<p>You don't have the Serre spectral sequence for \"honest topological spaces\" though, just for these homotopy types. I would like to see an honest group cohomology spectral sequence in a HoTT theory, that would be great!</p>",
        "id": 180222876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573214199
    },
    {
        "content": "<p>But homotopy types are precisely enough to talk about BG for any group G, etc., so I don't see what would be dishonest about the resulting group cohomology spectral sequence?</p>",
        "id": 180223137,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573214497
    },
    {
        "content": "<p>I'll see if I can put that together for our joint paper on the spectral sequence (which is way overdue)</p>",
        "id": 180223200,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573214558
    },
    {
        "content": "<blockquote>\n<p>Sorry to hijack your thread, but I've been meaning to do (or get a student to do) some group cohomology in HoTT, but I'm not exactly sure which theorems to aim for. I guess as a start, I'd prove that the two descriptions, in terms of homotopy theory (cohomology of BG with coefficients in M : BG -&gt; Ab) and combinatorics (cohomology of some cochain complex), are equal.</p>\n</blockquote>\n<p>This already sounds quite challenging to me, or at least the method I would apply in \"ordinary math\" doesn't seem to work, because you can't build the geometric realization of a simplicial set in HoTT, can you?</p>",
        "id": 180228548,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573219123
    },
    {
        "content": "<p>Oh right, you're the author of the $$\\mathbb{RP}^n$ paper. Then I would believe you know how to do this, even though I don't.</p>",
        "id": 180231686,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573221667
    },
    {
        "content": "<p>How about calculating the cohomology of free groups. That should be easier than Kevin's way :)</p>",
        "id": 180231714,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573221679
    },
    {
        "content": "<p>Can I hijack your hijack and ask whether we know how to construct <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">BU</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> in HoTT yet?</p>",
        "id": 180231940,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573221871
    },
    {
        "content": "<blockquote>\n<p>Can I hijack your hijack and ask whether we know how to construct <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">BU</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> in HoTT yet?</p>\n</blockquote>\n<p>I think so: construct <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi><mi>U</mi></mrow><annotation encoding=\"application/x-tex\"> KU </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> using Snaith's theorem, and take the connected component at the basepoint of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>×</mo><mi>B</mi><mi>U</mi><mo>≃</mo><msup><mi mathvariant=\"normal\">Ω</mi><mi mathvariant=\"normal\">∞</mi></msup><mi>K</mi><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\times BU \\simeq \\Omega^\\infty KU </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77222em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">Ω</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span>.</p>",
        "id": 180232274,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573222164
    },
    {
        "content": "<p>Oh hmm</p>",
        "id": 180232380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1573222226
    },
    {
        "content": "<p>That still doesn't get us <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi><mi>U</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> BU(n) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>, though, AFAICT.</p>",
        "id": 180232433,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573222269
    },
    {
        "content": "<blockquote>\n<p>This already sounds quite challenging to me, or at least the method I would apply in \"ordinary math\" doesn't seem to work, because you can't build the geometric realization of a simplicial set in HoTT, can you?</p>\n</blockquote>\n<p>Right, we don't have geometric realization of simplicial sets, but here we can build a corresponding CW structure directly, I think, and we know (and have formalized in the Agda library) that the cellular cochain complex computes cohomology correctly.</p>",
        "id": 180232723,
        "sender_full_name": "Ulrik Buchholtz",
        "timestamp": 1573222498
    },
    {
        "content": "<blockquote>\n<p>But homotopy types are precisely enough to talk about BG for any group G, etc</p>\n</blockquote>\n<p>Yes exactly! That's why I think this would be a brilliant thing to do in HoTT.</p>",
        "id": 180238000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1573225859
    },
    {
        "content": "<p>I thought I'd test out the new API we have for homological algebra, by doing a test case: building a model for group cohomology. There are competing topologists who I believe want to build a totally different model involving these exotic <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K(G,1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> spaces or whatever they're called, but my version with homogeneous cocycles and coboundaries is on the <code>group-cohomology</code> branch of mathlib and <a href=\"https://github.com/leanprover-community/mathlib/blob/ce56c4f6fa5913563abfc09b85a06e4962846e0e/src/algebra/group/cohomology.lean#L170-L171\">I just proved</a> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^2=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>.</p>\n<p>People have said various things to me in DMs about how building a model via cocycles is somehow \"not the right thing to do\" for some reason. However I have, in a sense, written down an explicit implementation of a projective resolution for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\Z[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>, and used it to calculate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>x</mi><msup><mi>t</mi><mi>i</mi></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><msup><mi>H</mi><mi>i</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Ext^i(\\Z[G],M):=H^i(G,M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0746639999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">x</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0746639999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>Given that I have proved that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^2=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> I would like to claim my free \"short-exact-sequence-implies-long-exact-sequence\" and \"Hochschild-Serre spectral sequence\" theorems, or at least the \"Inf-res\" long exact sequence for group cohomology in low degree. What API do you category people require? <span class=\"user-mention\" data-user-id=\"132893\">@Ken Lee</span> ?</p>",
        "id": 240735484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622345270
    },
    {
        "content": "<p>I haven't looked at this yet, but can you show that you've produced a projective resolution in the sense of <a href=\"https://github.com/leanprover-community/mathlib/issues/7486\">#7486</a>? This might be a good fit test.</p>",
        "id": 240735536,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622345351
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">cochain_succ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_apply'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">to_fun</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I guess we don't have a type for bundled <code>distrib_mul_action</code>-compatible maps.</p>",
        "id": 240735676,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622345625
    },
    {
        "content": "<p>Maybe it's better to quickly develop that, i.e. just replacing <code>fin n → G</code> with some arbitrary <code>distrib_mul_action G N</code>. Presumably everything up to line 148 holds in that setting.</p>",
        "id": 240735743,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622345757
    },
    {
        "content": "<p>The point of <a href=\"https://github.com/leanprover-community/mathlib/issues/7486\">#7486</a> (projective resolutions) <a href=\"https://github.com/leanprover-community/mathlib/issues/7487\">#7487</a> (derived functors) and <a href=\"https://github.com/leanprover-community/mathlib/issues/7525\">#7525</a> (Ext) is to provide you with a single \"chosen\" <code>left_derived n F</code>, for each functor <code>F</code>, and also to provide the API so you can bring your own favourite resolution, and know that <code>(left_derived n F).obj X</code> is isomorphic to the n-th homology of <code>F</code> applied to that resolution.</p>",
        "id": 240735853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622345947
    },
    {
        "content": "<p>I think the DMs saying building the model via cocycles is not the right thing to do (not from me) are just pointing out that your calculation of <code>d^2 = 0</code> here can likely be factored without much additional work into constructing a simplicial object, and then computing the alternating face complex of that simplicial object --- but that second piece of work only ever needs to be done once (and has been done in LTE).</p>",
        "id": 240735925,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622346095
    },
    {
        "content": "<p>But I haven't actually tried building the relevant simplicial object here, so I can't really promise that you get a reduction in work by using the alternately face complex.</p>",
        "id": 240735931,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622346123
    },
    {
        "content": "<p>I would hope that you can even get something that is pretty close to definitionally equal to what you've done!</p>",
        "id": 240735968,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622346143
    },
    {
        "content": "<p>Oh, sorry, scratch those last three comments. Maybe they only apply with the usual model of group cohomology. Maybe there's some augmentation trick, I'm not sure, to fit the homogeneous model into this picture, I'd have to think about it.</p>",
        "id": 240736025,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622346263
    },
    {
        "content": "<p>I'm fairly sure the homogeneous cochain complex is defeq to the alternating face map cochain complex associated to such a cosimplicial object, and furthermore this cosimplicial object can be built from K(pi,1) as a simplicial set (not a topological space! It's just the combinatorics that encapsulate the usual differential). I certainly wasn't suggesting constructing anything via any actual topological spaces <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span></p>",
        "id": 240736473,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622346992
    },
    {
        "content": "<p>I don't know if the simplicial construction of this might be helpful <a href=\"https://ncatlab.org/nlab/show/group+cohomology\">nlab#group+cohomology</a></p>",
        "id": 240736760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622347489
    },
    {
        "content": "<p>Looks like this describes modules with the trivial action, but I'm sure the general construction is written down somewhere...</p>",
        "id": 240736816,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622347610
    },
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsupp.equiv_congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→₀</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n<span class=\"c1\">-- by rw e</span>\n</code></pre></div>\n<p>I'm making the projective resolution using <code>finsupp</code>.</p>",
        "id": 240737546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622348861
    },
    {
        "content": "<p>If you use <code>map_domain</code> you need <code>M</code> to be (unnecessarily) an <code>add_comm_monoid</code> and if you use <code>comap_domain</code> you end up noncomputable.</p>",
        "id": 240737797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622349304
    },
    {
        "content": "<p>I think you want to use <code>emb_domain</code> instead</p>",
        "id": 240737810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622349347
    },
    {
        "content": "<p>actually that one is noncomputable too</p>",
        "id": 240737852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622349405
    },
    {
        "content": "<p>yeah I guess the computable version only works with an equiv, since the support maps and the function comaps</p>",
        "id": 240737879,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622349479
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7755\">#7755</a></p>",
        "id": 240738422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622350566
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action_hom\">docs#distrib_mul_action_hom</a> - isn't that the bundled type you ask for above?</p>",
        "id": 240755149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622380273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Group.20cohomology/near/240735853\">said</a>:</p>\n<blockquote>\n<p>The point of <a href=\"https://github.com/leanprover-community/mathlib/issues/7486\">#7486</a> (projective resolutions) <a href=\"https://github.com/leanprover-community/mathlib/issues/7487\">#7487</a> (derived functors) and <a href=\"https://github.com/leanprover-community/mathlib/issues/7525\">#7525</a> (Ext) is to provide you with a single \"chosen\" <code>left_derived n F</code>, for each functor <code>F</code>, and also to provide the API so you can bring your own favourite resolution, and know that <code>(left_derived n F).obj X</code> is isomorphic to the n-th homology of <code>F</code> applied to that resolution.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what Scott said here sounds like what's needed in the usual pen-and-paper maths construction of LES-from-SES for group cohomology. I remember inhomogeneous cocycles/coboundaries being very confusing, though great for computation, and I don't know much about the homogeneous ones. I also only know Inf-Res for <code>H^1</code>, and it always seemed quite strange to me because somehow it's about cohomologies in three different abelian categories rather than one. I don't know enough category theory to see this in a nice way.</p>",
        "id": 240776967,
        "sender_full_name": "Ken Lee",
        "timestamp": 1622413118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I think <code>finsupp.equiv_congr</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.dom_congr\">docs#finsupp.dom_congr</a>.</p>",
        "id": 240871086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622495170
    },
    {
        "content": "<p><code>dom_congr</code> also only works for <code>add_comm_monoid</code>s</p>",
        "id": 240871146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622495268
    },
    {
        "content": "<p>It's also badly named since the similar defs use <code>domain</code> instead of <code>dom</code></p>",
        "id": 240871338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622495439
    },
    {
        "content": "<p>The definitions in <code>equiv</code> call this <code>congr_left</code></p>",
        "id": 240872440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1622496261
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.Pi_congr_left\">docs#equiv.Pi_congr_left</a>?</p>",
        "id": 240876456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622500258
    },
    {
        "content": "<p>I'm a few days late to the party, but staring at this type</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">cochain_succ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_apply'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">to_fun</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and thinking about <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s suggestion about <code>distrib_mul_action</code>, it seems like if you were to generalize <code>fin n → G</code> to an arbitrary <code>G</code>-module <code>N</code>, then this is exactly the definition of the type of <code>G</code>-module homomorphisms <code>N → M</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group_action_hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.pi</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">uG</span> <span class=\"n\">uM</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uG</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uM</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">cochain_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>For my own education, I tried updating <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s implementation of <code>d</code> to use this type, hoping there was enough automatic stuff in mathlib already.  There were some missing instances and simp lemmas, but it wasn't so bad:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group_action_hom</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.pi</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fin</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">uG</span> <span class=\"n\">uM</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uG</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uM</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">cochain_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n                  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n            <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n                <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">add_left_neg</span><span class=\"o\">,</span> <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ev_zero</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_action_hom.coe_eta_ev</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ax</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">mul_action_hom.mk</span> <span class=\"n\">f</span> <span class=\"n\">ax</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_action_hom.add_ev</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Copied from data.fin_simplicial_complex to make this code block self contained.</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">fin</span>\n<span class=\"sd\">/-- The function denoted `δᵖ` by Riehl-Verity, sending`t` to `t` if `t&lt;p` and</span>\n<span class=\"sd\">  `t.succ` otherwise.`-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">delta</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- fin.succ_above expects p : fin i.succ for some reason</span>\n<span class=\"o\">⟨</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">t</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ht.trans</span> <span class=\"o\">(</span><span class=\"n\">nat.lt_succ_self</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">nat.succ_lt_succ</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">delta_eval</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"n\">hj</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">t</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">delta_comm_apply</span>  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">j.succ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hpq</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">delta</span> <span class=\"n\">hk</span> <span class=\"n\">q.succ</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"n\">hj</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">delta</span> <span class=\"n\">hk</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"n\">hj</span> <span class=\"n\">q</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">delta_eval</span><span class=\"o\">],</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">nat.succ_eq_add_one</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">nat.succ_eq_add_one</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"bp\">;</span>\n  <span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">linarith</span><span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">delta_comm_apply.symm</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i.succ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">j.succ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q_succ</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hpq</span> <span class=\"o\">:</span> <span class=\"n\">q_succ</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">delta</span> <span class=\"n\">hk</span> <span class=\"n\">p.succ</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"n\">hj</span> <span class=\"n\">q_succ</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">delta</span> <span class=\"n\">hk</span> <span class=\"n\">q_succ</span> <span class=\"o\">(</span><span class=\"n\">delta</span> <span class=\"n\">hj</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">delta_comm_apply</span> <span class=\"n\">hj</span> <span class=\"n\">hk</span> <span class=\"n\">hpq</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">fin</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cochain_succ</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">i</span> <span class=\"bp\">→+</span> <span class=\"n\">cochain_succ</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">c</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">fin.delta</span> <span class=\"n\">hj</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"o\">)),</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.smul_sum</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">congr</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">mul_action_hom.map_smul</span><span class=\"o\">,</span>\n      <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span> <span class=\"bp\">+</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_add_distrib</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>\n<p>I don't know if it's worth it, but that type is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">cochain_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">free_abelian_group</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>and then <code>d</code> comes from dualizing the chain complex of <code>free_abelian_group (fin n → G)</code> groups, which is essentially what others have already said.  It might be worth factoring it like this if someone wanted to do group homology, too, but it seems like in the short term it would be work to develop the API for <code>G</code>-module homomorphisms from free abelian groups without any real payoff, assuming it doesn't already exist somewhere.</p>",
        "id": 241430418,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1622743812
    },
    {
        "content": "<p>Note also that you don't need to take a free abelian group of anything, by the universal property of the free abelian group... It's just G-equivariant functions from n-tuples in G to N.</p>",
        "id": 241431270,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622744230
    },
    {
        "content": "<p>Oh sorry that's exactly what you wrote in the spoiler, Kyle <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 241431461,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622744310
    },
    {
        "content": "<p>Anyway, this is already essentially the simplicial approach I was hoping for above.</p>",
        "id": 241431537,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622744356
    },
    {
        "content": "<p>For group homology you can replace functions with finsupp, and still avoid free abelian groups</p>",
        "id": 241432095,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622744621
    },
    {
        "content": "<p>Oh, and I just noticed Reid’s comment about <code>EG/G</code> from 2019…</p>",
        "id": 241434989,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1622745987
    },
    {
        "content": "<p>I have a bunch of files showing that the explicit description of group cohomology in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy=\"false\">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Fun(G^n, M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> is the same as Ext.<br>\nAt some point while writing them I learned about delta functors and checked out the work on them &amp; LES's in LTE. I got worried that my files are redundant and I should've been making the LTE stuff PR'able instead.<br>\nBut I'm thinking there'd be a lot more work to do after that; stuff about universal delta functors would give you a correspondence with the right derived functors of the left exact functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mi>G</mi></msup></mrow><annotation encoding=\"application/x-tex\">M^G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span></span></span></span></span></span></span></span>, and that's not what you want, really, because the cocycles etc in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy=\"false\">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Fun(G^n, M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> \"come from\" a projective resolution. So you'd need balancing of Ext or something, too, which seems like it might be hard.<br>\nSo if I am thinking straight, I am hoping my work is still worth PR'ing. But I wanted to check.<br>\nMany thanks!</p>",
        "id": 268753639,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1642710947
    },
    {
        "content": "<p>I think it's certainly worthwhile to have an explicit projective resolution of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>-module (with the trivial action) in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>u</mi><mi>n</mi><mo stretchy=\"false\">(</mo><msup><mi>G</mi><mi>n</mi></msup><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Fun(G^n,M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> (which is essentially what the whole (in)homogeneous cocycle definition is all about).</p>",
        "id": 268754012,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642711114
    },
    {
        "content": "<p>That's the easiest way I know of showing, for example, that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^1(G,A) = Hom(G,A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> has a trivial action, relating <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^2(G,M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> to extensions, etc.</p>",
        "id": 268754090,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642711153
    },
    {
        "content": "<p>We should have the ability to \"compute\" Ext groups in terms of an explicit projective resolution (at least eventually).</p>",
        "id": 268754237,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642711218
    },
    {
        "content": "<p>Fair play. Thank you!</p>",
        "id": 268754369,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1642711289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> do you think it might be worthwhile to generalize a bit, and obtain a projective resolution of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">A[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>-module where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is any commutative ring?</p>",
        "id": 268755137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642711647
    },
    {
        "content": "<p>Sure - I wasn't sure whether to do this. Could we just tensor by A instead?</p>",
        "id": 268756026,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1642712071
    },
    {
        "content": "<p>Hello - I want to open another PR for my group cohomology stuff; I'm not sure of the future of <a href=\"https://github.com/leanprover-community/mathlib/pull/14308\">my current one</a> because it could be done in better generality, as can be seen <a href=\"https://github.com/leanprover-community/mathlib/pull/14372\">here</a>.<br>\nI decided the complex of inhomogeneous cochains would be the best place to start right now. Would this be ok? And for the proof that d^2 = 0, should I make use of <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebraic_topology/alternating_face_map_complex.lean\">this</a> (except I need the cochain version)?  </p>\n<p>Next PR after that could be some API for the cohomology in low degree, or the isomorphism of the complex of inhomog cochains with Hom(-, M) of a projective resolution. Also have a little file with Hilbert 90 in which doesn't technically rely on anything else.</p>",
        "id": 284790295,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1654196770
    },
    {
        "content": "<p>There are certainly different ways to do this. An approach could be to construct a resolution of <code>A</code> as an <code>A[G]</code>-module by starting from the construction of <code>EG</code> (which is a simplicial object in the category of <code>G</code>-sets). This could be done directly, or as a particular case of <code>algebraic_topology.cech_nerve</code> (applied to the map from the tautological <code>G</code>-set <code>G</code> to the terminal object); alternatively, this is also the nerve (now in mathlib) of a specific category. Then, the free <code>A</code>-module functor from sets to <code>A</code>-modules can be transformed into a functor <code>F</code> from <code>G</code>-sets to <code>A</code>-modules equipped with a <code>G</code>-action (i.e. <code>A[G]</code>-modules). Applying this functor <code>F</code> termwise gives a functor from simplicial <code>G</code>-sets to simplicial <code>A[G]</code>-modules. Applying this to <code>EG</code>, we get a certain simplicial <code>A[G]</code>-module, which we may denote <code>A[EG]</code>, and then take the alternate face map complex attached to <code>A[EG]</code>, which is a complex of <code>A[G]</code>-modules: it is a projective resolution of <code>A</code> as a <code>A[G]</code>-module. Using this resolution to compute Ext and by doing computations in appropriate bases, it should be possible to identify the differential to the usual differential on the usual cochain complex which computes group cohomology. (Note that I have not used cosimplicial objects, only simplicial objets! Even though at some point the alternate <em>co</em>face map complex should also be formalised.)</p>\n<p>In this way, the explicit formulas for the differentials on the cochains would appear as a computation rather than as a definition, and it would save the penance of checking <code>d^2=0</code>.</p>\n<p>However, I have skipped the details of some important step, which is why it is so that <code>A[EG]</code> is homotopic to <code>A</code> (in degree 0) <em>when we forget the action of <code>G</code></em>. There are various ways to do that. The most direct approach I see would be to use an argument which appears in Goerss-Jardine, <em>Simplicial Homotopy Theory</em>, p. 190. (It is basically a sufficient condition for a simplicial set to be homotopy equivalent to a discrete set, and this condition of \"having an extra degeneracy\" is preserved when we apply the free <code>A</code>-module functor, and in the case of additive categories, the condition gives a chain complex homotopy. I could certainly help implementing this part.)</p>",
        "id": 284940448,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654295802
    },
    {
        "content": "<p>I am still unproud to say that we have 0 cohomology theories in mathlib, although we're clearly getting close, and my instinct would be to choose the path of least resistance, which would be homogeneous cochains, where d^2=0 is pretty easy, so they are in my view the shortest route to an actual definition of an object <code>group_cohomolology.H n G M</code> which we can then actually say exists. The moment we have existence, we can go on to prove that this object is all the other objects which we also call group cohomology, e.g. unhomogeneous cocycles/coboundaries, singular cohomology of these exotic spaces, derived functor cohomology etc, and opening the door to explicit computations in low degree such as \"the answer to this question in group theory/field theory is an H^1\" or \"this theorem says that H^1 vanishes\". Right now we can't do any of this stuff because we have no definition.</p>\n<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> Shenyang Wu developed group cohomology using unhomogeneous cocycles <a href=\"https://github.com/Shenyang1995/M4R\">here</a> and d^2=0 was painful. That's why I'm suggesting homogeneous cocycles.</p>",
        "id": 285026889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654420709
    },
    {
        "content": "<p>The model I suggested using the simplicial <code>G</code>-set <code>EG</code> gives exactly the homogeneous cochains! The <code>n</code>-simplices of <code>EG</code> are elements of <code>G^{n+1}</code> equipped with the obvious action of <code>G</code>. In <code>mathlib</code> terms, these are just <code>fin (n+1) → G</code>. Then, we need the free <code>A</code>-module functor, as a functor <code>F</code> from <code>G-sets</code> to <code>A[G]-modules</code>. Applying <code>F</code> to <code>EG</code> gives a simplicial <code>A[G]-module</code> whose alternate face map complex is the projective resolution of <code>A</code> which allows us to compute <code>Ext</code> as homogeneous cochains. That it is a complex of projective modules comes from the fact that <code>F</code> of a <code>free G-set</code> is a free <code>A[G]-module</code>. That it is a resolution follows that the argument I mentionned from the book by Goerss-Jardine. (Comparison with inhomogeneous cochains would presumably correspond to a particular choice of basis...)</p>",
        "id": 285034837,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654432795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Group.20cohomology/near/285034837\">said</a>:</p>\n<blockquote>\n<p>Comparison with inhomogeneous cochains would presumably correspond to a particular choice of basis...</p>\n</blockquote>\n<p>If I remember correctly, if homogeneous cochains correspond to putting group elements at the vertices of simplices, then inhomogeneous cochains correspond to putting group elements along the spine of a simplex (the edges 0-&gt;1, 1-&gt;2, ..., n-1-&gt;n). Then, given a choice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> and an inhomogeneous cochain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(g_1,\\dots,g_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, one can get a homogeneous cochain by \"integrating\", getting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mo separator=\"true\">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>g</mi><msub><mi>g</mi><mn>1</mn></msub><msub><mi>g</mi><mn>2</mn></msub><mo>…</mo><msub><mi>g</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(g,gg_1,gg_1g_2,\\dots,gg_1g_2\\dots g_n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. Inhomogeneous cochains factor out the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> action, sort of pre-quotienting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">EG</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">EG</span></span></span></span> to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">BG</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">BG</span></span></span></span>, and each choice of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> gives a different lift of a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">BG</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">BG</span></span></span></span> simplex to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">EG</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">EG</span></span></span></span>.</p>",
        "id": 285040777,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1654441939
    },
    {
        "content": "<p>In a draft branch <a href=\"https://github.com/leanprover-community/mathlib/blob/extra_degeneracy/src/algebraic_topology/extra_degeneracy.lean\">https://github.com/leanprover-community/mathlib/blob/extra_degeneracy/src/algebraic_topology/extra_degeneracy.lean</a> I have formalised the notion of extra degeneracy for an augmented simplicial object. The main definitions are</p>\n<ul>\n<li>the structure <code>extra_degeneracy X</code> for any <code>X : simplicial_object.augmented C</code></li>\n<li>\n<p><code>extra_degeneracy.map</code>: extra degeneracies are preserved by the application of any<br>\nfunctor <code>C ⥤ D</code></p>\n</li>\n<li>\n<p><code>extra_degeneracy.for_cech_nerve_of_split_epi</code>: the augmented Čech nerve of a split<br>\nepimorphism has an extra degeneracy</p>\n</li>\n<li>\n<p><code>extra_degeneracy.preadditive.homotopy_equivalence</code>: when the category <code>C</code> is<br>\npreadditive and has a zero object, and <code>X : simplicial_object.augmented C</code> has an extra<br>\ndegeneracy, then the augmentation <code>alternating_face_map_complex.ε.app X</code> is a homotopy<br>\nequivalence of chain complexes</p>\n</li>\n</ul>\n<p>Using this, one may easily get that <code>A[EG]</code> is a resolution of <code>A</code> as an <code>A</code>-module. Taking into account the <code>A[G]</code>-modules structures, one may deduce that <code>A[EG]</code> is a (projective) resolution of <code>A</code> as an <code>A[G]</code>-module, and then that the homogeneous cochains can be used to compute <code>Ext</code> groups.</p>",
        "id": 285129273,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654530139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> After more thinking, it seems that as you suggested, you may need the dual version of the functor <code>alternating_face_map_complex</code>. It should be easy to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">alternating_coface_map_complex</span> <span class=\"o\">:</span> <span class=\"n\">cosimplicial_object</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">cochain_complex</span> <span class=\"n\">C</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>by using <code>alternating_face_map_complex</code> for the opposite category and the duality equivalences for simplicial objects or functors (in mathlib) and for homological complexes (it seems that <code>homological_complex.op_equivalence {ι : Type*} (c : complex_shape ι) : (homological_complex Cᵒᵖ c)ᵒᵖ ≌ homological_complex C c.symm</code> is not in mathlib yet).</p>\n<p>Then, in order to get the homogeneous cochain complex, you would have to define a cosimplicial <code>A</code>-module attached to any <code>A[G]</code>-module <code>M</code> by sending the integer <code>(n : simplex_category)</code> to <code>G</code>-equivariant maps <code>(fin (n+1) → G) → M</code>, and apply <code>alternating_coface_map_complex</code>. Definitionally speaking, this might be better than using <code>cech_nerve</code> (which would involve taking <code>wide_pullbacks</code> of <code>n+1</code> copies to the map <code>G → *</code>. The machinery I have suggested above would then enable us to do a comparison with Ext groups in the category of <code>A[G]</code>-modules.</p>",
        "id": 285141323,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654535198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Group.20cohomology/near/285141323\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118107\">Amelia Livingston</span> After more thinking, it seems that as you suggested, you may need the dual version of the functor <code>alternating_face_map_complex</code>. It should be easy to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">alternating_coface_map_complex</span> <span class=\"o\">:</span> <span class=\"n\">cosimplicial_object</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">cochain_complex</span> <span class=\"n\">C</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>by using <code>alternating_face_map_complex</code> for the opposite category and the duality equivalences for simplicial objects or functors (in mathlib) and for homological complexes (it seems that <code>homological_complex.op_equivalence {ι : Type*} (c : complex_shape ι) : (homological_complex Cᵒᵖ c)ᵒᵖ ≌ homological_complex C c.symm</code> is not in mathlib yet).</p>\n</blockquote>\n<p>This is done in LTE: <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_op.lean\">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_op.lean</a><br>\nFeel free to copy it elsewhere (eg mathlib).</p>",
        "id": 285143304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654536150
    },
    {
        "content": "<p>Also, <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean\">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean</a> contains that coface cochain complex.</p>",
        "id": 285143395,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654536195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Group.20cohomology/near/285143395\">said</a>:</p>\n<blockquote>\n<p>Also, <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean\">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/simplicial/complex.lean</a> contains that coface cochain complex.</p>\n</blockquote>\n<p>It is nice that the dualisation of homological complexes is in LTE <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span><br>\nAs the <code>alternating_face_map_complex</code>functor  is already in <code>mathlib</code>, I would suggest not duplicating all the definitions and proofs (as it is done for limits/colimits, projectives/injectives), but rather obtain the <em>co</em>face version by dualising the functor <code>alternating_face_map_complex</code> and stating an appropriate simp lemma for the calculation of the differential (which may not be a definitional equality ?).</p>",
        "id": 285144723,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654536882
    },
    {
        "content": "<p>I did that for <code>coboundary</code>. So the fact that <code>d² = 0</code> is deduced from the other version.</p>",
        "id": 285145202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654537162
    },
    {
        "content": "<p>But it can probably be optimised a bit.</p>",
        "id": 285145219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654537172
    },
    {
        "content": "<p>In fact, I think both versions should be refactored: every (co)simplicial object in <code>C</code> should give rise to a (co)chain complex in <code>free ℤ C</code> (the category with the same objects as <code>C</code>, but all the homsets replaced by their freely-generated ab groups).</p>",
        "id": 285145374,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654537247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Group.20cohomology/near/285145374\">said</a>:</p>\n<blockquote>\n<p>In fact, I think both versions should be refactored: every (co)simplicial object in <code>C</code> should give rise to a (co)chain complex in <code>free ℤ C</code> (the category with the same objects as <code>C</code>, but all the homsets replaced by their freely-generated ab groups).</p>\n</blockquote>\n<p>I do not think so, because the construction you describe can be very easily deduced from the existing one: <code>whisker</code> your (co)simplicial object in <code>C</code> with the functor <code>C ⥤ free ℤ C</code> and then apply the alternating (co)face map complex functor.</p>",
        "id": 285208183,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654583065
    },
    {
        "content": "<p>I have just PRed <a href=\"https://github.com/leanprover-community/mathlib/pull/14588\">#14588</a> the definition of the alternating coface map complex.</p>",
        "id": 285228141,
        "sender_full_name": "Joël Riou",
        "timestamp": 1654596384
    },
    {
        "content": "<p>The definition of the alternating coface map complex is now in mathlib.</p>",
        "id": 290503272,
        "sender_full_name": "Joël Riou",
        "timestamp": 1658495109
    }
]