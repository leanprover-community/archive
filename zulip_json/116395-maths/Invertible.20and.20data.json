[
    {
        "content": "<p>Motivated by <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> 's <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a>. Why do we carry data in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> ? Should we turn <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> into a typeclass instead?</p>",
        "id": 467733290,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725518218
    },
    {
        "content": "<p>Alternatively, we can turn <code>IsUnit</code> into a typeclass and treat <code>[Invertible _]</code> the same way we treat <code>Decidable</code>: only use it if we need a computable <code>invOf</code>.</p>",
        "id": 467733512,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725518292
    },
    {
        "content": "<p>I think it was done because there are examples where you can compute, and it is nice if it works in those examples. For example some localizations like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\Z[1/2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord\">1/2</span><span class=\"mclose\">]</span></span></span></span>, where <code>2</code> is invertible, but you don't have all rational numbers. Or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/8\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/8</span><span class=\"mord mathbb\">Z</span></span></span></span> where 3, 5, 7 are their own multiplicative inverses.</p>",
        "id": 467737382,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725519483
    },
    {
        "content": "<p>So I think it is worth looking into your 2nd suggestion. Where we have a data-carrying class that is used sparingly, and prop-class that is used for almost all the theory.</p>",
        "id": 467737457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725519521
    },
    {
        "content": "<p>I think there is no obvious overlap here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> is essentially a bundled <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> is the associated prop.</p>",
        "id": 467818665,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725534685
    },
    {
        "content": "<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a></li>\n</ul>",
        "id": 467819161,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725534745
    },
    {
        "content": "<p>yeah, sorry!</p>",
        "id": 467820104,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725534851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/467818665\">said</a>:</p>\n<blockquote>\n<p>I think there is no obvious overlap here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> is essentially a bundled <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> is the associated prop.</p>\n</blockquote>\n<p><code>IsUnit x</code> is the same as <code>Nonempty (Invertible x)</code>. What I'm trying to say is that we use a typeclass with subsingleton data (<code>Invertible</code>) as an assumption in theorems that don't need the data, and this can lead to non-defeq diamonds.</p>",
        "id": 467860417,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725543185
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a></p>",
        "id": 475032912,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728172841
    },
    {
        "content": "<p>On Github, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> argues that we should migrate to <code>(h : IsUnit _)</code> instead.</p>",
        "id": 475113735,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728233574
    },
    {
        "content": "<p>At least in places where we don't actually want the data</p>",
        "id": 475124425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728238617
    },
    {
        "content": "<p>My main argument pro <code>[IsUnit _]</code> is that people who don't care about fields of positive characteristic may want to apply theorems that require <code>IsUnit (2 : K)</code> without making another stop to prove it.</p>",
        "id": 475124625,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728238758
    },
    {
        "content": "<p>Is it 2 specifically that we care about?</p>",
        "id": 475125721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728239684
    },
    {
        "content": "<p>I definitely have some examples for <code>IsUnit (2 : K)</code>, incl. midpoint and <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a></p>",
        "id": 475125898,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239850
    },
    {
        "content": "<p>I don't have other examples in mind right now.</p>",
        "id": 475125915,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239875
    },
    {
        "content": "<p>Unless we want to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_inv_cancel#doc\">docs#mul_inv_cancel</a> etc to <code>[DivisionMonoid G] [IsUnit a]</code></p>",
        "id": 475125975,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239911
    },
    {
        "content": "<p>Note: we already have it as <code>@[simp]</code> for <code>Invertible a</code>.</p>",
        "id": 475126009,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239946
    },
    {
        "content": "<p>I think we might be missing the bigger picture on 14986; the result is also true (and I believe straightforward to prove with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuadraticMap.toBilin#doc\">docs#QuadraticMap.toBilin</a>) in free modules where 2 is not invertible</p>",
        "id": 475126454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728240293
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124\">https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124</a> for a list of lemmas that assume <code>[Invertible _]</code> but never use <code>invOf</code> in the statement.</p>",
        "id": 475127338,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728240796
    },
    {
        "content": "<p>(there are other pending linters in the same PR, so you need to search for <code>Invertible</code>)</p>",
        "id": 475127356,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728240823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/475127338\">said</a>:</p>\n<blockquote>\n<p>See <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124\">https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124</a> for a list of lemmas that assume <code>[Invertible _]</code> but never use <code>invOf</code> in the statement.</p>\n</blockquote>\n<p>I think I would be in favor of changing all these to <code>(h : IsUnit x)</code> and using <code>[Fact (IsUnit x)]</code> on the one or two instances.</p>",
        "id": 475130466,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728242077
    },
    {
        "content": "<p>Why <code>[IsUnit _]</code> is worse?</p>",
        "id": 475133186,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728243471
    },
    {
        "content": "<p>I don't understand how this argument doesn't lead to us converting everything of type <code>Prop</code> into a typeclass</p>",
        "id": 475133291,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728243503
    },
    {
        "content": "<p>Maybe that really is a fine outcome, but I've definitely heard arguments that doing that for, say, <code>Odd</code> and <code>Even</code> would amount to an abuse of typeclass search.</p>",
        "id": 475134581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728244141
    },
    {
        "content": "<p>This smells like typeclass abuse to me too. It feels much more likely that we'll want to prove <code>IsUnit</code> from other available hypotheses, than being able to infer it from the structure of the argument.</p>",
        "id": 475220187,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728284451
    },
    {
        "content": "<p>What do you think about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidAlgebra.Submodule.complementedLattice#doc\">docs#MonoidAlgebra.Submodule.complementedLattice</a> ?</p>",
        "id": 476858898,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944699
    },
    {
        "content": "<p>UPD: it should assume <code>NeZero</code>.</p>",
        "id": 476858934,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944732
    },
    {
        "content": "<p>Ignore my last 2 messages.</p>",
        "id": 476858947,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944739
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17754\">#17754</a> makes Maschke use <code>IsUnit</code>.</p>",
        "id": 476869438,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728952031
    },
    {
        "content": "<p>What should I do about <code>IsUnit 2</code>? Use <code>Fact</code>? Introduce a typeclass specifically for this?</p>",
        "id": 476880240,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959572
    },
    {
        "content": "<p>I also see an assumption <code>Invertible 3</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeierstrassCurve.exists_variableChange_isShortNF#doc\">docs#WeierstrassCurve.exists_variableChange_isShortNF</a></p>",
        "id": 476880404,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959641
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Linear.instEpiHSMulHomOfInvertible#doc\">docs#CategoryTheory.Linear.instEpiHSMulHomOfInvertible</a></p>",
        "id": 476880831,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959816
    },
    {
        "content": "<p>It's an instance that assumes <code>[Invertible r]</code> but doesn't use data.</p>",
        "id": 476880892,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959839
    },
    {
        "content": "<p>I think it makes sense to use <code>Fact</code> for these \"a specific number is invertible\" predicates</p>",
        "id": 477182422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729075270
    },
    {
        "content": "<p>I think that depends whether the instance you're using <code>Fact</code> on is data or a proof</p>",
        "id": 477183885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075763
    },
    {
        "content": "<p>If it's a proof, then <code>Fact (IsUnit x)</code> does indeed make the most sense. If it's data, then <code>Invertible x</code> is often better.</p>",
        "id": 477183927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075786
    },
    {
        "content": "<p>If your proof uses some auxiliary data along the way, use <code>def aux [Invertible x]</code> to define that data, then use <code>IsUnit.nonempty_invertible</code> to construct that instance mid-proof</p>",
        "id": 477184068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075831
    },
    {
        "content": "<p>Why <code>Fact (IsUnit _)</code> is better than <code>[IsUnit _]</code>?</p>",
        "id": 477239824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729091318
    },
    {
        "content": "<p>(e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a> is a typeclass but we mostly use it as a predicate)</p>",
        "id": 477239933,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729091354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/477239824\">said</a>:</p>\n<blockquote>\n<p>Why <code>Fact (IsUnit _)</code> is better than <code>[IsUnit _]</code>?</p>\n</blockquote>\n<p>I'll admit, I'm not sure. Why is <code>Fact (IsPrime _)</code> better than <code>[IsPrime _]</code>? Seems to be similar reasoning.</p>",
        "id": 477404982,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729159204
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a> have anything to say?</p>",
        "id": 477407470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729160087
    },
    {
        "content": "<p>Yes, but I don't really get its reasoning. Is the issue just that <code>Nat.prime</code> would become a one-field structure instead of being def-eq to its definition?</p>",
        "id": 477408652,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729160508
    },
    {
        "content": "<p>By that reasoning, <code>IsUnit</code> should probably not be a class either</p>",
        "id": 477408879,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729160571
    },
    {
        "content": "<p>Ah, I hadn't considered that (historic?) limitations around non-structure classes could have factored in here.</p>",
        "id": 477410492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729161130
    },
    {
        "content": "<p>My rule of thumb would be \"only use typeclasses for types\"</p>",
        "id": 477410592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729161175
    },
    {
        "content": "<p>I don't think it's quite as simple as that, e.g. having <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CharZero#doc\">docs#CharZero</a> as a typeclass is definitely a good thing.</p>",
        "id": 477411199,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161384
    },
    {
        "content": "<p>I'd argue the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT#doc\">docs#WellFoundedLT</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedGT#doc\">docs#WellFoundedGT</a> but maybe I'm biased since I'm the one who pushed for those <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 477411581,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161523
    },
    {
        "content": "<p>Oh wait, I misunderstood you as implying typeclasses should be type-valued rather than having type arguments</p>",
        "id": 477411707,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161572
    },
    {
        "content": "<p>I mostly agree with that rule of thumb.</p>",
        "id": 477412051,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161713
    },
    {
        "content": "<p>I'd like to point to the counterexample of the unbundled order classes like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsRefl#doc\">docs#IsRefl</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsTrans#doc\">docs#IsTrans</a>, etc. I'd argue these are still good to have, but if anyone ever wants to refactor them out I don't think I'll be strongly opposed.</p>",
        "id": 477412331,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161830
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a></p>",
        "id": 477458635,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729175690
    },
    {
        "content": "<p>IsClosed I'd argue should be de-classified, <code>NeZero</code> I haven't thought about before.</p>",
        "id": 477476686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729180697
    },
    {
        "content": "<p><code>NeZero</code> seems to be helpful e.g. to avoid using <code>PNat</code>.</p>",
        "id": 477481367,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1729182251
    },
    {
        "content": "<p>Do you suggest migrating to <code>Fact (IsClosed _)</code> whenever we need to assume <code>IsClosed</code> in an instance?</p>",
        "id": 477485736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729183758
    },
    {
        "content": "<p>Yes, that's my claim</p>",
        "id": 477490149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729185424
    },
    {
        "content": "<p>The reason we used <code>IsClosed</code> as a typeclass is to be able to obtain that quotients of normed spaces by closed subspaces are normed spaces. For instance, if you're in finite dimension, subspaces are automatically closed, so quotients are automatically normed spaces. If you want to get this fact for free using the <code>Fact</code> mechanism, then you need to register this as a global <code>Fact</code> instance, but if I remember correctly global <code>Fact</code> instances should be avoided if possible. So I see what we lose when going from <code>[IsClosed ...]</code> to <code>[Fact (IsClosed ...)]</code>. What do we gain?</p>",
        "id": 477492559,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1729186335
    },
    {
        "content": "<p>Agreed that the alternative would be a few global instances of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a>, but we have a number of those already</p>",
        "id": 477492845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729186460
    },
    {
        "content": "<p>Flipping the question around; what do we lose if we make _every_ <code>structure ... : Prop</code> a <code>class</code>?</p>",
        "id": 477492942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729186507
    },
    {
        "content": "<p>In Lean 3, that would have caused a lot of frozen instance cache issues</p>",
        "id": 477494679,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729187203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/477458635\">said</a>:</p>\n<blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a></p>\n</blockquote>\n<p><code>IsClosed</code> is a <em>class</em>? <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span></p>",
        "id": 477511620,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1729193650
    },
    {
        "content": "<p>RE <code>NeZero</code>, I've only ever come across <code>NeZero 1</code> in my own applications, which arguably could be made into a <code>OneNeZeroClass</code> if we really wanted to.</p>",
        "id": 477539508,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729207989
    },
    {
        "content": "<p><code>NeZero</code> is used, e.g., in our instances about <code>Fin</code>.</p>",
        "id": 477541243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209215
    },
    {
        "content": "<p>In many cases, <code>NeZero (1 : R)</code> can be replaced with <code>Nontrivial R</code>.</p>",
        "id": 477541321,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209252
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero.one#doc\">docs#NeZero.one</a></p>",
        "id": 477541410,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209344
    },
    {
        "content": "<p>It's also used for measures, where a bunch of lemmas break for the zero measure</p>",
        "id": 477602259,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729239559
    },
    {
        "content": "<p>Also in low characteristic <code>[NeZero (2 : R)]</code>and  <code>[NeZero (3 : R)]</code> are already useful (and one day we'll certainly get to <code>[NeZero (5 : R)]</code> and maybe higher). E.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EllipticCurve.ofJ_0_of_three_ne_zero#doc\">docs#EllipticCurve.ofJ_0_of_three_ne_zero</a></p>",
        "id": 477614497,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1729243659
    },
    {
        "content": "<p>That looks like it could just take <code>(h : 3 \\ne 0)</code> as an argument</p>",
        "id": 477616697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729244375
    },
    {
        "content": "<p>In these scenarios, I just want to avoid manually supplying a proof that something is not <code>0</code>. Typeclass synthesis is one mechanism. If set up appropriately, autoparams could be another. Though <code>NeZero</code> didn’t get upstreamed for no reason.</p>",
        "id": 477641539,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729253482
    },
    {
        "content": "<p>My understanding is that <code>NeZero</code> got upstreamed because of <code>Fin</code>, and the decision was based on \"this is what mathlib does\" not \"this is clearly the perfect solution\"</p>",
        "id": 477641889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729253602
    },
    {
        "content": "<p>NeZero is also somehow different because we have both the <code>class</code> and the non-class</p>",
        "id": 477642054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729253649
    },
    {
        "content": "<p>Sure, but if they had a better idea, they wouldn’t have. </p>\n<p>I think the cost of flipping everything to classes is just performance.</p>",
        "id": 477642612,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729253850
    },
    {
        "content": "<p>I would like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.ZMod.Defs</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p.Prime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to succeed</p>",
        "id": 477652479,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257014
    },
    {
        "content": "<p>Enough to create an RFC for it?</p>",
        "id": 477653265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729257278
    },
    {
        "content": "<p>If I recall correctly, having the possibility to run tactics for default arguments in typeclass inference was considered at the beginning of Lean 4, but it was discarded later because of added complexity and performance issues. Given how critical this is, I'm not sure the FRO is willing to revisit this.</p>",
        "id": 477653787,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1729257467
    },
    {
        "content": "<p>I think an RFC is fine but I would guess that as <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> says: significant changes to typeclass synthesis are currently off the table</p>",
        "id": 477654003,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257529
    },
    {
        "content": "<p>I would also guess that the FRO considered something like this before upstreaming <code>NeZero</code> but I have no first-hand knowledge</p>",
        "id": 477654225,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257597
    },
    {
        "content": "<p>Now my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18531\">#18531</a> of to elliptic curves is related to <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a>... If <code>IsUnit</code> is a typeclass then this PR could be simplified a little bit (also with API changes).</p>",
        "id": 480356008,
        "sender_full_name": "Jz Pan",
        "timestamp": 1730685723
    },
    {
        "content": "<p>Pinging that <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a> is marked <code>awaiting-zulip</code> based on this thread. It would be good to come to a decision here, and either close that PR or proceed with reviewing it.</p>",
        "id": 480549729,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730765402
    },
    {
        "content": "<p>+1 for ping</p>",
        "id": 481481192,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731175389
    },
    {
        "content": "<p>I've been using (and got to like) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> quite consistently in the recent factor of <code>rootsOfUnity</code>. So I think a <code>Prop</code>- valued version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> makes sense. But I haven't followed this discussion very closely.</p>",
        "id": 481485536,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1731178767
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> WDYT?</p>",
        "id": 481528445,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731215999
    },
    {
        "content": "<p>My stance is:</p>\n<ul>\n<li>IsUnit shouldn't be a class </li>\n<li>Invertible is mostly ok as is</li>\n<li>A new <code>HasInverse x x_inv : Prop</code> (which is to <code>IsUnit</code> as <code>HasSum</code> is to <code>Summable</code>) would ease some of the pain around Invertible.</li>\n</ul>",
        "id": 481534872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731221963
    },
    {
        "content": "<p>In the examples where I suggest we assume <code>[IsUnit a]</code>, we <strong>don't want</strong> to know <code>a_inv</code>.</p>",
        "id": 481534994,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222064
    },
    {
        "content": "<p>Right, in those examples I am suggesting <code>Fact (IsUnit a)</code></p>",
        "id": 481535190,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222287
    },
    {
        "content": "<p>(and I am not proposing <code>HasInverse</code> should be a <code>class</code>)</p>",
        "id": 481535222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222331
    },
    {
        "content": "<p>Why <code>Fact (IsUnit a)</code> is better than <code>class IsUnit</code> (rarely used as a class)?</p>",
        "id": 481535229,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222333
    },
    {
        "content": "<p>Should <code>Summable</code> be a class too? Should <code>Prime</code>?</p>",
        "id": 481535292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222365
    },
    {
        "content": "<p><code>Summable</code>: AFAICT, we never need it to construct an instance. <code>Prime</code>: possibly (we use <code>Fact (Nat.Prime p)</code> very often).</p>",
        "id": 481535333,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481535229\">said</a>:</p>\n<blockquote>\n<p>Why <code>Fact (IsUnit a)</code> is better than <code>class IsUnit</code> (rarely used as a class)?</p>\n</blockquote>\n<p>Here's one argument; if you make it a class, every caller has to think about whether to write <code>(h : IsUnit a)</code> or <code>[IsUnit a]</code>. If you use <code>Fact</code>, this choice is obvious</p>",
        "id": 481535448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222526
    },
    {
        "content": "<p>Makes sense, but didn't work for <code>Nat.Prime</code>... I don't see any system in <code>(h : p.Prime)</code> vs <code>[Fact p.Prime]</code>...</p>",
        "id": 481535542,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222619
    },
    {
        "content": "<p>So, we should add instances for, e.g., <code>[GroupWithZero G] {a : G} [NeZero a] : Fact (IsUnit a)</code>?</p>",
        "id": 481535576,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481535333\">said</a>:</p>\n<blockquote>\n<p>AFAICT, we never need it to construct an instance.</p>\n</blockquote>\n<p>I think \"needed to construct an instance\" is exactly the design problem that <code>Fact</code> is intended to solve. </p>\n<p>So I think your argument might extend to \"we should remove <code>Fact</code>\", which is worthy of its own thread.</p>",
        "id": 481535586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222676
    },
    {
        "content": "<p>BTW, are discrimination trees good enough with <code>Fact</code>s?</p>",
        "id": 481535591,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222681
    },
    {
        "content": "<p>They should be fine, <code>key (Fact X) = [Fact] ++ key X</code></p>",
        "id": 481535669,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222739
    },
    {
        "content": "<p>Does it mean that we can use <code>Fact (Predicate ...)</code> instead of turning <code>Predicate</code> into a class without slowdown?</p>",
        "id": 481535705,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222790
    },
    {
        "content": "<p>I think yes</p>",
        "id": 481535717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222804
    },
    {
        "content": "<p>(ignoring the negligable cost of the key having one more element)</p>",
        "id": 481535736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222834
    },
    {
        "content": "<p>Then I'll start migrating some <code>[Invertible]</code> assumptions to <code>[Fact (IsUnit _)]</code>.</p>",
        "id": 481536203,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731223291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481535705\">said</a>:</p>\n<blockquote>\n<p>Does it mean that we can use <code>Fact (Predicate ...)</code> instead of turning <code>Predicate</code> into a class without slowdown?</p>\n</blockquote>\n<p>While this is true, it also goes against our original plans to <em>not</em> use <code>Fact</code> as a general \"let's have typeclass search do our proving\" mechanism. </p>\n<p>(Perhaps it is a feature, not a bug, that there is overhead to turning something into a class?)</p>",
        "id": 481599741,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731274720
    },
    {
        "content": "<p>With <code>Nat.prime p</code> there is never any proving; it literally is just a convenient way of saying \"let p be a prime forever\". So this is a great use of <code>Fact</code> as far as I can see.</p>",
        "id": 481600517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731275416
    },
    {
        "content": "<p>My mental model was that <code>Fact</code> was only really intended to allow non-typeclasses into the assumptions of instances as <code>instance [Fact (Predicate ..)] : _</code>; which is compatible with Kim's comment which I think is objecting to it appearing in the conclusion as <code>instance : Fact (Predicate ..)</code>.</p>",
        "id": 481602106,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731276852
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a> indicates a few such instances exist, but I think they're mostly for convenience rather than doing heavy lifting)</p>",
        "id": 481602154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731276909
    },
    {
        "content": "<p>But we want to have at least the following instances for <code>IsUnit _</code> (or `Fact (IsUnit _)1):</p>\n<ul>\n<li><code>[Group G] (a : G) : IsUnit a</code></li>\n<li><code>[Invertible a] : IsUnit a</code></li>\n<li><code>IsUnit 1</code></li>\n<li><code>[GroupWithZero G₀] (a : G₀) [NeZero a]</code></li>\n<li><code>[CommMonoid M] {a b : M} [IsUnit a] [IsUnit b] : IsUnit (a * b)</code></li>\n<li><code>[IsUnit a] (n : Nat) : IsUnit (a ^ n)</code></li>\n<li><code>[IsUnit (OfNat.ofNat n : R)] : IsUnit (OfNat.ofNat : Module.End R M)</code> (this instance from <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a> and motivated this thread).</li>\n</ul>",
        "id": 481627031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731297687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Maybe we should just try to make <code>IsUnit</code> a class. Your argument is that this puts us on a slippery slope. Maybe it does. But we're still deciding on a case-by-case basis. And Yury has some good arguments for wanting automation to kick in. TC is the best we have for this right now.</p>",
        "id": 481650910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731310089
    },
    {
        "content": "<p>The examples above feel rather like</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481599741\">said</a>:</p>\n<blockquote>\n<p>\"let's have typeclass search do our proving\"</p>\n</blockquote>\n<p>I'm not sure that the fact some proposition can be deduced structurally is a sufficient argument for us to use typeclasses search to prove it; otherwise <code>Differentiable</code> and <code>IsSquare</code> would surely deserve the same treatment.</p>",
        "id": 481660019,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731313469
    },
    {
        "content": "<p>I find it sad that we can’t have “let’s have typeclass search do our proving”.</p>",
        "id": 481690542,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1731322834
    },
    {
        "content": "<p>IIRC we tried this a bit in LTE with simple inequalities. We were working with L^p spaces with p&lt;1 remembered as a Fact, and would occasionally get typeclass inference to prove things like q&lt;p and p&lt;1 implies q&lt;1.</p>",
        "id": 481694804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731324158
    },
    {
        "content": "<p>Yeah, we used it a lot. It did all sorts of multiplications of inequalities</p>",
        "id": 481700878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731325893
    },
    {
        "content": "<p>Of course we didn't have gcongr back then</p>",
        "id": 481700899,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731325901
    },
    {
        "content": "<p>The situation is somewhat similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.IsPrime#doc\">docs#Ideal.IsPrime</a> where that is a class. Sometimes IsPrime is passed as an explicit argument, and sometimes as a TC argument. And it has to be in TC access so that one can get an integral domain instance on the quotient ring.</p>",
        "id": 481701903,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1731326142
    },
    {
        "content": "<p>Note that I explained that we may have reasonable <code>IsUnit</code> instances but I didn't find any <strong>instances</strong> that need to assume <code>[IsUnit _]</code>, at least in this thread.</p>",
        "id": 481750371,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731339364
    },
    {
        "content": "<p>I guess, we can try to migrate some of those <code>[Invertible _]</code> to <code>(h : IsUnit _)</code> until we meet an <code>instance</code>, then come back to this discussion.</p>",
        "id": 481750543,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731339418
    },
    {
        "content": "<p>I think we should do that (and migrate to <code>Fact (IsUnit _)</code> where appropriate), then come back to this discussion once we know how many such <code>Fact (IsUnit _)</code>s there are which we want to de-<code>Fact</code></p>",
        "id": 481751421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731339645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481750371\">said</a>:</p>\n<blockquote>\n<p>Note that I explained that we may have reasonable <code>IsUnit</code> instances but I didn't find any <strong>instances</strong> that need to assume <code>[IsUnit _]</code>, at least in this thread.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/3f45494422faa4e895db8a57b7a486dd9e0c2a5d/Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean#L556-L563\">https://github.com/leanprover-community/mathlib4/blob/3f45494422faa4e895db8a57b7a486dd9e0c2a5d/Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean#L556-L563</a> in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18531\">#18531</a>. It is <code>[Invertible ...]</code> in current mathlib, but we plan to refactor it without requiring knowing what the exact inverse is.</p>",
        "id": 481781512,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731348950
    },
    {
        "content": "<p>My impression from that PR is that <code>IsElliptic</code> should perhaps also not be a <code>class</code></p>",
        "id": 481800085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731355405
    },
    {
        "content": "<p>I don't think that we'll have any instance implying <code>IsUnit (_ - 1728)</code>.</p>",
        "id": 481800163,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731355439
    },
    {
        "content": "<p>Just to be clear, what's the argument <em>against</em> having typeclass search take over every single structural predicate?</p>",
        "id": 481814781,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731361728
    },
    {
        "content": "<p>TC is already the most expensive part of building mathlib. I guess we should keep it in check a bit.<br>\nAnd probably going down that path would cause a net slowdown.</p>\n<p>I would still love to have more <em>invisible</em> automation for these structural proofs though...</p>",
        "id": 481868091,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731389724
    },
    {
        "content": "<p>Can we maybe make custom <code>simp</code> / <code>aesop</code> sets? And have an autoparam calling the relevant tactic</p>",
        "id": 481875491,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731394233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481800085\">said</a>:</p>\n<blockquote>\n<p>My impression from that PR is that <code>IsElliptic</code> should perhaps also not be a <code>class</code></p>\n</blockquote>\n<p>Then each time you write <code>j</code> you need to provide a proof that the discriminant is invertible. Or fall back to current design: <code>WeierstrassCurve</code> vs <code>EllipticCurve</code> which I want to refactor. Or assign <code>j</code> a junk value when the discriminant is not invertible.</p>",
        "id": 482098004,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479307
    },
    {
        "content": "<p>I have already list the reason in that PR why current design is suboptimal: it requires copies of APIs between <code>WeierstrassCurve</code> and <code>EllipticCurve</code>.</p>",
        "id": 482098094,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481800163\">said</a>:</p>\n<blockquote>\n<p>I don't think that we'll have any instance implying <code>IsUnit (_ - 1728)</code>.</p>\n</blockquote>\n<p>It is provided by <code>haveI</code> later in that file. That instance is used in another instance which does not require any other auxiliary inputs, and which is designed to be the public instance to use.</p>",
        "id": 482098493,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479591
    },
    {
        "content": "<p>Question: Should I be using <code>Invertible</code> or <code>IsUnit</code> in the following statement, and should it be a typeclass?</p>\n<p><code>theorem {R : Type*} [CommRing R] {P : RingPreordering R} hasIdealSupport_of_invertible_2 [Invertible (2 : R)] : P.HasIdealSupport</code></p>\n<p>Context: A <em>preordering</em> on a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>⊆</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">P\\subseteq R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> closed under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>+</mo></mrow><annotation encoding=\"application/x-tex\">+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">+</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding=\"application/x-tex\">\\cdot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord\">⋅</span></span></span></span> and containing all squares, but not containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>. The <em>support</em> of a preordering is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>supp</mtext><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>P</mi><mo>∩</mo><mo>−</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">\\text{supp}(P)=P\\cap-P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">supp</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">−</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span>. Now, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>supp</mtext><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{supp}(P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">supp</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> is an additive subgroup, but not necessarily an ideal. However, in nearly all relevant cases it <em>is</em> an ideal: in particular, if 2 has an inverse in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>. This matters in Lean because, if I know <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>supp</mtext><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{supp}(P)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">supp</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> is an ideal, then I can use the ideal structure <code>P.support</code> rather than having to use <code>P.supportAddSubgroup</code>.</p>",
        "id": 536521292,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1756348202
    },
    {
        "content": "<p>Theorems should arguably always assume the data-less version of things unless they use the data in the <em>statement</em>.</p>",
        "id": 536553169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756368979
    },
    {
        "content": "<p>I think here it's worth having the instance version assuming <code>Fact [(IsUnit (2 : R))]</code></p>",
        "id": 536554148,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756369377
    },
    {
        "content": "<p>I think the rule is usually \"only use Fact if you are writing an <code>instance</code>\"?</p>",
        "id": 536554720,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756369549
    },
    {
        "content": "<p>So... my suggestion agrees with the rule?</p>",
        "id": 536556261,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756370067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536554720\">said</a>:</p>\n<blockquote>\n<p>I think the rule is usually \"only use Fact if you are writing an <code>instance</code>\"?</p>\n</blockquote>\n<p>Or if the statement relies on an instance which uses Fact</p>",
        "id": 536557406,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756370443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536554148\">said</a>:</p>\n<blockquote>\n<p>I think here it's worth having the instance version assuming <code>Fact [(IsUnit (2 : R))]</code></p>\n</blockquote>\n<p>hm, why is having it as an instance better here? just so I know what principles to apply in future<br>\nI'm very aware of not wanting <code>Fact</code>-creep</p>",
        "id": 536647875,
        "sender_full_name": "Artie Khovanov",
        "timestamp": 1756399711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536554720\">said</a>:</p>\n<blockquote>\n<p>I think the rule is usually \"only use Fact if you are writing an <code>instance</code>\"?</p>\n</blockquote>\n<p>Isn't <code>[Fact p.Prime]</code> all over the number theory parts of mathlib? Searching for the phrase gives 179 hits and randomly clicking on them it seems that most of the usages are in <code>theorem</code>s rather than <code>instance</code>s. Or have I misunderstood what you're saying?</p>",
        "id": 536684092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756415440
    },
    {
        "content": "<p>What I wrote needs Bhavik's clarification</p>",
        "id": 536684380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756415572
    },
    {
        "content": "<p>Concrete examples: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isUnit_iff_not_dvd_char_of_ringChar_ne_zero#doc\">docs#isUnit_iff_not_dvd_char_of_ringChar_ne_zero</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isUnit_iff_not_dvd_char#doc\">docs#isUnit_iff_not_dvd_char</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Choose.choose_modEq_choose_mod_mul_choose_div#doc\">docs#Choose.choose_modEq_choose_mod_mul_choose_div</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit.natCast_factorial_of_isNilpotent#doc\">docs#IsUnit.natCast_factorial_of_isNilpotent</a> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Prime.mod_two_eq_one_iff_ne_two#doc\">docs#Nat.Prime.mod_two_eq_one_iff_ne_two</a> ,...</p>",
        "id": 536684384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756415577
    },
    {
        "content": "<p>If you can remove the Fact from an assumption to a non-instance and the statement still compiles, then I claim it should be a regular hypothesis instead</p>",
        "id": 536684500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756415624
    },
    {
        "content": "<p>Well I posted the 5 theorems at the top of the search results above, and I've just commented out <code>[Fact p.Prime]</code> from all of them and all the statements still compiled (and all the proofs broke) so whatever world you're living in it doesn't seem to be related to what's actually happening on the ground</p>",
        "id": 536684933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756415814
    },
    {
        "content": "<p>Well, the ground is always chaotic, the question is what fraction of it agrees with my claim, and what breaks if we fix the rest?</p>",
        "id": 536685185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756415940
    },
    {
        "content": "<p>Here's some code from <code>Data/Nat/Prime/Basic.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">odd_of_ne_two</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Odd</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">hp</span><span class=\"bp\">.</span><span class=\"n\">eq_two_or_odd'</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span><span class=\"w\"> </span><span class=\"n\">h_two</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">even_sub_one</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">.</span><span class=\"n\">odd_of_ne_two</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_sub_cancel</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">two_mul</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">mod_two_eq_one_iff_ne_two</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">eq_two_or_odd</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Fact</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>so quite what logic is being used to determine whether to use facts is beyond me.</p>",
        "id": 536685219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756415955
    },
    {
        "content": "<p>I agree with Eric here; it's true that some parts of the library, particularly around padic valuations don't follow the rules as above, but I'm confident that these are things we should correct. Indeed in the third example you give, avoiding Fact means the theorem is easier to use with dot notation, so it should be easier to apply in virtually all situations. <br>\nThe rule I gave above is essentially derived from the docstring for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a>, so I also claim this is also not a new idea.</p>",
        "id": 536689567,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756418827
    },
    {
        "content": "<p>So I'm not pushing back against the idea of removing those <code>Fact</code>s but let me put this into some context. The completion of the rationals that the analysts use is the real numbers and there's only one of those. But arithmeticians like to also use the p-adic completions which are an infinite family parametrised by prime numbers, and in general you typically fix p once and for all and then prove 100 theorems about it all of which assume p is prime. In the literature this is typically done by announcing that p is a fixed prime on page 1 of the paper and then never saying it again. Here you're saying that the thing to do is to constantly carry around <code>(hp : p.Prime)</code> and supply it everywhere. I can quite see how this gets old quickly, because the hypothesis will be used in all the theorems and proofs and if it's not being carried around by typeclass inference then it will have to be carried around manually. Imagine telling the analysts that every time they write the real numbers they have to also add some random extra variable -- there would be a lot of pushback. But that's what you're saying should be the way to develop, say, p-adic analysis.</p>",
        "id": 536690316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756419364
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Padic#doc\">docs#Padic</a></p>",
        "id": 536690437,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756419454
    },
    {
        "content": "<p>Ah, no you're not because there it is a Fact.</p>",
        "id": 536690509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756419493
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/29090\">#29090</a></p>",
        "id": 536691498,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756420162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536690509\">said</a>:</p>\n<blockquote>\n<p>Ah, no you're not because there it is a Fact.</p>\n</blockquote>\n<p>Yes, exactly this! I think Padic and its API is as it should be, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat_self#doc\">docs#padicValNat_self</a> (and the things around it) should be changed to avoid Fact.</p>",
        "id": 536694370,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1756422308
    },
    {
        "content": "<p>Suppose that we changed that lemma appropriately. If simp wanted to apply <code>padicValNat_self {p : ℕ} (hp : Nat.Prime p) : padicValNat p p = 1</code> and there's no <code>Nat.Prime p</code> in the argument list to simp, but there is a <code>Fact (Nat.Prime p)</code> in the context where the tactic executes, would simp be able to use that?</p>\n<p>In general I think \"any <code>Fact</code>s in context be passed to simp by default\" would probably often be a good rule of thumb, but afaik there's no such behavior</p>",
        "id": 536714392,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756440054
    },
    {
        "content": "<p>Can you just feed <code>Fact.out</code> or whatever to simp, or make it a local simp lemma or something?</p>",
        "id": 536741999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756456366
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact.out#doc\">docs#Fact.out</a> very annoyingly doesn't take the predicate explicitly</p>",
        "id": 536742188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756456455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536742188\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact.out#doc\">docs#Fact.out</a> very annoyingly doesn't take the predicate explicitly</p>\n</blockquote>\n<p>do you think we should have a version which does take the predicate explicitly</p>",
        "id": 536766870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756466194
    },
    {
        "content": "<p>I think <code>Fact.out</code> itself should change. It's very rarely used without specifying its argument, as one would then fully rely on unification to figure out what the Prop is</p>",
        "id": 536770465,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1756467734
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact.out#doc\">docs#Fact.out</a> is the way it is because the language feature was missing</p>",
        "id": 536783189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756472290
    },
    {
        "content": "<p>Even assuming there's an ergonomic syntax for Fact.out, my point is that -- often during a proof I'll try to just call simp and see if it does a lot for me (and I might not immediately know how much it will accomplish). It could be that simp _would_ do a lot more, if I passed it the appropriate Fact.out, but I don't always know to do that.</p>\n<p>But Facts are _usually_ relatively common and clean hypotheses, and would pretty much always be a useful thing to discharge away without having to think about it. If the simp lemmas all took Facts too, it would be fine because it's done by typeclass inference, but in a world where they're mixed a lot it's harder</p>",
        "id": 536821367,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756483818
    },
    {
        "content": "<p>It's especially a bit silly because <code>simp_all</code> and <code>simp [*]</code> won't pick it up</p>",
        "id": 536821422,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756483839
    },
    {
        "content": "<p>So I think it would be good to have the default discharger do something like <code>try Fact.out</code></p>",
        "id": 536821489,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1756483868
    },
    {
        "content": "<p>Can <code>Fact.out</code> itself be tagged <code>simp</code>?</p>",
        "id": 536821564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756483897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536821564\">said</a>:</p>\n<blockquote>\n<p>Can <code>Fact.out</code> itself be tagged <code>simp</code>?</p>\n</blockquote>\n<p>Would that be tried everywhere?</p>",
        "id": 536828115,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756486280
    },
    {
        "content": "<p>Yes :-(</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/j1lLv_M8b5XhvyD63HM-sjCB/Screenshot-2025-08-29-210522.png\">Screenshot 2025-08-29 210522.png</a><br>\n(some lines containing <code>Fact (Fact (Fact True))</code> or <code>Fact (a = b ∨ True)</code> are below)</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/j1lLv_M8b5XhvyD63HM-sjCB/Screenshot-2025-08-29-210522.png\" title=\"Screenshot 2025-08-29 210522.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"516x681\" src=\"/user_uploads/thumbnail/3121/j1lLv_M8b5XhvyD63HM-sjCB/Screenshot-2025-08-29-210522.png/840x560.webp\"></a></div>",
        "id": 536847536,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756494435
    },
    {
        "content": "<p><span aria-label=\"chili pepper\" class=\"emoji emoji-1f336\" role=\"img\" title=\"chili pepper\">:chili_pepper:</span> write all <code>(h : p.Prime := by first | assumption | exact Fact.out)</code> hypotheses with autoParams</p>",
        "id": 536852864,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1756496711
    },
    {
        "content": "<p>won't help with simp though</p>",
        "id": 536853768,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1756497106
    },
    {
        "content": "<p>Instead of making Fact.out a simp lemma, is it possible to teach simp about specific facts? For example in some big work about primes can simp be taught <code>p.Prime</code> somehow? i.e. \"teach simp the relevant fact\" rather than \"teach simp to extract stuff from <code>Fact</code> in general\"?</p>",
        "id": 536854217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756497315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536854217\">said</a>:</p>\n<blockquote>\n<p>Instead of making Fact.out a simp lemma, is it possible to teach simp about specific facts? For example in some big work about primes can simp be taught <code>p.Prime</code> somehow? i.e. \"teach simp the relevant fact\" rather than \"teach simp to extract stuff from <code>Fact</code> in general\"?</p>\n</blockquote>\n<p>Maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">of_fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n</code></pre></div>",
        "id": 536854620,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756497473
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 536855224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1756497768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/536854217\">said</a>:</p>\n<blockquote>\n<p>Instead of making Fact.out a simp lemma, is it possible to teach simp about specific facts? For example in some big work about primes can simp be taught <code>p.Prime</code> somehow? i.e. \"teach simp the relevant fact\" rather than \"teach simp to extract stuff from <code>Fact</code> in general\"?</p>\n</blockquote>\n<p>Sounds like a simproc to me.</p>",
        "id": 537042901,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1756709621
    }
]