[
    {
        "content": "<p>Motivated by <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> 's <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a>. Why do we carry data in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> ? Should we turn <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> into a typeclass instead?</p>",
        "id": 467733290,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725518218
    },
    {
        "content": "<p>Alternatively, we can turn <code>IsUnit</code> into a typeclass and treat <code>[Invertible _]</code> the same way we treat <code>Decidable</code>: only use it if we need a computable <code>invOf</code>.</p>",
        "id": 467733512,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725518292
    },
    {
        "content": "<p>I think it was done because there are examples where you can compute, and it is nice if it works in those examples. For example some localizations like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\Z[1/2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord\">1/2</span><span class=\"mclose\">]</span></span></span></span>, where <code>2</code> is invertible, but you don't have all rational numbers. Or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/8\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/8</span><span class=\"mord mathbb\">Z</span></span></span></span> where 3, 5, 7 are their own multiplicative inverses.</p>",
        "id": 467737382,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725519483
    },
    {
        "content": "<p>So I think it is worth looking into your 2nd suggestion. Where we have a data-carrying class that is used sparingly, and prop-class that is used for almost all the theory.</p>",
        "id": 467737457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725519521
    },
    {
        "content": "<p>I think there is no obvious overlap here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> is essentially a bundled <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> is the associated prop.</p>",
        "id": 467818665,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725534685
    },
    {
        "content": "<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a></li>\n</ul>",
        "id": 467819161,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725534745
    },
    {
        "content": "<p>yeah, sorry!</p>",
        "id": 467820104,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725534851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/467818665\">said</a>:</p>\n<blockquote>\n<p>I think there is no obvious overlap here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> is essentially a bundled <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> is the associated prop.</p>\n</blockquote>\n<p><code>IsUnit x</code> is the same as <code>Nonempty (Invertible x)</code>. What I'm trying to say is that we use a typeclass with subsingleton data (<code>Invertible</code>) as an assumption in theorems that don't need the data, and this can lead to non-defeq diamonds.</p>",
        "id": 467860417,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1725543185
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a></p>",
        "id": 475032912,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728172841
    },
    {
        "content": "<p>On Github, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> argues that we should migrate to <code>(h : IsUnit _)</code> instead.</p>",
        "id": 475113735,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728233574
    },
    {
        "content": "<p>At least in places where we don't actually want the data</p>",
        "id": 475124425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728238617
    },
    {
        "content": "<p>My main argument pro <code>[IsUnit _]</code> is that people who don't care about fields of positive characteristic may want to apply theorems that require <code>IsUnit (2 : K)</code> without making another stop to prove it.</p>",
        "id": 475124625,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728238758
    },
    {
        "content": "<p>Is it 2 specifically that we care about?</p>",
        "id": 475125721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728239684
    },
    {
        "content": "<p>I definitely have some examples for <code>IsUnit (2 : K)</code>, incl. midpoint and <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a></p>",
        "id": 475125898,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239850
    },
    {
        "content": "<p>I don't have other examples in mind right now.</p>",
        "id": 475125915,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239875
    },
    {
        "content": "<p>Unless we want to generalize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_inv_cancel#doc\">docs#mul_inv_cancel</a> etc to <code>[DivisionMonoid G] [IsUnit a]</code></p>",
        "id": 475125975,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239911
    },
    {
        "content": "<p>Note: we already have it as <code>@[simp]</code> for <code>Invertible a</code>.</p>",
        "id": 475126009,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728239946
    },
    {
        "content": "<p>I think we might be missing the bigger picture on 14986; the result is also true (and I believe straightforward to prove with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuadraticMap.toBilin#doc\">docs#QuadraticMap.toBilin</a>) in free modules where 2 is not invertible</p>",
        "id": 475126454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728240293
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124\">https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124</a> for a list of lemmas that assume <code>[Invertible _]</code> but never use <code>invOf</code> in the statement.</p>",
        "id": 475127338,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728240796
    },
    {
        "content": "<p>(there are other pending linters in the same PR, so you need to search for <code>Invertible</code>)</p>",
        "id": 475127356,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728240823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/475127338\">said</a>:</p>\n<blockquote>\n<p>See <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124\">https://github.com/leanprover-community/mathlib4/actions/runs/11195116893/job/31122394124</a> for a list of lemmas that assume <code>[Invertible _]</code> but never use <code>invOf</code> in the statement.</p>\n</blockquote>\n<p>I think I would be in favor of changing all these to <code>(h : IsUnit x)</code> and using <code>[Fact (IsUnit x)]</code> on the one or two instances.</p>",
        "id": 475130466,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728242077
    },
    {
        "content": "<p>Why <code>[IsUnit _]</code> is worse?</p>",
        "id": 475133186,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728243471
    },
    {
        "content": "<p>I don't understand how this argument doesn't lead to us converting everything of type <code>Prop</code> into a typeclass</p>",
        "id": 475133291,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728243503
    },
    {
        "content": "<p>Maybe that really is a fine outcome, but I've definitely heard arguments that doing that for, say, <code>Odd</code> and <code>Even</code> would amount to an abuse of typeclass search.</p>",
        "id": 475134581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728244141
    },
    {
        "content": "<p>This smells like typeclass abuse to me too. It feels much more likely that we'll want to prove <code>IsUnit</code> from other available hypotheses, than being able to infer it from the structure of the argument.</p>",
        "id": 475220187,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1728284451
    },
    {
        "content": "<p>What do you think about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidAlgebra.Submodule.complementedLattice#doc\">docs#MonoidAlgebra.Submodule.complementedLattice</a> ?</p>",
        "id": 476858898,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944699
    },
    {
        "content": "<p>UPD: it should assume <code>NeZero</code>.</p>",
        "id": 476858934,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944732
    },
    {
        "content": "<p>Ignore my last 2 messages.</p>",
        "id": 476858947,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728944739
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/17754\">#17754</a> makes Maschke use <code>IsUnit</code>.</p>",
        "id": 476869438,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728952031
    },
    {
        "content": "<p>What should I do about <code>IsUnit 2</code>? Use <code>Fact</code>? Introduce a typeclass specifically for this?</p>",
        "id": 476880240,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959572
    },
    {
        "content": "<p>I also see an assumption <code>Invertible 3</code> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeierstrassCurve.exists_variableChange_isShortNF#doc\">docs#WeierstrassCurve.exists_variableChange_isShortNF</a></p>",
        "id": 476880404,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959641
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Linear.instEpiHSMulHomOfInvertible#doc\">docs#CategoryTheory.Linear.instEpiHSMulHomOfInvertible</a></p>",
        "id": 476880831,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959816
    },
    {
        "content": "<p>It's an instance that assumes <code>[Invertible r]</code> but doesn't use data.</p>",
        "id": 476880892,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1728959839
    },
    {
        "content": "<p>I think it makes sense to use <code>Fact</code> for these \"a specific number is invertible\" predicates</p>",
        "id": 477182422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729075270
    },
    {
        "content": "<p>I think that depends whether the instance you're using <code>Fact</code> on is data or a proof</p>",
        "id": 477183885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075763
    },
    {
        "content": "<p>If it's a proof, then <code>Fact (IsUnit x)</code> does indeed make the most sense. If it's data, then <code>Invertible x</code> is often better.</p>",
        "id": 477183927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075786
    },
    {
        "content": "<p>If your proof uses some auxiliary data along the way, use <code>def aux [Invertible x]</code> to define that data, then use <code>IsUnit.nonempty_invertible</code> to construct that instance mid-proof</p>",
        "id": 477184068,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729075831
    },
    {
        "content": "<p>Why <code>Fact (IsUnit _)</code> is better than <code>[IsUnit _]</code>?</p>",
        "id": 477239824,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729091318
    },
    {
        "content": "<p>(e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a> is a typeclass but we mostly use it as a predicate)</p>",
        "id": 477239933,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729091354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/477239824\">said</a>:</p>\n<blockquote>\n<p>Why <code>Fact (IsUnit _)</code> is better than <code>[IsUnit _]</code>?</p>\n</blockquote>\n<p>I'll admit, I'm not sure. Why is <code>Fact (IsPrime _)</code> better than <code>[IsPrime _]</code>? Seems to be similar reasoning.</p>",
        "id": 477404982,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729159204
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a> have anything to say?</p>",
        "id": 477407470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729160087
    },
    {
        "content": "<p>Yes, but I don't really get its reasoning. Is the issue just that <code>Nat.prime</code> would become a one-field structure instead of being def-eq to its definition?</p>",
        "id": 477408652,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729160508
    },
    {
        "content": "<p>By that reasoning, <code>IsUnit</code> should probably not be a class either</p>",
        "id": 477408879,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729160571
    },
    {
        "content": "<p>Ah, I hadn't considered that (historic?) limitations around non-structure classes could have factored in here.</p>",
        "id": 477410492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729161130
    },
    {
        "content": "<p>My rule of thumb would be \"only use typeclasses for types\"</p>",
        "id": 477410592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729161175
    },
    {
        "content": "<p>I don't think it's quite as simple as that, e.g. having <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CharZero#doc\">docs#CharZero</a> as a typeclass is definitely a good thing.</p>",
        "id": 477411199,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161384
    },
    {
        "content": "<p>I'd argue the same for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT#doc\">docs#WellFoundedLT</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedGT#doc\">docs#WellFoundedGT</a> but maybe I'm biased since I'm the one who pushed for those <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 477411581,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161523
    },
    {
        "content": "<p>Oh wait, I misunderstood you as implying typeclasses should be type-valued rather than having type arguments</p>",
        "id": 477411707,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161572
    },
    {
        "content": "<p>I mostly agree with that rule of thumb.</p>",
        "id": 477412051,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161713
    },
    {
        "content": "<p>I'd like to point to the counterexample of the unbundled order classes like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsRefl#doc\">docs#IsRefl</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsTrans#doc\">docs#IsTrans</a>, etc. I'd argue these are still good to have, but if anyone ever wants to refactor them out I don't think I'll be strongly opposed.</p>",
        "id": 477412331,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729161830
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a></p>",
        "id": 477458635,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729175690
    },
    {
        "content": "<p>IsClosed I'd argue should be de-classified, <code>NeZero</code> I haven't thought about before.</p>",
        "id": 477476686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729180697
    },
    {
        "content": "<p><code>NeZero</code> seems to be helpful e.g. to avoid using <code>PNat</code>.</p>",
        "id": 477481367,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1729182251
    },
    {
        "content": "<p>Do you suggest migrating to <code>Fact (IsClosed _)</code> whenever we need to assume <code>IsClosed</code> in an instance?</p>",
        "id": 477485736,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729183758
    },
    {
        "content": "<p>Yes, that's my claim</p>",
        "id": 477490149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729185424
    },
    {
        "content": "<p>The reason we used <code>IsClosed</code> as a typeclass is to be able to obtain that quotients of normed spaces by closed subspaces are normed spaces. For instance, if you're in finite dimension, subspaces are automatically closed, so quotients are automatically normed spaces. If you want to get this fact for free using the <code>Fact</code> mechanism, then you need to register this as a global <code>Fact</code> instance, but if I remember correctly global <code>Fact</code> instances should be avoided if possible. So I see what we lose when going from <code>[IsClosed ...]</code> to <code>[Fact (IsClosed ...)]</code>. What do we gain?</p>",
        "id": 477492559,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1729186335
    },
    {
        "content": "<p>Agreed that the alternative would be a few global instances of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a>, but we have a number of those already</p>",
        "id": 477492845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729186460
    },
    {
        "content": "<p>Flipping the question around; what do we lose if we make _every_ <code>structure ... : Prop</code> a <code>class</code>?</p>",
        "id": 477492942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729186507
    },
    {
        "content": "<p>In Lean 3, that would have caused a lot of frozen instance cache issues</p>",
        "id": 477494679,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729187203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/477458635\">said</a>:</p>\n<blockquote>\n<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsClosed#doc\">docs#IsClosed</a></p>\n</blockquote>\n<p><code>IsClosed</code> is a <em>class</em>? <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span></p>",
        "id": 477511620,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1729193650
    },
    {
        "content": "<p>RE <code>NeZero</code>, I've only ever come across <code>NeZero 1</code> in my own applications, which arguably could be made into a <code>OneNeZeroClass</code> if we really wanted to.</p>",
        "id": 477539508,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729207989
    },
    {
        "content": "<p><code>NeZero</code> is used, e.g., in our instances about <code>Fin</code>.</p>",
        "id": 477541243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209215
    },
    {
        "content": "<p>In many cases, <code>NeZero (1 : R)</code> can be replaced with <code>Nontrivial R</code>.</p>",
        "id": 477541321,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209252
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero.one#doc\">docs#NeZero.one</a></p>",
        "id": 477541410,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1729209344
    },
    {
        "content": "<p>It's also used for measures, where a bunch of lemmas break for the zero measure</p>",
        "id": 477602259,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729239559
    },
    {
        "content": "<p>Also in low characteristic <code>[NeZero (2 : R)]</code>and  <code>[NeZero (3 : R)]</code> are already useful (and one day we'll certainly get to <code>[NeZero (5 : R)]</code> and maybe higher). E.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EllipticCurve.ofJ_0_of_three_ne_zero#doc\">docs#EllipticCurve.ofJ_0_of_three_ne_zero</a></p>",
        "id": 477614497,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1729243659
    },
    {
        "content": "<p>That looks like it could just take <code>(h : 3 \\ne 0)</code> as an argument</p>",
        "id": 477616697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729244375
    },
    {
        "content": "<p>In these scenarios, I just want to avoid manually supplying a proof that something is not <code>0</code>. Typeclass synthesis is one mechanism. If set up appropriately, autoparams could be another. Though <code>NeZero</code> didn’t get upstreamed for no reason.</p>",
        "id": 477641539,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729253482
    },
    {
        "content": "<p>My understanding is that <code>NeZero</code> got upstreamed because of <code>Fin</code>, and the decision was based on \"this is what mathlib does\" not \"this is clearly the perfect solution\"</p>",
        "id": 477641889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729253602
    },
    {
        "content": "<p>NeZero is also somehow different because we have both the <code>class</code> and the non-class</p>",
        "id": 477642054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729253649
    },
    {
        "content": "<p>Sure, but if they had a better idea, they wouldn’t have. </p>\n<p>I think the cost of flipping everything to classes is just performance.</p>",
        "id": 477642612,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729253850
    },
    {
        "content": "<p>I would like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.ZMod.Defs</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p.Prime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to succeed</p>",
        "id": 477652479,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257014
    },
    {
        "content": "<p>Enough to create an RFC for it?</p>",
        "id": 477653265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729257278
    },
    {
        "content": "<p>If I recall correctly, having the possibility to run tactics for default arguments in typeclass inference was considered at the beginning of Lean 4, but it was discarded later because of added complexity and performance issues. Given how critical this is, I'm not sure the FRO is willing to revisit this.</p>",
        "id": 477653787,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1729257467
    },
    {
        "content": "<p>I think an RFC is fine but I would guess that as <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> says: significant changes to typeclass synthesis are currently off the table</p>",
        "id": 477654003,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257529
    },
    {
        "content": "<p>I would also guess that the FRO considered something like this before upstreaming <code>NeZero</code> but I have no first-hand knowledge</p>",
        "id": 477654225,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1729257597
    },
    {
        "content": "<p>Now my PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18531\">#18531</a> of to elliptic curves is related to <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a>... If <code>IsUnit</code> is a typeclass then this PR could be simplified a little bit (also with API changes).</p>",
        "id": 480356008,
        "sender_full_name": "Jz Pan",
        "timestamp": 1730685723
    },
    {
        "content": "<p>Pinging that <a href=\"https://github.com/leanprover-community/mathlib4/pull/17458\">#17458</a> is marked <code>awaiting-zulip</code> based on this thread. It would be good to come to a decision here, and either close that PR or proceed with reviewing it.</p>",
        "id": 480549729,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1730765402
    },
    {
        "content": "<p>+1 for ping</p>",
        "id": 481481192,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731175389
    },
    {
        "content": "<p>I've been using (and got to like) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> quite consistently in the recent factor of <code>rootsOfUnity</code>. So I think a <code>Prop</code>- valued version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Invertible#doc\">docs#Invertible</a> makes sense. But I haven't followed this discussion very closely.</p>",
        "id": 481485536,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1731178767
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> WDYT?</p>",
        "id": 481528445,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731215999
    },
    {
        "content": "<p>My stance is:</p>\n<ul>\n<li>IsUnit shouldn't be a class </li>\n<li>Invertible is mostly ok as is</li>\n<li>A new <code>HasInverse x x_inv : Prop</code> (which is to <code>IsUnit</code> as <code>HasSum</code> is to <code>Summable</code>) would ease some of the pain around Invertible.</li>\n</ul>",
        "id": 481534872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731221963
    },
    {
        "content": "<p>In the examples where I suggest we assume <code>[IsUnit a]</code>, we <strong>don't want</strong> to know <code>a_inv</code>.</p>",
        "id": 481534994,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222064
    },
    {
        "content": "<p>Right, in those examples I am suggesting <code>Fact (IsUnit a)</code></p>",
        "id": 481535190,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222287
    },
    {
        "content": "<p>(and I am not proposing <code>HasInverse</code> should be a <code>class</code>)</p>",
        "id": 481535222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222331
    },
    {
        "content": "<p>Why <code>Fact (IsUnit a)</code> is better than <code>class IsUnit</code> (rarely used as a class)?</p>",
        "id": 481535229,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222333
    },
    {
        "content": "<p>Should <code>Summable</code> be a class too? Should <code>Prime</code>?</p>",
        "id": 481535292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222365
    },
    {
        "content": "<p><code>Summable</code>: AFAICT, we never need it to construct an instance. <code>Prime</code>: possibly (we use <code>Fact (Nat.Prime p)</code> very often).</p>",
        "id": 481535333,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481535229\">said</a>:</p>\n<blockquote>\n<p>Why <code>Fact (IsUnit a)</code> is better than <code>class IsUnit</code> (rarely used as a class)?</p>\n</blockquote>\n<p>Here's one argument; if you make it a class, every caller has to think about whether to write <code>(h : IsUnit a)</code> or <code>[IsUnit a]</code>. If you use <code>Fact</code>, this choice is obvious</p>",
        "id": 481535448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222526
    },
    {
        "content": "<p>Makes sense, but didn't work for <code>Nat.Prime</code>... I don't see any system in <code>(h : p.Prime)</code> vs <code>[Fact p.Prime]</code>...</p>",
        "id": 481535542,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222619
    },
    {
        "content": "<p>So, we should add instances for, e.g., <code>[GroupWithZero G] {a : G} [NeZero a] : Fact (IsUnit a)</code>?</p>",
        "id": 481535576,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481535333\">said</a>:</p>\n<blockquote>\n<p>AFAICT, we never need it to construct an instance.</p>\n</blockquote>\n<p>I think \"needed to construct an instance\" is exactly the design problem that <code>Fact</code> is intended to solve. </p>\n<p>So I think your argument might extend to \"we should remove <code>Fact</code>\", which is worthy of its own thread.</p>",
        "id": 481535586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222676
    },
    {
        "content": "<p>BTW, are discrimination trees good enough with <code>Fact</code>s?</p>",
        "id": 481535591,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222681
    },
    {
        "content": "<p>They should be fine, <code>key (Fact X) = [Fact] ++ key X</code></p>",
        "id": 481535669,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222739
    },
    {
        "content": "<p>Does it mean that we can use <code>Fact (Predicate ...)</code> instead of turning <code>Predicate</code> into a class without slowdown?</p>",
        "id": 481535705,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731222790
    },
    {
        "content": "<p>I think yes</p>",
        "id": 481535717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222804
    },
    {
        "content": "<p>(ignoring the negligable cost of the key having one more element)</p>",
        "id": 481535736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731222834
    },
    {
        "content": "<p>Then I'll start migrating some <code>[Invertible]</code> assumptions to <code>[Fact (IsUnit _)]</code>.</p>",
        "id": 481536203,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731223291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481535705\">said</a>:</p>\n<blockquote>\n<p>Does it mean that we can use <code>Fact (Predicate ...)</code> instead of turning <code>Predicate</code> into a class without slowdown?</p>\n</blockquote>\n<p>While this is true, it also goes against our original plans to <em>not</em> use <code>Fact</code> as a general \"let's have typeclass search do our proving\" mechanism. </p>\n<p>(Perhaps it is a feature, not a bug, that there is overhead to turning something into a class?)</p>",
        "id": 481599741,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1731274720
    },
    {
        "content": "<p>With <code>Nat.prime p</code> there is never any proving; it literally is just a convenient way of saying \"let p be a prime forever\". So this is a great use of <code>Fact</code> as far as I can see.</p>",
        "id": 481600517,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731275416
    },
    {
        "content": "<p>My mental model was that <code>Fact</code> was only really intended to allow non-typeclasses into the assumptions of instances as <code>instance [Fact (Predicate ..)] : _</code>; which is compatible with Kim's comment which I think is objecting to it appearing in the conclusion as <code>instance : Fact (Predicate ..)</code>.</p>",
        "id": 481602106,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731276852
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a> indicates a few such instances exist, but I think they're mostly for convenience rather than doing heavy lifting)</p>",
        "id": 481602154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731276909
    },
    {
        "content": "<p>But we want to have at least the following instances for <code>IsUnit _</code> (or `Fact (IsUnit _)1):</p>\n<ul>\n<li><code>[Group G] (a : G) : IsUnit a</code></li>\n<li><code>[Invertible a] : IsUnit a</code></li>\n<li><code>IsUnit 1</code></li>\n<li><code>[GroupWithZero G₀] (a : G₀) [NeZero a]</code></li>\n<li><code>[CommMonoid M] {a b : M} [IsUnit a] [IsUnit b] : IsUnit (a * b)</code></li>\n<li><code>[IsUnit a] (n : Nat) : IsUnit (a ^ n)</code></li>\n<li><code>[IsUnit (OfNat.ofNat n : R)] : IsUnit (OfNat.ofNat : Module.End R M)</code> (this instance from <a href=\"https://github.com/leanprover-community/mathlib4/pull/14986\">#14986</a> and motivated this thread).</li>\n</ul>",
        "id": 481627031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731297687
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Maybe we should just try to make <code>IsUnit</code> a class. Your argument is that this puts us on a slippery slope. Maybe it does. But we're still deciding on a case-by-case basis. And Yury has some good arguments for wanting automation to kick in. TC is the best we have for this right now.</p>",
        "id": 481650910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731310089
    },
    {
        "content": "<p>The examples above feel rather like</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Invertible.20and.20data/near/481599741\">said</a>:</p>\n<blockquote>\n<p>\"let's have typeclass search do our proving\"</p>\n</blockquote>\n<p>I'm not sure that the fact some proposition can be deduced structurally is a sufficient argument for us to use typeclasses search to prove it; otherwise <code>Differentiable</code> and <code>IsSquare</code> would surely deserve the same treatment.</p>",
        "id": 481660019,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731313469
    },
    {
        "content": "<p>I find it sad that we can’t have “let’s have typeclass search do our proving”.</p>",
        "id": 481690542,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1731322834
    },
    {
        "content": "<p>IIRC we tried this a bit in LTE with simple inequalities. We were working with L^p spaces with p&lt;1 remembered as a Fact, and would occasionally get typeclass inference to prove things like q&lt;p and p&lt;1 implies q&lt;1.</p>",
        "id": 481694804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731324158
    },
    {
        "content": "<p>Yeah, we used it a lot. It did all sorts of multiplications of inequalities</p>",
        "id": 481700878,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731325893
    },
    {
        "content": "<p>Of course we didn't have gcongr back then</p>",
        "id": 481700899,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731325901
    },
    {
        "content": "<p>The situation is somewhat similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ideal.IsPrime#doc\">docs#Ideal.IsPrime</a> where that is a class. Sometimes IsPrime is passed as an explicit argument, and sometimes as a TC argument. And it has to be in TC access so that one can get an integral domain instance on the quotient ring.</p>",
        "id": 481701903,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1731326142
    },
    {
        "content": "<p>Note that I explained that we may have reasonable <code>IsUnit</code> instances but I didn't find any <strong>instances</strong> that need to assume <code>[IsUnit _]</code>, at least in this thread.</p>",
        "id": 481750371,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731339364
    },
    {
        "content": "<p>I guess, we can try to migrate some of those <code>[Invertible _]</code> to <code>(h : IsUnit _)</code> until we meet an <code>instance</code>, then come back to this discussion.</p>",
        "id": 481750543,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731339418
    },
    {
        "content": "<p>I think we should do that (and migrate to <code>Fact (IsUnit _)</code> where appropriate), then come back to this discussion once we know how many such <code>Fact (IsUnit _)</code>s there are which we want to de-<code>Fact</code></p>",
        "id": 481751421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731339645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481750371\">said</a>:</p>\n<blockquote>\n<p>Note that I explained that we may have reasonable <code>IsUnit</code> instances but I didn't find any <strong>instances</strong> that need to assume <code>[IsUnit _]</code>, at least in this thread.</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/3f45494422faa4e895db8a57b7a486dd9e0c2a5d/Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean#L556-L563\">https://github.com/leanprover-community/mathlib4/blob/3f45494422faa4e895db8a57b7a486dd9e0c2a5d/Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean#L556-L563</a> in PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/18531\">#18531</a>. It is <code>[Invertible ...]</code> in current mathlib, but we plan to refactor it without requiring knowing what the exact inverse is.</p>",
        "id": 481781512,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731348950
    },
    {
        "content": "<p>My impression from that PR is that <code>IsElliptic</code> should perhaps also not be a <code>class</code></p>",
        "id": 481800085,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731355405
    },
    {
        "content": "<p>I don't think that we'll have any instance implying <code>IsUnit (_ - 1728)</code>.</p>",
        "id": 481800163,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1731355439
    },
    {
        "content": "<p>Just to be clear, what's the argument <em>against</em> having typeclass search take over every single structural predicate?</p>",
        "id": 481814781,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731361728
    },
    {
        "content": "<p>TC is already the most expensive part of building mathlib. I guess we should keep it in check a bit.<br>\nAnd probably going down that path would cause a net slowdown.</p>\n<p>I would still love to have more <em>invisible</em> automation for these structural proofs though...</p>",
        "id": 481868091,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1731389724
    },
    {
        "content": "<p>Can we maybe make custom <code>simp</code> / <code>aesop</code> sets? And have an autoparam calling the relevant tactic</p>",
        "id": 481875491,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1731394233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481800085\">said</a>:</p>\n<blockquote>\n<p>My impression from that PR is that <code>IsElliptic</code> should perhaps also not be a <code>class</code></p>\n</blockquote>\n<p>Then each time you write <code>j</code> you need to provide a proof that the discriminant is invertible. Or fall back to current design: <code>WeierstrassCurve</code> vs <code>EllipticCurve</code> which I want to refactor. Or assign <code>j</code> a junk value when the discriminant is not invertible.</p>",
        "id": 482098004,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479307
    },
    {
        "content": "<p>I have already list the reason in that PR why current design is suboptimal: it requires copies of APIs between <code>WeierstrassCurve</code> and <code>EllipticCurve</code>.</p>",
        "id": 482098094,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/channel/116395-maths/topic/Invertible.20and.20data/near/481800163\">said</a>:</p>\n<blockquote>\n<p>I don't think that we'll have any instance implying <code>IsUnit (_ - 1728)</code>.</p>\n</blockquote>\n<p>It is provided by <code>haveI</code> later in that file. That instance is used in another instance which does not require any other auxiliary inputs, and which is designed to be the public instance to use.</p>",
        "id": 482098493,
        "sender_full_name": "Jz Pan",
        "timestamp": 1731479591
    }
]