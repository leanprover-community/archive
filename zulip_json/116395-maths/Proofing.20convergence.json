[
    {
        "content": "<p>Hi so I want to use <code>tendsto_integral_of_dominated_convergence</code>. Therefor I  need to define a measure on unitInterval. For the <code>hmeas</code>argument, <code>Measure alpha</code>is required, so I'm simple defining exactly that. Sadly that returns Type1 which is not <code>Measure alpha</code>. I'm still not trusted at all with the functional type way of thinking about things and quite confused. Could somebody explain what's happening here? Type1 is a type, ok, but what's <code>Measure alpha</code> requiring then, if not a Type or a instance of such..<br>\nregards</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">bound</span> <span class=\"o\">:=</span> <span class=\"n\">unitInterval</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚Ñù</span>\n    <span class=\"k\">let</span> <span class=\"n\">Œº</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.Measure</span> <span class=\"n\">unitInterval</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:=</span> <span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Œº</span>\n<span class=\"c1\">--    let hint := Integrable bound Œº</span>\n<span class=\"c1\">--    let hbound := ‚àÄ n, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF n a‚Äñ ‚â§ bound a</span>\n<span class=\"c1\">--    let hlim := ‚àÄ·µê a ‚àÇŒº, Filter.Tendsto (fun n : ‚Ñï ‚Ü¶ F n a) Filter.atTop (ùìù (f a))</span>\n<span class=\"c1\">--    exact tendsto_integral_of_dominated_convergence bound hmeas hint hbound hlim</span>\n</code></pre></div>",
        "id": 396069832,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697024780
    },
    {
        "content": "<p>You want <code>let Œº : MeasureTheory.Measure unitInterval := sorry</code>, not <code>let Œº := MeasureTheory.Measure unitInterval</code></p>",
        "id": 396072216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697025315
    },
    {
        "content": "<p>The analog is <code>let r : Real := 3.14</code> vs <code>let r := Real</code></p>",
        "id": 396072343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697025343
    },
    {
        "content": "<p>If you're lucky, the sorry is <code>volume</code></p>",
        "id": 396072393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697025358
    },
    {
        "content": "<p>thanks! volume works as well. This was obvious again, sry. I was looking at the wrong def of Measurable, wasn't aware that it returns a prop.</p>",
        "id": 396240657,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697099610
    },
    {
        "content": "<p>I want to proof the following expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Œº</span> <span class=\"o\">:=</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">MeasurableSpace.Top.measurable</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Œº</span><span class=\"o\">)</span> <span class=\"o\">))</span>\n</code></pre></div>\n<p>where:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">C</span>\n<span class=\"n\">Œº</span><span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"bp\">‚Üë</span><span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n</code></pre></div>\n<p>But lean throws the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">MeasurableSpace.Top.measurable</span> <span class=\"bp\">?</span><span class=\"n\">m.236751</span><span class=\"o\">))</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">AEStronglyMeasurable</span> <span class=\"bp\">?</span><span class=\"n\">m.236751</span> <span class=\"bp\">?</span><span class=\"n\">m.54280</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">),</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">Œº</span> <span class=\"o\">:</span> <span class=\"n\">PropLean</span> <span class=\"mi\">4</span>\n</code></pre></div>\n<p>It could very well be that I'm approaching completely wrong since I'm completely new to the \"less intuitive\" analysis part of lean (opposing to the basic algebra stuff...).<br>\nFor context, I'm trying to proof <code>hmeas</code> in order to proof <code>tendsto_integral_of_dominated_convergence</code>.<br>\nI would be so thankful for any help!</p>",
        "id": 396488912,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697197374
    },
    {
        "content": "<p>The lemma you are applying is used to prove that a single function is <code>AEStronglyMeasurable</code>. But the statement you are proving is that in a whole family of functions, each of them is <code>AEStronglyMeasurable</code>. You should say that you want to focus on a single function with <code>intro n</code>. This issue has nothing to do with measures, it's a general Lean thing.</p>",
        "id": 396489390,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1697197546
    },
    {
        "content": "<p>(I know it's quite hard to decipher error message, but the error message you posted is trying to tell you exactly this).</p>",
        "id": 396489527,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1697197593
    },
    {
        "content": "<p>Ok, that's what it looks like now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">Œº</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">ns</span>\n      <span class=\"n\">exact</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">MeasurableSpace.Top.measurable</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>And It seems more \"reasonable\" than what I had before but the error it throws is a bit cryptic to me.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Main.lean</span><span class=\"o\">:</span><span class=\"mi\">104</span><span class=\"o\">:</span><span class=\"mi\">71</span>\n<span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">MeasurableSpace.Top.measurable</span> <span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">))</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">MeasurableSpace.Top.measurable</span> <span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Measurable</span> <span class=\"bp\">‚Üë</span><span class=\"n\">unitInterval</span> <span class=\"n\">‚Ñù</span> <span class=\"bp\">‚ä§</span> <span class=\"n\">Real.measurableSpace</span> <span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">Measurable</span> <span class=\"bp\">‚Üë</span><span class=\"n\">unitInterval</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">Subtype.instMeasurableSpace</span> <span class=\"n\">Real.measurableSpace</span> <span class=\"bp\">‚Üë</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 396634116,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697276111
    },
    {
        "content": "<p>Looks like <code>MeasurableSpace.Top.measurable</code> is not the right expression to write there</p>",
        "id": 396636041,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1697277684
    },
    {
        "content": "<p>ok, because the signature returns <code>Measurable f</code>....</p>",
        "id": 396636540,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697278063
    },
    {
        "content": "<p>Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 396636714,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1697278196
    },
    {
        "content": "<p>Sure, this is a bit of a mess though... I want to proof that C 0 1 is also uniform convergent to f with the L1 norm.. The last lemma <code>tendsto_integral_of_dominated_convergence</code>is (hopefully) proofing that through the assumption that it's uniform convergent without the integral as well.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousFunction.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Init.Core</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.SetIntegral</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Intervals.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.ENNReal</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Haar.OfBasis</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UnitInterval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Group.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Normed.Group.Completion</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">StronglyMeasurable</span>\n<span class=\"kn\">open</span> <span class=\"n\">Num</span>\n<span class=\"kn\">open</span> <span class=\"n\">Group</span>\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n<span class=\"kn\">open</span> <span class=\"n\">ENNReal</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">NatCast</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">Measure</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousMap</span> <span class=\"n\">unitInterval</span> <span class=\"n\">‚Ñù</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">:=</span> <span class=\"bp\">‚à´</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">|</span>\n\n<span class=\"c1\">-- Define the L1 space</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"n\">L1_norm</span> <span class=\"n\">f</span> <span class=\"bp\">‚â•</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Define the uniform convergence</span>\n<span class=\"kd\">def</span> <span class=\"n\">uniform_convergent</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">Œµ</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">,</span> <span class=\"n\">Œµ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">‚â•</span> <span class=\"n\">N</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">:=</span> <span class=\"n\">normedAddCommGroup</span>\n<span class=\"c1\">-- Theorem: If (fn) converges uniformly to f, then it also converges in L1 norm to f.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">uniform_convergence_implies_L1_convergence</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_uniform</span> <span class=\"o\">:</span> <span class=\"n\">uniform_convergent</span> <span class=\"n\">f</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"n\">L1_norm</span> <span class=\"n\">limit</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c1\">-- We need to show that the L1 norms converge to the L1 norm of the limit</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Metric.tendsto_atTop</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span> <span class=\"n\">Œµ</span> <span class=\"n\">Œµ_pos</span>\n    <span class=\"c1\">-- Use the uniform convergence property to find N</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">‚ü®</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">hN</span><span class=\"o\">‚ü©</span> <span class=\"o\">:=</span> <span class=\"n\">h_uniform</span> <span class=\"n\">Œµ</span> <span class=\"n\">Œµ_pos</span>\n    <span class=\"n\">use</span> <span class=\"n\">N</span>\n    <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n    <span class=\"c1\">-- Use the definition of the L1 norm</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">L1_norm</span>\n    <span class=\"k\">have</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">‚â§</span> <span class=\"n\">Œµ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hN</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">hN</span><span class=\"o\">)</span>\n\n    <span class=\"c1\">-- rw[‚Üê L1.dist_eq_integral_dist]</span>\n\n    <span class=\"c1\">-- Apply the Lebesgue Dominated Convergence Theorem</span>\n    <span class=\"c1\">-- integral_le_integral_of_le</span>\n    <span class=\"c1\">-- exact integral_le_integral_of_le (ContinuousMap.abs_sub_integral_le _ _ h‚ÇÅ)</span>\n\n\n    <span class=\"k\">let</span> <span class=\"n\">bound</span> <span class=\"o\">:=</span> <span class=\"n\">limit</span>\n    <span class=\"k\">let</span> <span class=\"n\">Œº</span><span class=\"o\">:</span> <span class=\"n\">MeasureTheory.Measure</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n    <span class=\"c1\">-- let hmeas : ‚àÄn, AEStronglyMeasurable (f n) Œº := by</span>\n    <span class=\"c1\">--   intro ns</span>\n    <span class=\"c1\">--   exact AEMeasurable.aestronglyMeasurable (Measurable.aemeasurable (MeasurableSpace.Top.measurable ((f ns))))</span>\n\n    <span class=\"k\">have</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">MeasureTheory.IntegrableOn</span> <span class=\"n\">bound</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">Œº</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">let</span> <span class=\"n\">hint</span> <span class=\"o\">:</span> <span class=\"n\">Integrable</span> <span class=\"n\">bound</span> <span class=\"n\">Œº</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.IntegrableOn.integrable</span> <span class=\"n\">l</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hbound</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ·µê</span> <span class=\"n\">a</span> <span class=\"bp\">‚àÇ</span><span class=\"n\">Œº</span><span class=\"o\">,</span> <span class=\"bp\">‚Äñ</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"bp\">‚Äñ</span> <span class=\"bp\">‚â§</span> <span class=\"n\">bound</span> <span class=\"n\">a</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">let</span> <span class=\"n\">hlim</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ·µê</span> <span class=\"n\">a</span> <span class=\"bp\">‚àÇ</span><span class=\"n\">Œº</span><span class=\"o\">,</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"n\">a</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tendsto_integral_of_dominated_convergence</span> <span class=\"n\">bound</span> <span class=\"n\">hmeas</span> <span class=\"n\">hint</span> <span class=\"n\">hbound</span> <span class=\"n\">hlim</span>\n<span class=\"bp\">¬¥¬¥¬¥</span>\n</code></pre></div>",
        "id": 396637880,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697279070
    },
    {
        "content": "<p>For your specific question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">ns</span>\n      <span class=\"n\">refine</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">apply</span><span class=\"bp\">?</span> <span class=\"n\">says</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ContinuousMap.measurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 396642045,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1697282098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/116395-maths/topic/Proofing.20convergence/near/396642045\">said</a>:</p>\n<blockquote>\n<p>For your specific question:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">ns</span>\n      <span class=\"n\">refine</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">apply</span><span class=\"bp\">?</span> <span class=\"n\">says</span>\n        <span class=\"n\">exact</span> <span class=\"n\">ContinuousMap.measurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>thanks so much... to me this is still black magic <span aria-label=\"fire\" class=\"emoji emoji-1f525\" role=\"img\" title=\"fire\">:fire:</span> I will need some time working though it</p>",
        "id": 396643598,
        "sender_full_name": "Robert hackman",
        "timestamp": 1697283443
    }
]