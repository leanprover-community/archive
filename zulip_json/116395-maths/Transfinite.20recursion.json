[
    {
        "content": "<p>I'm trying to recreate <a href=\"https://kerodon.net/tag/006R\">this proof</a> in Lean, but I'm having a hard time figuring out transfinite recursion. I don't think the specifics of the proof are that important here, but my basic problem is this:</p>\n<p>For a fixed ordinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span> I need to recursively define morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>u</mi><mi>γ</mi></msub><msub><mo stretchy=\"false\">}</mo><mrow><mi>γ</mi><mo>≤</mo><mi>α</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\{  u_{\\gamma } \\} _{\\gamma \\leq \\alpha }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">γ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2952em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> satisfying certain properties which depend on the morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>u</mi><mi>β</mi></msub><msub><mo stretchy=\"false\">}</mo><mrow><mi>β</mi><mo>&lt;</mo><mi>γ</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\{  u_{\\beta } \\} _{ \\beta &lt; \\gamma }</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">β</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05278em;\">β</span><span class=\"mrel mtight\">&lt;</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05556em;\">γ</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>, but I haven't been able to come up with a good way to package this.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFounded.recursion#doc\">docs#WellFounded.recursion</a> seems close to what I need but I don't think it's enough (I think it would work if I just had to assign each ordinal to a proposition, but I have to assign morphisms as well).</p>\n<p>Can anyone suggest a way to do this?</p>",
        "id": 461992601,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1723512743
    },
    {
        "content": "<p>Recursion is what you're looking for</p>",
        "id": 461993432,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723513194
    },
    {
        "content": "<p>Note the signature <code>C : α → Sort</code>, meaning <code>C</code> can contain propositions or data</p>",
        "id": 461993496,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723513218
    },
    {
        "content": "<p>We don't have a way to do bounded recursion on ordinals directly just yet, so as a way to sidestep it you could define, for all ordinals <code>x</code>, an element of <code>x &lt; α → M</code> where <code>M</code> is the type of your morphisms</p>",
        "id": 461993699,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1723513332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Transfinite.20recursion/near/461993699\">said</a>:</p>\n<blockquote>\n<p>We don't have a way to do bounded recursion on ordinals directly just yet, so as a way to sidestep it you could define, for all ordinals <code>x</code>, an element of <code>x &lt; α → M</code> where <code>M</code> is the type of your morphisms</p>\n</blockquote>\n<p>Thank you,  I think this has put me back on track</p>",
        "id": 461997371,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1723515111
    },
    {
        "content": "<p>Doing such an induction is quite technical. I have already completely formalized the small object argument, but I am PRing it slowly to mathlib. If I understand the language properly, the fact that the class of morphisms which satisfy the left lifting property with respect to a class of morphisms is stable by transfinite composition is the last declaration in this file  <a href=\"https://github.com/joelriou/k-injective/blob/main/KInjective/SmallObject/Lifting.lean\">https://github.com/joelriou/k-injective/blob/main/KInjective/SmallObject/Lifting.lean</a></p>",
        "id": 462028893,
        "sender_full_name": "Joël Riou",
        "timestamp": 1723529741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Transfinite.20recursion/near/462028893\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/joelriou/k-injective/blob/main/KInjective/SmallObject/Lifting.lean\">https://github.com/joelriou/k-injective/blob/main/KInjective/SmallObject/Lifting.lean</a></p>\n</blockquote>\n<p>This is great, Joël. It looks like much of this repo will be useful to me <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 462034170,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1723531760
    }
]