[
    {
        "content": "<p>Greetings! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> The version of Vitali's convergence theorem in Mathlib <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.tendstoInMeasure_iff_tendsto_Lp#doc\">docs#MeasureTheory.tendstoInMeasure_iff_tendsto_Lp</a> requires the <code>IsFiniteMeasure</code> hypothesis. The result of course holds even if the underlying measure space has infinite volume, requiring instead the additional hypothesis that the converging functions are \"uniformly tight\".</p>\n<p>I've formalized the proof of this more general version. I'm posting it below. It'd be nice to include it in Mathlib eventually. But since it is my first experience with Lean (or any proof assistant), I'd be happy to hear any comments about doing things more inline with best practices. I've left XXX marks in the code where I had some specific questions or issues. If it's clear that the code could be integrated into Mathlib, a pointer to instructions on how to make a pull request would be welcome.</p>\n<p>A comment about my experience. One of the biggest headaches was dealing with routine ENNReal arithmetic. Neither <code>linarith</code> nor <code>field_simp</code> nor <code>simp</code> were of any help. It'd be nice to have extra assistance here, since I've noticed that ENNReal is used everywhere in measure theory.</p>",
        "id": 407999376,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702571701
    },
    {
        "content": "<p>Can't post it directly (too long). I'll set up a small git repository and post the link to it in a bit.</p>",
        "id": 407999685,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702571783
    },
    {
        "content": "<p>Pointer: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a> ; you'll need to ask for push access to the main repository if you don't have it yet</p>",
        "id": 408001290,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702572316
    },
    {
        "content": "<p>Here it is (about 550 lines): <a href=\"https://github.com/igorkhavkine/VitaliConvergence/blob/main/VitaliConvergence.lean\">https://github.com/igorkhavkine/VitaliConvergence/blob/main/VitaliConvergence.lean</a></p>",
        "id": 408001299,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702572319
    },
    {
        "content": "<p><code>AEStronglyMeasurable.ennnorm</code> returning <code>AEMeasurable</code> rather than <code>AEStronglyMeasurable</code> seems odd to me as well; cc <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> who added it in <a href=\"https://github.com/leanprover-community/mathlib/pull/12985\">!3#12985</a></p>",
        "id": 408002510,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702572707
    },
    {
        "content": "<p>It is the reasonable and useful statement: for ENNReal-valued functions, the assumption one uses all the time for the Lebesgue integral is <code>AEMeasurable</code>, while <code>AEStronglyMeasurable</code> is more relevant for Bochner integration, i.e., for functions taking values in a vector space. This should probably be more properly explained in the docstring!</p>",
        "id": 408016341,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702577263
    },
    {
        "content": "<p><code>(AE)StronglyMeasurable</code> is used everywhere around Lp spaces, so I naturally followed that trend. I updated the core <code>lintegral_indicator_compl_le</code> lemma to use only <code>AEMeasurable</code>.</p>",
        "id": 408047361,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702588411
    },
    {
        "content": "<p>Still it would make more sense to me to get <code>AEMeasurable</code> from <code>hstrongmeasfunc.ennnorm.aemeasurable</code> rather that straight from <code>hstrongmeasfunc.ennnorm</code>. Afterall <code>hstrongmeasfunc.nnnorm.aemeasurable</code> does the expected thing.</p>",
        "id": 408047380,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702588421
    },
    {
        "content": "<p>Also, about consistency. I've noticed that in different parts under <code>MeasureTheory</code> a.e. convergence when referred to in theorem names sometimes is written as <code>ae_tendsto</code> and sometimes <code>tendsto_ae</code>. It's about 50%/50% as far as I can tell. Would it make sense to standardize that?</p>",
        "id": 408047863,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702588637
    },
    {
        "content": "<p>Another thing I found confusing. What is the right way to attach an instance of <code>IsFiniteMeasure μ</code>to a measure space? It is an implicit argument that is expected to be synthesized when calling <code>tendsto_Lp_of_tendsto_ae_of_meas</code>. What is the purpose of wrapping a proof of <code>μ univ &lt; ∞</code>inside <code>IsFiniteMeasure μ</code> or more generally <code>Fact (...)</code>?</p>",
        "id": 408050833,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702589783
    },
    {
        "content": "<p>Possibly so you don't have to pass the hypothesis manually every time</p>",
        "id": 408050934,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702589834
    },
    {
        "content": "<p>What is the underlying Lean mechanism here? I guess I just don't understand what's different between arguments <code>[IsFiniteMeasure μ]</code> or <code>[μ univ &lt; ∞]</code> or just leaving a <code>_</code> in place of an argument when invoking a theorem.</p>",
        "id": 408051394,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702590046
    },
    {
        "content": "<p>The terms you're looking for are \"type class\" or \"instance argument\"</p>",
        "id": 408052233,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702590435
    },
    {
        "content": "<p>Note that <code>[μ univ &lt; ∞]</code> isn't allowed (i.e. won't work) because <code>&lt;</code> is a structure but not a <code>class</code>.</p>",
        "id": 408056843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702592415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"674314\">Igor Khavkine</span> <a href=\"#narrow/stream/116395-maths/topic/Vitali's.20convergence.20theorem/near/408047380\">said</a>:</p>\n<blockquote>\n<p>Still it would make more sense to me to get <code>AEMeasurable</code> from <code>hstrongmeasfunc.ennnorm.aemeasurable</code> rather that straight from <code>hstrongmeasfunc.ennnorm</code>. Afterall <code>hstrongmeasfunc.nnnorm.aemeasurable</code> does the expected thing.</p>\n</blockquote>\n<p>Indeed the first version I had was like that, with <code>hstrongmeasfunc.ennnorm.aemeasurable</code>. Except I realized later that <em>all</em> uses of <code>AEStronglyMeasurable.ennnorm</code> were of this form (not one single exception!), composing with <code>.aemeasurable</code> aferwards. So I switched to the version giving the aemeasurable conclusion, since it's the one which is really needed.</p>",
        "id": 408130227,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702625196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Vitali's.20convergence.20theorem/near/408130227\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"674314\">Igor Khavkine</span> <a href=\"#narrow/stream/116395-maths/topic/Vitali's.20convergence.20theorem/near/408047380\">said</a>:</p>\n<blockquote>\n<p>Still it would make more sense to me to get <code>AEMeasurable</code> from <code>hstrongmeasfunc.ennnorm.aemeasurable</code> rather that straight from <code>hstrongmeasfunc.ennnorm</code>. Afterall <code>hstrongmeasfunc.nnnorm.aemeasurable</code> does the expected thing.</p>\n</blockquote>\n<p>Indeed the first version I had was like that, with <code>hstrongmeasfunc.ennnorm.aemeasurable</code>. Except I realized later that <em>all</em> uses of <code>AEStronglyMeasurable.ennnorm</code> were of this form (not one single exception!), composing with <code>.aemeasurable</code> aferwards. So I switched to the version giving the aemeasurable conclusion, since it's the one which is really needed.</p>\n</blockquote>\n<p>I understand the logic. I can only offer the perspective of a casual user. And from that perspective this choice looks like Unexpected Behavior (TM).</p>",
        "id": 408276870,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702685954
    },
    {
        "content": "<p>I've now looked up some basics about typeclasses. Thanks for the hints about them! In terms of saving on typing, it seems to me that's exactly what coercions are for. Indeed, there are canonical implications in the <code>StronglyMeasurable</code>, <code>Measurable</code>, <code>AEStronglyMeasurable</code> and <code>AEMeasurable</code> hierarchy. I see no reason why they couldn't be coerced using the usual Mathlib mechanisms.</p>",
        "id": 408277339,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702686170
    },
    {
        "content": "<p>Here's sample code for doing exactly that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Topology</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">NNReal</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory.AEStronglyMeasurable</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">mβ</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">StronglyMeasurable.measurable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeStronglyMeasurable_toMeasurable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">StronglyMeasurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.measurable</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">StronglyMeasurable.aestronglyMeasurable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeStronglyMeasurable_toAEStronglyMeasurable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">StronglyMeasurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.aestronglyMeasurable</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">AEStronglyMeasurable.aemeasurable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeAEStronglyMeasurable_toAEMeasurable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.aemeasurable</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">coe</span><span class=\"o\">]</span> <span class=\"n\">Measurable.aemeasurable</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instCoeMeasurable_toAEMeasurable</span>\n  <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"o\">(</span><span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.aemeasurable</span>\n\n<span class=\"c1\">-- fails: Why can't it synthesize `μ` for `AEMeasurable f _`, even though `μ` appears in `hf`?</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span>\n\n<span class=\"c1\">-- works! uses the new coercions</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">StronglyMeasurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">StronglyMeasurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span>\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace.PseudoMetrizableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span>\n\n<span class=\"c1\">-- works! with β = ℝ≥0∞</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span>\n\n<span class=\"c1\">-- works, but `hf.ennnorm` by current convention is already `AEMeasurable`</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span> <span class=\"n\">μ</span>\n  <span class=\"o\">:=</span> <span class=\"n\">hf.ennnorm</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">measurability</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">ennnorm_aestronglyMeasurable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">ENNReal.continuous_coe.comp_aestronglyMeasurable</span> <span class=\"n\">hf.nnnorm</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- works! this uses coercion of `AEStronglyMeasurable` to `AEMeasurable`</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SeminormedAddCommGroup</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">f</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">))</span> <span class=\"n\">μ</span>\n  <span class=\"o\">:=</span> <span class=\"n\">hf.ennnorm_aestronglyMeasurable</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">MeasureTheory.AEStronglyMeasurable</span>\n</code></pre></div>",
        "id": 408277576,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702686281
    },
    {
        "content": "<p>The last example shows what I think would be expected behavior by a casual user (who happens to be aware of coercions).</p>",
        "id": 408277737,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702686360
    },
    {
        "content": "<p>OK, I've managed to package my code as a branch (<a href=\"https://github.com/igorkhavkine/mathlib4-fork/commits/vitali_convergence_update/\"><code>vitali_convergence_update</code></a>) on a personal fork of Mathlib (see the last 4 commits there).</p>\n<p>I'm happy to submit a Pull Request for review. If it makes anyone's life easier, I could just as easily add this branch to the main Mathlib repository and make a PR that way. In that case I believe I should ask someone for write access (<span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> sorry if I'm pinging the wrong persons)? As far as a self-introduction, please see:</p>\n<p><a href=\"https://users.math.cas.cz/~khavkine/\">https://users.math.cas.cz/~khavkine/</a></p>",
        "id": 408998907,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1703012672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674314\">@Igor Khavkine</span>, invitation sent!</p>",
        "id": 409029543,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1703026558
    },
    {
        "content": "<p>Done! PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/9163\">#9163</a> submitted.</p>",
        "id": 409181191,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1703077187
    }
]