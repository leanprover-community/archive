[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and I have been discussing the sheaf of meromorphic functions.</p>\n<p>Here is an initial definition of the sheaf of rings of fractions.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.filtered_colimits</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.limits</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.sites.sheaf</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.sites.sheafification</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.sheaves.sheaf_condition.sites</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"c1\">--import category_theory.filtered</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Sheaf</span> <span class=\"o\">(</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V</span><span class=\"o\">)),</span> <span class=\"n\">P.val.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">regular_element</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hf</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hs</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ht</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_is_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hf</span> <span class=\"n\">W</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">P.val.map_comp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">op_comp</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">⟶</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">U.unop</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">V.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_hom</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">V.unop</span> <span class=\"bp\">≤</span> <span class=\"n\">U.unop</span> <span class=\"o\">:=</span> <span class=\"n\">le_of_hom</span> <span class=\"n\">h.unop</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">map_is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">this</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">h.unop.op</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">congr'</span> <span class=\"mi\">1</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">total_fraction_presheaf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">CommRing</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">CommRing.of</span> <span class=\"bp\">$</span> <span class=\"n\">localization</span> <span class=\"o\">(</span><span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">U.unop</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comap_regular_element</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">change</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U.unop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V.unop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">P.val.map</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_localization.map_comp_map</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span> <span class=\"bp\">.</span>\n\n<span class=\"c1\">-- Why is this needed???</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_filtered</span> <span class=\"o\">((</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cover</span> <span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">total_fraction_sheaf</span> <span class=\"o\">:</span> <span class=\"n\">Sheaf</span> <span class=\"o\">(</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">CommRing</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">total_fraction_presheaf</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Now if `P` is the sheaf of holomorphic functions, then `total_fraction_sheaf P` should be</span>\n<span class=\"c1\">-- the sheaf of meromorphic functions.</span>\n</code></pre></div>\n</div></div>\n<p>As you can see, there are some pain points in this code, around the following points:</p>\n<ol>\n<li>I used Grothendieck topologies, because as far as I know we cannot easily sheafify presheaves of commutative rings using sheaves from the <code>topology</code> part of mathlib.</li>\n<li>Mapping localizations is more difficult than it should be... I could add some algebra instances, sure, but it's still a bit annoying.</li>\n<li>There are some annoying points coming up due to <code>op</code>, but I don't see any way to avoid them.</li>\n<li>Why do I need to manually add the <code>is_filtered</code> instance toward the bottom?</li>\n</ol>",
        "id": 267316997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641677412
    },
    {
        "content": "<p>It would be better to develop a general construction of localization of sheaves of commutative rings by a sub(pre)sheaf of monoids. If someone wants to try to even write down the type of such a construction, that would be great!</p>",
        "id": 267317269,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641677813
    },
    {
        "content": "<p>A probably not that related question: what is a better way to talk about a \"sub(pre)sheaf of monoids\"?<br>\nAn mono into the image of the <code>F : Sheaf X CommRing</code> under some forgetful functor <code>Sheaf X CommRing ⥤  Sheaf X Monoid</code>?<br>\nI was thinking about this just this afternoon (though I was thinking about ideal sheaves) and I have yet obtained a satisfactory solution.</p>",
        "id": 267317737,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641678538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> that question is definitely related! Note that to localize a ring, one must use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid\">docs#submonoid</a> at some point</p>",
        "id": 267317820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678666
    },
    {
        "content": "<p>(at least in the way localization is currently done)</p>",
        "id": 267317826,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678682
    },
    {
        "content": "<p>If you have a morphism of sheaves of monoids, you can localize at the images, I guess... But I don't know how workable that would be in practice</p>",
        "id": 267317886,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678738
    },
    {
        "content": "<p>I thought so too. Since most of the substuff library talks about the bundled substuff, we would need to juggle with images all the time if we go for this approach.</p>",
        "id": 267317912,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641678792
    },
    {
        "content": "<p>For sheaves of ideals, you can model them as kernels of morphisms of sheaves of rings, for example.</p>",
        "id": 267318580,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641679556
    },
    {
        "content": "<p>You'll have a bad notion of equality that way</p>",
        "id": 267319362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641680491
    },
    {
        "content": "<p>equality is evil anyway</p>",
        "id": 267319370,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641680509
    },
    {
        "content": "<p>Perhaps not for sheaves of ideals</p>",
        "id": 267319419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641680535
    },
    {
        "content": "<p>ok, fair point..</p>",
        "id": 267319425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641680546
    },
    {
        "content": "<p>Is there no way to use <code>non_zero_divisors</code> here?</p>",
        "id": 267323550,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641685946
    },
    {
        "content": "<p>For example, if I am reading the definition, correctly, you're working on <code>{ obj := λ U, CommRing.of $ fraction_ring (P.val.obj U), ...}</code>? There are some API missing for your <code>2.</code> point. Just to familiarize myself with this part of the library, is there a reason to not use <code>CommRing.of_hom _</code> for your <code>hom := </code> construction?</p>",
        "id": 267324150,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641686825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> take a look at the definition on the nlab, <br>\n<a href=\"http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/sheaf+of+meromorphic+functions\">http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/sheaf+of+meromorphic+functions</a></p>\n<p>and also (in the algebraic context) the top of page 141 of Hartshorne.</p>",
        "id": 267324896,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688060
    },
    {
        "content": "<p>I don't think using <code>non_zero_divisors</code> works in this level of generality.</p>",
        "id": 267324938,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688086
    },
    {
        "content": "<p>As for <code>CommRing.of_hom</code>, it's not really needed here, as morphisms in the category <code>CommRing</code> are defeq to ring homs.</p>",
        "id": 267324945,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688132
    },
    {
        "content": "<p>Oh wait, I see what you mean... maybe it does work to resolve 2, let me check.</p>",
        "id": 267324962,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688184
    },
    {
        "content": "<p>No, unfortunately the same annoyances show up with <code>CommRing.of_hom</code> as well... lean is not able to deduce the algebra and <code>is_localization</code> instances for some reason.</p>",
        "id": 267325052,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688304
    },
    {
        "content": "<p>Yeah it didn't help when I tried</p>",
        "id": 267325053,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641688316
    },
    {
        "content": "<p>A section of a sheaf of rings is regular if all its restrictions are <code>non_zero_divisors</code>. This is strictly stronger than just being a <code>non_zero_divisor</code> in <code>P(U)</code>, so <code>fraction_ring (P U)</code> already inverts too many things</p>",
        "id": 267342689,
        "sender_full_name": "David Wärn",
        "timestamp": 1641714685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267316997\">said</a>:</p>\n<blockquote>\n<p>As you can see, there are some pain points in this code, around the following points:</p>\n<ol>\n<li>I used Grothendieck topologies, because as far as I know we cannot easily sheafify presheaves of commutative rings using sheaves from the <code>topology</code> part of mathlib.</li>\n</ol>\n</blockquote>\n<p>I didn't realise we had both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf\">docs#category_theory.Sheaf</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.sheaf\">docs#Top.sheaf</a>.  Is it planned for the former to subsume the latter at some point?</p>",
        "id": 267493874,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641845826
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 267495605,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641846750
    },
    {
        "content": "<p>Quoting Justus from his PR linking the two notions:</p>\n<blockquote>\n<p>@jcommelin I did briefly think about this and I'm not sure. It's a design decision I don't feel comfortable making at the moment. Removing the sheaf-on-space definition by making it a special case of the more general one certainly feels like the right thing to do. But on the other hand, I consider sheaves on spaces a pretty important special case and some users (e.g. me three weeks ago) may not want to think about sites and just do sheaves on spaces. So there probably should be a lot of API specialising every applicable concept around sheaves to the case of spaces anyway. So maybe it wouldn't even make that much of a difference in size. But conceptually, it would probably be the right thing do to in the long run.</p>\n<p>Note that some things can already be deduplicated using the equivalence of categories: Right now there are two proofs that composing a sheaf with an isomorphism-reflecting limit-preserving functor again yields a sheaf. They work in slightly different settings, but you could definitely make one a special case of the other by going around the equivalence of categories. I might try to do that soon.</p>\n</blockquote>",
        "id": 267495878,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641846907
    },
    {
        "content": "<p>Also -- how do I make a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf\">docs#category_theory.Sheaf</a>?  I think it's nearly possible to make the structure sheaf of a complex manifold as a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.sheaf\">docs#Top.sheaf</a> -- <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.local_predicate\">docs#Top.local_predicate</a> does this, the only problem is that it makes a sheaf of types rather than a sheaf of rings.</p>",
        "id": 267496002,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641846963
    },
    {
        "content": "<p>We have the equivalence between the two notions as an equivalence of categories.</p>",
        "id": 267496112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847027
    },
    {
        "content": "<p>I see.  Would some sheaf person be up for modifying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.local_predicate\">docs#Top.local_predicate</a> to make sheaves of rings?</p>",
        "id": 267496167,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847059
    },
    {
        "content": "<p>The type vs. commring is an issue.</p>",
        "id": 267496172,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847061
    },
    {
        "content": "<p>We could refactor <code>local_predicate</code> to take in a sufficiently nice concrete category instead of <code>Type*</code>.</p>",
        "id": 267496486,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847216
    },
    {
        "content": "<p>Or we could build up enough of the API so that using <code>Sheaf (opens.grothendieck_topology X) A</code> isn't so scary.</p>",
        "id": 267496647,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> what do you think?</p>",
        "id": 267496702,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267496112\">said</a>:</p>\n<blockquote>\n<p>We have the equivalence between the two notions as an equivalence of categories.</p>\n</blockquote>\n<p>If I understand correctly, an equivalence of categories wouldn't give a bijection of the objects, let alone a bijection respecting definitional equality ... so this sounds like it would get awkward.</p>",
        "id": 267496770,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847378
    },
    {
        "content": "<p>I think the functors for this equivalence are defeq to the identity on the level of presheaves, but I'm not 100% sure (I think Justus is the person who built that equivalence?)</p>",
        "id": 267496860,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847430
    },
    {
        "content": "<p>Oh, that's nice then!</p>",
        "id": 267496946,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847455
    },
    {
        "content": "<p>For a presheaf <code>Cᵒᵖ ⥤ D</code>, we know that it is a sheaf on the space iff it is a sheaf wrt the grothendieck topology, and the two categories are defined as merely a subtype of the category of presheaves, so it should not be a pain to move from one to another.</p>",
        "id": 267497190,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267496486\">said</a>:</p>\n<blockquote>\n<p>We could refactor <code>local_predicate</code> to take in a sufficiently nice concrete category instead of <code>Type*</code>.</p>\n</blockquote>\n<p>This sounds great ...</p>",
        "id": 267497557,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847799
    },
    {
        "content": "<p>I'm not sure how one would generalize <code>local_predicate</code> to concrete categories.<br>\nWe would need to know that the set of the functions satisfying P locally is an object in the category, and the condition would vary for different categories?</p>",
        "id": 267497677,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847844
    },
    {
        "content": "<p>Note that we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presheaf.is_sheaf_iff_is_sheaf_forget\">docs#category_theory.presheaf.is_sheaf_iff_is_sheaf_forget</a>, so we should still be able to use the local predicate stuff for good enough concrete categories.</p>",
        "id": 267497888,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267497677\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how one would generalize <code>local_predicate</code> to concrete categories.<br>\nWe would need to know that the set of the functions satisfying P locally is an object in the category, and the condition would vary for different categories?</p>\n</blockquote>\n<p>Could you do it for categories which have been constructed using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled\">docs#category_theory.bundled</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom.category\">docs#category_theory.bundled_hom.category</a> ?</p>",
        "id": 267500137,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641848970
    },
    {
        "content": "<p>We would still need to prove things like <a href=\"https://github.com/leanprover-community/mathlib/blob/dc3cbb7d7d31191be71a6a52015e03a7578ff961/src/algebraic_geometry/structure_sheaf.lean#L147-L210\">https://github.com/leanprover-community/mathlib/blob/dc3cbb7d7d31191be71a6a52015e03a7578ff961/src/algebraic_geometry/structure_sheaf.lean#L147-L210</a><br>\nfor each local predicates we want to use, and the condition crucially depends on the P used.</p>",
        "id": 267500693,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641849188
    },
    {
        "content": "<p>Even if there's no way to abstract it to sheaves of \"certain kinds of categories\", it might be nice to provide a local-predicate construction for sheaves of rings, since that one's used a lot.</p>",
        "id": 267509111,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641852886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267342689\">said</a>:</p>\n<blockquote>\n<p>A section of a sheaf of rings is regular if all its restrictions are <code>non_zero_divisors</code>. This is strictly stronger than just being a <code>non_zero_divisor</code> in <code>P(U)</code>, so <code>fraction_ring (P U)</code> already inverts too many things</p>\n</blockquote>\n<p>For those of you who want to look at old stuff, this problem is the source of a mistake in Grothendieck's EGA (it is written that the obvious presheaf is a sheaf, but it's not a presheaf!). It has been adressed in a nice paper of Steven Kleiman, <em>Some misconceptions about K_X</em>, L'enseignement mathématique, DOI:10.5169/seals-50379</p>",
        "id": 267787286,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1642022135
    },
    {
        "content": "<p>Antoine, I added a refence to your blog post about this, by Kevin's pointer to it! <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/field_theory/ratfunc.lean#L58\">https://github.com/leanprover-community/mathlib/blob/master/src/field_theory/ratfunc.lean#L58</a></p>",
        "id": 267787410,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642022200
    },
    {
        "content": "<p>It was my motivation to generalize <code>ratfunc.lift_on</code> to arbitary <code>[comm_ring K}</code> without requiring <code>[is_domain K]</code></p>",
        "id": 267787496,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642022260
    },
    {
        "content": "<p>I think there is still a lot of stuff in the sheaf theory library that should be generalised from sheaves of types to sheaves valued in more general \"nice enough\" category. In fact, working with sheaves in lean made me realise what exactly \"nice enough\" means in this context: It needs to be a concrete category whose forgetful functor reflects isomorphisms and preserves limits and filtered colimits. The first two properties ensures that a presheaf is a sheaf if and only if the underlying presheaf of types is a sheaf, while preserving colimits ensures that taking stalks commutes with the forgetful functor. All the typical \"algebraic\" categories, like <code>Group</code> or <code>CommRing</code> satisfy this property (and this is already in mathlib). The stacks project calls these categories \"types of algebraic structures\" in <a href=\"https://stacks.math.columbia.edu/tag/007L\">stacks#007L</a>. So I believe if sheafification and the stuff about local prediactes should be generalised, it is this class of categories one should look at, not only <code>CommRing</code>.</p>",
        "id": 267917793,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642101858
    },
    {
        "content": "<p>Those are exactly the conditions I had set up for sheafification over a general site.</p>",
        "id": 267918273,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102101
    },
    {
        "content": "<p>E.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.grothendieck_topology.sheafify_is_sheaf\">docs#category_theory.grothendieck_topology.sheafify_is_sheaf</a></p>",
        "id": 267918371,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102151
    },
    {
        "content": "<p>Oh wow, I didn't know this already exists in mathlib for sites.</p>",
        "id": 267918883,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642102378
    },
    {
        "content": "<p>Actually since we have the adjunction <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.sheafification_adjunction\">docs#category_theory.sheafification_adjunction</a> and the equivalence between the site-theoretic definition of sheaves and the topological one, as an equivalence of categories, it would be easy to obtain the sheafification adjunction for topological spaces as well by composing... that's some sort of sheafification in general for topological spaces, although if you need more control over the stalks that would require additional work.</p>",
        "id": 267919098,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102491
    },
    {
        "content": "<p>Yeah,  it seems it's about time that sheaves on sites and sheaves on spaces are unified. Maybe I should have tried to do that when I built the equivalence. The longer the theories move independently the harder it will be to clean it up and unify them. In a sense it doesn't matter that much because we'll still want all the API for the special case of sheaves on spaces, but it's the right thing to do conceptually.</p>",
        "id": 267920136,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642103012
    },
    {
        "content": "<p>I also think that we should make the sites one the official definition (while keeping all the other sheaves on topology stuff). I would suppose that the transition won't be that painful, since we are just replacing a Prop valued thing into another that we know is equivalent.<br>\nThis gives us sheaves in categories without products (which I do not know how useful it is), but more importantly this makes it easier to access the sites stuff (sheafification, pullback-pushforward, abelian-ness, etc).</p>",
        "id": 267920548,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1642103206
    },
    {
        "content": "<p>(Thanks for the reminder that I should eventually mathlibify the fact that abelian sheaves are an abelian category ;))<br>\n<code>mathlibify</code> is the left adjoint to the forgetful functor from mathlib to lte, of course.</p>",
        "id": 267920733,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642103294
    },
    {
        "content": "<p>If we just want the sheaf for schemes and not general ringed spaces, then according to the misconceptions paper, we can define sections of the presheaf using the \"wrong\" definition on open affines, then sheafify and extend to all opens, using Andrew's work at <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/sites/dense_subsite.html\">https://leanprover-community.github.io/mathlib_docs/category_theory/sites/dense_subsite.html</a>.</p>",
        "id": 268241634,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642409056
    },
    {
        "content": "<p>Sure, but we should have a construction that will also let us construct meromorphic functions in the holomorphic setting (and other settings as well), not just in the algebraic context.</p>",
        "id": 268275865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642428958
    },
    {
        "content": "<p>I'd like to gather some opinions about how best to implement meromorphic functions (from an open subset of ℂ to ℂ).</p>\n<p>We can certainly define a function to be <code>MeromorphicAt z</code> if <code>∃ (n : ℕ), AnalyticAt ℂ (fun x ↦ (x - z) ^ n * f x) z</code>. But I am worried that this would capture some rather silly functions: e.g. with this definition the function \"f(x) = 1 if x = 0 and else 0\" is meromorphic at 0, which seems undesirable.</p>\n<p>We could try requiring that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span> should be defined as 0 if f has a pole, but this plays badly with arithmetic on functions: with this definition, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">f(x) = 1/x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1/</span><span class=\"mord mathnormal\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">g(x) = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> are both meromorphic, but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x) + g(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> is not. We can rescue addition by instead requiring that, even at a pole, <code>f z</code> must equal the constant term of the Laurent expansion of <code>f</code> at <code>z</code>, but it doesn't seem to be possible to fix multiplication the same way. </p>\n<p>I think there's no way of fixing this without dropping the idea that meromorphic functions be a subset of <code>ℂ → ℂ</code>: we need to carry around more data. </p>\n<p>I wondered about encoding meromorphic functions as functions <code>ℂ → ℂ((X))</code>, where <code>ℂ((X))</code> is the space of Laurent series in a formal variable <code>X</code>, satisfying the compatibility condition that for all <code>z</code>, the Laurent series <code>f z ∈ ℂ((X))</code> has to be a Laurent expansion for the function \"x ↦ constant term of f (x)\" around <code>z</code>. Then addition and multiplication are well-defined, and we have a uniquely determined <code>evaluate at a point</code> map given by taking constant terms of Laurent series (which is even a map of ℂ-vector spaces); but we have to live with the fact that in general <code>eval f z * eval g z ≠ eval (f * g) z</code>.</p>\n<p>I'd be interested in any feedback as to whether this is a good approach.</p>",
        "id": 393479572,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695818544
    },
    {
        "content": "<p>In your 2nd paragraph, you meant <code>(x - z) ^ n</code> instead of <code>x ^ n</code>, right?</p>",
        "id": 393481843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695819444
    },
    {
        "content": "<p>It doesn't change your point, of course.</p>",
        "id": 393481893,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695819462
    },
    {
        "content": "<p>yes, that was a typo, sorry!</p>",
        "id": 393483814,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695820093
    },
    {
        "content": "<p>I like the question, and thought about it recently, and besides what you are describing I had two alternative definitions:</p>\n<ul>\n<li>the meromorphic functions on a connected open set are the field of fractions of holomorphic functions on that set, which is nicely defined. but there is the issue of evaluation at a point because we need to say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">/</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x/x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">x</span></span></span></span> at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and Lean would think it is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></li>\n<li>meromorphic functions on <code>U</code> are the holomorphic functions from <code>U</code> to the Riemann sphere that are not identically infinite.</li>\n</ul>",
        "id": 393484407,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1695820309
    },
    {
        "content": "<p>How about defining a meromorphic function on an open subset <code>U</code> of <code>C</code> as a function that:</p>\n<ol>\n<li>Is defined on <code>U</code> minus a closed discrete set <code>P</code>.</li>\n<li>Is analytic/holomorphic on <code>U \\ P</code>.</li>\n<li>Has a Laurent series expansion on a small punctured disk (contained in <code>U\\P</code>) around each point <code>p</code> of <code>P</code>. </li>\n</ol>\n<p>With that definition, it should be provable in a rather elementary way that if we extend by <code>\\infty</code> at points of <code>P</code>, then a meromorphic function “on <code>U</code>” is a holomorphic map <code>U \\to CP^1</code> and vice-versa. </p>\n<p>(sent from a cell phone, sorry)</p>",
        "id": 393485240,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695820614
    },
    {
        "content": "<p>I think the either: we consider maps to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">P</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{P}^1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span>, or the values at poles must be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. The benefit of the second convention is that it will be a lot easier to reason with all the finite values, since they will be ordinary complex numbers.</p>",
        "id": 393485649,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695820756
    },
    {
        "content": "<p>I’m afraid that setting the value at a pole to be <code>0</code> might introduce complications later on <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 393485929,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695820839
    },
    {
        "content": "<p>Yes, up to the question of whether we want to impose poles at <code>P</code> or not (I would be inclined not to, because then the sum and product of meromorphic functions is nicely meromorphic, you don't need to take care of cancellations)</p>",
        "id": 393485961,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1695820856
    },
    {
        "content": "<p>But surely we do not want <code>exp(1/z)</code> to be considered meromorphic, right?</p>",
        "id": 393486345,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695820985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513540\">@Flo (Florent Schaffhauser)</span> It has to have some value, unless you want to work with functions defined on subtypes. But that creates its own set of headaches.</p>",
        "id": 393486395,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695821004
    },
    {
        "content": "<p>Right, I mean at every point at <code>P</code> we have either a pole or a continuous extension</p>",
        "id": 393486476,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1695821034
    },
    {
        "content": "<p>But what is \"a pole\"?</p>",
        "id": 393486747,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695821126
    },
    {
        "content": "<p>What is the <em>type</em> of a meromorphic function?</p>",
        "id": 393486780,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695821138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> In that case, can the value be an <code>\\infty</code> symbol? We would just have to take <code>C \\cup {\\infty}</code> as target.</p>",
        "id": 393486952,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393486780\">said</a>:</p>\n<blockquote>\n<p>What is the <em>type</em> of a meromorphic function?</p>\n</blockquote>\n<p>Triples <code>(U, P, f: U\\P \\to C)</code> satisfying the conditions above.</p>",
        "id": 393487388,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821323
    },
    {
        "content": "<p>I think the easiest would be <code>\\C \\to \\C</code> with <code>IsMeromophicOn U</code> as a predicate that states <code>\\exists P, discrete P and whatever</code></p>",
        "id": 393487478,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1695821355
    },
    {
        "content": "<p>Is working with the riemann sphere too much work?</p>",
        "id": 393487533,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695821375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393487478\">said</a>:</p>\n<blockquote>\n<p>I think the easiest would be <code>\\C \\to \\C</code> with <code>IsMeromophicOn U</code> as a predicate that states <code>\\exists P, discrete P and whatever</code></p>\n</blockquote>\n<p>Yes, <code>\\exists P</code> is also fine, I think. Probably makes things easier to check that the sum and product of meromorphic functions are meromorphic.</p>",
        "id": 393488409,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393487533\">said</a>:</p>\n<blockquote>\n<p>Is working with the riemann sphere too much work?</p>\n</blockquote>\n<p>That would depend on whether we have the Riemann sphere (with nice API) <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 393488596,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1695821676
    },
    {
        "content": "<p>Yes of course. But it seems the mathematically correct approach, but maybe we are very far from complex manifolds...</p>",
        "id": 393488728,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695821730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393486747\">said</a>:</p>\n<blockquote>\n<p>But what is \"a pole\"?</p>\n</blockquote>\n<p>I think we can simply say that a function defined on an open set minus a point has a pole at that point if it admits a Laurent series expansion in a punctured disk around that point.</p>",
        "id": 393489088,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821825
    },
    {
        "content": "<p>Like this a constant function has poles everywhere</p>",
        "id": 393489352,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695821902
    },
    {
        "content": "<p>of course we can add \"a laurent series such that...\", but this seems already a little complicated</p>",
        "id": 393489438,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695821932
    },
    {
        "content": "<p>Sure, poles of order <code>0</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 393489441,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821933
    },
    {
        "content": "<p>No, you’re right, we have to add something 👍🏻</p>",
        "id": 393489526,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695821957
    },
    {
        "content": "<p>We define the Laurent series expansion, it gives us an “order” at the point, and we call the point a pole if the order is negative.</p>",
        "id": 393489697,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822010
    },
    {
        "content": "<p>The key notion is the Laurent series expansion, not that of a pole.</p>",
        "id": 393489774,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822036
    },
    {
        "content": "<p>Laurent series expansion of what?</p>",
        "id": 393489836,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822052
    },
    {
        "content": "<p>I’ve formalized complex manifolds and the Riemann sphere as part of the Mandelbrot work, whence a metamorphic function is just a holomorphic function from C to S.</p>",
        "id": 393489876,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822059
    },
    {
        "content": "<p>I am halfway through the Lean 4 port, and then I can upstream those pieces first if people are interested.</p>",
        "id": 393489994,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393489876\">said</a>:</p>\n<blockquote>\n<p>I’ve formalized complex manifolds and the Riemann sphere as part of the Mandelbrot work, when a metamorphic function is just a holomorphic function from C to S.</p>\n</blockquote>\n<p>This is exactly what I proposed</p>",
        "id": 393490004,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393489836\">said</a>:</p>\n<blockquote>\n<p>Laurent series expansion of what?</p>\n</blockquote>\n<p>Of a function <code>f: U \\ P \\to C</code></p>",
        "id": 393490025,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Apologies, I missed that when scrolling.</p>",
        "id": 393490245,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822130
    },
    {
        "content": "<p>It has the drawback that a function <code>f : ℂ → ℂ</code> cannot be meromorphic, but we can maybe live with that</p>",
        "id": 393490353,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> no worries, I am very happy to know that is doable and even happier to know that it is already done!</p>",
        "id": 393490476,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822191
    },
    {
        "content": "<p>Such a function always has a unique lift, at least.</p>",
        "id": 393490525,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822202
    },
    {
        "content": "<p>Exactly, I think a coercion will do the job</p>",
        "id": 393490627,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822223
    },
    {
        "content": "<p><a href=\"https://github.com/girving/ray/blob/main/src/riemann_sphere.lean\">https://github.com/girving/ray/blob/main/src/riemann_sphere.lean</a></p>",
        "id": 393490724,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393490353\">said</a>:</p>\n<blockquote>\n<p>It has the drawback that a function <code>f : ℂ → ℂ</code> cannot be meromorphic, but we can maybe live with that</p>\n</blockquote>\n<p>Sorry, why?</p>",
        "id": 393490805,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822259
    },
    {
        "content": "<p>I was talking about the approach with the Riemann sphere. Because it takes values in <code>ℂ</code> and not in the Riemann sphere</p>",
        "id": 393490973,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822299
    },
    {
        "content": "<p>The <code>holomorphic</code> def in <a href=\"https://github.com/girving/ray/blob/main/src/complex_manifold.lean\">https://github.com/girving/ray/blob/main/src/complex_manifold.lean</a> includes all of these, so you can be generic if desired.</p>",
        "id": 393491084,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822314
    },
    {
        "content": "<p>(of course there is a \"canonical\" meromorphic function associated to <code>f</code>)</p>",
        "id": 393491118,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822321
    },
    {
        "content": "<p>I should spell it out:</p>\n<ol>\n<li>Holomorphic C to S functions are meromorphic at any finite value</li>\n<li>Holomorphic S to S functions are meromorphic including at infinity (they are rational)</li>\n</ol>",
        "id": 393491957,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393488409\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393487478\">said</a>:</p>\n<blockquote>\n<p>I think the easiest would be <code>\\C \\to \\C</code> with <code>IsMeromophicOn U</code> as a predicate that states <code>\\exists P, discrete P and whatever</code></p>\n</blockquote>\n<p>Yes, <code>\\exists P</code> is also fine, I think. Probably makes things easier to check that the sum and product of meromorphic functions are meromorphic.</p>\n</blockquote>\n<p>But still I would be a bit reluctant to define a meromorphic function as a function defined on all of <code>C</code>.</p>",
        "id": 393492040,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822483
    },
    {
        "content": "<p>From experience, working over manifolds and charted spaces does have a fairly significant pain cost, of course.</p>",
        "id": 393492449,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822552
    },
    {
        "content": "<p>I agree this seems problematic, since we have to choose a garbage value. One possibility can be a predicate on functions <code>ℂ → Option ℂ</code></p>",
        "id": 393492612,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822583
    },
    {
        "content": "<p>Alexandroff C. :)</p>",
        "id": 393492703,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822602
    },
    {
        "content": "<p>My Riemann sphere is just Option C if you unpack definitions.</p>",
        "id": 393492910,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695822633
    },
    {
        "content": "<p>Yes, of course. The point of the API is to hide that or not</p>",
        "id": 393493131,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822677
    },
    {
        "content": "<p>Anyway, we can keep on discussing several approaches forever, each one will have benefits and drawbacks... maybe the best thing is to choose one and go for it (after a not too long discussion...)</p>",
        "id": 393493719,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695822791
    },
    {
        "content": "<p>To be clear, I like the option of defining meromorphic functions “on <code>U</code>” as <code>CP^1</code>-valued holomorphic functions on <code>U</code>, especially if the Riemann sphere is already defined.</p>",
        "id": 393494265,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695822895
    },
    {
        "content": "<p>But we may have to go back to the other approach sooner or later, to define functions that have an essential singularity at a point. </p>\n<p>There, you just replace the Laurent series expansion by an expansion as a series indexed from <code>-\\infty</code> to <code>+\\infty</code>.</p>",
        "id": 393494914,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695823006
    },
    {
        "content": "<p>And you get for instance <code>exp(1/z)</code> as an example, <em>etc</em>.</p>",
        "id": 393495349,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695823080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393493719\">said</a>:</p>\n<blockquote>\n<p>Anyway, we can keep on discussing several approaches forever, each one will have benefits and drawbacks... maybe the best thing is to choose one and go for it (after a not too long discussion...)</p>\n</blockquote>\n<p>Yes, I’ve reached my point, I will shut up now <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 393495910,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695823185
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393492040\">said</a>:</p>\n<blockquote>\n<p>But still I would be a bit reluctant to define a meromorphic function as a function defined on all of <code>C</code>.</p>\n</blockquote>\n<p>Also because at some point we will have to define the sheaf of meromorphic functions on a complex analytic manifold.</p>",
        "id": 393499129,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695823767
    },
    {
        "content": "<p>The \"Riemann sphere\" approach seems to be getting some traction; but do we really want the constant function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> to be a meromorphic function? I'm quite keen on having meromorphic functions having a natural ring structure (and even a field structure if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is connected) and that seems to be something that's hard to get with the Riemann-sphere definition – the ring operations are not even defined unless you restrict to functions such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> is discrete, and even then, defining addition and multiplication is awkward to do.</p>",
        "id": 393506008,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695825031
    },
    {
        "content": "<p>Yes, you’re right, the function <code>f: U \\to \\CP^1</code> should be holomorphic and not equal to the constant function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>.</p>",
        "id": 393507064,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695825322
    },
    {
        "content": "<p>Good point</p>",
        "id": 393507796,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1695825499
    },
    {
        "content": "<p>Also about the definition of sum and product being awkward with that approach, yes.</p>",
        "id": 393508001,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695825558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393493719\">said</a>:</p>\n<blockquote>\n<p>Anyway, we can keep on discussing several approaches forever, each one will have benefits and drawbacks... maybe the best thing is to choose one and go for it (after a not too long discussion...)</p>\n</blockquote>\n<p>Here's a first stab at my \"function taking values in Laurent series\" approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">local</span> <span class=\"n\">macro_rules</span> <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">HPow.hPow</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! IGNORE THIS -- make a FormalMultlinearSeries out of a one-variable</span>\n<span class=\"cm\">power series -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">PowerSeries.formalMultilinearSeries</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">PowerSeries</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FormalMultilinearSeries</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">PowerSeries.coeff</span> <span class=\"n\">ℂ</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">•</span>\n  <span class=\"o\">(</span><span class=\"n\">ContinuousMultilinearMap.mkPiAlgebra</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! A `LaurentFamily` is a family of formal Laurent series indexed by `ℂ`. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">LaurentFamily</span> <span class=\"n\">where</span> <span class=\"o\">(</span><span class=\"n\">laurentSeriesAt</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">LaurentSeries</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LaurentFamily.constTermAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">LaurentFamily</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f.laurentSeriesAt</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">LaurentFamily.orderAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">LaurentFamily</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f.laurentSeriesAt</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">order</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MeromorphicAt</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">LaurentFamily</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasFPowerSeriesAt</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">f.orderAt</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">f.constTermAt</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f.laurentSeriesAt</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">powerSeriesPart.formalMultilinearSeries</span> <span class=\"n\">z</span>\n</code></pre></div>",
        "id": 393508293,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695825631
    },
    {
        "content": "<p>For what it's worth, I would use the naive definition from your first post (i.e., <code>f</code> is meromorphic on <code>U</code> if there exists a discrete set such that <code>f</code> is holomorphic on <code>U - P</code>, and <code>(z -p)^n f</code> extends continuously at <code>p</code> in <code>P</code> for some <code>n</code>), without caring about the specific value at <code>p</code>. Because I think the zeta function and the Gamma functions we already have are meromorphic, and I am very happy to be able to use them as functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</p>",
        "id": 393522172,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1695829636
    },
    {
        "content": "<p>^ And anything with that definition easily lifts to something C to S which is equal except on the discrete countable set, so we can provide the conversion function (I’ve already proven the needed lemmas in the files shared above).  Specifically, you can write the function which produces the S value at a point, and the lift is just all of these S values.</p>",
        "id": 393523419,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695830063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393522172\">said</a>:</p>\n<blockquote>\n<p>For what it's worth, I would use the naive definition from your first post (i.e., <code>f</code> is meromorphic on <code>U</code> if there exists a discrete set such that <code>f</code> is holomorphic on <code>U - P</code>, and <code>(z -p)^n f</code> extends continuously at <code>p</code> in <code>P</code> for some <code>n</code>), without caring about the specific value at <code>p</code>. Because I think the zeta function and the Gamma functions we already have are meromorphic, and I am very happy to be able to use them as functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</p>\n</blockquote>\n<p>That's actually a pretty convincing argument! I tried to flesh out my Laurent-series definition a little, but it seems to be more painful to work with than I anticipated.</p>",
        "id": 393526370,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695830934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> I was actually planning to define meromorphic functions using sheaf theory (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopCat.Presheaf.totalQuotientPresheaf#doc\">docs#TopCat.Presheaf.totalQuotientPresheaf</a> in particular) -- my current PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/7332\">#7332</a> is on the way to this.</p>",
        "id": 393532288,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695833045
    },
    {
        "content": "<p>This would be a definition in arbitrary dimension rather than just for <code>ℂ</code>, so maybe we should have both definitions and they should be proved equivalent on <code>ℂ</code>?</p>",
        "id": 393532444,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695833107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393489876\">said</a>:</p>\n<blockquote>\n<p>I’ve formalized complex manifolds and the Riemann sphere as part of the Mandelbrot work</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> I think I missed this earlier comment of yours.  What do you mean by having formalized complex manifolds?  (The definition has been in mathlib for many years.)</p>",
        "id": 393547772,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695838994
    },
    {
        "content": "<p>Where is it?  I mean writing down the analytic groupoid and things like HolomorphicAt (a manifold version of AnalyticAt).  It’s not hard on top of the existing manifold machinery, to be clear: <a href=\"https://github.com/girving/ray/blob/main/src/complex_manifold.lean\">https://github.com/girving/ray/blob/main/src/complex_manifold.lean</a></p>",
        "id": 393549153,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695839489
    },
    {
        "content": "<p>I could have just used smooth manifolds, but I believe they are only equivalent in finite dimensions.  Admittedly that’s all I need, but I thought I might as well write down the single file with the analytic groupoid.</p>",
        "id": 393549906,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695839762
    },
    {
        "content": "<p>Oh, I see.  We should really decide whether our development of complex manifolds is going to take place in the <code>ℂ</code>-smooth setting or the <code>ℂ</code>-analytic setting, given that they are mathematically equivalent.  I have been working so far in the  <code>ℂ</code>-smooth setting, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MDifferentiable.exists_eq_const_of_compactSpace#doc\">docs#MDifferentiable.exists_eq_const_of_compactSpace</a></p>",
        "id": 393549996,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695839792
    },
    {
        "content": "<p>I suppose I would say that you formalized <em>analytic</em> manifolds :)</p>",
        "id": 393550292,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695839920
    },
    {
        "content": "<p>I’m happy to adjust, but regardless of what we use for the manifold type classes I think having the equivalent of AnalyticAt is valuable.  The relationship of pointwise vs. global for differentiable vs. analytic is quite different.</p>\n<p>And yeah, if we do think having analytic manifolds as a separate type class is useful, happy to change the name.  We can also define suitable finite dimensionality type classes, and make the type classes cleanly interconvert.</p>",
        "id": 393550688,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695840104
    },
    {
        "content": "<p>I'm also very happy to have the ability to talk about <em>real</em> analytic manifolds!</p>",
        "id": 393550785,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695840137
    },
    {
        "content": "<p>Should we also correct the name here? :)</p>\n<p><a href=\"https://en.m.wikipedia.org/wiki/Complex_manifold\">https://en.m.wikipedia.org/wiki/Complex_manifold</a></p>\n<p>I suppose they explicitly limit only to finite dimensions.</p>",
        "id": 393553161,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695841088
    },
    {
        "content": "<p>Sorry, I don't follow?</p>",
        "id": 393554299,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695841543
    },
    {
        "content": "<p>That’s why I called it ComplexManifold.</p>\n<p>(But I do agree that AnalyticManifold is better.)</p>",
        "id": 393556143,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695842348
    },
    {
        "content": "<p>I don't understand, sorry -- are you saying that you think there is a difference between the Wikipedia definition and the mathlib SmoothManifoldWithCorners \\C?</p>",
        "id": 393556498,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1695842500
    },
    {
        "content": "<p>(I think Geoffrey is arguing that <code>ComplexManifold</code> corresponds to Wikipedia's complex manifolds and that if you want to change one name you should also change the other)</p>",
        "id": 393557178,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695842785
    },
    {
        "content": "<p>But I’m not actually arguing that, just making a bad joke.  I think we should have AnalyticManifold in Mathlib given that it will cover arbitrary fields and infinite dimensions.</p>",
        "id": 393558291,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695843247
    },
    {
        "content": "<p>The analytic groupoid <a href=\"https://github.com/leanprover-community/mathlib4/pull/6386\">was recently merged into mathlib</a>! I see that a review was requested from <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> but she didn't leave one, maybe she didn't notice ...</p>",
        "id": 393608317,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1695872071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393522172\">said</a>:</p>\n<blockquote>\n<p>For what it's worth, I would use the naive definition from your first post (i.e., <code>f</code> is meromorphic on <code>U</code> if there exists a discrete set such that <code>f</code> is holomorphic on <code>U - P</code>, and <code>(z -p)^n f</code> extends continuously at <code>p</code> in <code>P</code> for some <code>n</code>), without caring about the specific value at <code>p</code>.</p>\n</blockquote>\n<p>I agree with this too, and I think it's important that we allow a discrete set of regular points where the value could differ from what it should be, so that we don't need to change the value at 0 when adding up 1+1/z and -1/z, for example. I think the situation is similar to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.AEEqFun#doc\">docs#MeasureTheory.AEEqFun</a>, but instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.ae#doc\">docs#MeasureTheory.Measure.ae</a> we use the filter of co-discrete sets; in higher dimensions you'd work with the filter of complements of sets that are locally a hypersurface (the zero set of a nonzero holomorphic function). The identity principle <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOn.eqOn_of_preconnected_of_frequently_eq#doc\">docs#AnalyticOn.eqOn_of_preconnected_of_frequently_eq</a> (and in higher dimension <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticOn.eqOn_of_preconnected_of_eventuallyEq#doc\">docs#AnalyticOn.eqOn_of_preconnected_of_eventuallyEq</a>) should facilitate working with functions up to equivalence under the filter (it's crucial that hypersurfaces have real codimension 2 so they don't disconnect a domain). Worth noting in higher dimensions meromorphic functions (which are locally quotients of ) don't necessarily correspond to maps to the Riemann sphere (for example z1/z2 is undefined at (0,0)), so that approach doesn't work. The sheaf approach still works and we should prove the equivalence.</p>",
        "id": 393615021,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1695876214
    },
    {
        "content": "<p>For what it's worth, my preferred way to discuss poles (I don't know if this is the best for formalization) is the following. First I prove Riemann's removable singularity theorem (if a function is holomorphic in <code>U-{p}</code> and bounded there, then it can be extended to a holomorphic function on <code>U</code>). Then: <code>f</code> has a pole at <code>p</code> if: it's holomorphic on <code>U-{p}</code>, and <code>1/f</code>has a removable singularity at <code>p</code> with value <code>0</code>. Thoughts on this approach? (Very down to earth... so probably not \"mathlib\"y...)</p>",
        "id": 393621295,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1695879631
    },
    {
        "content": "<p>The issue is how to add 1-1/z and 1/z, because whether you used infinity or a junk value for the value at 0 the sum of two of these values won't be 1.</p>\n<p>In the classical algebraic geometry theory of varieties one uses the concept of a rational map, which when I had to lecture this stuff myself I defined via equivalence classes of non-infinite-valued functions defined on dense open subsets and I remember at the time thinking how awful it would be to formalise. The concept of a sheaf of meromorphic functions is a thing and it has tripped up mathematicians in the past; the exposition in Hartshorne contains errors IIRC. But this way avoids infinity completely, functions are all defined on an unspecified dense open and you show afterwards that there's at most one finite correct answer for the value at any point</p>",
        "id": 393626999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695882182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393626999\">said</a>:</p>\n<blockquote>\n<p>The issue is how to add 1-1/z and 1/z, because whether you used infinity or a junk value for the value at 0 the sum of two of these values won't be 1.</p>\n</blockquote>\n<p>Indeed. But in principle, if along with the two functions <code>f1</code> and <code>f2</code> we had their set of poles <code>P1</code> and <code>P2</code> and the Laurent series at each pole, we could determine the set of poles of <code>f1 + f2</code> along with the Laurent series at each of these poles (a subset of <code>P1 \\cup P2</code>).</p>",
        "id": 393629017,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695883083
    },
    {
        "content": "<p>This would give a definition of the sum of two meromorphic functions and then one has to check that the sum of two holomorphic functions seen as meromorphic ones coincide with their sum as holomorphic functions (seen, again, as a meromorphic one).</p>",
        "id": 393629219,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695883171
    },
    {
        "content": "<p>Right, you're saying \"I desperately want to cling to the idea of a canonical representative\" but if you do this then things like proving associativity of addition will be a case split nightmare. I'm saying it's easier to work with the entire equivalence classes, where things are only defined up to some error set, like they do with Lp spaces and functions being ae equivalent.</p>",
        "id": 393634418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695884885
    },
    {
        "content": "<p>Examples where we cling to a canonical representative do exist in mathlib however. The rationals are defined as coprime pairs (n,d) with d&gt;0 and finsupp also carries around the explicit finite support of the function. But this is for computability reasons which I don't think apply here.</p>",
        "id": 393634909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695885055
    },
    {
        "content": "<p>If you define the rationals as equivalence classes then proving the basic API that they're a field is much much easier. It's just that addition of [1/2] and [1/2] will be [4/4] which upsets people who want to #eval everything (indeed quotients in general upset the #eval crowd precisely because there is no canonical representative which they can point to without having to continually run an algorithm to tame representatives). This is not an issue here because there's no need to make the theory computable.</p>",
        "id": 393635421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695885257
    },
    {
        "content": "<p>Point taken!</p>",
        "id": 393643472,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1695887870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393626999\">said</a>:</p>\n<blockquote>\n<p>The issue is how to add 1-1/z and 1/z, because whether you used infinity or a junk value for the value at 0 the sum of two of these values won't be 1.</p>\n</blockquote>\n<p>I think the issue is already to decide what value <code>1-1/z</code> would take at <code>z = 0</code>. If it takes the value <code>1</code> (because after all, <code>1 - 1/0 = 1 - 0 = 1</code> in Lean), then there is no problem at all with adding <code>1 - 1/z</code> and <code>1/z</code>.</p>",
        "id": 393662685,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695892931
    },
    {
        "content": "<p>If we give up on canonical representatives, then evaluating a meromorphic function at a point will become quite a bit more complicated. But maybe that is in fact still the way to minimize the global amount of pain when working with meromorphic functions.</p>",
        "id": 393662879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695893009
    },
    {
        "content": "<p>Why do you want to have a canonical representative, instead of many representatives? In measure theory, we have the space <code>𝓛^p</code> (the space of all functions whose norm is <code>p</code>-integrable), and the space <code>L^p</code> (the space of equivalence classes up to measures zero of such functions, which becomes a Banach space with a nice norm and so on). Most of the time, you work with regular functions in <code>𝓛^p</code> (although you know that, morally, they are only defined almost everywhere), and when you need to do functional analysis you switch to the equivalence classes <code>L^p</code>. And it works very well!</p>",
        "id": 393663920,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1695893397
    },
    {
        "content": "<p>One approach that we might take, in order to figure out the \"correct\" definition in Lean is to apply some top-down strategizing. As <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> pointed out, we already have examples of functions that should satisfy the <code>MeromorphicAt</code> predicate. So that more or less means that we'll work with functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C} \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> and a predicate on those.<br>\nNow if we write down a bunch of basic API lemmas that we want to be true, all proven by <code>sorry</code>, then we can try to start organizing them in a way shows which of them should be \"axioms\" (aka part of the definition of the predicate), and which one we can slickly derive from those more basic ones.</p>",
        "id": 393664171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695893478
    },
    {
        "content": "<p>Yeah, so we could have a <code>AEMeromorphicWithin</code> predicate. (I don't know if <code>AE</code> is really the right prefix...)</p>",
        "id": 393664667,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695893659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393664667\">said</a>:</p>\n<blockquote>\n<p>Yeah, so we could have a <code>AEMeromorphicWithin</code> predicate. (I don't know if <code>AE</code> is really the right prefix...)</p>\n</blockquote>\n<p>How is <code>AEMeromorphic</code> supposed to be different from <code>Meromorphic</code>?</p>",
        "id": 393717861,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695907775
    },
    {
        "content": "<blockquote>\n<p>e.g. with this definition the function \"f(x) = 1 if x = 0 and else 0\" is meromorphic at 0, which seems undesirable.</p>\n</blockquote>\n<p>This function would be <code>AEMeromorphic</code>, but I would hesitate to call it meromorphic.</p>",
        "id": 393719740,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695908104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393662685\">said</a>:</p>\n<blockquote>\n<p>I think the issue is already to decide what value <code>1-1/z</code> would take at <code>z = 0</code>. If it takes the value <code>1</code> (because after all, <code>1 - 1/0 = 1 - 0 = 1</code> in Lean), then there is no problem at all with adding <code>1 - 1/z</code> and <code>1/z</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393719740\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>e.g. with this definition the function \"f(x) = 1 if x = 0 and else 0\" is meromorphic at 0, which seems undesirable.</p>\n</blockquote>\n<p>This function would be <code>AEMeromorphic</code>, but I would hesitate to call it meromorphic.</p>\n</blockquote>\n<p>If you want <code>Meromorphic</code> to allow only the correct value at regular points, then multiplicativity <code>Meromorphic f → Meromorphic g → Meromorphic (f * g)</code> and <code>Meromorphic f → Meromorphic f⁻¹</code> are unachievable. Additivity is achievable (in dimension one) by allowing only the constant term of the Laurent expansion as the value at a pole (a convention which 1/z and 1-1/z conform to, but Gamma doesn't: compare <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.Gamma_zero#doc\">docs#Complex.Gamma_zero</a> with <a href=\"/user_uploads/3121/BnJUhekiBF2573vovZ8Prejb/image.png\">image.png</a>), but that seems to be too stringent a restriction without enough benefit (won't fix multiplicativity).</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/BnJUhekiBF2573vovZ8Prejb/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/BnJUhekiBF2573vovZ8Prejb/image.png\"></a></div>",
        "id": 393740958,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1695912258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Are you proposing that we make a definition <code>AEMeromorphic</code> but <em>not</em> <code>Meromorphic</code>? Or are you proposing to have both, and set things up so that each ae-eq class of <code>AEMeromorphic</code> functions has a unique <code>Meromorphic</code> representative (where ae = away from a discrete set)? The latter seems to bring us back to the problem we had at the start.</p>",
        "id": 393744223,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695913223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393662685\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393626999\">said</a>:</p>\n<blockquote>\n<p>The issue is how to add 1-1/z and 1/z, because whether you used infinity or a junk value for the value at 0 the sum of two of these values won't be 1.</p>\n</blockquote>\n<p>I think the issue is already to decide what value <code>1-1/z</code> would take at <code>z = 0</code>. If it takes the value <code>1</code> (because after all, <code>1 - 1/0 = 1 - 0 = 1</code> in Lean), then there is no problem at all with adding <code>1 - 1/z</code> and <code>1/z</code>.</p>\n</blockquote>\n<p>Well let me write the first one as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">(z-1)/z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> and then the problem is back.</p>",
        "id": 393772348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695922110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393744223\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> Are you proposing that we make a definition <code>AEMeromorphic</code> but <em>not</em> <code>Meromorphic</code>? Or are you proposing to have both, and set things up so that each ae-eq class of <code>AEMeromorphic</code> functions has a unique <code>Meromorphic</code> representative (where ae = away from a discrete set)? The latter seems to bring us back to the problem we had at the start.</p>\n</blockquote>\n<p>I think I'm leaning towards:</p>\n<ul>\n<li><code>AEMeromorphic</code> (and <code>AEMeromorphicWithin U</code>) are predicates on functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C} \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</li>\n<li><code>Meromorphic U</code> is a new type (so data, not a prop) that comes with a way to evaluate terms at regular points. It also comes with an instance of <code>CommRing</code>.</li>\n</ul>\n<p>I don't have a strong opinion on how <code>Meromorphic U</code> would be defined. It could be via a quotient using <code>AEMeromorphicWithin U</code>, or it could be a hands-on structure, or it could be using functions to the Riemann sphere.</p>",
        "id": 393849361,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695961260
    },
    {
        "content": "<p>It seems <code>AEMeromorphicWithin U</code> is also a CommRing, with an ideal of a.e. zero functions that you can quotient out to get the field <code>Meromorphic U</code> (if U is connected).</p>\n<p>And I just realized that the co-discrete subsets don't actually form a filter, because the union of two discrete subsets may not be discrete, for example S={1,1/2,1/3,...} and {0}. The correct filter in all dimensions should use the sets locally contained in zero sets of (locally) holomorphic functions, and the union of two zero sets is a zero set because you can take the product of the two holomorphic functions and the intersection of the neighborhoods on which they are defined. In one dimension, a simpler description of this filter is that it consists of complements of sets S such that every point p has a neighborhood whose intersection with S is either empty or {p}.</p>\n<p>If you don't use filters, you may get away with discrete subsets, because if there are infinitely many poles in around a point p then the function is <a href=\"https://math.stackexchange.com/questions/135458/limit-point-of-poles-is-essential-singularity-am-i-speaking-nonsense\">pathologic around p</a> and can't be meromorphic there.</p>",
        "id": 393861754,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1695967870
    },
    {
        "content": "<p>The complements of discrete <em>closed</em> subsets are a filter (in any non-discrete <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> space).</p>",
        "id": 393862672,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695968305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393861754\">said</a>:</p>\n<blockquote>\n<p>It seems <code>AEMeromorphicWithin U</code> is also a CommRing, with an ideal of a.e. zero functions that you can quotient out to get the field <code>Meromorphic U</code> (if U is connected).</p>\n</blockquote>\n<p>This is of course true (and is quite close to how <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>L</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">L^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> spaces already work in mathlib), but defining it this way you lose the ability to evaluate elements of <code>Meromorphic U</code> anywhere.</p>",
        "id": 393863190,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695968550
    },
    {
        "content": "<p>With my naming police hat on: Please please don't make <code>AESomeAdjective</code> a structure when <code>SomeAdjective</code> is a predicate, or the other way around.</p>",
        "id": 393864145,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695968935
    },
    {
        "content": "<p><code>Meromorphic U</code> wouldn't be a predicate, it would be bundled functions.</p>",
        "id": 393874499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695972418
    },
    {
        "content": "<p>Or is that what you are objecting against?</p>",
        "id": 393874561,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695972433
    },
    {
        "content": "<p>So you want <code>MeromorphicFunction U</code>? If I'm allowed to be a bit naughty... <code>Meromorphism U</code>?</p>",
        "id": 393874758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1695972479
    },
    {
        "content": "<p>Yes, that's exactly what I'm objecting about. Because then people will expect <code>AEMeromorphic</code> to be bundled functions, but it would be a predicate. I had <code>MeromorphicFun</code> in mind, but <code>Meromorphism</code> sounds even better.</p>",
        "id": 393876117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695972783
    },
    {
        "content": "<p>I am torn here between the beauty of the word \"meromorphism\" and the fact that we should stick to the language in the human literature, however noncanonical :-)</p>",
        "id": 393879908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1695974271
    },
    {
        "content": "<p>Meromorph, in analogy to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Homeomorph#doc\">docs#Homeomorph</a> :)</p>",
        "id": 393881599,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1695975013
    },
    {
        "content": "<p>Ah! I've always wanted to rename <code>Homeomorph</code> to <code>Homeo</code>.</p>",
        "id": 393882134,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695975262
    },
    {
        "content": "<p>As for naming: I'm not keen on <code>AEMeromorphic</code> for the predicate on functions (\"AE\" is too strongly suggestive of measure theory). I'd suggest <code>Quasimeromorphic</code> or something. </p>\n<p>For the bundled version I'd vote for <code>MeromorphicMap</code>, rather then <code>Meromorphism</code> (by analogy with <code>ContinuousMap</code>).</p>",
        "id": 393907625,
        "sender_full_name": "David Loeffler",
        "timestamp": 1695984804
    },
    {
        "content": "<p>But there wasn't any other option for <code>ContinuousMap</code>, right? <code>Continuism</code>?</p>",
        "id": 393909774,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695985650
    },
    {
        "content": "<p>Topologism?</p>",
        "id": 393910677,
        "sender_full_name": "Richard Copley",
        "timestamp": 1695986011
    },
    {
        "content": "<p>Topomorphism <a href=\"https://en.wikipedia.org/wiki/Interior_algebra#Topomorphisms\">is taken</a></p>",
        "id": 393911180,
        "sender_full_name": "Richard Copley",
        "timestamp": 1695986230
    },
    {
        "content": "<p><code>AEMeromorphic</code> is also bad because the true function is meromorphic everywhere.  I would expect <code>e^(1/z)</code> to be considered almost everywhere meromorphic.  The same issue applies to QuasiMeromorphic.</p>",
        "id": 393915109,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1695987946
    },
    {
        "content": "<p>Yeah I think there's no need to add <code>AE</code> to the name.<br>\n<a href=\"https://link.springer.com/chapter/10.1007/978-3-8348-8661-3_6\">This reference</a> looks nice:<br>\n<a href=\"/user_uploads/3121/wash3NzKMRE07MXN0bSteZa5/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wash3NzKMRE07MXN0bSteZa5/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wash3NzKMRE07MXN0bSteZa5/image.png\"></a></div>",
        "id": 394000949,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696019950
    },
    {
        "content": "<p>I don't think it's worth doing a bare-hands definition in several variables -- better to go straight to manifolds and the sheaf-y stuff.</p>",
        "id": 394001212,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1696020097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394000949\">said</a>:</p>\n<blockquote>\n<p>Yeah I think there's no need to add <code>AE</code> to the name.<br>\n<a href=\"https://link.springer.com/chapter/10.1007/978-3-8348-8661-3_6\">This reference</a> looks nice:<br>\n<a href=\"/user_uploads/3121/wash3NzKMRE07MXN0bSteZa5/image.png\">image.png</a></p>\n</blockquote>\n<p>That's not a good definition because it is not a priori local.<br>\nSame for meromorphic functions as fraction field of the homomorphic ones. <br>\n(Also, they would fail for non paracompact manifolds).</p>",
        "id": 394113842,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696108842
    },
    {
        "content": "<p>What's non-local about this definition? The definition of thin subsets is also local: <a href=\"/user_uploads/3121/H2OtRXMZMDrktjeCSMSSP8OO/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/H2OtRXMZMDrktjeCSMSSP8OO/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/H2OtRXMZMDrktjeCSMSSP8OO/image.png\"></a></div><blockquote>\n<p>Same for meromorphic functions as fraction field of the homomorphic ones. </p>\n</blockquote>\n<p>Of course there are many manifolds (e.g. the Riemann sphere) with many meromorphic functions but no nonconstant holomorphic functions. The plan is certainly to take the sheafification of the presheaf of FractionRings. (This doesn't work in general in the algebraic setting as pointed out in the <a href=\"https://www.e-periodica.ch/cntmng?pid=ens-001:1979:25::101\">misconceptions</a> paper, but in our setting a holomorphic function on an open set is a nonzerodivisor iff it's identically zero on none of the connected components, so nonzerodivisors restrict to nonzerodivisors and we indeed get a presheaf of FractionRings.)</p>\n<p>I also don't see why the definitions won't work for paracompact manifolds, but let me mention the interesting fact that a connected Hausdorff complex 1-manifold is automatically second-countable/paracompact, a <a href=\"https://en.wikipedia.org/wiki/Rad%C3%B3%27s_theorem_(Riemann_surfaces)\">theorem due to Tibor Radó</a>. This is not true in higher dimensions, and for real analytic 1-manifolds, as the <a href=\"https://mathoverflow.net/questions/404692/what-is-known-about-differentiable-and-analytic-structures-on-the-long-line-and\">long line admits real analytic structures</a>. (I learned this because I became curious whether the uniformization theorem requires second countability.)</p>",
        "id": 394120440,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696115774
    },
    {
        "content": "<p>Whatever the definition of thin, the fact that the definition requests a global thin set makes it nonlocal. A variant would ask, for every point, the existence of a neighborhood, a thin set there, etc.</p>\n<p>If you have this, to get a global thin set requires to take some union of the locally given thin sets,  which you can't say anything about unless the space is paracompact, because then you can refine the open covering to a locally finite one, etc.</p>",
        "id": 394160846,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1696142212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394000949\">said</a>:</p>\n<blockquote>\n<p>Yeah I think there's no need to add <code>AE</code> to the name.<br>\n<a href=\"https://link.springer.com/chapter/10.1007/978-3-8348-8661-3_6\">This reference</a> looks nice:<br>\n<a href=\"/user_uploads/3121/wash3NzKMRE07MXN0bSteZa5/image.png\">image.png</a></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> IMHO, the  problem with that definition is that it is <em>not</em> a predicate on functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">G \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</p>",
        "id": 394442865,
        "sender_full_name": "David Loeffler",
        "timestamp": 1696255719
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> Indeed, it is isn’t. But shouldn’t the definition of a meromorphic function on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> reflect the fact that in general it is <em>not</em> a function on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>?</p>",
        "id": 394443915,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1696255940
    },
    {
        "content": "<p>Isn't that begging the question a bit? The whole point of this thread was to decide which, among the many possible formalisations of the notion of \"meromorphic\", we should implement in mathlib.</p>",
        "id": 394444595,
        "sender_full_name": "David Loeffler",
        "timestamp": 1696256148
    },
    {
        "content": "<p>Yes, I know, I just haven’t given up yet <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 394444770,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1696256197
    },
    {
        "content": "<p>I thought we had decided to formalise two different notions in parallel – a \"bundled\" notion and a \"predicate on functions\" version – and <code>AEMeromorphic</code> was supposed to be the predicate version.</p>\n<p>I don't greatly care what it's called, and I agree with the remark that <code>AEMeromorphic</code> is probably a bad name; but I am very keen to have a definition which makes it meaningful to say e.g. \"the Gamma function is [quasi/ae/weakly/etc]-meromorphic\".</p>",
        "id": 394446348,
        "sender_full_name": "David Loeffler",
        "timestamp": 1696256613
    },
    {
        "content": "<p>Yes, you’re right, this seems to be the consensus, and I don’t have an issue with that <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span></p>",
        "id": 394446886,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1696256757
    },
    {
        "content": "<p>/poll How should we call functions that are meromorphic outside a \"small\" locus</p>\n<ul>\n<li>QuasiMeromorphic</li>\n<li>WeaklyMeromorphic</li>\n<li>PreMeromorphic</li>\n</ul>",
        "id": 394450655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696257765
    },
    {
        "content": "<p>I don't understand the question. Consider the function <code>f</code> equal to <code>1/z</code> on the unit disk, except at <code>0</code> where it is equal to <code>37</code>, and which is arbitrarily bad outside the unique disk. Would you use your predicate as <code>PremerormorphicOn f (ball 0 1)</code> here? And if the function is equal to <code>0</code> at <code>0</code>, would you like to promote it to <code>MeromorphicOn f (ball 0 1)</code>, or would the latter be kept for functions taking values in the Riemann sphere (and equal to infinity at the pole)?</p>",
        "id": 394454495,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1696258838
    },
    {
        "content": "<p>I think that one day someone will define something like a meromorphic function on a space without complex structure using a certain property of a meromorphic function. That will be more appropriate to be called a quasi-meromorphic function.</p>",
        "id": 394454664,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696258898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394454495\">said</a>:</p>\n<blockquote>\n<p>I don't understand the question. Consider the function <code>f</code> equal to <code>1/z</code> on the unit disk, except at <code>0</code> where it is equal to <code>37</code>, and which is arbitrarily bad outside the unique disk. Would you use your predicate as <code>PremerormorphicOn f (ball 0 1)</code> here? </p>\n</blockquote>\n<p>Yes, that is also unclear to me. <del>And if one wants to define a meromorphic function on <code>ball 0 1</code>, will it be necessary to also give its values outside the open unit ball?</del></p>\n<blockquote>\n<p>And if the function is equal to <code>0</code> at <code>0</code>, would you like to promote it to <code>MeromorphicOn f (ball 0 1)</code>, or would the latter be kept for functions taking values in the Riemann sphere (and equal to infinity at the pole)?</p>\n</blockquote>\n<p>I would say: only in the second case is the function promoted to <code>MeromorphicOn f (ball 0 1)</code>. But maybe I am not understanding what the consensus is this far.</p>",
        "id": 394456921,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1696259578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394442865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> IMHO, the  problem with that definition is that it is <em>not</em> a predicate on functions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">G \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>.</p>\n</blockquote>\n<p>I think it is if you existentially quantify over the thin set M? The definition says that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a holomorphic function on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∖</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">G\\setminus M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, but we can instead say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">f : G \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is holomorphic on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∖</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">G \\setminus M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and we don't care about its value outside of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 394459609,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696260339
    },
    {
        "content": "<p>In my opinion, <code>Meromorphic{X}</code> should be reserved for equivalence classes of \"premeromorphic{X} functions\". In particular, it will not be a predicate on honest functions. So</p>\n<blockquote>\n<p>the function <code>f</code> equal to <code>1/z</code> on the unit disk, except at <code>0</code> where it is equal to <code>37</code>, and which is arbitrarily bad outside the unique disk</p>\n</blockquote>\n<p>will be <code>PreMeromorphicOn f (ball 0 1)</code>, and if it is in fact <del><code>0</code></del> [edit: <code>1/z</code>] outside the disc (but still equal to <code>37</code> at <code>0</code>) then it will be <code>PreMeromorphic f</code>.</p>",
        "id": 394459675,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696260359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394459675\">said</a>:</p>\n<blockquote>\n<p>In my opinion, <code>Meromorphic{X}</code> should be reserved for equivalence classes of \"premeromorphic{X} functions\". In particular, it will not be a predicate on honest functions. So</p>\n<blockquote>\n<p>the function <code>f</code> equal to <code>1/z</code> on the unit disk, except at <code>0</code> where it is equal to <code>37</code>, and which is arbitrarily bad outside the unique disk</p>\n</blockquote>\n<p>will be <code>PreMeromorphicOn f (ball 0 1)</code></p>\n</blockquote>\n<p>Agreed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">and</span> <span class=\"k\">if</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"k\">in</span> <span class=\"n\">fact</span> <span class=\"bp\">`</span><span class=\"mi\">0</span><span class=\"bp\">`</span> <span class=\"n\">outside</span> <span class=\"n\">the</span> <span class=\"n\">disc</span> <span class=\"o\">(</span><span class=\"n\">but</span> <span class=\"n\">still</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"bp\">`</span><span class=\"mi\">37</span><span class=\"bp\">`</span> <span class=\"n\">at</span> <span class=\"bp\">`</span><span class=\"mi\">0</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"n\">it</span> <span class=\"n\">will</span> <span class=\"n\">be</span> <span class=\"bp\">`</span><span class=\"n\">PreMeromorphic</span> <span class=\"n\">f</span><span class=\"bp\">`.</span>\n</code></pre></div>\n<p>I don't think you meant that <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 394460052,
        "sender_full_name": "David Loeffler",
        "timestamp": 1696260479
    },
    {
        "content": "<p>Yes, you are right, I didn't mean that. Of course I meant <code>1/z</code> outside the disc. <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span> <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 394460412,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696260586
    },
    {
        "content": "<p>IMO <code>Meromorphic</code>/<code>MeromorphicOn</code> should be a predicate, and the bundled/equivalence class version could be called (as suggested before) <code>MeromorphicMap</code> or <code>Meromorph</code>.</p>",
        "id": 394461034,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696260756
    },
    {
        "content": "<p>Fair enough. But I would even think that we might have only a predicate <code>PreMeromorphic{X}</code> and a bundled <code>Meromorph{icMap}</code>. I'm not sure what the predicate <code>Meromorphic{X}</code> would be... (I can come up with definitions, but they don't seem to have a useful API.)</p>",
        "id": 394461638,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1696260937
    },
    {
        "content": "<p>Note that my <code>Meromorphic</code> is your <code>PreMeromorphic</code> (see my vote above). We could maybe define some <code>MaximallyMeromorphic</code> that is the <code>Meromorphic</code> that you have in mind (i.e. equals to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo>^</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\hat{f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1523em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9579em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span><span style=\"top:-3.2634em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.0833em;\"><span class=\"mord\">^</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>∖</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">G\\setminus P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∖</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> in the <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/394000949\">textbook definition</a>), but yes it's probably not very useful. If you already allow <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> be replaced by an arbitrary value, why not allow a thin set of finite values to be arbitrary as well?</p>",
        "id": 394467924,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1696262931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"514145\">Geoffrey Irving</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/393489876\">发言道</a>：</p>\n<blockquote>\n<p>I’ve formalized complex manifolds and the Riemann sphere as part of the Mandelbrot work</p>\n</blockquote>\n<p>Where is it in mathlib4? I am going to formalize hyperbolic surfaces, so I need the Riemann sphere.​</p>",
        "id": 395987248,
        "sender_full_name": "Wen Yang",
        "timestamp": 1696987474
    },
    {
        "content": "<p>^ It’s in a separate repo that I’ve just finished porting to Lean 4.  Will share in a couple days, and then I can start porting whatever pieces people want.  AnalyticManifold and the RiemannSphere might be a good place to start.</p>",
        "id": 396029708,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1697010420
    },
    {
        "content": "<p>^ And here's the thread about the Lean 4-ported repo: <a href=\"#narrow/stream/116395-maths/topic/Mandelbrot.20-.20Lean.204.20version/near/396156117\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Mandelbrot.20-.20Lean.204.20version/near/396156117</a></p>",
        "id": 396156304,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1697054130
    }
]