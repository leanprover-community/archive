[
    {
        "content": "<p>I think this is true if <code>classical</code> is not allowed to use, since you can't have a program which stops in a finite time and decides the equality of uncountably many elements. Is this correct? And this result cannot be proved inside Lean, right?</p>",
        "id": 453031500,
        "sender_full_name": "Jz Pan",
        "timestamp": 1721590449
    },
    {
        "content": "<p>There is a formalization of something equivalent to a Turing machine in the library, but how do you formally <em>state</em> your theorem without assuming that the type is countable? What's the input of a program that implements <code>DecidableEq</code>?</p>",
        "id": 453038812,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721595541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/116395-maths/topic/offtopic.3A.20.60DecidableEq.20.CE.B1.60.20implies.20.60.23.CE.B1.20.E2.89.A4.20.E2.84.B5.E2.82.80.60.3F/near/453031500\">said</a>:</p>\n<blockquote>\n<p>I think this is true if <code>classical</code> is not allowed to use, since you can't have a program which stops in a finite time and decides the equality of uncountably many elements. Is this correct? And this result cannot be proved inside Lean, right?</p>\n</blockquote>\n<p>I'm not sure how to prove that there isn't any quotient of <code>ℕ → ℕ</code>, for instance, with a decidable relation (when given the functions as oracles) but uncountably many equivalence classes</p>",
        "id": 453063450,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721615312
    },
    {
        "content": "<p>I figured out how: for any function <code>f</code> look at the execution of <code>rel f f</code>. If you only look at the values of <code>f</code> this computation queries, you get a function <code>f' : ℕ →₀ ℕ</code>. Now note that if <code>f' = g'</code> then surely <code>rel f g</code>, and because <code>ℕ →₀ ℕ</code> is countable there can only be a countable number of congruence classes.</p>",
        "id": 453064872,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721615942
    },
    {
        "content": "<p>I think you should be able to prove your statement using structural induction on <code>α</code>, then, but yeah, it couldn't be proven in Lean, as choice is consistent</p>",
        "id": 453065164,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721616067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/116395-maths/topic/offtopic.3A.20.60DecidableEq.20.CE.B1.60.20implies.20.60.23.CE.B1.20.E2.89.A4.20.E2.84.B5.E2.82.80.60.3F/near/453064872\">said</a>:</p>\n<blockquote>\n<p>I figured out how: for any function <code>f</code> look at the execution of <code>rel f f</code>. If you only look at the values of <code>f</code> this computation queries, you get a function <code>f' : ℕ →₀ ℕ</code>. Now note that if <code>f' = g'</code> then surely <code>rel f g</code>, and because <code>ℕ →₀ ℕ</code> is countable there can only be a countable number of congruence classes.</p>\n</blockquote>\n<p>Actually this can generalized to \"when you run the algorithm to decide <code>x = x</code> you can only check a part of <code>x</code> for which there are countably many options\"</p>",
        "id": 453090060,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721628474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/116395-maths/topic/offtopic.3A.20.60DecidableEq.20.CE.B1.60.20implies.20.60.23.CE.B1.20.E2.89.A4.20.E2.84.B5.E2.82.80.60.3F/near/453064872\">said</a>:</p>\n<blockquote>\n<p>If you only look at the values of <code>f</code> this computation queries, you get a function <code>f' : ℕ →₀ ℕ</code>.</p>\n</blockquote>\n<p>Yes that was what I thought. But I think this part cannot be formalized inside Lean...</p>",
        "id": 453109017,
        "sender_full_name": "Jz Pan",
        "timestamp": 1721635257
    },
    {
        "content": "<p>Not an expert, but I guess it is consistent to assume the implication as an axiom (in the absence of choice).<br>\nBut you can't <em>prove</em> the implication without axioms, exactly because it contradicts choice. If it were provable, then Lean + choice would be inconsistent.</p>",
        "id": 453117425,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1721637685
    },
    {
        "content": "<p>You can replace <code>DecidableEq</code> with something explicit involving turing machines, but I don't know how to do it without assuming that <code>α</code> is countable.</p>",
        "id": 453180506,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721656148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/offtopic.3A.20.60DecidableEq.20.CE.B1.60.20implies.20.60.23.CE.B1.20.E2.89.A4.20.E2.84.B5.E2.82.80.60.3F/near/453180506\">said</a>:</p>\n<blockquote>\n<p>You can replace <code>DecidableEq</code> with something explicit involving turing machines, but I don't know how to do it without assuming that <code>α</code> is countable.</p>\n</blockquote>\n<p>You could define Turing Machines with oracle access to a restricted part of Lean</p>",
        "id": 453212141,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721662908
    }
]