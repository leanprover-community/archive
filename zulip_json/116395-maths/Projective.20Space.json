[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I’m currently thinking about defining the following mathematical object:</p>\n<p>Given a (comm semi)ring R and a module M, and also an indexing set n, form the following subquotient:</p>\n<ol>\n<li>The full space is n -&gt; M, i.e. M^n.</li>\n<li>The subobject is n -&gt; M whose image spans M.</li>\n<li>Then quotient by the action defined by (Units R).</li>\n</ol>\n<p>And I have a few questions / statements:</p>\n<ol>\n<li>If we consider M across Pic R, we will recover P^n(R), so there is no generality that is lost here.</li>\n<li>I intentionally left out any invertibility assumption on M, or anything close to that.</li>\n<li>I propose to call this object <code>ProjCoords R M n</code> in mathlib4.</li>\n<li>We might want to do the quotient first and then prove that the condition respects the setoid; though on second thought maybe there is no difference.</li>\n<li>David, I think in the recent future I would want to refactor your current projective elliptic curve in mathlib using this new object. Maybe we will start with <code>ProjCoords R R (Fin 3)</code> first, before relaxing the second R to be M.</li>\n</ol>\n<p>What are your thoughts?</p>",
        "id": 524057860,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749899554
    },
    {
        "content": "<p>(I basically invented this object, so I don’t know if anyone else has done it before, and if it already has a name in the literature.)</p>",
        "id": 524057902,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749899608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524057860\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> I’m currently thinking about defining the following mathematical object:</p>\n<p>Given a (comm semi)ring R and a module M, and also an indexing set n, form the following subquotient:</p>\n<ol>\n<li>The full space is n -&gt; M, i.e. M^n.</li>\n<li>The subobject is n -&gt; M whose image spans M.</li>\n<li>Then quotient by the action defined by (Units R).</li>\n</ol>\n<p>And I have a few questions / statements:</p>\n<ol>\n<li>If we consider M across Pic R, we will recover P^n(R), so there is no generality that is lost here.</li>\n<li>I intentionally left out any invertibility assumption on M, or anything close to that.</li>\n<li>I propose to call this object <code>ProjCoords R M n</code> in mathlib4.</li>\n<li>We might want to do the quotient first and then prove that the condition respects the setoid; though on second thought maybe there is no difference.</li>\n<li>David, I think in the recent future I would want to refactor your current projective elliptic curve in mathlib using this new object. Maybe we will start with <code>ProjCoords R R (Fin 3)</code> first, before relaxing the second R to be M.</li>\n</ol>\n<p>What are your thoughts?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> had/has an M4R student working on Grasmannians, maybe projective space should be obtained as a specialization of this. But I don't know how close that code is to PR-ready (or what the eventual conclusion of this project was).</p>",
        "id": 524059877,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749901877
    },
    {
        "content": "<p>I assume <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Projectivization#doc\">docs#Projectivization</a> is the wrong thing here?</p>",
        "id": 524061604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749903594
    },
    {
        "content": "<p>Yes that only works for division rings</p>",
        "id": 524063732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906033
    },
    {
        "content": "<p>To be honest it could probably be beefed up for general rings but then it will be harder to use for fields</p>",
        "id": 524063904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906226
    },
    {
        "content": "<p>I would hesitate to start refactoring elliptic curves though. Our definition is already wrong and changes that you suggest won't make it right, they'll just make it less wrong. Our current definition is fine for fields (less general than rings)  and what we really want is a definition which works for schemes (more general than rings), so it's not clear to me who you're actually helping if you tinker with the definition which we essentially accidentally have for rings (I say accidentally because in some sense it's an accident that it type checks, it's the wrong definition in general as I explain in great detail in docstrings)</p>",
        "id": 524064103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906423
    },
    {
        "content": "<p>Note that there was a <a href=\"#narrow/channel/116395-maths/topic/thoughts.20on.20elliptic.20curves/near/384147037\">similar proposal here about two years ago</a></p>",
        "id": 524064119,
        "sender_full_name": "David Ang",
        "timestamp": 1749906443
    },
    {
        "content": "<p>Personally I don't like the current API for projective coordinates in elliptic curves in terms of <code>Fin 3 -&gt; R</code> + nonsingular condition, and I proposed <a href=\"https://github.com/leanprover-community/mathlib4/pull/24593\">#24593</a> to change this into <code>R x R x R</code> + nonsingular condition <a href=\"#narrow/channel/116395-maths/topic/thoughts.20on.20elliptic.20curves/near/516027611\">so that more things are defeq</a>. What you're proposing is to change this into <code>Fin n -&gt; R</code> + image spans <code>R</code> + nonsingular condition, which is going to revert that PR. Unless you have a way of maintaining the defeqs from <code>R x R x R</code> without adding a tonne of extra rewrites, I would much rather have something like <code>R x R x R</code> + image spans <code>R</code> + nonsingular condition.</p>\n<p>Note that the nonsingular condition implies that the image spans <code>R</code>, but I'm happy for this to be added (e.g. it allows <code>Jacobian.comp_equiv_comp</code> to be written without the nonsingular condition, since this is true for any weighted projective coordinates). Note that I am strongly inclined to keep the Jacobian and projective coordinates API essentially identical (which helps with maintenance immensely), so you'd need to define a weighted version of <code>ProjCoords</code> if you want to do the refactor.</p>",
        "id": 524064671,
        "sender_full_name": "David Ang",
        "timestamp": 1749907114
    },
    {
        "content": "<p>But otherwise I'm all for your proposal - why don't you redefine <code>Projectivization</code> to be this rather than calling it <code>ProjCoords</code>?</p>",
        "id": 524064743,
        "sender_full_name": "David Ang",
        "timestamp": 1749907201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> When Kevin Buzzard mentioned it to me, I thought that we could have both and then some relation between them. I don’t know what the general philosophy here, I thought that having a more special thing vs a more general thing generally shouldn’t be a conflict because different degrees of generalisation could have different uses. For example, a mathematician would see Fin 2 -&gt; R and R x R to be the same object, but for mathlib I think we definitely want to be able to write both Fin n -&gt; R and also R x R.</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what I’m proposing here would seem to me to be “one more step in the right direction”. For example, as I’ve mentioned, the functor represented by P^n(R) could be seen as the disjoint union of my objects <code>ProjCoords R M n</code> across <code>M : Pic (R)</code>. So, similarly, given a cubic for a ring (I know it doesn’t always exist), the correct E(R) would also be a disjoint union of the refactored points.</p>\n<p>Taking a step back, would you agree that it would be a good idea to have my proposed object even if I don’t refactor elliptic curves using it?</p>\n<p><span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> there might be a general point to be made on how much we rely on defeq, but perhaps that’s a discussion for another day. I’ll look into your linked PR later to get more information.</p>\n<p>What if we made a “power type” so that R ^ 3 is defeq to R x R x R? This might be useful to have in general, and I think this might even be a good step in general and we could develop this a lot to be used in way larger generality? I feel like we haven’t paid enough attention to the low dimensional cases and we’ve just taken Fin n -&gt; R as axiom.</p>\n<p>As another alternative, what if both versions coexist? Then you would keep your Projective folder, and I would have a new folder ProjCoords?</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> You might be in a better position to answer my question above. This is also related to Projectivisation. In general, do you think it’s a better idea to have different degrees of generality coexisting, or to define just the most general thing and then keep specialising?</p>",
        "id": 524069408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749912211
    },
    {
        "content": "<p>I don't understand why you want <code>R ^n</code> at all here rather that a general vector space / free module</p>",
        "id": 524070692,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749913624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524063904\">said</a>:</p>\n<blockquote>\n<p>To be honest it could probably be beefed up for general rings but then it will be harder to use for fields</p>\n</blockquote>\n<p>Should I take it that this means that simply replacing <code>Field</code> with <code>Ring</code> gives the wrong generalization?</p>",
        "id": 524072543,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749915814
    },
    {
        "content": "<p>Yeah, you have to replace \"vector isn't zero\" with \"ideal generated by the coefficients of the vector is the entire ring\" which is more annoying to deal with</p>",
        "id": 524073955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749917352
    },
    {
        "content": "<p>I don't think the definition uses \"vector isn't zero?</p>",
        "id": 524074443,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749918032
    },
    {
        "content": "<p>Does it not?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The setoid whose quotient is the projectivization of `V`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">projectivizationSetoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">orbitRel</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">ˣ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The projectivization of the `K`-vector space `V`.</span>\n<span class=\"sd\">The notation `ℙ K V` is preferred. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Projectivization</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">projectivizationSetoid</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 524074477,
        "sender_full_name": "David Ang",
        "timestamp": 1749918090
    },
    {
        "content": "<p>I think it's a bad idea to have two (equally weighted) projective coordinates for elliptic curves! Why would we ever need two?</p>",
        "id": 524074563,
        "sender_full_name": "David Ang",
        "timestamp": 1749918192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524070692\">said</a>:</p>\n<blockquote>\n<p>I don't understand why you want <code>R ^n</code> at all here rather that a general vector space / free module</p>\n</blockquote>\n<p>when you unfold all of the definitions etc. then the object actually has very little do with M^n (in the notation of my original exposition); it's really to do with \"n elements in M\" that satisfy certain properties etc.</p>",
        "id": 524075214,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749918978
    },
    {
        "content": "<p>(yes, in the case of M := R, then it does have to do with R^n, but that's the wrong generalisation)</p>",
        "id": 524075338,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749919172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524070692\">said</a>:</p>\n<blockquote>\n<p>I don't understand why you want <code>R ^n</code> at all here rather that a general vector space / free module</p>\n</blockquote>\n<p>I do want to explicitly control the \"dimension\" here as well. As I've mentioned above, the correct model for <code>P^n(R)</code> is <code>Σ M : Pic (R), ProjCoords R M n</code>. Note how <code>n</code> is explicit there and corresponds to the subscript <code>n</code> in <code>P^n</code>.</p>",
        "id": 524076085,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749920301
    },
    {
        "content": "<p>and yeah I also want to control the module <code>M</code> explicitly.</p>",
        "id": 524076097,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749920314
    },
    {
        "content": "<p>so I'm not advocating to \"projectivise\" an arbitrary (free or not) module, that's the wrong generalisation</p>",
        "id": 524076117,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749920337
    },
    {
        "content": "<p>It's a bit hard in general to gauge the consensus of the community because people don't tend to reply in concrete terms. Without the consensus, then I can't make sure that after I spend time working on this new object, people won't just say \"but like why would you make this object?\", and we all know how long PR's can take.</p>\n<p>To summarise, I propose to define the object <code>ProjCoords R M n</code> where <code>R</code> is a (comm semi)ring, <code>M</code> is a module over <code>R</code>, and <code>n</code> is an arbitrary indexing type. It will be a subquotient of <code>n -&gt; M</code>, namely take <code>{ f : n -&gt; M | image of f spans M }</code>, and then quotient by the natural action by <code>Units R</code>.</p>\n<p>So, with that in mind, could people react to this message with an indication of their opinion?</p>\n<ul>\n<li><span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> I would be happy to see this object in Mathlib4.</li>\n<li><span aria-label=\"thumbs down\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"thumbs down\">:thumbs_down:</span> I would not want to see this object in Mathlib4.</li>\n<li><span aria-label=\"hammer and wrench\" class=\"emoji emoji-1f6e0\" role=\"img\" title=\"hammer and wrench\">:hammer_and_wrench:</span> I would propose some modifications (please specify, including change of name).</li>\n</ul>",
        "id": 524090763,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749939925
    },
    {
        "content": "<p>I would be happy to see this object in Mathlib4 if it replaces <code>Projectivization</code></p>",
        "id": 524090813,
        "sender_full_name": "David Ang",
        "timestamp": 1749940014
    },
    {
        "content": "<p>What is the point of fixing <code>M</code>? If I've understood correctly, when <code>Pic(R)</code> is non-trivial, and <code>M</code> is in <code>Pic(R)</code> then <code>ProjCoords R M n</code> will be a subset of <code>P^n(R)</code>. Why are we interested in this subset for say <code>M</code> non-isomorphic to <code>R</code>?</p>",
        "id": 524091592,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749941238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> Earlier I expressed hesitation of replacing <code>Projectivization</code> with the reason of \"maybe we want general things and specialised cases to co-exist\". Now I actually come with a very strong reason of why these two objects are not compatible.</p>\n<p>Firstly, <code>Projectivization K V</code> works with an arbitrary module over a division ring. The lack of commutativity might be a concern, I haven't really thought about it, maybe we can make my object work without commutativity as well.</p>\n<p>Secondly, <code>V</code> is not given a basis. To say that it is equivalent to an instance of my <code>ProjCoords R R n</code> (I'm assuming you want <code>M := R</code> here), you're essentially choosing a basis. While there might be a short convenient idiom to do so, this transformation is highly non-canonical. I searched <a href=\"https://loogle.lean-lang.org/?q=Projectivization\">Projectivization</a> on Loogle, and there are certainly some results that can be transformed this way, such as those that involve <code>Fin 3</code>, but there are also results that cannot. The strongest example here is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Projectivization/Subspace.html#Projectivization.Subspace\">Projectivization.Subspace</a>, which just does not have an (easy) equivalent. (you could probably cook up an equivalent definition such as maybe <code>ProjCoords R R m</code> injecting into <code>ProjCoords R R n</code>, but that feels \"different\" and is not actually a more general definition).</p>\n<p>(The same reason is why we can't just teach linear algebra using matrices, because you'll naturally run into subspaces like { (x,y,z) | x+y+z=0 } which is not canonically isomorphic to K^2.)</p>\n<p>And thirdly, I've kept the strongest reason to the last: it actually breaks if <code>dim V</code> is aleph-0! My <code>ProjCoords K K n</code> corresponds to <code>Projectivization K (n -&gt; K)</code>, and it's actually a theorem that direct products of <code>K</code> never have dimension aleph-0. This means that if <code>V</code> has dimension aleph-0, then there is no <code>n</code> such that <code>ProjCoords K K n</code> is equivalent to <code>Projectivization K V</code>!</p>\n<p>(This is also making me wonder about what scheme would naturally correspond to <code>ℕ →₀ K</code>. Maybe we can build an \"affine space with finite support\"? Anyway, this is a topic for another discussion.)</p>",
        "id": 524091623,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749941286
    },
    {
        "content": "<p>(continuing my comment above). Wouldn't you want to treat all <code>M</code> (in <code>Pic(R)</code> for now) at the same time, so that you get <code>ProjCoords R n</code> consisting of tuples <code>(M, n-&gt;M)</code> where the second factor satisfied your condition from before.</p>",
        "id": 524091785,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749941499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524091592\">said</a>:</p>\n<blockquote>\n<p>What is the point of fixing <code>M</code>? If I've understood correctly, when <code>Pic(R)</code> is non-trivial, and <code>M</code> is in <code>Pic(R)</code> then <code>ProjCoords R M n</code> will be a subset of <code>P^n(R)</code>. Why are we interested in this subset for say <code>M</code> non-isomorphic to <code>R</code>?</p>\n</blockquote>\n<p>I suppose there is a bigger point here to be made. Let's say we want to talk about the scheme <code>GL_n</code>, and I give you an explicit definition right now (it's <code>Spec ℤ[a11, ..., ann, 1/Det(aij)]</code>). Are we done here? In my personal philosophy (I don't know if this aligns with Mathlib's philosophy), I would say that we are not done, and we would actually want to construct <code>GL_n(R)</code> separately first (functor <code>CommRing ⥤ Grp</code>), and then prove that the scheme <code>GL_n</code> represents the functor <code>GL_n(R)</code>.</p>\n<p>(There's actually an extra bonus point that comes with first defining the functor, because we get a cogroup structure for free on that big explicit ring.)</p>\n<p>So in the same vein, I would also want to construct the functor explicitly first, and then prove that <code>P^n</code> represents the functor. In this case, the functor is just the disjoint union of <code>ProjCoords R M n</code> across <code>M : Pic R</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524091785\">said</a>:</p>\n<blockquote>\n<p>(continuing my comment above). Wouldn't you want to treat all <code>M</code> (in <code>Pic(R)</code> for now) at the same time, so that you get <code>ProjCoords R n</code> consisting of tuples <code>(M, n-&gt;M)</code> where the second factor satisfied your condition from before.</p>\n</blockquote>\n<p>Then we can't talk about other invertible modules that happen to not be (definitionally) equal to terms of <code>Pic R</code>. My personal philosophy here is that I would want to split things into more steps, with smaller objects in each step, and also in greater generality.</p>",
        "id": 524091906,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749941645
    },
    {
        "content": "<p>Okay I think your second point is good :)</p>",
        "id": 524092058,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749941918
    },
    {
        "content": "<p>Although could you not just rephrase it in a more general way? Like as pairs <code>(M, n-&gt;M)</code> such that we have <code>[IsInvertible M]</code> (I dont know if this class exists)?</p>",
        "id": 524092213,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749942144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524092213\">said</a>:</p>\n<blockquote>\n<p><code>[IsInvertible M]</code> (I dont know if this class exists)?</p>\n</blockquote>\n<p>All part of the ongoing PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25337\">#25337</a> (please review!)</p>",
        "id": 524092385,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524092213\">said</a>:</p>\n<blockquote>\n<p>Although could you not just rephrase it in a more general way? Like as pairs <code>(M, n-&gt;M)</code> such that we have <code>[IsInvertible M]</code> (I dont know if this class exists)?</p>\n</blockquote>\n<p>Then that statement you're implicitly referring to is false. You must take isomorphism classes to produce the correct functor represented by <code>P^n</code>.</p>",
        "id": 524092407,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749942434
    },
    {
        "content": "<p>Okay good point. But let me ask: what do you expect to gain from this definition for rings with non-trivial picard group which can't be achieved with the more general notion of surjective maps from some fixed free module <code>V</code> of rank <code>n</code> to an invertible module <code>M</code> (all up to isomorphism)</p>",
        "id": 524092530,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749942649
    },
    {
        "content": "<p>Just adding my voice to say I don't see any benefit of specifying the invertible quotient module explicitly.</p>",
        "id": 524092581,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1749942766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524092530\">said</a>:</p>\n<blockquote>\n<p>Okay good point. But let me ask: what do you expect to gain from this definition for rings with non-trivial picard group which can't be achieved with the more general notion of surjective maps from some fixed free module <code>V</code> of rank <code>n</code> to an invertible module <code>M</code> (all up to isomorphism)</p>\n</blockquote>\n<p>I'm not sure what the domain of you \"all up to isomoprhism\" is. I'll assume that it's the correct one, i.e. isomorphism on M. I'm not sure if your definition is more general, because in mine I did not even assume <code>M</code> is invertible (or in fact any condition at all), <code>M</code> is an arbitrary module.</p>\n<p>I'm also not sure what you gain by letting the indexing <code>n -&gt; M</code> be replaced with free module of rank <code>n</code>. (Let's also repeat that you'd have to be more careful if <code>n</code> is infinite)</p>",
        "id": 524092973,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749943450
    },
    {
        "content": "<p>and I've basically made it more explicit. I've implicitly used the result that End(M,M) = R for any invertible module M, so I've skipped directly to <code>Units R</code> as the group acting on the subset.</p>",
        "id": 524092996,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749943500
    },
    {
        "content": "<p>I consider <code>Units R</code> to be more explicit and user-friendly than \"up to isomorphism\"</p>",
        "id": 524093017,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749943522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"630477\">Scott Carnahan</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524092581\">said</a>:</p>\n<blockquote>\n<p>Just adding my voice to say I don't see any benefit of specifying the invertible quotient module explicitly.</p>\n</blockquote>\n<p>which point are you replying to?</p>",
        "id": 524094513,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749946324
    },
    {
        "content": "<p>Sorry I was unclear. I don't know how things work in the noncommutative or semiring settings, but for commutative rings <code>R</code>, EGA II Prop 4.2.3 says that if you have an <code>R</code>-module <code>N</code>, the <code>A</code>-points of its projectivization are equivalence classes of <code>A</code>-linear surjections <code>N ⊗ A → L</code> where <code>L</code> is locally <code>A</code>-free of rank 1, and equivalence is by isomorphisms of invertible modules commuting with the surjections. When we want the usual <code>P^n</code>, we set <code>N</code> to be free of rank <code>n+1</code>.</p>\n<p>The definition of <code>ProjCoords</code> given here doesn't directly correspond with this: we are varying both the source module (taking <code>M^(n+1)</code> instead of fixing <code>R^(n+1)</code>) and the target. Also, I haven't seen any situations in the literature where people use a stratification of points by choosing a particular invertible quotient (but this may just be my own ignorance since it is far from my main research focus).</p>",
        "id": 524102588,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1749959829
    },
    {
        "content": "<p>Yes projective space is a special case of Grassmannians and the underlying functor for these can all definitely be done in the way Scott suggests without ever taking a disjoint union over isomorphism classes of modules. The latter feels unnatural to me and it will be much easier to prove that the former is representable.</p>",
        "id": 524112052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749973472
    },
    {
        "content": "<p>It's all very elegantly explained in FGA (will try and remember to add link later) (edit: it's not FGA but <span class=\"user-mention\" data-user-id=\"638465\">@Ivan Farabella</span> and me found <a href=\"https://www.numdam.org/item/SHC_1960-1961__13_1_A8_0/\">https://www.numdam.org/item/SHC_1960-1961__13_1_A8_0/</a> very nice.</p>",
        "id": 524112154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749973603
    },
    {
        "content": "<p>Yes I think that my point is the following: it's nice to have a simpler description for projective space e.g. by quotienting by units instead of some more general automorphisms, but I have only ever seen these descriptions being used for local ring-valued points (and I think rarely outside the case of fields, which we already have). In the generality you are working in, I feel that one should just work with the object one actually wants (which is the Grassmannian). Also, it's definitely very useful to be in the case of a general vector space (and not just k^n) as sometimes you are interested in parametrizing rank 1 quotients of a certain vector space which might not come with a canonical basis.</p>",
        "id": 524114491,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749976367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> I know two or three places of proofs where one stratifies the projective space by the invertible ideal generated by a set projective coordinates. In all theses cases, the goal is to compute something associated to that projective space, number of points of bounded height, or description of the Kapranov zeta function, things like that, via a more concrete expression. This is how the class number appears in the computation for the residue of Dedekind's zeta function, at least in the classic, non-adelic, approach.</p>",
        "id": 524114725,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1749976640
    },
    {
        "content": "<p>There is a design question here. I can feel that people who use projective spaces of fields only wouldn't even want to thinks about invertible modules, and Mathlib could have <code>ProjectiveSpace</code> and <code>Scheme.ProjectiveSpace</code>, with an equality that would hold in particular cases only. Then it would be useful to have <code>TwistedProjectiveSpace J</code> where the projective coordinates generate a fixed ideal <code>J</code>, so that <code>ProjectiveSpace R</code> corresponds to <code>TwistedProjectiveSpace R</code>.</p>",
        "id": 524114879,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1749976859
    },
    {
        "content": "<p>It could make some sense to put more focus on complex numbers. Critically, nobody has done ℂP-∞ or complex grassmanians, and these classify vector bundles.</p>\n<p>In higher math, this analytic situation can 'stick to its guns' because of how GLₙ(ℂ) is the hub of characteristic class theory, in the integral cohomology<br>\nof which the Chern classes reside.</p>\n<p>The Thom class of the complex Grassmanian and its universal vector bundle, which classifies vector bundles of a fixed rank, is the universal characteristic class up to splitting.</p>\n<p>So it could be good to try complex Grassmanians.</p>",
        "id": 524115537,
        "sender_full_name": "Jeremy Ravenel",
        "timestamp": 1749977667
    },
    {
        "content": "<p>It certainly wouldn't hurt to have <code>ComplexProjectiveSpace</code> and <code>RealProjectiveSpace</code>, whatever initial definition they could be based on.</p>",
        "id": 524115769,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1749978006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"630477\">Scott Carnahan</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524102588\">said</a>:</p>\n<blockquote>\n<p>for commutative rings <code>R</code>, EGA II Prop 4.2.3 says that if you have an <code>R</code>-module <code>N</code>, the <code>A</code>-points of its projectivization are equivalence classes of <code>A</code>-linear surjections <code>N ⊗ A → L</code> where <code>L</code> is locally <code>A</code>-free of rank 1, and equivalence is by isomorphisms of invertible modules commuting with the surjections. When we want the usual <code>P^n</code>, we set <code>N</code> to be free of rank <code>n+1</code>.</p>\n<p>The definition of <code>ProjCoords</code> given here doesn't directly correspond with this: we are varying both the source module (taking <code>M^(n+1)</code> instead of fixing <code>R^(n+1)</code>) and the target.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"630477\">@Scott Carnahan</span> I think there is some misunderstanding here. <code>M^(n+1)</code> does not show up anywhere, or maybe, these two are equivalent. In the case of <code>P^n(R)</code> (so <code>A := R</code>), you set <code>N</code> to be <code>R^(n+1)</code>, and I fixed <code>L</code> here to be <code>M</code>, so your formula <code>N ⊗ A → L</code> becomes <code>R^(n+1) ⊗ R → M</code>, which is equivalent to the choice of <code>n+1</code> elements of <code>M</code>, which I am arguing here to be a much more explicit and much more <strong>usable</strong> definition.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524112052\">said</a>:</p>\n<blockquote>\n<p>Yes projective space is a special case of Grassmannians and the underlying functor for these can all definitely be done in the way Scott suggests without ever taking a disjoint union over isomorphism classes of modules. The latter feels unnatural to me and it will be much easier to prove that the former is representable.</p>\n</blockquote>\n<p>I understand that if you look at the statement \"isomorphism classes of surjections\" literally, it does not mention a disjoint union. But if you actually examine it, and if you want to make the object usable, isn't it the same as first taking isomorphism classes of the target, and then taking a disjoint union of surjections?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524114491\">said</a>:</p>\n<blockquote>\n<p>Yes I think that my point is the following: it's nice to have a simpler description for projective space e.g. by quotienting by units instead of some more general automorphisms, but I have only ever seen these descriptions being used for local ring-valued points (and I think rarely outside the case of fields, which we already have). In the generality you are working in, I feel that one should just work with the object one actually wants (which is the Grassmannian). Also, it's definitely very useful to be in the case of a general vector space (and not just k^n) as sometimes you are interested in parametrizing rank 1 quotients of a certain vector space which might not come with a canonical basis.</p>\n</blockquote>\n<p>That description is also used for Z because Z has trivialclass group.</p>\n<p>The Grassmannian is certainly nice, but I don't think it completely overshadows the usefulness of a separate P^n functor. In fact, if you read <a href=\"https://stacks.math.columbia.edu/tag/089R\">Grassmannians in Stacks Project</a>, the last lemma they proved is that G(n, n+1) = P^n, which means that in terms of \"formalisation\" (in their case, not using a computer), it might be useful to do both generalities, i.e. P^n and G(k, n), separately?</p>\n<p>After all, I don't think you would deny that P^n is by itself a very useful functor apart from being G(n, n+1)? (For example, P^2 itself is very useful as well, and elliptic curve is (locally) a closed subscheme of P^2). What I'm saying is, let's say I did do Grassmannians and it was in Mathlib4 right now. Then it would also be a goal to specialise that to P^n, right? So my point here is that the functor P^n is separately useful and should definitely be done, instead of saying \"it's just a special case of G(k,n) so it doesn't need to be done\". I hope I'm making sense here.</p>",
        "id": 524119914,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749982559
    },
    {
        "content": "<p>This situation is basically identical to the situation of <code>Polynomial</code> vs. <code>MvPolynomial</code>. The fact that <code>MvPolynomial</code> exists does not suddenly mean that <code>Polynomial</code> is useless (it's \"just\" MvPolynomial but indexed by PUnit), which I feel like is unfortunately an attitude that I'm getting from the discussion here...</p>",
        "id": 524120578,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749983135
    },
    {
        "content": "<p>I believe that P°n is important independent of Grassmannians. What I'm not at all clear about is your claim that introducing the disjoint union is a step in the right direction. I have been through the proof this year when supervising a lean MSc and I would say that in fact it's a step in the wrong direction because in the proof of representabity you never focus on the global isomorphism class of the module, you just use that it's locally free. So you are introducing what looks to be to be a spurious extra global stratification in your definition. In fact we never say \"isomorphism classes of surjections\" in the proof, we just say \"submodules such that the quotient has these properties\" so never get into isomorphism class hell at all. You're introducing the hell in a fundamental way with your proposal and it's not needed in the construction of the functor or the proof that it's representable.</p>",
        "id": 524120885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749983388
    },
    {
        "content": "<p>Thanks for the clarification.</p>\n<p>So, if I ask you what \"is\" P^n(Spec R) as a set, the correct answer would be the following?</p>\n<ol>\n<li>P^n(Spec R) is the following subquotient:</li>\n<li>The total space is <code>Submodule (R^n)</code>. (There is some unfortunate indexing issues here, which I will ignore for now)</li>\n<li>The sub-space is <code>{ S // _ ⧸ S is locally free of rank 1 }</code>.</li>\n<li>The quotient is by the equivalence relation <code>Nonempty (_ ⧸S₁ ≃ₗ[R] _ ⧸S₂)</code>.</li>\n</ol>\n<p>If you think this is the right direction, I'm very happy to do this. But I would still want to ask a question in my original direction: I think my more explicit construction, <strong>this time crucially I will not use M at all</strong>, is still useful for the case Cl(R)=1, specialised to the case of local rings, and also specialised to the case of fields. Would you agree that we should still build my original object but this time without mention of <code>M</code>? i.e. I propose <code>ProjCoords R n</code> this time, without the <code>M</code>.</p>\n<p>I'm still a bit torn here, I've accepted your point that we should not mention <code>M</code> at all, but I know that <code>Projectivization</code> exists in the library and is useful in its own right (again, different degrees of generality is useful), even though it's only correct for fields. I would argue that a wrong definition that happens to be correct for local rings, is also useful: for local rings the condition would say that one of the coordinates is a unit. For example, this could be useful for a DVR.</p>",
        "id": 524121777,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749984180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> (forgot to ping you in the original message)</p>",
        "id": 524121795,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749984195
    },
    {
        "content": "<p>I think <code>ProjCoords R n</code> seems reasonable!</p>",
        "id": 524122320,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749984736
    },
    {
        "content": "<p>Also i definitely agree that it is useful to have a specialized notation for P^n, I was only mentioning the Grassmannian since I thought your original definition would apply to give coordinates for that as well (since you could take <code>M</code> to be a vector bundle in particular), but now I realize that you specialize to only quotient by the units.</p>",
        "id": 524122534,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1749984957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524122320\">said</a>:</p>\n<blockquote>\n<p>I think <code>ProjCoords R n</code> seems reasonable!</p>\n</blockquote>\n<p>There's still a huge implementation question here, in all cases the quotient will be by <code>Units R</code>, this will never change. However, the definition of the subspace will change a lot:</p>\n<ul>\n<li>If <code>R</code> is a field, then the condition  is just <code>x ≠ 0</code>. This is how <code>Projectivization</code> is defined in Mathlib4.</li>\n<li>If <code>R</code> is a local ring, then the condition is <code>∃ i, IsUnit (x i)</code>. This is useful for example in a DVR.</li>\n<li>If <code>R</code> is a general ring with <code>Pic(R)=1</code>, then we get the most general definition, which is the one I proposed, where the condition says that the elements generate the whole ring.</li>\n</ul>",
        "id": 524123867,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749986360
    },
    {
        "content": "<p>so maybe the correct thing to do is to build the function <code>.mk</code>, <code>.mk'</code>, and <code>.mk''</code> for the three cases...</p>",
        "id": 524123888,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749986389
    },
    {
        "content": "<p>We won't have defeqs, and I can't predict the ramification of this. I believed that defeqs are overrated, but David Ang has a strong reason to believe otherwise.</p>",
        "id": 524123950,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749986453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524121777\">said</a>:</p>\n<blockquote>\n<p>So, if I ask you what \"is\" P^n(Spec R) as a set, the correct answer would be the following?</p>\n<ol>\n<li>P^n(Spec R) is the following subquotient:</li>\n<li>The total space is <code>Submodule (R^n)</code>. (There is some unfortunate indexing issues here, which I will ignore for now)</li>\n<li>The sub-space is <code>{ S // _ ⧸ S is locally free of rank 1 }</code>.</li>\n<li>The quotient is by the equivalence relation <code>Nonempty (_ ⧸S₁ ≃ₗ[R] _ ⧸S₂)</code>.</li>\n</ol>\n</blockquote>\n<p>No, there is no quotient at all. This is why it's much simpler. It's just the subspace. In fact your suggestion is just Pic again; over a field the quotients are all isomorphic, for example.</p>",
        "id": 524131164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749994211
    },
    {
        "content": "<p>cf P^1 over a field K is lines in K^2 = submodules of K^2 such that the quotient is 1-dimensional , no \"up to isomorphism\" needed.</p>",
        "id": 524131324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749994368
    },
    {
        "content": "<p><del>it would indeed be quite neat if we don't need quotients! (i said \"would\" here because i don't see why yet)</del></p>",
        "id": 524131459,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749994554
    },
    {
        "content": "<p>aha, i see where i went wrong, i forgot that the isomorphism has to commute with the surjection as well. now I see why we don't need quotient. this is very nice and neat!</p>",
        "id": 524132160,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749995505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> now I see why this is a nice object. It's very satisfying to not need to quotient. So what should the Mathlib4 name of this object be?</p>",
        "id": 524132199,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749995563
    },
    {
        "content": "<p>I suppose this construction can be immediately generalised to the grassmannians by replacing \"1\" with \"n-k\" (i really don't like this indexing)</p>",
        "id": 524132248,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749995634
    },
    {
        "content": "<p>can we do <code>Grassmannian k n</code> with docstring saying that this corresponds to <code>n-k n</code> lol</p>",
        "id": 524132265,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749995657
    },
    {
        "content": "<p>Aren't they isomorphic? ;-) (maybe not canonically though?)</p>",
        "id": 524137797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750001007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> there's no n-1 if n is infinite</p>",
        "id": 524138060,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001082
    },
    {
        "content": "<p><code>GrassmannianFunctor</code>? <code>ProjectiveSpaceFunctor</code>? The correct generality is probably a base scheme and a quasicoherent sheaf rather than an <code>n</code>.</p>",
        "id": 524138091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750001111
    },
    {
        "content": "<p>yes, the correct functor is probably typed Scheme^op =&gt; Set rather than Ring =&gt; Set...</p>",
        "id": 524138244,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001239
    },
    {
        "content": "<p>i don't know what the philosophy should be</p>",
        "id": 524138255,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001252
    },
    {
        "content": "<p>the correct generality is probably some machinery that takes in a functor Ring =&gt; Set that satisfies certain axioms, and outputs a smooth scheme <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 524138307,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001301
    },
    {
        "content": "<p>We should probably have both anyway (referring to Scheme^op =&gt; Set vs Ring =&gt; Set)</p>",
        "id": 524138411,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750001400
    },
    {
        "content": "<p>Note that Calle has done some of the key gluing machinery here IIRC</p>",
        "id": 524138447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750001424
    },
    {
        "content": "<p>What's the correct generalisation of the <code>n</code> that Kevin is referring to? As in, are we saying that given a quasi-coherent sheaf M on a scheme X, we can construct Grassmannian(M, k) as { N subsheaf M | M/N locally free rank k }?</p>",
        "id": 524138517,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001482
    },
    {
        "content": "<p>so i currently count 7 objects now... lol</p>",
        "id": 524138555,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001523
    },
    {
        "content": "<p>Yes although I don't know the conditions for when this is representable (you might have to force <code>M</code> to be a vector bundle?)</p>",
        "id": 524138565,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750001533
    },
    {
        "content": "<p>that's fine, it doesn't have to be representable to be a functor</p>",
        "id": 524138583,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001551
    },
    {
        "content": "<p>actually, i skipped some steps, let me try again</p>",
        "id": 524138647,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524138555\">said</a>:</p>\n<blockquote>\n<p>so i currently count 7 objects now... lol</p>\n</blockquote>\n<p>Yeah to me it seems we should have the Grassmannian on both the ring side and the scheme side (in this case maybe <code>ProjectiveSpace</code> could even be an abbrev). Then we should have something like you suggest <code>ProjectiveCoords</code> for explicit descriptions over fields/local rings/pic=1 rings.</p>",
        "id": 524138775,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750001682
    },
    {
        "content": "<p><code>S : Scheme</code>, <code>M : quasi-coherent sheaf on S</code> and <code>k : ℕ</code> , then we define the functor <code>Grassmannians {S} M k</code> with type <code>(Scheme/S)ᵒᵖ ⥤ Set</code> that sends the scheme <code>f : X ⟶ S</code> to the set <code>{ N subsheaf f⁻¹M | f⁻¹M ⧸ N locally free of rank k }</code>.</p>",
        "id": 524138862,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001763
    },
    {
        "content": "<p>is this correct?</p>",
        "id": 524138874,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524138775\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524138555\">said</a>:</p>\n<blockquote>\n<p>so i currently count 7 objects now... lol</p>\n</blockquote>\n<p>Yeah to me it seems we should have the Grassmannian on both the ring side and the scheme side (in this case maybe <code>ProjectiveSpace</code> could even be an abbrev). Then we should have something like you suggest <code>ProjectiveCoords</code> for explicit descriptions over fields/local rings/pic=1 rings.</p>\n</blockquote>\n<p>to be clear, when you said it's an abbrev, you're referring to <code>ProjectiveSpaceFunctor : Schemeᵒᵖ ⥤ Set</code> right? it's because I also made <code>ProjectiveSpace : Scheme</code></p>",
        "id": 524138971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001859
    },
    {
        "content": "<p>i'm also thinking about whether we want:</p>\n<ul>\n<li><code>HomogeneousCoords</code></li>\n<li><code>HomogeneousCoordinatess</code></li>\n<li><code>HomogCoords</code></li>\n<li><code>HomoCoords</code></li>\n<li><code>ProjCoords</code></li>\n<li><code>ProjectiveCoords</code></li>\n<li><code>ProjectiveCoordinates</code></li>\n</ul>",
        "id": 524139016,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750001907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524138447\">said</a>:</p>\n<blockquote>\n<p>Note that Calle has done some of the key gluing machinery here IIRC</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/AlgebraicGeometry/Sites/Representability.lean\">This</a> is what Kevin is referring to (and Joël also wrote it). Although I think it needs to be refactored at some point since now you can't immediately apply it if you're working on <code>Sch/S</code> for a base scheme <code>S</code>.</p>",
        "id": 524139531,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750002359
    },
    {
        "content": "<p>well... if the whole functor over Spec Z is representable then surely i can just take the product with S right</p>",
        "id": 524140206,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750002976
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> so, in summary:</p>\n<ol>\n<li>We want to build the functor <code>GrassmannianFunctorScheme</code> that has type <code>(Scheme/S)ᵒᵖ ⥤ Set</code>, given a quasi-coherent sheaf on S and <code>k : ℕ</code>. (perhaps a later goal)</li>\n<li>We want to build the functor  <code>GrassmannianFunctorRing</code> with type <code>R ↓ CommRing ⥤ Set</code>, given an R-module <code>M</code> and <code>k : ℕ</code>. Concretely, given <code>f : R ⟶ A</code>, the corresponding set is <code>{ N ≤ A ⊗[R] M | _ ⧸ N is locally free of rank k }</code>.</li>\n<li>Specialise 1 to projective (see 4).</li>\n<li>Specialise (with <code>abbrev</code>) 2 to <code>ProjectiveSpaceFunctorRing</code> with <code>M := (n → R)</code> and <code>k := 1</code>.</li>\n<li>Separately, build <code>ProjCoords R n</code> to be <code>{ f : n → R | range of f spans R } / Rˣ</code>, which mathematically is isomorphic to <code>ProjectiveSpaceFunctorRing R n</code> when Pic(R) = 1.</li>\n<li>Make a constructor for local rings, where the condition becomes <code>∃ i, IsUnit (f i)</code>.</li>\n<li>Make a constructor for fields, where the condition becomes <code>f ≠ 0</code>. And refactor <code>Projectivization</code> to use this whenever possible?</li>\n</ol>\n<p>And please suggest shorter names <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 524140853,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750003587
    },
    {
        "content": "<p>what's the advantage of using an arbitrary module in 2 instead of n -&gt; R?</p>",
        "id": 524140965,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750003669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524140965\">said</a>:</p>\n<blockquote>\n<p>what's the advantage of using an arbitrary module in 2 instead of n -&gt; R?</p>\n</blockquote>\n<p>Because what if you are interested in parametrizing rank k quotients of something with no canonical basis?</p>\n<p>Here is a very convoluted example: infinitesimal subgroups of an abelian scheme corresponds to submodules of the Lie algebra of the abelian scheme (or something like this). I am personally interested in parametrizing these, so now I want to consider the projectivization of this lie algebra (but it would be much more convoluted if I was forced to choose a basis here!). Maybe someone else has a very clever simple example.</p>",
        "id": 524141176,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750003873
    },
    {
        "content": "<p>Maybe with some choice of namespaces your names could become shorter (so the first 3 should just be <code>Grassmannian</code> and <code>ProjectiveSpace</code>). And also there should be notation in these namespaces anyways.</p>",
        "id": 524141514,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750004209
    },
    {
        "content": "<p>And in <code>3</code> there should be a version where you are able to choose which <code>M</code> to use. Maybe some nice notation could make both of these possible at once (so that P^n picks R^n for you, but you can also write <code>P(V)</code>).</p>",
        "id": 524141623,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750004349
    },
    {
        "content": "<p><code>ℙ^(n; R)</code> vs. <code>ℙ(V; R)</code>? I mean, whatever notation we choose, we'll also have to deal with namespace conflict, because the scheme <code>ProjectiveSpace : Scheme</code> should also use <code>ℙ^(n; R)</code>?</p>",
        "id": 524143002,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750005687
    },
    {
        "content": "<p>maybe <code>;</code> vs. <code>,</code>? this feels very evil</p>",
        "id": 524143007,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750005692
    },
    {
        "content": "<p>I think that the correct definition of \"projective morphism\" (ie the EGA one not the Hartshorne one) uses this generality (X-&gt;S is projective if it factors through P(M)-&gt;S where M is some general qc O_S-module or something?)</p>",
        "id": 524144983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750007788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524143002\">said</a>:</p>\n<blockquote>\n<p><code>ℙ^(n; R)</code> vs. <code>ℙ(V; R)</code>? I mean, whatever notation we choose, we'll also have to deal with namespace conflict, because the scheme <code>ProjectiveSpace : Scheme</code> should also use <code>ℙ^(n; R)</code>?</p>\n</blockquote>\n<p>I have sadly not kept up to date with all the recent AG developments, so someone else has a better reply here. But I'm not sure if we have figured out how to deal with the whole scheme vs functor of points situation. There might be a world where one wants to define something like <code>Scheme.HasFunctor</code> which contains a given functor that is naturally isomorphic to the functor obtained by yoneda. Then the notation could be <code>Scheme.functor</code> to access it or something like this. Then maybe the functor will be <code>ℙ(V; R).functor</code> but at the same time the notation <code>ℙ(V; R)</code> might mean only the functor in some other namespace(s) where its clear we only ever want to talk about the functor.</p>",
        "id": 524149814,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1750014234
    },
    {
        "content": "<p>This sounds nice, we can just have that notation today</p>",
        "id": 524151011,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750015580
    },
    {
        "content": "<p>My impression is that in the toric project they have some equivalence between affine group schemes and Hopf algebras so maybe they have some ideas? <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> ?</p>",
        "id": 524151907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750016656
    },
    {
        "content": "<p>Yes, we definitely have some ideas here. It's a bit of a hectic for us three, but soon there will be some detailed explanation on what we've done</p>",
        "id": 524152578,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1750017547
    },
    {
        "content": "<p>About the notation thing: My default answer would be just scope both and don't open them at the same time.</p>",
        "id": 524152819,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750017898
    },
    {
        "content": "<p><code>Scheme.HasFunctor</code> is a fun idea, but I would be inclined to pass around <code>Functor.RepresentableBy</code> for now unless this proves to be tedious and repetitive.</p>",
        "id": 524152903,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750018001
    },
    {
        "content": "<p>There's a subtle point here about infinite modules. Let's just consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msup><mo>=</mo><msub><mo>⨁</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R^{\\oplus \\mathbb{N}} = \\bigoplus_{n \\in \\mathbb{N}} R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8452em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1825em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>.</p>\n<p>We currently have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">A</mi><mi mathvariant=\"double-struck\">N</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{A}^\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8452em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span></span></span> whose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-points are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">\\prod_{n \\in \\mathbb{N}} R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0771em;vertical-align:-0.3271em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1825em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3271em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, which is perhaps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><msup><mi>R</mi><mrow><mo>⊕</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msup><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(R^{\\oplus \\mathbb{N}}, R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0952em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>?</p>\n<p>Then the grassmannian discussed above, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">P</mi><mi mathvariant=\"double-struck\">N</mi></msup><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"double-struck\">G</mi><mo stretchy=\"false\">(</mo><msup><mi>R</mi><mrow><mo>⊕</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msup><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{P}^\\mathbb{N}(R) = \\mathbb{G}(R^{\\oplus \\mathbb{N}}, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0952em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">P</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0952em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">G</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> is the \"hyperplanes\" of the module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R^{\\oplus \\mathbb{N}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8452em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span></span></span></span>.</p>\n<p>The subtle point here is that sometimes it comes up as a direct sum, and sometimes it comes up as a direct product. For example, the \"lines\" and the \"hyperplanes\" of the module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mrow><mo>⊕</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">R^{\\oplus \\mathbb{N}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8452em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8452em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span></span></span></span></span></span></span></span> are not equivalent!</p>",
        "id": 524196442,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750059867
    },
    {
        "content": "<p>On the point of taking dual: let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo>⊕</mo><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow></msub><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">A(M) = \\oplus_{n \\in \\mathbb{N}} M^{\\otimes n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9487em;vertical-align:-0.1774em;\"></span><span class=\"mord\"><span class=\"mbin\">⊕</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3322em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathbb mtight\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> be its... I tried to find the name but could not.</p>\n<p>Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">r</mi></mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mrow><mi mathvariant=\"normal\">S</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Spec}(A(M))(\\mathrm{Spec}(R)) = \\mathrm{Mor}(\\mathrm{Spec}(R), \\mathrm{Spec}(A(M)) = \\mathrm{Hom}(A(M), R) = \\mathrm{Hom}(M,R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">))</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Mor</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Spec</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> which indeed takes duals, a subtle point that is not clear when we only focused on free modules of finite rank.</p>",
        "id": 524204464,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750062558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> should we generalise AffineSpace to take a module?</p>",
        "id": 524204561,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750062590
    },
    {
        "content": "<p>Update: A(M) above should be Sym(M), we need to take symmetric quotient to make it commutative</p>",
        "id": 524311597,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750097880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524120578\">said</a>:</p>\n<blockquote>\n<p>This situation is basically identical to the situation of <code>Polynomial</code> vs. <code>MvPolynomial</code>. The fact that <code>MvPolynomial</code> exists does not suddenly mean that <code>Polynomial</code> is useless (it's \"just\" MvPolynomial but indexed by PUnit)</p>\n</blockquote>\n<p>Actually, it's not that…</p>",
        "id": 524354193,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1750121724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524091906\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524091592\">said</a>:</p>\n<blockquote>\n<p>What is the point of fixing <code>M</code>? If I've understood correctly, when <code>Pic(R)</code> is non-trivial, and <code>M</code> is in <code>Pic(R)</code> then <code>ProjCoords R M n</code> will be a subset of <code>P^n(R)</code>. Why are we interested in this subset for say <code>M</code> non-isomorphic to <code>R</code>?</p>\n</blockquote>\n<p>I suppose there is a bigger point here to be made. Let's say we want to talk about the scheme <code>GL_n</code>, and I give you an explicit definition right now (it's <code>Spec ℤ[a11, ..., ann, 1/Det(aij)]</code>). Are we done here? In my personal philosophy (I don't know if this aligns with Mathlib's philosophy), I would say that we are not done, and we would actually want to construct <code>GL_n(R)</code> separately first (functor <code>CommRing ⥤ Grp</code>), and then prove that the scheme <code>GL_n</code> represents the functor <code>GL_n(R)</code>.</p>\n<p>(There's actually an extra bonus point that comes with first defining the functor, because we get a cogroup structure for free on that big explicit ring.)</p>\n<p>So in the same vein, I would also want to construct the functor explicitly first, and then prove that <code>P^n</code> represents the functor. In this case, the functor is just the disjoint union of <code>ProjCoords R M n</code> across <code>M : Pic R</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524091785\">said</a>:</p>\n<blockquote>\n<p>(continuing my comment above). Wouldn't you want to treat all <code>M</code> (in <code>Pic(R)</code> for now) at the same time, so that you get <code>ProjCoords R n</code> consisting of tuples <code>(M, n-&gt;M)</code> where the second factor satisfied your condition from before.</p>\n</blockquote>\n<p>Then we can't talk about other invertible modules that happen to not be (definitionally) equal to terms of <code>Pic R</code>. My personal philosophy here is that I would want to split things into more steps, with smaller objects in each step, and also in greater generality.</p>\n</blockquote>\n<p>For the GL_n example I object to saying that you get the group structure for free. We currently have 2 APIs for getting group object instances on affine schemes: through a Hopf algebra structure or through Yoneda. If you do identify these two things as schemes you would also need to identify them as group schemes. This does not come for free.</p>",
        "id": 524427624,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750158930
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"548696\">@Michał Mrugała</span> Does the Hopf algebra structure not come from Yoneda?</p>",
        "id": 524428435,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750159186
    },
    {
        "content": "<p>You can recover a Hopf algebra structure from Yoneda, but you also want to be able to do computations with the Hopf algebra structrure. The instance you'll get with Yoneda won't have a nice form and you will need to show that it is the Hopf algebra structure you expect regardless.</p>",
        "id": 524428877,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750159337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548696\">Michał Mrugała</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524428877\">said</a>:</p>\n<blockquote>\n<p>you also want to be able to do computations with the Hopf algebra structrure. The instance you'll get with Yoneda won't have a nice form</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"548696\">@Michał Mrugała</span> I object to this claim. In fact, I have no idea how to compute any of the Hopf algebra structure (by hand), except via Yoneda.</p>",
        "id": 524430437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750159835
    },
    {
        "content": "<p>On paper I agree, but from my experience working with this in Lean I don't think what you get from just unfolding the definitions will be useable. Right now the way you get an instance through Yoneda is quite hacky. Me and <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> are currently working on formalizing SO2, so we can try and see if I'm wrong about this.</p>",
        "id": 524431309,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750160071
    },
    {
        "content": "<p>Also note that you can compute the Hopf algebra morphisms using the classical theory of linear algebraic groups without needing to go through Yoneda.</p>",
        "id": 524431766,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750160198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548696\">Michał Mrugała</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524431309\">said</a>:</p>\n<blockquote>\n<p>On paper I agree, but from my experience working with this in Lean I don't think what you get from just unfolding the definitions will be useable.</p>\n</blockquote>\n<p><code>unfold</code> is not the only way to solve a problem, it's sometimes also the worst way</p>",
        "id": 524432210,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750160338
    },
    {
        "content": "<p>I don't think the concrete description of the comultiplication map is a bad thing to have, so we should have it anyways.</p>",
        "id": 524432425,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750160400
    },
    {
        "content": "<p>Concretely: let's say you define GL_n(R) and show that it represents a group functor. This gives you a group scheme instance and recovers a Hopf algebra instance on its global sections. How do I write down the comultiplication or antipode of an element?</p>",
        "id": 524432521,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750160425
    },
    {
        "content": "<p>And then we should give the description of multiplication on the yoneda presheaf so that people can do the calculations in yoneda if they prefer.</p>",
        "id": 524432591,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750160446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548696\">Michał Mrugała</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/524432521\">said</a>:</p>\n<blockquote>\n<p>Concretely: let's say you define GL_n(R) and show that it represents a group functor. This gives you a group scheme instance and recovers a Hopf algebra instance on its global sections. How do I write down the comultiplication or antipode of an element?</p>\n</blockquote>\n<p>You do the computation you would on paper, and hope that Yoneda has enough API to translate that paper computation directly into Lean</p>",
        "id": 524432646,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750160462
    },
    {
        "content": "<p>I don't know what else to say than: until you can give me a proof of concept I remain very skeptical this works out. I don't believe the current API supports this and I don't know how you'd design one that does this. Maybe <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> can see how this would work?</p>",
        "id": 524433306,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750160691
    },
    {
        "content": "<p>I think you basically write some thing analogous to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Grp_Class.ofRepresentableBy#doc\">docs#Grp_Class.ofRepresentableBy</a> and things will work out fine.</p>",
        "id": 524433484,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1750160741
    },
    {
        "content": "<p>Also could I say that this does not feel very relevant to Projective Space, mainly because the Grassmannian basically has no structure (it's just a set)</p>",
        "id": 524433915,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750160877
    },
    {
        "content": "<p>Do I understand correctly that you'd want to have a representability statement when you turn it into a functor on algebras? I guess this would work, although you still need a compatibility API between schemes and algebras.</p>",
        "id": 524433968,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1750160896
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/26060\">#26060</a>: define Grassmannians G(M; R, k) of module over ring</p>",
        "id": 524613753,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750205922
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/26061\">#26061</a>: define ProjectiveSpace ℙ(n; S) as a scheme over a given scheme S with an arbitrary indexing type n</p>",
        "id": 524614596,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750206733
    },
    {
        "content": "<p>so i'm now returning to projective space and i have forgotten all of the previous conversation 4 months ago</p>",
        "id": 542513998,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759329703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> what would we want in projective space? should we copy the approach in affine space? or should we ignore that file?</p>",
        "id": 542514102,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759329730
    },
    {
        "content": "<p>do we want <code>S x Proj Z[n]</code>? do we want <code>Proj R[n]</code>? (<code>R[n]</code> means <code>MvPolynomial n R</code>)</p>",
        "id": 542514248,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759329777
    },
    {
        "content": "<p>do we want <code>Proj R[Fin n]</code>?</p>",
        "id": 542514359,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759329807
    },
    {
        "content": "<p>do we want to describe the functor? do we want the open cover by n charts?</p>",
        "id": 542514412,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759329819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/542513998\">said</a>:</p>\n<blockquote>\n<p>so i'm now returning to projective space and i have forgotten all of the previous conversation 4 months ago</p>\n</blockquote>\n<p>so I read through the conversation and they didn't seem very relevant so let's just start again</p>",
        "id": 542515889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759330193
    },
    {
        "content": "<p>note that in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26061\">#26061</a> I used <code>S x Proj Z[n]</code> just because <code>AffineSpace</code> did it that way, and <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> commented that he would want the isomorphism to <code>Proj R[n]</code> when <code>S = Spec R</code>, so now I'm thinking that we would want <code>Proj R[n]</code> anyway so why not do that first</p>",
        "id": 542516355,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759330294
    },
    {
        "content": "<p>I think in private communications <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> also noted that <code>n</code> and <code>S</code> should be in the same universe, so that's another point on which I should not blindly copy <code>AffineSpace</code></p>",
        "id": 542516604,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759330352
    },
    {
        "content": "<p>I don't think we want much API on Proj R[n], and only the ones necessary to establish the isomorphism (which I assume is none if it the iso is done in the generality of base changes of graded rings)</p>",
        "id": 542518392,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759330769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> how do you get the charts?</p>",
        "id": 542518853,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759330885
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.Proj.affineOpenCover#doc\">docs#AlgebraicGeometry.Proj.affineOpenCover</a></p>",
        "id": 542519080,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759330942
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> yes, but you still need the fact that R[n]_(X i)_0 is isomorphic to R[n without i]</p>",
        "id": 542520749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759331412
    },
    {
        "content": "<p>I don't get what you are trying to say. The fact you are describing is useful and we need it, but I don't see how it is related to the discussion about not needing API for <code>Proj R[n]</code>.</p>",
        "id": 542521994,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759331768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> firstly i'm asking about whether we want <code>S x Proj Z[n]</code> in the first place (which is the approach in <a href=\"https://github.com/leanprover-community/mathlib4/pull/26061\">#26061</a>), or if we just want to focus on <code>Proj R[n]</code>.</p>\n<p>Secondly, in any case, we would want an open cover of P^n by A^n (replace one n by n+1 or n-1), which means that after using your linked result, we would still need to make the isomorphism bewteen the homogeneous localization and the concrete mvpolynomial ring</p>",
        "id": 542523123,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759332080
    },
    {
        "content": "<p>your linked result is a cover by \"homogeneous localizations\", but I think we want a cover by \"spec of mvpolynomial\"</p>",
        "id": 542523301,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759332121
    },
    {
        "content": "<ol>\n<li>We want <code>ProjectiveSpace n R := S x Proj Z[n]</code> and not <code>Proj R[n]</code>.</li>\n<li>We want an open cover of <code>ProjectiveSpace n R</code> by <code>AffineSpace _ R</code> (Still no <code>Proj R[n]</code>).</li>\n</ol>",
        "id": 542523656,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759332202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> ok, but 2 still requires my isomorphism for Z</p>",
        "id": 542525319,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759332609
    },
    {
        "content": "<p>for 1, might I ask why? to be clear, the alternative definition I'm proposing is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ProjectiveSpaceAffine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 542525708,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759332708
    },
    {
        "content": "<p>i.e. i propose that we don't talk about P^n/S</p>",
        "id": 542525802,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759332732
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/EllipticCurve/blob/007f6b58a9b563ca74eb5441a66d87b610261a07/EllipticCurve/ProjectiveSpace/TensorProduct/GradedAlgebra.lean#L363\">https://github.com/kckennylau/EllipticCurve/blob/007f6b58a9b563ca74eb5441a66d87b610261a07/EllipticCurve/ProjectiveSpace/TensorProduct/GradedAlgebra.lean#L363</a></p>",
        "id": 542699912,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759398488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> I now have a graded algebra structure on the base change</p>",
        "id": 542699947,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759398500
    },
    {
        "content": "<p>summary:</p>\n<ol>\n<li>we want to show that <code>P^n(Spec R) = Proj R[n]</code>, which requires</li>\n<li>in general a theorem <code>Spec S x[Spec R] Proj A = Proj (S ⊗[R] A)</code>, which requires</li>\n<li>firstly a graded algebra structure on <code>Proj (S ⊗[R] A)</code>, which is the result linked above</li>\n</ol>",
        "id": 542700332,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759398618
    },
    {
        "content": "<p>so now i'm in step 2, and the only reference i could find is <a href=\"https://math.arizona.edu/~cais/CourseNotes/AlgGeom04/notes216.pdf\">https://math.arizona.edu/~cais/CourseNotes/AlgGeom04/notes216.pdf</a> , which already implicitly uses a \"by cover\" construction</p>",
        "id": 542707075,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759400912
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/XZa8MgEkD-FwyKuYY0BKCVHr/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/XZa8MgEkD-FwyKuYY0BKCVHr/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1070x225\" src=\"/user_uploads/thumbnail/3121/XZa8MgEkD-FwyKuYY0BKCVHr/image.png/840x560.webp\"></a></div><p>(the highlighted part is the \"by cover\")</p>",
        "id": 542707149,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759400936
    },
    {
        "content": "<p>oh and also this uses S0 instead of R</p>",
        "id": 542707265,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759400980
    },
    {
        "content": "<p>actually now that I think about it, I don't know why in mathlib Proj takes a GradedAlgebra instead of a GradedRing...</p>",
        "id": 542707786,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759401138
    },
    {
        "content": "<p>the base ring plays no part</p>",
        "id": 542707806,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759401146
    },
    {
        "content": "<p>so i'm still doing this and i strongly suspect that this will produce at least 5 PR's</p>",
        "id": 543037875,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759531819
    },
    {
        "content": "<p>for example we don't even know that the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HomogeneousLocalization.Away.mk#doc\">docs#HomogeneousLocalization.Away.mk</a> of 0 is 0</p>",
        "id": 543037900,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759531844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> <a href=\"http://HomogeneousLocalization.Away.mk\">HomogeneousLocalization.Away.mk</a></p>",
        "id": 543037981,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759531908
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.html#HomogeneousLocalization.Away.mk\">HomogeneousLocalization.Away.mk</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.html#HomogeneousLocalization.Away.mk_surjective\">HomogeneousLocalization.Away.mk_surjective</a>, and <a href=\"https://loogle.lean-lang.org/?q=HomogeneousLocalization.Away.mk\">5 more</a></p>",
        "id": 543037984,
        "sender_full_name": "loogle",
        "timestamp": 1759531909
    },
    {
        "content": "<p>since there are only 7 declarations i would also suggest to make this instead an add hom from A i?</p>",
        "id": 543038016,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759531934
    },
    {
        "content": "<p>so now i have an isomorphism of each component but not yet the proof that they agree on intersection</p>",
        "id": 543048371,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759541339
    },
    {
        "content": "<p>(each component of Spec R x Proj A vs. Proj (R tensor A))</p>",
        "id": 543048408,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759541372
    },
    {
        "content": "<p>I think the right theorem is that the canonical map Spec R x Proj A -&gt; Proj (R tensor A) is an isomorphism?</p>",
        "id": 543048552,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759541492
    },
    {
        "content": "<p>aha that might be better, thanks</p>",
        "id": 543070899,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759567042
    },
    {
        "content": "<p>and we don't have functoriality of Proj...</p>",
        "id": 543071069,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759567265
    },
    {
        "content": "<p>(i don't think we even have \"morphism of graded algebra\", i've been inputting the definition manually)</p>",
        "id": 543071080,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759567283
    },
    {
        "content": "<p>I now have 5 <code>erw</code>s in my project <span aria-label=\"melt\" class=\"emoji emoji-1fae0\" role=\"img\" title=\"melt\">:melt:</span></p>",
        "id": 543100793,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759595768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span> and I have written a fair number of lines about graded algebras for our divided powers project. Especially, base change and quotients by homogeneous ideals. In case this helps…<br>\n<a href=\"https://github.com/AntoineChambert-Loir/DividedPowers4\">https://github.com/AntoineChambert-Loir/DividedPowers4</a></p>",
        "id": 543101532,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1759596391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> aha, thanks for the pointer, but i'm afraid i've already done (and duplicated) base change for graded algebra</p>",
        "id": 543101655,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759596527
    },
    {
        "content": "<p>here: <a href=\"https://github.com/kckennylau/EllipticCurve/blob/master/EllipticCurve/ProjectiveSpace/TensorProduct/GradedAlgebra.lean#L366\">https://github.com/kckennylau/EllipticCurve/blob/master/EllipticCurve/ProjectiveSpace/TensorProduct/GradedAlgebra.lean#L366</a></p>",
        "id": 543101673,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759596547
    },
    {
        "content": "<p>corresponding to your file here: <a href=\"https://github.com/AntoineChambert-Loir/DividedPowers4/blob/8ac87135ef7b23afe47748073c19e8e16b2a44ec/DividedPowers/ForMathlib/GradedBaseChange.lean#L172\">https://github.com/AntoineChambert-Loir/DividedPowers4/blob/8ac87135ef7b23afe47748073c19e8e16b2a44ec/DividedPowers/ForMathlib/GradedBaseChange.lean#L172</a></p>",
        "id": 543101682,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759596560
    },
    {
        "content": "<p>Proj is now functorial (in my project): <a href=\"https://github.com/kckennylau/EllipticCurve/blob/74075515ae23812b74a38e6bcae8b351842aebaf/EllipticCurve/ProjectiveSpace/TensorProduct/ProjMap.lean#L262\">https://github.com/kckennylau/EllipticCurve/blob/74075515ae23812b74a38e6bcae8b351842aebaf/EllipticCurve/ProjectiveSpace/TensorProduct/ProjMap.lean#L262</a></p>",
        "id": 543105640,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759600338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> using your suggestion I've tried to come up with the details on paper:</p>\n<ol>\n<li>I assume you meant the opposite direction, i.e. we get a map <code>e : Proj(R ⊗ 𝒜) ⟶ Spec(R) × Proj(𝒜)</code> using UMP of pullback and the functoriality result I just proved.</li>\n<li>the away map <code>Spec((𝒜_f)₀) ⟶ Proj(𝒜)</code> is an open immersion (in mathlib), so pullback gives us an open immersion <code>V := Spec(R) × Spec((𝒜_f)₀) ⟶ Spec(R) × Proj(𝒜)</code> (I hope).</li>\n<li>Similarly we have open immersion <code>U := Spec(((R ⊗ 𝒜)_(1 ⊗ₜ f))₀) ⟶ Proj(R ⊗ 𝒜)</code>.</li>\n<li>I hope we can prove that on the level of points, <code>e</code> maps <code>U</code> to <code>V</code>.</li>\n<li>By the UMP of open immersion, we can restrict <code>e</code> to <code>e|UV : U ⟶ V</code>.</li>\n<li>I hope we can prove that <code>e|UV</code> is exacly (the forward direction of) the isomorphism I talked about before your message (the isomorphism of components).</li>\n<li>Therefore <code>e</code> is locally invertible (<code>f</code> is a cover), therefore <code>e</code> is iso.</li>\n</ol>",
        "id": 543107131,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759601601
    },
    {
        "content": "<p>Is this what you have in mind?</p>",
        "id": 543107137,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759601609
    },
    {
        "content": "<p>Instead of 4, you show that <code>e</code> commutes with the (R ox A)_(1 ox f) = R ox A_(f) iso you had earlier and then you should be done.</p>",
        "id": 543107324,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759601844
    },
    {
        "content": "<p>That makes sense, but I suspect it might still involve the same work, because in the (to be proved commutative) square you're referring to, I need to compare two maps from Spec S to scheme X, and I don't know how to do that</p>",
        "id": 543107501,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759602060
    },
    {
        "content": "<p><a href=\"https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXG1hdGhybXtQcm9qfShSIFxcb3RpbWVzIEEpIl0sWzEsMCwiXFxtYXRocm17U3BlY30oUikgXFx0aW1lcyBcXG1hdGhybXtQcm9qfShBKSJdLFswLDEsIlxcbWF0aHJte1NwZWN9KChSIFxcb3RpbWVzIEEpX3sxIFxcb3RpbWVzIGZ9KV8wIl0sWzEsMSwiXFxtYXRocm17U3BlY30oUikgXFx0aW1lcyBcXG1hdGhybXtTcGVjfShBX2YpXzAiXSxbMCwxLCJlIl0sWzIsMCwiVSJdLFsyLDMsImVfZiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMywxLCJWIiwyXSxbMiwzLCJcXGNvbmciLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d\">quiver</a></p>\n<p><a href=\"/user_uploads/3121/Uv6bg596RTP_ntjg6PojTmlF/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Uv6bg596RTP_ntjg6PojTmlF/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"835x317\" src=\"/user_uploads/thumbnail/3121/Uv6bg596RTP_ntjg6PojTmlF/image.png/840x560.webp\"></a></div>",
        "id": 543107666,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759602238
    },
    {
        "content": "<p>I’m not sure what X is, but what it boils down to is that the map between Projs commutes with the affine open cover, which should be true by construction.</p>",
        "id": 543107694,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759602260
    },
    {
        "content": "<p>aha yes i forgot it's a map to a pullback so it has UMP</p>",
        "id": 543107722,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759602293
    },
    {
        "content": "<p>thanks!</p>",
        "id": 543107787,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759602353
    },
    {
        "content": "<p>it's amazing how much you can prove with no input (i.e. just category theory)</p>",
        "id": 543107894,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759602457
    },
    {
        "content": "<p>the square that commutes \"by construction\" is now proven in my project: <a href=\"https://github.com/kckennylau/EllipticCurve/blob/4437ba885487cb04532d918900772075f5c0ce7a/EllipticCurve/ProjectiveSpace/TensorProduct/ProjMap.lean#L451\">https://github.com/kckennylau/EllipticCurve/blob/4437ba885487cb04532d918900772075f5c0ce7a/EllipticCurve/ProjectiveSpace/TensorProduct/ProjMap.lean#L451</a></p>",
        "id": 543170374,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759678638
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">The following square commutes:</span>\n<span class=\"sd\">```</span>\n<span class=\"sd\">Proj 𝒜₂         ⟶ Proj 𝒜₁</span>\n<span class=\"sd\">    ^                   ^</span>\n<span class=\"sd\">    |                   |</span>\n<span class=\"sd\">Spec A₂[f(s)⁻¹]₀ ⟶ Spec A₁[s⁻¹]₀</span>\n<span class=\"sd\">```</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">awayι_comp_map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">𝒜₁</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">awayι</span><span class=\"w\"> </span><span class=\"n\">𝒜₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CommRingCat</span><span class=\"bp\">.</span><span class=\"n\">ofHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Away</span><span class=\"bp\">.</span><span class=\"n\">mapₐ</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toRingHom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">awayι</span><span class=\"w\"> </span><span class=\"n\">𝒜₁</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n</code></pre></div>",
        "id": 543170379,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759678647
    },
    {
        "content": "<p>also the total line count for the code relating to this part is definitely more than 1000</p>",
        "id": 543170447,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759678750
    },
    {
        "content": "<p>I would not be surprised if I produced 10 PR's this week</p>",
        "id": 543171059,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759679439
    },
    {
        "content": "<p>Andrew Yang <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543107324\">said</a>:</p>\n<blockquote>\n<p>Instead of 4, you show that <code>e</code> commutes with the (R ox A)_(1 ox f) = R ox A_(f) iso you had earlier and then you should be done.</p>\n</blockquote>\n<p>I now have this result locally! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> so I \"should be done\" with one more step</p>",
        "id": 543197629,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759704034
    },
    {
        "content": "<p>I suspect we won't have a lemma that \"is an isomorphism\" can be checked locally</p>",
        "id": 543197639,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759704051
    },
    {
        "content": "<p>but i can prove that easily</p>",
        "id": 543197660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759704062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543197639\">said</a>:</p>\n<blockquote>\n<p>I suspect we won't have a lemma that \"is an isomorphism\" can be checked locally</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.instIsLocalAtTargetIsomorphismsScheme#doc\">docs#AlgebraicGeometry.instIsLocalAtTargetIsomorphismsScheme</a></p>",
        "id": 543198727,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759705397
    },
    {
        "content": "<p>nice</p>",
        "id": 543198858,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759705560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"648495\">@Christian Merten</span> the version I'm stating in my file is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- To check if `f : X ⟶ Y` is an isomorphism, one can supply an open cover of `X` and an open</span>\n<span class=\"sd\">cover of `Y` (indexed by the same set `S`), and then maps `f_i : U_i ⟶ V_i` for `i : S` that are</span>\n<span class=\"sd\">iso such that the squares commute. -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isIso_of_cover</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Scheme</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">OpenCover</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">OpenCover</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iU</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">I₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hu</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iU</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iV</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">I₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">iV</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iU</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iV</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hfφ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iU</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iV</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsIso</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 543198983,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759705693
    },
    {
        "content": "<p>I wonder if you have the intermediate steps</p>",
        "id": 543198995,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759705704
    },
    {
        "content": "<p>(I suspect in actual applications we will have U.I0 = V.I0 so we can perhaps strengthen the assumption to an equiv</p>",
        "id": 543199333,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759706148
    },
    {
        "content": "<p>oh wow this generalisation is not true... lol</p>",
        "id": 543203526,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759711069
    },
    {
        "content": "<p>I need to control each preimage</p>",
        "id": 543203548,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759711098
    },
    {
        "content": "<p>counter-example: take X = disjoint union of two copies of Y, call them X1 and X2, then the cover is {X1, X2} on X and {Y, Y} on Y</p>",
        "id": 543203588,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759711147
    },
    {
        "content": "<p><a href=\"https://github.com/kckennylau/EllipticCurve/blob/9a891db3938c36b94e5a96d39e0703b89c272545/EllipticCurve/ProjectiveSpace/TensorProduct/Proj.lean#L568\">Proj of tensor product!</a></p>",
        "id": 543210598,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759718987
    },
    {
        "content": "<p>I have finally <a href=\"https://github.com/kckennylau/EllipticCurve/blob/d0e5a50421ad919106280f91f27b3ff0365df0db/EllipticCurve/ProjectiveSpace/Scheme.lean#L106\">completed</a> the \"fundamental theorem\" of projective space, i.e. the characterisation when S is affine</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- `ℙ(n; Spec(R))` is isomorphic to `Proj R[n]`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SpecIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℙ</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">Spec</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">homogeneousSubmodule</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 543339963,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759762825
    },
    {
        "content": "<p>I propose we define a class of rings with a canonical graded structure, and then a function <code>Graded.of</code> to retrieve the structure, and then define the notation <code>Proj(R)</code> to mean <code>Proj (Graded.of R)</code></p>",
        "id": 543340486,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759762918
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CanonicalGradedStructure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">grading</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"c1\">-- to be replaced with `AddSubmonoidClass`</span>\n<span class=\"w\">  </span><span class=\"n\">gradedAlgebra</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">GradedAlgebra</span><span class=\"w\"> </span><span class=\"n\">grading</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">CanonicalGradedStructure</span><span class=\"bp\">.</span><span class=\"n\">gradedAlgebra</span>\n\n<span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"Proj(\"</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"s2\">\")\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CanonicalGradedStructure</span><span class=\"bp\">.</span><span class=\"n\">grading</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">CanonicalGradedStructure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MvPolynomial</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">grading</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">homogeneousSubmodule</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">  </span><span class=\"n\">gradedAlgebra</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MvPolynomial</span><span class=\"bp\">.</span><span class=\"n\">gradedAlgebra</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Proj</span><span class=\"o\">(</span><span class=\"n\">MvPolynomial</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">AlgebraicGeometry</span>\n</code></pre></div>",
        "id": 543342982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759763410
    },
    {
        "content": "<p>The fact that <code>Proj (R)</code> and <code>Proj(R)</code> have different meaning is very confusing (so is <code>Spec(R)</code> and <code>Spec (R)</code> so we are getting rid of the former).</p>",
        "id": 543344144,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759763629
    },
    {
        "content": "<p>oh no, i liked Spec(R)</p>",
        "id": 543344718,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759763752
    },
    {
        "content": "<p>I don't like <code>Spec(R)</code> at all. The only use case I see for this is for propaganda purposes, but in this case one can easily locally create the notation.</p>",
        "id": 543344984,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759763815
    },
    {
        "content": "<p>like, they might be confusing, but i don't think anyone can read <code>Proj (fun n ↦ (𝒜 n).baseChange S))</code></p>",
        "id": 543345000,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759763819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543344984\">said</a>:</p>\n<blockquote>\n<p>locally create the notation</p>\n</blockquote>\n<p>isn't that the point of a scoped notation; also this one I proposed for Proj is not as easy, since it requires a class of canonically graded rings</p>",
        "id": 543345201,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759763863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543345000\">said</a>:</p>\n<blockquote>\n<p>like, they might be confusing, but i don't think anyone can read <code>Proj (fun n ↦ (𝒜 n).baseChange S))</code></p>\n</blockquote>\n<p>But this would already be fixed by your first suggestion of introducing <code>CanonicalGradedStructure</code>, which I think is worth considering.</p>",
        "id": 543345410,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759763907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543344984\">said</a>:</p>\n<blockquote>\n<p>propaganda purposes</p>\n</blockquote>\n<p>well I do want to make lean notation as close to maths as possible... if you count that as \"propaganda purposes\" then I guess we just have different aims</p>",
        "id": 543345503,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759763925
    },
    {
        "content": "<p>I thought the point was that <code>MvPolynomial _ R</code> has no canonical graded structure because you often want different variables to have different weights.</p>",
        "id": 543345735,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759763976
    },
    {
        "content": "<p>actually i didn't quite understand that point; the input in <code>GradedAlgebra</code> already tells you which family of submodules you're considering, so i don't really see why we shouldn't make it an instance</p>",
        "id": 543345976,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764031
    },
    {
        "content": "<p>taking a step back, even if I accept that, we can just copy the same thing, and make <code>MvPolynomial.instCanonicallyGradedHomogeneousSubmodule</code> a definition and a local instance when we need it</p>",
        "id": 543346220,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543345503\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543344984\">said</a>:</p>\n<blockquote>\n<p>propaganda purposes</p>\n</blockquote>\n<p>well I do want to make lean notation as close to maths as possible... if you count that as \"propaganda purposes\" then I guess we just have different aims</p>\n</blockquote>\n<p>By propaganda purposes I mean Lean demos for non-Lean people, where I don't want to spend time on explaining the <code>.of R</code> in <code>Spec (.of R)</code>.</p>\n<p>We should of course try to make mathlib close to paper notation, but we also need to make sure it is not confusing for the people that actually work in it.</p>",
        "id": 543346231,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759764081
    },
    {
        "content": "<p>I think people working in it know that <code>ident(</code> is special notation...</p>",
        "id": 543346562,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543345976\">said</a>:</p>\n<blockquote>\n<p>actually i didn't quite understand that point; the input in <code>GradedAlgebra</code> already tells you which family of submodules you're considering, so i don't really see why we shouldn't make it an instance</p>\n</blockquote>\n<p>I'm saying that <code>homogeneousSubmodule</code> shouldn't be automatic. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial.gradedAlgebra#doc\">docs#MvPolynomial.gradedAlgebra</a> could be. I don't know why it's not.</p>",
        "id": 543346983,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759764231
    },
    {
        "content": "<p>yes, so we'll make that a local instance</p>",
        "id": 543347784,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543344984\">said</a>:</p>\n<blockquote>\n<p>locally create the notation</p>\n</blockquote>\n<p>taking a step back, would it be acceptable to scope the notation in its own scope? so <code>Spec(R)</code> should live in the scope <code>AlgebraicGeometry.Spec.Notation</code> and <code>Proj(R)</code> should live in the scope <code>AlgebraicGeometry.Proj.Notation</code>; I think this is as good as making it a local notation each time we want it, and this also makes it more maintainable (since the notation is only defined once)</p>",
        "id": 543348804,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764543
    },
    {
        "content": "<p>for accessibility we should also mention the scopes in the docstrings of Spec and Proj</p>",
        "id": 543348971,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764567
    },
    {
        "content": "<p>I am keeping the <code>Spec()</code> notation for now but removing its usage in mathlib.</p>",
        "id": 543349003,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1759764573
    },
    {
        "content": "<p>We should ban it from being used in mathlib though.</p>",
        "id": 543349079,
        "sender_full_name": "Christian Merten",
        "timestamp": 1759764587
    },
    {
        "content": "<p>I respectfully disagree.</p>",
        "id": 543349164,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759764603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543344144\">said</a>:</p>\n<blockquote>\n<p>The fact that <code>Proj (R)</code> and <code>Proj(R)</code> have different meaning is very confusing (so is <code>Spec(R)</code> and <code>Spec (R)</code> so we are getting rid of the former).</p>\n</blockquote>\n<p>Wait, what? I thought we had won that battle!</p>",
        "id": 543450837,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1759817518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/channel/116395-maths/topic/Projective.20Space/near/543346231\">said</a>:</p>\n<blockquote>\n<p>We should of course try to make mathlib close to paper notation, but we also need to make sure it is not confusing for the people that actually work in it.</p>\n</blockquote>\n<p>I claimed in the past and claim again now that goals full of things of the form <code>Spec (CommRingCat.of R)</code> are in fact confusing for the people that work on them</p>",
        "id": 543451198,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1759817755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> this conversation has been moved to <a href=\"#narrow/channel/287929-mathlib4/topic/Remove.20.60Spec.28.29.60.20notation\">#mathlib4 &gt; Remove &#96;Spec()&#96; notation</a></p>",
        "id": 543453335,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759818953
    },
    {
        "content": "<p>here's the (future) PR graph i drew:<br>\n<a href=\"/user_uploads/3121/8we7_d7BTAhjCHAFIpHTfj1A/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8we7_d7BTAhjCHAFIpHTfj1A/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1209x754\" src=\"/user_uploads/thumbnail/3121/8we7_d7BTAhjCHAFIpHTfj1A/image.png/840x560.webp\"></a></div>",
        "id": 543622978,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759871721
    },
    {
        "content": "<p>update:<br>\n<a href=\"/user_uploads/3121/xpsfChOmbECpLH2pTUdW2gTY/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/xpsfChOmbECpLH2pTUdW2gTY/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1333x709\" src=\"/user_uploads/thumbnail/3121/xpsfChOmbECpLH2pTUdW2gTY/image.png/840x560.webp\"></a></div>",
        "id": 544201499,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1760111191
    }
]