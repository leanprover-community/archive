[
    {
        "content": "<p>I wanted to introduce a predicate for cofinal sets, so I opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/18214\">#18214</a> with some basic API. I was then informed that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> already exists, though this is for the type of cofinal sets, rather than being just a predicate.</p>\n<p>Does it make sense to have both? Or should one be used in favor of the other?</p>",
        "id": 478869434,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729845756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"565854\">@Nir Paz</span></p>",
        "id": 478871215,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729846378
    },
    {
        "content": "<p>To give a few examples of the API I want for cofinal sets:</p>\n<ul>\n<li>the empty set is cofinal iff the type is empty - gives a very short proof of <code>cof o = 0 ↔ o = 0</code></li>\n<li>a set in an <code>OrderTop</code> is cofinal iff it contains <code>⊤</code> - should allow a similarly short proof of cof o = 1 ↔ o ∈ range succ`</li>\n<li>if <code>f</code> and <code>g</code> form a galois connection and <code>s</code> is cofinal, so is <code>g '' s</code> - this gives a very quick proof that relation isomorphisms preserve cofinality</li>\n</ul>",
        "id": 478871844,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729846587
    },
    {
        "content": "<p>I feel like all of these would be somewhat awkward to state with the type approach.</p>",
        "id": 478871905,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729846614
    },
    {
        "content": "<p>There's an ambiguity in cofinality that it can be defined as a cardinal  (for sets in a preordered type) or as an ordinal (for sets in a well-ordered type). For well-ordered types, both approaches concur in the end, but the definition as an ordinal says something slightly stronger.</p>",
        "id": 478889751,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1729852473
    },
    {
        "content": "<p>Is it common in mathlib to have both a structure and a predicate? Seems bad for scaling. If we choose one, I'm definitely in favor of a predicate since otherwise like you say it's clumsy to state a theorem that a set is cofinal, which is pretty common</p>",
        "id": 478900906,
        "sender_full_name": "Nir Paz",
        "timestamp": 1729856611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/Cofinal.20sets/near/478889751\">said</a>:</p>\n<blockquote>\n<p>There's an ambiguity in cofinality that it can be defined as a cardinal  (for sets in a preordered type) or as an ordinal (for sets in a well-ordered type). For well-ordered types, both approaches concur in the end, but the definition as an ordinal says something slightly stronger.</p>\n</blockquote>\n<p>I think it's fine to just have the cardinality definition, as the cofinality definition is easy to state as a theorem afterwards</p>",
        "id": 478944951,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729871188
    },
    {
        "content": "<p>In the current API that would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.ord_cof_eq#doc\">docs#Ordinal.ord_cof_eq</a></p>",
        "id": 478945013,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729871212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"565854\">Nir Paz</span> <a href=\"#narrow/channel/116395-maths/topic/Cofinal.20sets/near/478900906\">said</a>:</p>\n<blockquote>\n<p>Is it common in mathlib to have both a structure and a predicate? Seems bad for scaling. If we choose one, I'm definitely in favor of a predicate since otherwise like you say it's clumsy to state a theorem that a set is cofinal, which is pretty common</p>\n</blockquote>\n<p>I recall I've seen a few other structures like these around the order library, but I can't find any for the moment.</p>",
        "id": 478969199,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729880865
    },
    {
        "content": "<p>I think it's fine to have both the predicate and the type, since there is at least one property of the type we care about: it's nonempty</p>",
        "id": 478969314,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729880908
    },
    {
        "content": "<p>I'd rather have it just be a subtype so we could use e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.forall#doc\">docs#Subtype.forall</a>, but maybe there's a good reason for not doing that</p>",
        "id": 478969384,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729880951
    },
    {
        "content": "<p>Talking about the type, would it make sense to rename it to <code>Cofinals</code>? </p>\n<p>And also, should the predicate <code>Cofinal</code> be in the <code>Order</code> namespace?</p>",
        "id": 478969734,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729881099
    },
    {
        "content": "<p>Another question: is it a big deal to lose the def-eq <code>(type r).cof = Order.cof r</code>?</p>",
        "id": 478977675,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729884959
    },
    {
        "content": "<p>With my planned redefinition of <code>Order.cof</code> in terms of a preorder, I can still guarantee <code>(type α (· &lt; ·)).cof = Order.cof α</code>, but since <code>LinearOrder</code> is data-carrying I sadly can't make that a def-eq</p>",
        "id": 478977773,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1729884996
    },
    {
        "content": "<p>I've thought about this a bit. I think we can have both the predicate <code>IsCofinal</code> and the type <code>Cofinal</code>, in analogy to e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUpperSet#doc\">docs#IsUpperSet</a> vs <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UpperSet#doc\">docs#UpperSet</a></p>",
        "id": 480253906,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730585277
    },
    {
        "content": "<p>Yes, but what's the use case of the structure?</p>",
        "id": 480254069,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730585414
    },
    {
        "content": "<p>I'm not sure I can answer that, but looking at the API for the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.idealOfCofinals#doc\">docs#Order.idealOfCofinals</a>, a lot of these theorems seem more natural to state using the type</p>",
        "id": 480254117,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730585477
    },
    {
        "content": "<p>It's also used a bit in model theory it seems, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.PartialIso.definedAtLeft#doc\">docs#Order.PartialIso.definedAtLeft</a></p>",
        "id": 480254343,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730585695
    },
    {
        "content": "<p>Maybe it's best to ask the author <span class=\"user-mention\" data-user-id=\"612162\">@Gabin Kolly</span></p>",
        "id": 480254676,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730586025
    },
    {
        "content": "<p>Also, just found this two-month old convo where you also argue for <code>Cofinal</code> to be a predicate: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11177/files#r1715176361\">https://github.com/leanprover-community/mathlib4/pull/11177/files#r1715176361</a></p>",
        "id": 480254706,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730586065
    },
    {
        "content": "<p>Honestly, I don't see an issue with having both the predicate and the type. In any case, we can probably benefit from having the type by defining the cofinality of a type <code>α</code> as <code>⨅ s : Cofinal α, #s.carrier</code> and making use of the <code>Nonempty</code> instance on <code>Cofinal α</code>.</p>",
        "id": 480254900,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730586256
    },
    {
        "content": "<p>A more pressing issue: is it ok for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> to be in the <code>Order</code> namespace? It makes sense, but other order-related types/predicates like the aforementioned <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UpperSet#doc\">docs#UpperSet</a> are in the root namespace instead.</p>",
        "id": 480254929,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730586304
    },
    {
        "content": "<p>Is there anyone else currently working on model theory I could ask for comment?</p>",
        "id": 480356585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730686210
    },
    {
        "content": "<p>IIRC <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> was defined a long time ago for the Rasiowa--Sikorsi lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.idealOfCofinals#doc\">docs#Order.idealOfCofinals</a> and the related <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.iso_of_countable_dense#doc\">docs#Order.iso_of_countable_dense</a>. This has since been generalised to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FirstOrder.Language.equiv_between_cg#doc\">docs#FirstOrder.Language.equiv_between_cg</a>. These seem to be the only uses of <code>Order.Cofinal</code>? For these purposes it was convenient to use the structure, but I guess one would also like to have the property</p>",
        "id": 480393147,
        "sender_full_name": "David Wärn",
        "timestamp": 1730710084
    },
    {
        "content": "<p>About the namespaces, I note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a> requires <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder#doc\">docs#Preorder</a> while <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UpperSet#doc\">docs#UpperSet</a> is content with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LE#doc\">docs#LE</a>.  The namespaces can help disambiguate, which seems unnecessary here, and to allow for dot notation, which is neither the case here, because orders are usually given at the level of typeclasses. For algebraic structures, the namespace seems to refer either to the morphisms (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function#doc\">docs#Function</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgHom#doc\">docs#AlgHom</a>…) or predicates. All in all, this suggests for suppressing the namespace here.</p>",
        "id": 480394662,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1730710668
    },
    {
        "content": "<p>So as the author of FirstOrder.Language.equiv_between_cg, I don't think using a property instead of a structure would change a lot, and the proof can be easily adapted to use the predicate.</p>",
        "id": 480429707,
        "sender_full_name": "Gabin Kolly",
        "timestamp": 1730722118
    },
    {
        "content": "<p>I can leave this refactor as a TODO within my own PR</p>",
        "id": 480463608,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730732410
    },
    {
        "content": "<p>Would we also need to refactor <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Ideal#doc\">docs#Order.Ideal</a> in this way?</p>",
        "id": 480463701,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1730732433
    },
    {
        "content": "<p>In the proof, I use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.sequenceOfCofinals#doc\">docs#Order.sequenceOfCofinals</a> which is in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Ideal#doc\">docs#Order.Ideal</a>, so it would need to be refactored as well.</p>",
        "id": 480695821,
        "sender_full_name": "Gabin Kolly",
        "timestamp": 1730805083
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 485582854,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733132756
    },
    {
        "content": "<p>I'm confused on what to do with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Cofinal#doc\">docs#Order.Cofinal</a>.</p>",
        "id": 485702838,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733171116
    },
    {
        "content": "<p>I think it makes sense to keep <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.Ideal#doc\">docs#Order.Ideal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.PFilter#doc\">docs#Order.PFilter</a> as structures rather than predicates, if only to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter#doc\">docs#Filter</a>. But under that logic, refactoring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cofinal#doc\">docs#Cofinal</a> would make the <code>Order.Ideal</code> file inconsistent.</p>",
        "id": 485703242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733171281
    },
    {
        "content": "<p>For the moment I've opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/19681\">#19681</a>, which redefines <code>Cofinal</code> in terms of <code>IsCofinal</code>.</p>",
        "id": 485703314,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733171299
    },
    {
        "content": "<p>Not quite the original thread topic, but you might be interested in knowing I'm doing a very large refactor on the cofinality API: <a href=\"https://github.com/leanprover-community/mathlib4/pull/19698\">#19698</a></p>",
        "id": 486030874,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733298916
    },
    {
        "content": "<p>This is meant to solve two major problems with the current API:</p>\n<ul>\n<li>Defining <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Order.cof#doc\">docs#Order.cof</a> in terms of an unbundled relation rather than a linear order is pretty inconvenient, most notably not allowing us to easily link together cofinality to cofinal sets.</li>\n<li>A lot of theorems are written in terms of <code>lsub</code>, <code>blsub</code>, etc. which are in process of being deprecated.</li>\n<li>(and also, a lot of the current proofs are a mess)</li>\n</ul>",
        "id": 486031243,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733299081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"565854\">@Nir Paz</span></p>",
        "id": 486031328,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733299107
    },
    {
        "content": "<p>Defining cofinality for relation really does seem like redundant generality, preorders are what I would think is the most general use case, so no objections!</p>\n<p>Could you clearify how this will help the <code>lsub</code>-and-friends problem? Do you just mean this gives you an opportunity to refactor them out of a lot of places?</p>",
        "id": 486045535,
        "sender_full_name": "Nir Paz",
        "timestamp": 1733304041
    },
    {
        "content": "<p>Oh yeah, I'm really just taking the opportunity to refactor everything at once.</p>",
        "id": 486049280,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733305166
    },
    {
        "content": "<p>Otherwise I end up duplicating work, e.g. if I redefine <code>Order.cof</code> I have to reprove all of the <code>lsub</code> theorems and such, and then I have to get rid of them!</p>",
        "id": 486049497,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733305217
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 486064394,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733309807
    },
    {
        "content": "<p>The refactor is almost done! I'm just missing some minor theorems on <code>nfpFamily</code>, plus some not so minor results about the infinite pigeonhole principle</p>",
        "id": 486066408,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310427
    },
    {
        "content": "<p>What exactly is the infinite pigeonhole principle in this context?</p>",
        "id": 486066454,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310443
    },
    {
        "content": "<p>The version I learned simply states \"given finitely many holes and infinitely many pigeons, some hole contains infinitely many pigeons\"</p>",
        "id": 486066533,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310477
    },
    {
        "content": "<p>I'm having a hard time parsing the version on Mathlib: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.infinite_pigeonhole#doc\">docs#Ordinal.infinite_pigeonhole</a></p>",
        "id": 486066621,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310499
    },
    {
        "content": "<p>Given infinitely many pigeons <code>b</code>, and less holes than the cofinality of <code>b</code>, some hole has <code>b</code> pigeons?</p>",
        "id": 486067146,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310686
    },
    {
        "content": "<p>That makes sense actually</p>",
        "id": 486067640,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733310830
    },
    {
        "content": "<p>In other words, if <code>x</code> is a cardinal with cofinality <code>y</code>, the sum / supremum of <code>&lt; y</code> cardinals less than <code>x</code> is also less than <code>x</code></p>",
        "id": 486070106,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1733311660
    }
]