[
    {
        "content": "<p>Dear All,</p>\n<p>I'm happy to tell everyone that I have formalized most of the <a href=\"https://en.wikipedia.org/wiki/Lindemann%E2%80%93Weierstrass_theorem\">Lindemann-Weierstrass theorem</a>. The main theorem is <a href=\"https://github.com/negiizhao/transcendental/blob/master/src/lindemann.lean#L2296\">here</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">linear_independent_exp</span>\n  <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_integral</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">u_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_integral</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">exp</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>There are still some sorry in the code. Two of them are waiting for <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>'s work on <code>is_domain</code> for <code>add_monoid_algebra</code>. And the other two are <a href=\"https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial#Fundamental_theorem_of_symmetric_polynomials\">fundamental theorem of symmetric polynomials</a>. Symmetric polynomials are only used in the very last part of the proof, and I believe it can be replaced by some Galois theory, however, it seems to be the simplest way if we have sufficient infrastructures.</p>\n<p>There is also a file <code>e.lean</code> in this repository, that is <em>unrelated</em> to this work. I just reused this repository.</p>\n<p>If there is any way to improve my proof, please feel free to give suggestions.</p>",
        "id": 297900963,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662693052
    },
    {
        "content": "<p>That's great, congratulations!</p>\n<p>I've broken one of the <code>is_domain</code> PR, but have not yet had time to figure out which instance I still need to provide to make it compile again.  I'll try to do it soon, but I'm not sure how much time I'll have before late next week.</p>",
        "id": 297905682,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662698955
    },
    {
        "content": "<p>Have you considered using <code>is_algebraic</code> in your statement? It's trivially equivalent, of course, but it matches what people would usually write, I think.</p>",
        "id": 297907606,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662700997
    },
    {
        "content": "<p>Nice, sounds like I can drop  <a href=\"https://github.com/leanprover-community/mathlib/pull/15954\">#15954</a> then :)</p>",
        "id": 297908486,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1662701830
    },
    {
        "content": "<p>Isn't that a prerequisite? Or did <span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> do a completely new proof?</p>",
        "id": 297912037,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662704524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Lindemann-Weierstrass.20theorem.20almost.20done/near/297912037\">said</a>:</p>\n<blockquote>\n<p>Isn't that a prerequisite? Or did <span class=\"user-mention silent\" data-user-id=\"455791\">Yuyang Zhao</span> do a completely new proof?</p>\n</blockquote>\n<p>My proof is independent. I think I knew about that PR very late, probably after I had finished the analytical part. I didn't check how many duplicates there are.</p>",
        "id": 297914192,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662705960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Lindemann-Weierstrass.20theorem.20almost.20done/near/297907606\">said</a>:</p>\n<blockquote>\n<p>Have you considered using <code>is_algebraic</code> in your statement? It's trivially equivalent, of course, but it matches what people would usually write, I think.</p>\n</blockquote>\n<p>I would add some variants of this statement.</p>",
        "id": 297914462,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662706128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/116395-maths/topic/Lindemann-Weierstrass.20theorem.20almost.20done/near/297905682\">said</a>:</p>\n<blockquote>\n<p>That's great, congratulations!</p>\n<p>I've broken one of the <code>is_domain</code> PR, but have not yet had time to figure out which instance I still need to provide to make it compile again.  I'll try to do it soon, but I'm not sure how much time I'll have before late next week.</p>\n</blockquote>\n<p><code>K s</code> is a ℚ-vector space, so it's just ring equiv to <code>is_domain (add_monoid_algebra (ι →₀ ℚ) F)</code>.</p>",
        "id": 297915590,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662706847
    },
    {
        "content": "<p>I see. So you have an independent proof of transcendence of <code>e</code>. Because that mathematical fact is still an input to your proof of Lindemann─Weierstrass, right?</p>",
        "id": 297915614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662706855
    },
    {
        "content": "<p>No, it just doesn't need the proof of transcendence of <code>e</code>. I mean <code>e.lean</code> is previously written in this repository and has no relation to this proof.</p>",
        "id": 297916472,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1662707345
    },
    {
        "content": "<p>Oooh, ok! <span aria-label=\"bulb\" class=\"emoji emoji-1f4a1\" role=\"img\" title=\"bulb\">:bulb:</span></p>",
        "id": 297916508,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1662707373
    },
    {
        "content": "<p>I'm outlining in Lean <a href=\"https://en.wikipedia.org/wiki/Elementary_symmetric_polynomial#Alternative_proof\">the second proof in Wikipedia</a> for the symmetric polynomial theorem, which essentially uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.lex\">docs#finsupp.lex</a> that Damiano introduced into mathlib recently (looks like we'll also need well-foundedness apart from linear order). The first thing I observed is that the <code>sorry</code> as stated seems to be wrong: we don't get an isomorphism for comm_semiring because for example x^2+y^2=(x+y)^2+(-2)xy, and -2 doesn't exist in ℕ. However I think <span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> only applies it to comm_rings, so it should be okay.</p>",
        "id": 298494571,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1663025736
    },
    {
        "content": "<p>Thanks! I didn't check the conditions carefully and the assumption <code>comm_semiring</code> is too weak, but <code>comm_ring</code> is certainly enough.</p>",
        "id": 298504470,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1663034583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> have you (or someone else) been working on the symmetric polynomial proof? Would be cool to get this finished</p>",
        "id": 305551504,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1666452453
    },
    {
        "content": "<p>I don't know anyone who is working on the symmetric polynomial proof. This part of the theory is related to integer partitions or Young diagrams, and their APIs still seem inadequate. I think it might be better to discuss with other people who need these APIs.</p>",
        "id": 305560847,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1666457460
    },
    {
        "content": "<p>I <a href=\"#narrow/stream/116395-maths/topic/Lindemann-Weierstrass.20theorem.20almost.20done/near/298494571\">thought about the proof</a> and opened <a href=\"https://github.com/leanprover-community/mathlib/pull/16772\">#16772</a> (well-foundedness of lexicographic orders) with the proof as an motivation (the other motivation being <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299256970\">this thread</a>). (I proved a much more general result, but deducing what we actually need from the general result is arguably what we should do for mathlib.) However, one dependency <a href=\"https://github.com/leanprover-community/mathlib/pull/16777\">#16777</a> of the well-foundedness result hasn't been merged yet, and I haven't returned to the symmetric polynomial proof. As far as I can see, it doesn't have to depend on Young diagrams, but it may be nice to make the connection.</p>",
        "id": 305737792,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1666579182
    },
    {
        "content": "<p>Happy to announce that the fundamental theorem of symmetric polynomials has been done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6593\">#6593</a>!</p>",
        "id": 385299084,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692141029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Lindemann-Weierstrass.20theorem.20almost.20done/near/385299084\">said</a>:</p>\n<blockquote>\n<p>Happy to announce that the fundamental theorem of symmetric polynomials have been done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6593\">#6593</a>!</p>\n</blockquote>\n<p>Have you looked at porting your mathlib3 PR for Lindemann-Weierstrass? If not, I might spend some time on that soonish</p>",
        "id": 385356901,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692169542
    },
    {
        "content": "<p>That was <span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> 's <del>branch</del> repo (~3.3k lines), not yet made into a PR AFAIK. Looking into porting is certainly welcome, but there's still a missing piece (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/6260#issuecomment-1679308823\">my comment</a>) that should probably be done via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueSums#doc\">docs#UniqueSums</a> now.</p>",
        "id": 385512639,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692208731
    },
    {
        "content": "<p>Whoops, sorry, names are hard for me. I'll take a look</p>",
        "id": 385513832,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692209148
    },
    {
        "content": "<p>Some initial work at <a href=\"https://github.com/leanprover-community/mathlib4/compare/transcendental?expand=1\">https://github.com/leanprover-community/mathlib4/compare/transcendental?expand=1</a></p>",
        "id": 385529206,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692215088
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>, contrary to <a href=\"https://github.com/leanprover-community/mathlib4/pull/6260#issuecomment-1680236710\">my comment</a>, I started porting the <code>NoZeroDivisor</code> instance: <a href=\"https://github.com/leanprover-community/mathlib4/pull/6627\">#6627</a>.</p>\n<p>The PR is just the back-end work.  I have not actually golfed the <code>NZD</code> instance on <code>Polynomial</code>s.</p>",
        "id": 385621398,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692259759
    },
    {
        "content": "<p>Oh thanks a lot <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> ! But I thought your motivation of introducing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueSums#doc\">docs#UniqueSums</a> is to prove NoZeroDivisor in that generality, and then show a biordered (add_)monoid has unique products/sums? I will comment on your PR.</p>\n<p>Re: the Lindemann-Weierstrass PR: I looked at the one file that was ported by Ruben, and my first impressions are that we should try to avoid the reliance on <code>quotient.out</code>, which shouldn't be hard, and that we could also avoid using <code>HEq</code> with an easier proof of <code>minpoly.inj</code>.</p>",
        "id": 385699888,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1692286182
    },
    {
        "content": "<p>Junyan, you are absolutely right!  <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> I simply went ahead and re-PRed the earlier version.  I'll update it, though not today!</p>",
        "id": 385736009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692299533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I was looking at using your PR in <a href=\"https://github.com/leanprover-community/mathlib4/tree/transcendental\">branch#transcendental</a>, but am being hindered by not knowing what I'm doing :)</p>\n<p>Would you be able to offer some guidance?</p>",
        "id": 386344827,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692610086
    },
    {
        "content": "<p>Ruben, sure!  Except... can you be more specific on the kind of guidance?</p>",
        "id": 386345157,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692610187
    },
    {
        "content": "<p>Concretely, I've got two sorries here: <a href=\"https://github.com/leanprover-community/mathlib4/blob/transcendental/Mathlib/Analysis/Transcendental.lean#L982\">https://github.com/leanprover-community/mathlib4/blob/transcendental/Mathlib/Analysis/Transcendental.lean#L982</a> (can't really call it a \"minimal\" working example :))</p>",
        "id": 386346074,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692610452
    },
    {
        "content": "<p>Ah, ok, I'll take a look!</p>",
        "id": 386346167,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692610480
    },
    {
        "content": "<p>I'm trying to slowly get up to speed.</p>",
        "id": 386347905,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692610987
    },
    {
        "content": "<p><code>AddMonoidAlgebra (K s) (K s)</code> seems to mean the AddMonoidAlgebra</p>\n<ul>\n<li>whose base ring is <code>K s</code>, a splitting field -- good, and</li>\n<li>whose grading (add)monoid is <code>K s</code>, the same field.</li>\n</ul>\n<p>The latter seems like it should be something else...</p>",
        "id": 386348179,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692611057
    },
    {
        "content": "<p>Should maybe the second <code>K s</code> be some form of <code>Nat</code> or something similar?</p>",
        "id": 386348268,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692611091
    },
    {
        "content": "<p>(Summarizing, <code>AddMonoidAlgebra R A</code> means taking <code>R</code>-linear combinations of \"monomials\" indexes by <code>A</code>.  So, common choices for <code>A</code> are <code>Nat</code> (and you get polynomials), <code>\\sigma -&gt; Nat</code> (and you get multivariate polynomials on a set of variables indexed by <code>\\sigma</code>).)</p>",
        "id": 386348657,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692611191
    },
    {
        "content": "<p>As Lean confirms, what is there does type-check, but seems \"wrong\" to me...</p>",
        "id": 386348752,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692611217
    },
    {
        "content": "<p>Anyway, reading further, I see that this happens a lot in the file.  So, let me stop questioning what the question is and try to fill in the sorries!</p>",
        "id": 386350893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692611849
    },
    {
        "content": "<p>(I'm trying to make lean 3 tell me where it's used, but it's in a bad mood today)</p>",
        "id": 386351609,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692612064
    },
    {
        "content": "<p>Ok, no worries.  Here is a silly approach to break the first sorry into two:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Transcendental</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.MonoidAlgebra.NoZeroDivisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.UniqueProds</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instIsDomain1</span> <span class=\"o\">:</span> <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">CovariantClass</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">apply</span> <span class=\"n\">AddMonoidAlgebra.NoZeroDivisors.biOrdered</span>\n</code></pre></div>",
        "id": 386352297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612279
    },
    {
        "content": "<p>(I created a new file, removing the sorries from the old one.)</p>",
        "id": 386352419,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612309
    },
    {
        "content": "<p>I suspect that it will be easier to prove that <code>K s</code> satisfies <code>UniqueSums</code>, rather than going via an order, but the instance <code>UniqueSums (K s) -&gt; NoZeroDivisors (AddMonoidAlgebra (K s) (K s)</code> is not even PRed.</p>",
        "id": 386352726,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612395
    },
    {
        "content": "<p>I was going to do this in <code>mathlib3</code>, did not do it there (but PRed the relevant background from <code>UniqueSums</code>), then thought I had PRed it to <code>mathlib4</code>, but actually I PRed an older version that might be harder to use in this case.</p>",
        "id": 386353006,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612480
    },
    {
        "content": "<p>Let's try and see if this works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Transcendental</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.MonoidAlgebra.NoZeroDivisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.UniqueProds</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">wanted</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueSums</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">UniqueSums</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instIsDomain1</span> <span class=\"o\">:</span> <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n</code></pre></div>",
        "id": 386353614,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612641
    },
    {
        "content": "<p>This first one is used in one place: the <code>prod_ne_zero_iff</code> in <a href=\"https://github.com/negiizhao/transcendental/blob/master/src/lindemann.lean#L1281\">https://github.com/negiizhao/transcendental/blob/master/src/lindemann.lean#L1281</a> , so strictly speaking it needs <code>NoZeroDivisors</code> rather than <code>IsDomain</code></p>",
        "id": 386353619,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692612645
    },
    {
        "content": "<p>The difference between <code>NoZeroDivisors</code> and <code>IsDomain</code> is tiny, I would focus on <code>NoZeroDivisors</code>.  Usually, <code>IsDomain</code> follows by increasing the typeclass assumptions on the base \"ring\" and deducing it from <code>NoZeroDivisors</code>.</p>",
        "id": 386353859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612722
    },
    {
        "content": "<p>I cannot remember the details, but essentially <code>NoZeroDivisors</code> applies to <code>Semiring</code>s, while <code>IsDomain</code> uses a <code>Ring</code>, but they are otherwise identical.</p>",
        "id": 386354114,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612774
    },
    {
        "content": "<p>I am almost certain that <code>wanted</code> is true and the proof is simply looking at the support and the \"unique sum in there\".</p>",
        "id": 386354485,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612836
    },
    {
        "content": "<p>I need to step out for a bit - thanks for looking in any case!</p>",
        "id": 386354641,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692612881
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">UniqueSums</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I have not really thought about, but I would argue informally that</p>\n<ul>\n<li>finite subsets of <code>K s</code> span, as an additive submodule, something of the form <code>Nat ^ n</code>;</li>\n<li><code>Nat ^ n</code> satisfies <code>UniqueSums</code></li>\n<li>therefore <code>K s</code> satisfies <code>UniqueSums</code>.</li>\n</ul>",
        "id": 386354732,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692612916
    },
    {
        "content": "<p>Ok, here is a proof of <code>wanted</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.MonoidAlgebra.NoZeroDivisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.UniqueProds</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finsupp</span> <span class=\"k\">in</span>\n<span class=\"kd\">instance</span> <span class=\"n\">wanted</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueSums</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">eq_zero_or_eq_zero_of_mul_eq_zero</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">b</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hb</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">c</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">da</span><span class=\"o\">,</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">db</span><span class=\"o\">,</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">UniqueSums.uniqueAdd_of_nonempty</span>\n      <span class=\"o\">(</span><span class=\"n\">support_nonempty_iff.mpr</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">support_nonempty_iff.mpr</span> <span class=\"n\">hb</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">support_nonempty_iff.mp</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Set.nonempty_of_mem</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">da</span> <span class=\"bp\">+</span> <span class=\"n\">db</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mem_support_iff.mpr</span>\n    <span class=\"n\">convert_to</span> <span class=\"n\">a</span> <span class=\"n\">da</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">db</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidAlgebra.mul_apply_add_eq_mul_of_forall_ne</span><span class=\"o\">]</span>\n      <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ma</span> <span class=\"n\">nb</span> <span class=\"n\">H</span>\n      <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">H</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"n\">ma</span> <span class=\"n\">nb</span> <span class=\"n\">H</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">mul_eq_zero.not.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_or</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.mp</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.mp</span> <span class=\"n\">b0</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Note: I simply aimed to prove the result above -- golfing expected and welcome!</p>",
        "id": 386366703,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692617031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> I think that what is below proves the two sorries that you had:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Transcendental</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.MonoidAlgebra.NoZeroDivisors</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.UniqueProds</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finsupp.Lex</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Extension.Linear</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">UniqueProds</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mulHom_image_of</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">uG</span> <span class=\"o\">:</span> <span class=\"n\">UniqueProds</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UniqueProds</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">classical</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">A0</span> <span class=\"n\">B0</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">ha0</span><span class=\"o\">,</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">hb0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">uG.uniqueMul_of_nonempty</span>\n    <span class=\"o\">(</span><span class=\"n\">A0.image</span> <span class=\"n\">f.invFun</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B0.image</span> <span class=\"n\">f.invFun</span><span class=\"o\">)</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.image_id</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">MulEquiv.eq_symm_comp</span> <span class=\"n\">f</span> <span class=\"n\">f.invFun</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n    <span class=\"n\">convert</span> <span class=\"n\">Finset.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">ha0</span>\n    <span class=\"n\">ext</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">MulEquiv.toEquiv_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">Equiv.invFun_as_coe</span><span class=\"o\">,</span> <span class=\"n\">MulEquiv.coe_toEquiv_symm</span><span class=\"o\">,</span>\n      <span class=\"n\">MulEquiv.self_comp_symm</span><span class=\"o\">,</span> <span class=\"n\">Finset.image_id</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_image</span><span class=\"o\">,</span> <span class=\"n\">exists_exists_and_eq_and</span><span class=\"o\">,</span>\n      <span class=\"n\">MulEquiv.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.image_id</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">MulEquiv.eq_symm_comp</span> <span class=\"n\">f</span> <span class=\"n\">f.invFun</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n    <span class=\"n\">convert</span> <span class=\"n\">Finset.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hb0</span>\n    <span class=\"n\">ext</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">MulEquiv.toEquiv_eq_coe</span><span class=\"o\">,</span> <span class=\"n\">Equiv.invFun_as_coe</span><span class=\"o\">,</span> <span class=\"n\">MulEquiv.coe_toEquiv_symm</span><span class=\"o\">,</span>\n      <span class=\"n\">MulEquiv.self_comp_symm</span><span class=\"o\">,</span> <span class=\"n\">Finset.image_id</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_image</span><span class=\"o\">,</span> <span class=\"n\">exists_exists_and_eq_and</span><span class=\"o\">,</span>\n      <span class=\"n\">MulEquiv.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">UniqueMul.mulHom_image_iff</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">EquivLike.injective</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span>\n    <span class=\"bp\">·</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n<span class=\"sd\">/-- `UniqueProd` is preserved under multiplicative equivalences. -/</span>\n<span class=\"kd\">@[to_additive \"`UniqueSums` is preserved under additive equivalences.\"]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mulHom_image_iff</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">UniqueProds</span> <span class=\"n\">G</span> <span class=\"bp\">↔</span> <span class=\"n\">UniqueProds</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">mulHom_image_of</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">mulHom_image_of</span> <span class=\"n\">f.symm</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">UniqueProds</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">vs</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddGroup</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">ContravariantClass</span> <span class=\"n\">L</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span>\n    <span class=\"o\">[</span><span class=\"n\">CovariantClass</span> <span class=\"n\">L</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">Function.swap</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">+</span> <span class=\"bp\">·</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">UniqueSums</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"n\">UniqueSums</span> <span class=\"o\">((</span><span class=\"n\">Lex</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">L</span><span class=\"o\">)))</span> <span class=\"k\">from</span>\n  <span class=\"o\">{</span> <span class=\"n\">uniqueAdd_of_nonempty</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"n\">A0</span> <span class=\"n\">B0</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">A.max'_mem</span> <span class=\"n\">A0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">B.max'_mem</span> <span class=\"n\">B0</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">aA</span> <span class=\"n\">bB</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">add_eq_add_iff_eq_and_eq</span> <span class=\"o\">(</span><span class=\"n\">A.le_max'</span> <span class=\"n\">a</span> <span class=\"n\">aA</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B.le_max'</span> <span class=\"n\">b</span> <span class=\"n\">bB</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finsupp</span> <span class=\"k\">in</span>\n<span class=\"kd\">instance</span> <span class=\"n\">wanted</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueSums</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">eq_zero_or_eq_zero_of_mul_eq_zero</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">b</span> <span class=\"mi\">0</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hb</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n    <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">c</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">da</span><span class=\"o\">,</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">db</span><span class=\"o\">,</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">UniqueSums.uniqueAdd_of_nonempty</span>\n      <span class=\"o\">(</span><span class=\"n\">support_nonempty_iff.mpr</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">support_nonempty_iff.mpr</span> <span class=\"n\">hb</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">support_nonempty_iff.mp</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Set.nonempty_of_mem</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">da</span> <span class=\"bp\">+</span> <span class=\"n\">db</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mem_support_iff.mpr</span>\n    <span class=\"n\">convert_to</span> <span class=\"n\">a</span> <span class=\"n\">da</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">db</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidAlgebra.mul_apply_add_eq_mul_of_forall_ne</span><span class=\"o\">]</span>\n      <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">ma</span> <span class=\"n\">nb</span> <span class=\"n\">H</span>\n      <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">H</span>\n      <span class=\"n\">apply</span> <span class=\"n\">h</span> <span class=\"n\">ma</span> <span class=\"n\">nb</span> <span class=\"n\">H</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">mul_eq_zero.not.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_or</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.mp</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.mp</span> <span class=\"n\">b0</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">UniqueSums</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">bas</span> <span class=\"o\">:=</span> <span class=\"n\">Basis.ofVectorSpace</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span>\n  <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">bas.repr</span>\n  <span class=\"n\">apply</span> <span class=\"n\">UniqueSums.addHom_image_of</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">Basis.ofVectorSpaceIndex</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"n\">r.symm</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"o\">(</span><span class=\"n\">Basis.ofVectorSpaceIndex</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">=</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n    <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">ab</span> <span class=\"n\">bc</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq.trans</span> <span class=\"n\">ab</span> <span class=\"n\">bc</span>\n    <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ab</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ab</span> <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">((</span><span class=\"n\">Basis.ofVectorSpaceIndex</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">show</span> <span class=\"n\">LinearOrder</span> <span class=\"o\">(</span><span class=\"n\">LinearExtension</span> <span class=\"o\">(</span><span class=\"n\">Basis.ofVectorSpaceIndex</span> <span class=\"n\">ℚ</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n    <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span>\n  <span class=\"n\">exact</span> <span class=\"n\">inferInstance</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instIsDomain1</span> <span class=\"o\">:</span> <span class=\"n\">NoZeroDivisors</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstance</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instIsDomain2</span> <span class=\"o\">:</span> <span class=\"n\">IsDomain</span> <span class=\"o\">(</span><span class=\"n\">AddMonoidAlgebra</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">IsDomain.mk</span>\n</code></pre></div>\n<p>I made no effort to clean up: feel free to adapt as you see fit!</p>",
        "id": 386449785,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692641997
    },
    {
        "content": "<p>There is some awkwardness, since you choose an arbitrary linear order on a type to deduce <code>UniqueSums</code>.  In some sense, this is expected: <code>UniqueSums</code> is not the \"correct\" hypothesis, it is just a sufficient one.  I do not know what a better approach could be.</p>",
        "id": 386450166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692642162
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 386457952,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692645341
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 386462467,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692647448
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 386462825,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692647611
    },
    {
        "content": "<p>I thought that I had proved <code>mulHom_image_of</code> with the assumption <code>f : H →* G</code> injective.  That should be true and better!</p>",
        "id": 386464564,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692648342
    },
    {
        "content": "<p>Still 15 or so errors in the mathport output and a few proofs timing out, but that'll be for tomorrow (unless someone feels like looking into it)</p>",
        "id": 386467059,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692649377
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/f3f8ba065f461a239bc798d69517f8231ee431f6/Mathlib/Analysis/Transcendental.lean#L1787\">https://github.com/leanprover-community/mathlib4/blob/f3f8ba065f461a239bc798d69517f8231ee431f6/Mathlib/Analysis/Transcendental.lean#L1787</a> Eventually the Lindemann-Weierstrass theorem was ported to Lean4 and all <code>sorry</code>s were removed. Thank you everyone!</p>",
        "id": 386528755,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1692681179
    },
    {
        "content": "<p>Some tactics such as <code>simp only</code> and <code>simp_rw</code> are very slow near the end of the file. This did not happen in lean3 IIRC.</p>",
        "id": 386528796,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1692681212
    },
    {
        "content": "<p>Do you want to make the pr? :)</p>",
        "id": 386532156,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692682668
    },
    {
        "content": "<p>I was thinking of taking care of PRing the NoZeroDivisors and IsDomain instances today.</p>",
        "id": 386536995,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692684510
    },
    {
        "content": "<p>(I'm just saying this, so you do not waste time with that part, which is essentially orthogonal to the actual result.)</p>",
        "id": 386537093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692684551
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6723\">#6723</a></p>",
        "id": 386580345,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1692701438
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455791\">@Yuyang Zhao</span> not sure if you noticed, but  <a href=\"https://github.com/leanprover-community/mathlib4/pull/6740\">#6740</a> is delegated to you</p>",
        "id": 390062006,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1694290829
    }
]