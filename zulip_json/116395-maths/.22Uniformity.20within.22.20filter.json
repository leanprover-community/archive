[
    {
        "content": "<p>I want to express the statement, \"as we consider sets of pairs of points in <code>s Ã—Ë¢ t</code> that get closer and closer together, the distance between each pair gets closer and closer to some <code>r : â„â‰¥0âˆ</code> in filter-ese. I tried</p>\n<ul>\n<li><code>Tendsto edist.uncurry (ğ“¤ Î± âŠ“ ğ“Ÿ (s Ã—Ë¢ t))Â (ğ“ r)</code>, but this seems to result in a vacuous statement; by rewriting I can turn such a hypothesis into <code>Â âˆ€ Îµ &gt; 0, âˆƒ Îµ' &gt; 0, âˆ€ a âˆˆ s, âˆ€ b âˆˆ t , edist a b &lt; Îµ' â†’ r - Îµ â‰¤ edist a b âˆ§ edist a b â‰¤ r + Îµ</code>, which is vacuously true if <code>edist a b</code> has nontrivial lower bound.</li>\n<li><code>Tendsto (fun (x, y) â†¦ edist x.1 y.1) (comap (Prod.map (â†‘) (â†‘) : s Ã— t â†’ Î± Ã— Î±) (ğ“¤ Î±)) (ğ“ r)</code>, but this leads to a vacuous statement even quicker, because a) I'm pretty sure <code>comap edist.uncurry (ğ“ r)</code> is just <code>ğ“¤ Î±</code> so that tendsto becomes trivial and b) anyway the comapped filter is bottom if, again, there's a nontrivial lower bound on <code>edist</code>s.</li>\n<li><code>Tendsto edist.uncurry ğ“Ÿ (s Ã—Ë¢ t) (ğ“ r)</code> itself, just for kicks, but of course that's much too coarse a filter to do what I want.</li>\n</ul>",
        "id": 536873479,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756510769
    },
    {
        "content": "<p>can you express it in non-filter-ese I don't understand what you want here</p>",
        "id": 536873704,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511008
    },
    {
        "content": "<p>how can they get closer (distance approaches <code>0</code>) but the distance approaches <code>r</code> if <code>r</code> is nonzero</p>",
        "id": 536873804,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511100
    },
    {
        "content": "<p>It gets closer, but not without bound. At some point you hit a minimum, though it may not actually be achieved.</p>",
        "id": 536873846,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511129
    },
    {
        "content": "<p>also are <code>s</code> and <code>t</code> sets in the same type?</p>",
        "id": 536873852,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511134
    },
    {
        "content": "<p>yes</p>",
        "id": 536873863,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536873846\">said</a>:</p>\n<blockquote>\n<p>It gets closer, but not without bound. At some point you hit a minimum, though it may not actually be achieved.</p>\n</blockquote>\n<p>I don't think we have a filter for that</p>",
        "id": 536873870,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511150
    },
    {
        "content": "<p>specifically they are sets in the same pseudo(e)metric space, thus the <code>edist</code></p>",
        "id": 536873871,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511152
    },
    {
        "content": "<p>can you express what you want in epsilon-delta form or whatever that makes it completely unambiguous for me</p>",
        "id": 536873928,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511206
    },
    {
        "content": "<p>I want the set of pairs of points that are \"at closest approach\", that witness the infimum distance between points drawn one from each of <code>s, t</code>; but since open sets exist and there may not actually be any points that achieve that minimum bound, I need to use a filter instead.</p>",
        "id": 536873931,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511207
    },
    {
        "content": "<p>It would probably be the filter generated by <code>{ { (x, y) | (x âˆˆ s) (y âˆˆ t) (_h : edist x y &lt; Îµ) } | Îµ &gt; 0 }</code>, but I would prefer to build it out of existing filters so I have more API to work with</p>",
        "id": 536874073,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536873931\">said</a>:</p>\n<blockquote>\n<p>I want the set of pairs of points that are \"at closest approach\", that witness the infimum distance between points drawn one from each of <code>s, t</code>; but since open sets exist and there may not actually be any points that achieve that minimum bound, I need to use a filter instead.</p>\n</blockquote>\n<p>this <em>might</em> be <code>ğ“Ÿ t âŠ“Â Filter.map (fun u =&gt; Metric.thickening u s) (ğ“ (Metric.hausdorffDist s t)) âŠ” ğ“Ÿ s âŠ“Â Filter.map (fun u =&gt; Metric.thickening u t) (ğ“ (Metric.hausdorffDist s t))</code> but I'm not sure because you're not defining your things rigorously</p>",
        "id": 536874192,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511549
    },
    {
        "content": "<p>well at least it typechecks</p>",
        "id": 536874229,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511593
    },
    {
        "content": "<p>wait no you wanted paris</p>",
        "id": 536874248,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511619
    },
    {
        "content": "<p>no I meant pairs</p>",
        "id": 536874259,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511632
    },
    {
        "content": "<p>I don't know which pairing you want without you telling me the order of the quantifiers</p>",
        "id": 536874316,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511715
    },
    {
        "content": "<p>yeah<br>\nuh, trying to come up with another definition is kind of hard, because it's precisely because this \"generalized set\" is hard to address in other ways that I'm trying to define it like this through filters, but</p>",
        "id": 536874324,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511720
    },
    {
        "content": "<p>there are about three different ways to make a product of filters</p>",
        "id": 536874331,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536874073\">said</a>:</p>\n<blockquote>\n<p>It would probably be the filter generated by <code>{ { (x, y) | (x âˆˆ s) (y âˆˆ t) (_h : edist x y &lt; Îµ) } | Îµ &gt; 0 }</code>, but I would prefer to build it out of existing filters so I have more API to work with</p>\n</blockquote>\n<p>does this not work as a precise/rigorous definition?</p>",
        "id": 536874350,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536874350\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536874073\">said</a>:</p>\n<blockquote>\n<p>It would probably be the filter generated by <code>{ { (x, y) | (x âˆˆ s) (y âˆˆ t) (_h : edist x y &lt; Îµ) } | Îµ &gt; 0 }</code>, but I would prefer to build it out of existing filters so I have more API to work with</p>\n</blockquote>\n<p>does this not work as a precise/rigorous definition?</p>\n</blockquote>\n<p>this is just <code>ğ’« (s Ã—Ë¢ t) âŠ“ ğ“¤ Î±</code></p>",
        "id": 536874404,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511859
    },
    {
        "content": "<p>that was the first thing I tried &gt;.&gt;;</p>",
        "id": 536874425,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756511886
    },
    {
        "content": "<p>because <code>Îµ</code> can be any positive number in particular it can be smaller than the distance between the sets</p>",
        "id": 536874487,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756511973
    },
    {
        "content": "<p>right, so at some point you just run out of sets<br>\nbut what I don't understand is why that's a <em>problem</em>; the principal filter also just runs out of sets/bottoms out at some point but that just means it represents something other than a 'generalized point'</p>",
        "id": 536874580,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512044
    },
    {
        "content": "<p>what do you mean you run out of sets</p>",
        "id": 536874632,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512083
    },
    {
        "content": "<p>you don't run out of sets</p>",
        "id": 536874636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512090
    },
    {
        "content": "<p>what happens is you start including the empty set</p>",
        "id": 536874649,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512097
    },
    {
        "content": "<p>which trivializes your filter</p>",
        "id": 536874660,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512107
    },
    {
        "content": "<p>with the principal filter <code>ğ’« s</code> you stop at <code>s</code></p>",
        "id": 536874760,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512169
    },
    {
        "content": "<p>... ah.</p>\n<p>What I meant was, you reach for a smaller set and there isn't one; the filter does not go on forever, a limit taken along the principal filter simply does not include any set smaller than <code>s</code></p>",
        "id": 536874772,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512174
    },
    {
        "content": "<p>Yeah</p>",
        "id": 536874776,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512177
    },
    {
        "content": "<p>but you haven't set a stopping point for <code>Îµ</code> so it keeps going</p>",
        "id": 536874780,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512183
    },
    {
        "content": "<p>That is the behavior I'm trying to replicate; something like, use <code>ğ’« (s Ã—Ë¢ t) âŠ“ ğ“¤ Î±</code> but chop off all the empty sets from the bottom (and then prove that the result is still a filter I guess)</p>",
        "id": 536874834,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512234
    },
    {
        "content": "<p>so that's tricky because you need to determine if a set is empty or not</p>",
        "id": 536874883,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512296
    },
    {
        "content": "<p>Lemme try and write the overall statement in LaTeX for you, it's borderline tautological but the hope is that it lets me reason about \"generalized neighborhoods of close points\" instead of \"preimages under the distance function\" or whatever...</p>",
        "id": 536874920,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512325
    },
    {
        "content": "<p>and that's not a condition on your domain <code>Î±</code>Â that's a condition on your sets which are <code>Set Î±</code>Â so you can't use a <code>Filter Î±</code> to encode that condition</p>",
        "id": 536874939,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512344
    },
    {
        "content": "<p>.... yeah okay, I pretty much just want to say <code>â¨… x âˆˆ s, â¨… y âˆˆ t, edist x y = Îµ</code><br>\nwhich is what I wanted to put on the other side of my lemma, but</p>",
        "id": 536875147,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512588
    },
    {
        "content": "<p>so now something happened and <code>Îµ</code> is free</p>",
        "id": 536875214,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512674
    },
    {
        "content": "<p>yeah, I think I definitely misunderstood the behavior of the <code>Tendsto</code> predicate</p>",
        "id": 536875351,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756512848
    },
    {
        "content": "<p>no I think you misunderstood the filter you're constructing</p>",
        "id": 536875417,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756512934
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Tendsto#doc\">docs#Filter.Tendsto</a> works a lot like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.MapsTo#doc\">docs#Set.MapsTo</a> (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.MapsTo.tendsto#doc\">docs#Set.MapsTo.tendsto</a> which is actually an iff but I couldn't find the iff lemma in mathlib)</p>",
        "id": 536875498,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513030
    },
    {
        "content": "<p>mmmm<br>\nIs there a nice way to represent <code>{ { (x, y) | (x âˆˆ s) (y âˆˆ t) (_h : edist x y &lt; Îµ) } | Îµ &gt; r }</code> for some given <code>r</code>?</p>",
        "id": 536875599,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513110
    },
    {
        "content": "<p>well it's</p>",
        "id": 536875632,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513143
    },
    {
        "content": "<p>uhmm</p>",
        "id": 536875636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513145
    },
    {
        "content": "<p>is there a nice way to represent <code>{(x, y) | edist x y &lt; r}</code> for some given <code>r</code>?</p>",
        "id": 536875673,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513203
    },
    {
        "content": "<p><code>{ MetricSpace.ball x r | (x : Î±) }</code>? Not really much different, I guess...</p>",
        "id": 536875799,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513332
    },
    {
        "content": "<p>I guess you can just do <code>ğ’« (s Ã—Ë¢ t) âŠ“ Filter.map (fun Îµ =&gt; { p | edist p.1 p.2 &lt; ÎµÂ }) (ğ“[&gt;] r)</code></p>",
        "id": 536875960,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513502
    },
    {
        "content": "<p>and this isn't really a uniformity thing since you're looking at distances</p>",
        "id": 536876066,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513608
    },
    {
        "content": "<p>you can't perform this construction in an arbitrary uniform space</p>",
        "id": 536876100,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513627
    },
    {
        "content": "<p>Mm<br>\nYeah, that'll probably do<br>\nThere's also a topology on sets/filters somewhere, so you could probably do an Iio if I could remember where I saw it -_</p>",
        "id": 536876117,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513648
    },
    {
        "content": "<p>point, though it feels like it should be extensible<br>\nbut I guess extensions can wait until I understand the base case lol</p>",
        "id": 536876147,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513682
    },
    {
        "content": "<p>what do you mean extensible</p>",
        "id": 536876203,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513738
    },
    {
        "content": "<p>just that while I am referring to distances, I'm only really using \"the set of points closer to each other than some arbitrary threshold\"<br>\nand saying that \"at some point this condition becomes unsatisfiable, find that point\"<br>\nwhich uses only concepts that are representable by entourages I think?</p>",
        "id": 536876354,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513818
    },
    {
        "content": "<p>so you find a point (a family of enourages instead of an ennreal) and what do you do with it?</p>",
        "id": 536876461,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513910
    },
    {
        "content": "<p>oh I guess that makes sense</p>",
        "id": 536876498,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513934
    },
    {
        "content": "<p>no I don't get it anymore</p>",
        "id": 536876531,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756513962
    },
    {
        "content": "<p>yeah<br>\nI mean don't get me wrong, in my actual <em>use case</em> the next step is \"go take a bunch of distances\", but the underlying concept of \"find the 'generalized points' of closest approach and then do something with them\" is something that should be representable in terms of entourages</p>",
        "id": 536876575,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756513993
    },
    {
        "content": "<p>this is no \"closest approach\" in a uniform space for sets which are separated</p>",
        "id": 536876616,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756514021
    },
    {
        "content": "<p>I can have a partial uniform equivalence which rotates my set Ï€ radians and suddenly the closest approach is on the other side</p>",
        "id": 536876651,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756514064
    },
    {
        "content": "<p>wouldn't the uniformity have to change to fit that definition tho?</p>",
        "id": 536876688,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756514098
    },
    {
        "content": "<p>it's an uniform equivalence meaning it preserves the uniformity</p>",
        "id": 536876717,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756514120
    },
    {
        "content": "<p>huh</p>",
        "id": 536876724,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756514127
    },
    {
        "content": "<p>for example if I have (0, 1) union (2, 3) as a subspace of the real line with the induced uniformity then flipping (2, 3) and doing nothing to (0, 1) is a uniform equivalence</p>",
        "id": 536876832,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756514221
    },
    {
        "content": "<p>ah<br>\nI guess, but in that case wouldn' there be....</p>\n<p>Well, I clearly don't really understand uniformities very well, but the picture in my mind is something like, \"two points are 'close' to the extent that there are many sets containing both in the uniformity filter\"</p>\n<p>Let's talk about finite sets for a moment, then everything gets a lot easier to think about. I can then say \"find the sets in the uniformity filter that contain exactly one point from set <code>s</code> and one point from set <code>t</code>; then according to this uniformity these two points are a 'closest approach' pair\"</p>",
        "id": 536877071,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756514432
    },
    {
        "content": "<p>and that may or may not line up with any other sense of 'closeness' but as far as the uniformity is concerned that should be correct</p>",
        "id": 536877092,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756514456
    },
    {
        "content": "<p>and then we generalized to infinite sets by replacing those points with ultrafilters but the construction remains roughly the same?</p>",
        "id": 536877109,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756514478
    },
    {
        "content": "<p>finite sets are trivial since uniformities on finite sets are canonically in bijection with equivalence relations</p>",
        "id": 536877476,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756514961
    },
    {
        "content": "<p>I mean, sure, but each of those equivalence relations is saying something specific about what points are 'close'<br>\npresumably I really want to talk about compact sets tho</p>",
        "id": 536877530,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756515045
    },
    {
        "content": "<p>as my 'simple example'</p>",
        "id": 536877534,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756515056
    },
    {
        "content": "<p>compact sets should also realize their closest-approach bound, there should be actual points that are closest to each other</p>",
        "id": 536877556,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756515077
    },
    {
        "content": "<p>since the uniformity is always principal</p>",
        "id": 536877585,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515128
    },
    {
        "content": "<p>two points are indistinguishable iff they're in the same equivalence class, you can't really say any more</p>",
        "id": 536877615,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515176
    },
    {
        "content": "<p>and all the other points might as well be infinitely far away</p>",
        "id": 536877651,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515209
    },
    {
        "content": "<p>for an equivalence relation <code>r</code> its corresponding uniformity is induced by the pseudoemetric <code>fun a b =&gt; if r a b then 0 else âŠ¤</code></p>",
        "id": 536877692,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515261
    },
    {
        "content": "<p>your definition should be invariant under isomorphism, so in particular it should be invariant under bilipschitz equivalence which can make close points far and far points close</p>",
        "id": 536878013,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515707
    },
    {
        "content": "<p>uniform spaces just don't give you a \"relative closeness\" for separated sets</p>",
        "id": 536878113,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756515826
    },
    {
        "content": "<p>That sounds like it's in large part a property of disconnected topologies, though</p>\n<p>so, if we're talking about finite sets in nicer spaces...?</p>",
        "id": 536878374,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756516160
    },
    {
        "content": "<p>(or, again, moving to compact sets)</p>",
        "id": 536878378,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756516166
    },
    {
        "content": "<p>oh do you care about the stuff outside the sets</p>",
        "id": 536878494,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756516343
    },
    {
        "content": "<p>ok maybe you give an example of a \"nicer space\"</p>",
        "id": 536878511,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756516371
    },
    {
        "content": "<p>Only insofar as it makes it easier to come up with good simple baseline examples :p</p>",
        "id": 536878520,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756516395
    },
    {
        "content": "<p>in particular it seems like working in a connected space means that it's much harder to change, essentially, how far 'down' the uniformity filter a given pair of points are, without changing the filter as a whole</p>",
        "id": 536878639,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756516524
    },
    {
        "content": "<p>what do you mean \"down\"</p>",
        "id": 536879042,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756516989
    },
    {
        "content": "<p>two points are close in all entourages or they are not</p>",
        "id": 536879055,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517010
    },
    {
        "content": "<p>there's not a \"degree\" with which they can be close until you have sets of pairs of points</p>",
        "id": 536879076,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517036
    },
    {
        "content": "<p>eh? <br>\nI mean, it's a filter. Partially ordered by containment. Two arbitrary sets in the filter may be incomparable, but every set is part of a chain...?</p>",
        "id": 536879153,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517132
    },
    {
        "content": "<p>sure but how does that allow you to compare two points</p>",
        "id": 536879189,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517189
    },
    {
        "content": "<p>It doesn't <em>always</em> , but <em>sometimes</em> ;  \"closer together\" becomes a partial order but it's still an order</p>",
        "id": 536879205,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517212
    },
    {
        "content": "<p>I claim the order is symmetric</p>",
        "id": 536879233,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517236
    },
    {
        "content": "<p>Suppose that, when restricting to sets of the uniformity that contain point <code>a</code> (i.e. neighborhoods of <code>a</code>), point <code>c</code> is never in a set unless point <code>b</code> is as well; then <code>b</code> is 'absolutely closer' than <code>c</code></p>",
        "id": 536879309,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517347
    },
    {
        "content": "<p>Suppose that the same is true, but only when restricting further to sets of some subfilter <code>ğ“• â‰¥ ğ“ a</code>; then we can claim that <code>b</code> is closer than <code>c</code> along the \"direction\" <code>ğ“•</code></p>",
        "id": 536879424,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517482
    },
    {
        "content": "<p><code>b</code> is 'absolutely closer' than <code>c</code> iff <code>a</code> and <code>b</code> are inseparable <del>or <code>b</code> and <code>c</code> are inseparable</del></p>",
        "id": 536879493,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517572
    },
    {
        "content": "<p>I don't know how <code>ğ“•</code> can be considered as a \"subfilter\" if <code>ğ“• â‰¥ ğ“ a</code> ie <code>ğ“•</code> is <em>bigger</em> than <code>ğ“ a</code> (unless we're using opposite orders?)</p>",
        "id": 536879559,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517664
    },
    {
        "content": "<p>also, sets of the uniformity are <code>Set (Î± Ã— Î±)</code>, you need to use the two-dimensionalness somehow otherwise it's just a topological space</p>",
        "id": 536879604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517713
    },
    {
        "content": "<p><del>Coarser, has fewer sets, bottoms out sooner?</del> Every neighborhood of <code>a</code> is a neighborhood of <code>a</code> tautologically, but only some of them are 'neighborhoods in a particular direction'</p>",
        "id": 536879623,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517732
    },
    {
        "content": "<p>oh ok</p>",
        "id": 536879690,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517800
    },
    {
        "content": "<p>so this is a predicate on sets</p>",
        "id": 536879693,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517805
    },
    {
        "content": "<p>you're saying <code>c âˆˆ Filter.ker ğ“• â†’ b âˆˆ Filter.kerÂ ğ“•</code></p>",
        "id": 536879727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517847
    },
    {
        "content": "<p>yeah</p>",
        "id": 536879759,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517883
    },
    {
        "content": "<p>so you didn't need filters after all</p>",
        "id": 536879775,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517907
    },
    {
        "content": "<p>I don't if <code>Filter.ker</code> is nonempty, no, but my impression is that it's empty for any filter with no corresponding representing set?</p>",
        "id": 536879825,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517959
    },
    {
        "content": "<p>well if it's empty then <code>c âˆˆ Filter.ker ğ“• â†’ b âˆˆ Filter.kerÂ ğ“•</code> is vacuously true</p>",
        "id": 536879845,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756517986
    },
    {
        "content": "<p>sure but then it's no longer interesting</p>",
        "id": 536879857,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756517997
    },
    {
        "content": "<p>so come up with a more interesting definition</p>",
        "id": 536879876,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756518013
    },
    {
        "content": "<p>Also dammit yeah I got the filter ordering backward, if <code>ğ“•</code> has sets that are subsets of  <code>ğ“ a</code> then <code>ğ“• â‰¤ ğ“ a</code></p>",
        "id": 536879930,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756518096
    },
    {
        "content": "<p>Bleh</p>",
        "id": 536879931,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756518097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536879604\">said</a>:</p>\n<blockquote>\n<p>also, sets of the uniformity are <code>Set (Î± Ã— Î±)</code>, you need to use the two-dimensionalness somehow otherwise it's just a topological space</p>\n</blockquote>\n<p>well, just quantify over the base point <code>a</code>?</p>",
        "id": 536879952,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756518121
    },
    {
        "content": "<p>oh maybe I can't logic</p>",
        "id": 536879962,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756518129
    },
    {
        "content": "<p>I need to review all my work real quick</p>",
        "id": 536879966,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756518137
    },
    {
        "content": "<p>oh I think this is <em>actually</em> equivalent to <code>b = c âˆ¨ b âˆˆ Filter.ker ğ“•</code> but I can't trust myself so I'll have to prove it in Lean</p>",
        "id": 536880214,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756518373
    },
    {
        "content": "<p>ok this makes sense</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ğ“•</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">ğ“•</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†”</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">âˆ¨</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"n\">ğ“•</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">or_iff_not_imp_left</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">hbc</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_âŸ©</span>\n<span class=\"w\">  </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">resolve_left</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">hbc</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_insert_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">mem_of_superset</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">subset_insert</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_insert</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n</code></pre></div>",
        "id": 536880588,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756518827
    },
    {
        "content": "<p>... <em>huh</em></p>",
        "id": 536880759,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756518961
    },
    {
        "content": "<p>Okay, I <em>really</em> do not understand filters very well then, if they're that 'rigid'</p>",
        "id": 536880771,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756518975
    },
    {
        "content": "<p>you can try reading my proof</p>",
        "id": 536880823,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756519075
    },
    {
        "content": "<p>I'm looking at it, but I'm also thinking about how to update my general intuition about them<br>\nI've been thinking of them as 'large' objects where points can have 'trajectories', so to speak<br>\nand maybe they are, but they're not so large that there can be much in the way of internal dependencies between points, if \"b guarantees some specific other c\" is enough to say \"b is in <em>everything in</em> ğ“•\"</p>",
        "id": 536881163,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1756519512
    },
    {
        "content": "<p>I just think of them like weird \"generalized\" sets</p>",
        "id": 536881251,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756519625
    },
    {
        "content": "<p>they're really weird sometimes</p>",
        "id": 536881265,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756519655
    },
    {
        "content": "<p>but yeah for me they don't really have \"trajectories\" for individual points</p>",
        "id": 536881302,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756519743
    },
    {
        "content": "<p>I don't know how to describe my mental model of a filter</p>",
        "id": 536881373,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756519845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/channel/116395-maths/topic/.22Uniformity.20within.22.20filter/near/536881163\">said</a>:</p>\n<blockquote>\n<p>if \"b guarantees some specific other c\" is enough to say \"b is in <em>everything in</em> ğ“•\"</p>\n</blockquote>\n<p>Think of the equivalent theorem for sets, which is <code>(âˆ€ s âŠ‡ F, c âˆˆ s â†’ b âˆˆ s) â†” b = c âˆ¨ b âˆˆ F</code></p>",
        "id": 536881474,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756520063
    }
]