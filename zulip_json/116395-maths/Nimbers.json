[
    {
        "content": "<p>I just realized we don't have nimbers in mathlib!</p>",
        "id": 464516211,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724376482
    },
    {
        "content": "<p>That could be a really nice project. Defining nimber addition and multiplication, and proving that ordinals under it are a ring → field → algebraically closed field</p>",
        "id": 464516263,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724376527
    },
    {
        "content": "<p>The API design could be lifted directly from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatOrdinal#doc\">docs#NatOrdinal</a>. Basically, we prove most things for ordinals, but create the type alias <code>Nimber</code> for whenever we need to use more general properties about rings / fields / whatnot.</p>",
        "id": 464516452,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724376640
    },
    {
        "content": "<p>What would be some good notation for nimber addition and multiplication?</p>",
        "id": 464528010,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724383489
    },
    {
        "content": "<p>I'm tempted to use <code>^^^</code> for the former but I don't have good ideas for the latter</p>",
        "id": 464528020,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724383501
    },
    {
        "content": "<p>All sources I've found just use <code>⊕</code> and <code>⊗</code> which are of course unacceptable to us</p>",
        "id": 464528774,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724383845
    },
    {
        "content": "<p>I guess we could always use something boring like <code>+ₙ</code> and <code>×ₙ</code>, but being able to use <code>♯</code> and <code>⨳</code> in the NatOps file was really fun and I really wish there was an analog of that</p>",
        "id": 464530281,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724384222
    },
    {
        "content": "<p>That being said. Maybe the solution here is to not define these operations on ordinals at all.</p>",
        "id": 464530984,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724384403
    },
    {
        "content": "<p>This design works great for <code>NatOrdinal</code> since that type shares a lot of structure with <code>Ordinal</code>. They have the exact same order, and there's many connections between usual ordinal addition and natural addition, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.add_le_nadd#doc\">docs#Ordinal.add_le_nadd</a> and everything to do with the Cantor normal forms.</p>",
        "id": 464531284,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724384491
    },
    {
        "content": "<p>This is not at all the case for nimbers. They can't be ordered, and the arithmetic is completely distinct. I guess you can do things like <code>a ^^^ b ≤ a + b</code> but that's about it.</p>",
        "id": 464531882,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724384630
    },
    {
        "content": "<p>It might make sense to define <code>≤</code> on nimbers. After all, how else are you supposed to talk about minimum excluded values? This relation wouldn't nicely interact with the arithmetic, but still</p>",
        "id": 464535078,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724385403
    },
    {
        "content": "<p>Why are <code>⊕</code> and <code>⊗</code> unacceptable?</p>",
        "id": 464540692,
        "sender_full_name": "Ted Hwa",
        "timestamp": 1724387404
    },
    {
        "content": "<p><code>⊕</code> already has the much more common usage as a sum type <code>α ⊕ β</code></p>",
        "id": 464540760,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724387428
    },
    {
        "content": "<p><code>⊗</code> is a bit better, but it's still way too firmly associated with tensors in my opinion</p>",
        "id": 464540801,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724387441
    },
    {
        "content": "<p>That being said, I think I've convinced myself that defining these operation on ordinals isn't the best idea. Nimbers are an algebraically closed field, and surely we don't expect to have special symbols for \"nimber division on ordinals\" or worse, \"nimber roots on ordinals\".</p>",
        "id": 464541333,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724387635
    },
    {
        "content": "<p>These problems didn't exist on <code>NatOrdinal</code> since that's only a (commutative) semiring</p>",
        "id": 464543013,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724388815
    },
    {
        "content": "<p>All we really need to do to talk about the nimber sum on ordinals is to use the casts <code>toNimber</code> and <code>toOrdinal</code></p>",
        "id": 464546165,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724389622
    },
    {
        "content": "<p>Starting work on <a href=\"https://github.com/leanprover-community/mathlib4/tree/vi.nimber\">https://github.com/leanprover-community/mathlib4/tree/vi.nimber</a></p>",
        "id": 464557374,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724394071
    },
    {
        "content": "<p>Maybe the existing operators with a subscript?</p>",
        "id": 464569960,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724397895
    },
    {
        "content": "<p>Wait, I think I know a good compromise</p>",
        "id": 464578664,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724400184
    },
    {
        "content": "<p>I can implement <code>Xor</code> for <code>Ordinal</code> as nimber addition, but keep all other operations specific to <code>Nimber</code></p>",
        "id": 464579140,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724400392
    },
    {
        "content": "<p>XOR-ing ordinals can be a useful concept, but all the other operations really only make sense in the context of nimbers proper</p>",
        "id": 464579208,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724400422
    },
    {
        "content": "<p>...except, maybe in the contexts where we XOR ordinals, we should be using <code>Nimber</code> instead?</p>",
        "id": 464580426,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724400831
    },
    {
        "content": "<p>Yeah, I'm not sure anymore</p>",
        "id": 464580456,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724400837
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/16088\">#16088</a></p>",
        "id": 464598658,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724406246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/464580426\">said</a>:</p>\n<blockquote>\n<p>...except, maybe in the contexts where we XOR ordinals, we should be using <code>Nimber</code> instead?</p>\n</blockquote>\n<p>When do you XOR ordinals?</p>",
        "id": 464646741,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724418550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/464646741\">said</a>:Nimbers/near/464580426):</p>\n<blockquote>\n<p>When do you XOR ordinals?</p>\n</blockquote>\n<p>To add together Sprague-Grundy values for games, and basically nowhere else</p>",
        "id": 464767503,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724460766
    },
    {
        "content": "<p>That's kinda my point, it might be better if we simply make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SetTheory.PGame.grundyValue#doc\">docs#SetTheory.PGame.grundyValue</a> return <code>Nimber</code></p>",
        "id": 464767526,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724460800
    },
    {
        "content": "<p>btw just proved that nimbers are a commutative domain</p>",
        "id": 464767540,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724460830
    },
    {
        "content": "<p>I'll build up probably up to division in <a href=\"https://github.com/leanprover-community/mathlib4/tree/vi.nimber_mul\">https://github.com/leanprover-community/mathlib4/tree/vi.nimber_mul</a> while the initial PR gets approved</p>",
        "id": 464767608,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724460892
    },
    {
        "content": "<p>I have no idea how to show nimbers are algebraically closed, I'll have to look that up and see if it's feasible</p>",
        "id": 464767617,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724460912
    },
    {
        "content": "<p>I looked it up</p>",
        "id": 464796421,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479533
    },
    {
        "content": "<p>It seems hard but definitely feasible</p>",
        "id": 464796427,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479541
    },
    {
        "content": "<p>Basically, you proceed by contradiction. If they weren't algebraically closed, you could take the smallest polynomial (in lexicographic order) without a root. Consider the least ordinal containing all roots of previous polynomials closed under all four (three) field operations. Prove that this is a root of said polynomial.</p>",
        "id": 464796542,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479655
    },
    {
        "content": "<p>There is an issue... Conway does operations on both ordinals and nimbers!</p>",
        "id": 464796561,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479678
    },
    {
        "content": "<p>His notation is that he does ordinal operations in square brackets. So [2 × 2] = 4 while 2 × 2 = 3. Clearly this won't work for us.</p>",
        "id": 464796621,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479710
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 464796635,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479736
    },
    {
        "content": "<p>I'm still not sure if this justifies defining these operations on the <code>Ordinal</code> type. By doing so, we lose all of the cool field theorems and tactics.</p>",
        "id": 464796885,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724479968
    },
    {
        "content": "<p>And if we're going to have to cast things anyways, casting operations from Ordinal into Nimber is probably better than the converse</p>",
        "id": 464796923,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724480006
    },
    {
        "content": "<p>I'll just keep going like this. If we ever need to define nim arithmetic on ordinals, we do it. Otherwise, we don't.</p>",
        "id": 464799529,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724481551
    },
    {
        "content": "<p>Anyways... I managed to show nimbers form a field!</p>",
        "id": 464808510,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724486476
    },
    {
        "content": "<p>The proof for showing that the nimbers are algebraically complete is a bit convoluted, and Conway as usual skims over a few important details. So here's an attempt at giving a more thorough explanation to be used as a blueprint for formalization. This is all adapted from pages 57 and 58 of On Numbers And Games.</p>\n<p>First, to contextualize Conway's notation. Conway uses the standard x + y and xy notation for nimber operations, and square brackets [x + y] and [xy] for ordinal operations. I think the best way to handle this ourselves is to just define local notation <code>x +ₒ y = toNimber (toOrdinal x + toOrdinal y)</code>, etc. so I'll write the proof in this style too. Confusingly, Conway sometimes writes x - y even though nimbers are of characteristic 2 (to perhaps suggest y is less than x?), so I'll just change that to x + y.</p>\n<p>Conway also talks about nimbers being groups, rings, or fields. The Mathlib translation would be that certain intervals <code>Iio a</code> are closed under addition, multiplication, and multiplicative inverses, respectively.</p>\n<p>A final thing to note: the \"excludents\" of a Nim sum or product simply refer to the nimbers in the minimum excluded values of their respective definitions.</p>",
        "id": 464941357,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724561837
    },
    {
        "content": "<p><strong>Lemma 1:</strong> If <code>x</code> is a group, then <code>x *ₒ y + z = x *ₒ y +ₒ z</code> for any <code>y</code> and for <code>z &lt; x</code>. </p>\n<p>This is a very standard inductive proof, where you just show the excludents of the nim sum <code>x *ₒ y + z</code>precisely coincide with the nimbers less than <code>x *ₒ y +ₒ z</code>. Specifically, the excludents either take the form <code>(x *ₒ y' +ₒ w) + z = x *ₒ y' + (w + z)</code> for <code>y' &lt; y</code> and <code>w &lt; x</code> or <code>x *ₒ y + z' = x *ₒ y +ₒ z'</code> for <code>z' &lt; z</code>. Since <code>x</code> is a group, the expression <code>w + z</code> in the first set ranges over all values less than <code>x</code> as <code>w</code> does.</p>",
        "id": 464942120,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724562100
    },
    {
        "content": "<p>...actually, wait a second</p>",
        "id": 464943763,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563150
    },
    {
        "content": "<p>I'm not at all convinced that Conway's proof actually works.</p>",
        "id": 464943765,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563157
    },
    {
        "content": "<p>Oh, of course. There's a note a few pages later about how the proof for theorem 44 is incomplete. And I don't really know how to fix it.</p>",
        "id": 464944434,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563521
    },
    {
        "content": "<p>In fact, I'd argue the usage of theorem 44 in theorem 45 (the main result) is incorrect too.</p>",
        "id": 464944673,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563743
    },
    {
        "content": "<p>Theorem 44 says that if <code>x</code> is a ring but not a field, and <code>y</code> is the largest group less than the least non-invertible element in <code>x</code>, then <code>x ^ n * cₙ + ... + x * c₁ + a = x *ₒ (y ^ₒ (n - 1) *ₒ cₙ₋₁ +ₒ ... +ₒ c₁) +ₒ a</code> for <code>cᵢ &lt; y</code> and <code>a &lt; x</code>.</p>",
        "id": 464944694,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563770
    },
    {
        "content": "<p>But Theorem 45 uses 44 in the case where <code>x</code> is a field, by setting <code>y = x</code>. I don't believe that's correct.</p>",
        "id": 464944757,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724563808
    },
    {
        "content": "<p>And moreso, Conway reduces the proof of theorem 44 to proving <code>x ^ (n + 1) = x *ₒ y ^ₒ n</code>. That might be correct, but at least I can't see how the proof follows from that.</p>",
        "id": 464945181,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724564005
    },
    {
        "content": "<p>...does anyone know of any other exposition of the proof? This is hurting my head.</p>",
        "id": 464945225,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724564018
    },
    {
        "content": "<p>I believe I know of a way to make the proof work if you can show theorem 46 first, which is that for <code>x</code> a field and <code>cᵢ &lt; x</code>, you have <code>x ^ n * cₙ + ... + c₀ = x ^ₒ n *ₒ cₙ +ₒ ... +ₒ c₀</code>. Conway seems to imply theorem 46 follows from 45, but again, I don't really see how that can be the case.</p>",
        "id": 464945826,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724564515
    },
    {
        "content": "<p>And from Lemma 1, which seems completely correct to me, I think this should follow from just knowing <code>x ^ n * c = x ^ₒ n *ₒ c</code>, since <code>x ^ n</code> should be a group whenever <code>x</code> is.</p>",
        "id": 464946237,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724564897
    },
    {
        "content": "<p>Unfortunately <code>x ^ n</code> won't always be a ring, which means you can't use theorem 42 for this.</p>",
        "id": 464946283,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724564937
    },
    {
        "content": "<p>Wait... isn't theorem 46 false? 2 is a field yet <code>2 ^ 2 = 3</code> does not match <code>2 ^ₒ 2 = 4</code>.</p>",
        "id": 464946600,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565074
    },
    {
        "content": "<p>I hope this is just a big misunderstanding on my part. If not, what a mess.</p>",
        "id": 464946680,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565113
    },
    {
        "content": "<p>Oh, never mind. I see that theorem 46 only works for exponents less than the degree of the least polynomial in lexicographic order without a root.</p>",
        "id": 464947112,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565412
    },
    {
        "content": "<p>But then I don't really understand where the theorem comes from.</p>",
        "id": 464947318,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565572
    },
    {
        "content": "<p>Is theorem 44 even being used in theorem 45? In fact, can we not just prove theorem 45 directly? I don't know.</p>",
        "id": 464947384,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565589
    },
    {
        "content": "<p>I think the course of action is to ask on MathOverflow.</p>",
        "id": 464948275,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724565955
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/q/477566/147705\">https://mathoverflow.net/q/477566/147705</a></p>",
        "id": 464953968,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724568439
    },
    {
        "content": "<p>Alright, I've got another exposition of the proof that's hopefully clearer.</p>",
        "id": 464968101,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724576564
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/_CbaueXM8GCoiPXFTEGLnoD-/image.png\">image.png</a><br>\nOk, this all makes much more sense</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_CbaueXM8GCoiPXFTEGLnoD-/image.png\" title=\"image.png\"><img data-original-dimensions=\"926x467\" src=\"/user_uploads/thumbnail/3121/_CbaueXM8GCoiPXFTEGLnoD-/image.png/840x560.webp\"></a></div>",
        "id": 464968396,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724576772
    },
    {
        "content": "<p>This is page 440 of Siegel's Combinatorial Game Theory</p>",
        "id": 464968413,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724576797
    },
    {
        "content": "<p>This is proven alongside the simplest extension theorem, but I don't think we need that with the explicit definition of the inverse I showed. That can be a separate project for someone else that's interested.</p>",
        "id": 464968741,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724577088
    },
    {
        "content": "<p>That is, we just need to show lemma 4.4 and theorem 4.3 (d)</p>",
        "id": 464968858,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724577162
    },
    {
        "content": "<p>In fact... I don't think we even need lemma 4.4 (b')</p>",
        "id": 464969036,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724577348
    },
    {
        "content": "<p>Ok, so, for the blueprint</p>",
        "id": 464971175,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724578384
    },
    {
        "content": "<p>Lemma 1 is unchanged</p>",
        "id": 464971206,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724578403
    },
    {
        "content": "<p>It seems you already solved this, but: does <a href=\"https://arxiv.org/abs/math/0410026\">https://arxiv.org/abs/math/0410026</a> clarify some questions about rigours? I'm not sure if it covers nimbers, but it does explain the basics about games.</p>",
        "id": 464978611,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1724580455
    },
    {
        "content": "<p>Haha, I've read that paper before. It was a key aid in the surreal multiplication proof. Unfortunately it doesn't cover much about nimbers.</p>",
        "id": 464978955,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724580491
    },
    {
        "content": "<p>But yeah, I think I've solved my problems. Currently writing down Lemma 2...</p>",
        "id": 464979025,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724580502
    },
    {
        "content": "<p><strong>Lemma 2:</strong> if <code>x</code> is a field where all polynomials of degree less or equal to <code>n</code> have roots, then <code>x ^ m * a = x ^ₒ m *ₒ a</code> for <code>m ≤ n</code> and <code>a &lt; x</code>.</p>\n<p>Proceed by induction on <code>m</code>. The case <code>m = 0</code> is trivial. We first show the general case for <code>a = 1</code>. Any <code>y &lt; x ^ₒ m</code> can be written as <code>x ^ₒ (m - 1) *ₒ aₘ₋₁ +ₒ ... +ₒ aₒ = x ^ (m - 1) * aₘ₋₁ + ... + aₒ = x ^ m + f(x)</code> for a monic degree <code>m</code> polynomial <code>f</code>. By hypothesis, <code>f</code> has at least one root <code>r</code>, so we can rewrite <code>x ^ m + f(x) = x ^ m + (x + r) * g(x) = x ^ (m - 1) * r + (x + r) * (x ^ (m - 1) + g(x))</code>. Since <code>r &lt; x</code> and <code>x ^ (m - 1) + g(x) &lt; x ^ (m - 1)</code>, we conclude this is an excludent for <code>x ^ (m - 1) * x = x ^ m</code>. </p>\n<p>Conversely, every excludent for <code>x ^ (m - 1) * x</code> has the form <code>a * x + x ^ (m - 1) * b + a * b</code> for <code>a &lt; x ^ (m - 1)</code> and <code>b &lt; x</code>. This can be written as a polynomial over <code>x</code> of degree <code>m - 1</code>. By induction, we can rewrite that as an ordinal sum, which will be less than <code>x ^ₒ m</code>. We conclude <code>x ^ m = x ^ₒ m</code>.</p>\n<p>Notice also that by this same argument of rewriting as a polynomial,<code>x ^ m</code> is closed under addition, and under multiplication by nimbers less than <code>x</code>.</p>\n<p>For arbitrary <code>a &lt; x</code>, we have that <code>x ^ m * a</code> is the mex of <code>x ^ m * a' + x' * (a + a')</code> for <code>x' &lt; x ^ m</code> and <code>a' &lt; a</code>. Since <code>x</code> is a field, <code>a + a'</code> is invertible, and thus <code>x' * (a + a')</code> takes all values less than<code>x ^ m</code> as <code>x' &lt; x ^ m</code> varies. Therefore, <code>x ^ m * a</code> is the mex of <code>x ^ m * a' + b</code> for <code>a' &lt; a</code> and <code>b &lt; x ^ m</code>. By Lemma 1, we can rewrite this as <code>x ^ m * a' +ₒ b</code>, and by induction we can rewrite as <code>x ^ m *ₒ a' +ₒ b = x ^ₒ m *ₒ a' +ₒ b</code>. This is the typical ordinal less than <code>x ^ₒ m *ₒ a</code>, so we conclude <code>x ^ m * a = x ^ₒ m *ₒ a</code>.</p>",
        "id": 464986887,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724581797
    },
    {
        "content": "<p>This is probably going to be the hardest part of the proof by far.</p>",
        "id": 464987004,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724581811
    },
    {
        "content": "<p><strong>Lemma 3:</strong> The nimbers forming a field are unbounded.</p>\n<p>This one is a very standard argument. For any nimber <code>x₀</code>, take the set of all sums, products, and inverses in <code>x₀</code>, as well as any nimbers below them, to create <code>x₁</code>. Build a sequence indexed by <code>ℕ</code> in this manner. The supremum of all <code>xᵢ</code> will be a field at least larger than <code>x₀</code>.</p>",
        "id": 464988320,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724582087
    },
    {
        "content": "<p><strong>Lemma 4:</strong> If <code>x</code> is a field that isn't algebraically closed, then <code>x</code> is a root of the smallest polynomial <code>f</code> in <code>x</code> in lexicographic order without a root.</p>\n<p>Let <code>n</code> be the degree of <code>f</code>. Clearly <code>f</code> is monic, so we write <code>f = X ^ n + g</code> for <code>g</code> of degree at most <code>n - 1</code>. For any <code>g' ≺ g</code>, we have <code>X ^ n + g' ≺ X ^ n + g</code>, meaning it has a root <code>r</code> and we can write <code>g'(x) = x ^ n + (x ^ n + g'(x)) = x ^ n + (x + r) * h(x) = r * x ^ (n - 1) + (x + r) * (x ^ (n - 1) + h(x))</code>. Again, this is an excludent for <code>x ^ n</code>. By Lemma 3, this implies all ordinals less than <code>g(x)</code> are excludents for <code>x ^ n</code>.</p>\n<p>Conversely (just as in Lemma 2), every excludent of <code>x ^ n = x * x ^ (n - 1)</code> has the form <code>a * x + x ^ (n - 1) * b + a * b</code>. If <code>g(x)</code> were an excludent, we could write <code>g(x) = a * x + x ^ (n - 1) * b + a * b</code>, then compare the base <code>x</code> ordinal expansions of both (by Lemma 2) to deduce <code>g = a * X + X ^ (n - 1) * b + a * b</code> as polynomials (this is a subtle point not adressed in Siegel!) Thus <code>f = X ^ n + g</code> can be straightforwardly be shown to have the root <code>b</code>, a contradiction.</p>\n<p>We conclude <code>x ^ n = g(x)</code>and thus <code>f(x) = 0</code>.</p>",
        "id": 464995541,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724584414
    },
    {
        "content": "<p><strong>Theorem:</strong> Nimbers are algebraically closed.</p>\n<p>We prove that every (non-constant) polynomial has a root, by induction on the lexicographic order. If <code>f</code> has no root but all previous polynomials do, we first build a field <code>x₀</code> containing all coefficients of <code>f</code> (Lemma 3). Then we construct a sequence of fields <code>F : ℕ → ON₂</code> such that each subsequent field <code>F(n + 1)</code> contains <code>F(n)</code>, as well as all roots of lexicographically earlier polynomials to <code>p</code> <strong>within</strong> <code>F(n)</code> (as otherwise this might be a proper class!) The union of all these fields is a field such that <code>f</code> is the smallest polynomial in it without a root, so by Lemma 4, we conclude it actually did have a root.</p>",
        "id": 464996514,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724584665
    },
    {
        "content": "<p>I think all of this is doable in Lean. But it's probably going to take me a month or even two.</p>",
        "id": 464996727,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724584726
    },
    {
        "content": "<p>If anyone else wants to join in, that'd be awesome.</p>",
        "id": 464997082,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724584821
    },
    {
        "content": "<p>I'd love to help, although I'm not sure if I'll have the time</p>",
        "id": 464999630,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724586670
    },
    {
        "content": "<p>I think either Lemma 1 or Lemma 3 is a good starting point. You can build off <a href=\"https://github.com/leanprover-community/mathlib4/tree/vi.nimber_mul\">my branch</a> which already proves nimbers are a field.</p>",
        "id": 464999900,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724586743
    },
    {
        "content": "<p>Unfortunately I won't have time to start the proof for the next few days.</p>",
        "id": 465000015,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724586778
    },
    {
        "content": "<blockquote>\n<p>Conway also talks about nimbers being groups, rings, or fields. The Mathlib translation would be that certain intervals <code>Iio a</code> are closed under addition, multiplication, and multiplicative inverses, respectively.</p>\n</blockquote>\n<p>How are you planning to do that? I think the most natural way would've been to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsAddSubgroup#doc\">docs#IsAddSubgroup</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSubring#doc\">docs#IsSubring</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSubfield#doc\">docs#IsSubfield</a> on <code>Set.Iio x</code>, but those are deprecated so it's not a good idea.</p>",
        "id": 465000931,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724587019
    },
    {
        "content": "<p>I asked about this on Xena. The conclusion I ended up with is that it's probably better to just define these predicates ourselves. For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>The proofs should hold by vacuity for <code>0</code>, so we don't need to specify it in our definition. Also, there's no need to specify closure under inverses, since <code>x - y</code> is the same as <code>x + y</code>. So really, all we care about are the closure properties.</p>",
        "id": 465001246,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587162
    },
    {
        "content": "<p>It'd be a bit awkward to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup#doc\">docs#AddSubgroup</a>, not only because of the unneeded extra conditions, but also because it's a type rather than a predicate on a set. We'd have to write <code>∃ s : AddSubgroup Nimber, x = ↑s</code>, which of course isn't very ideal.</p>",
        "id": 465001422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587264
    },
    {
        "content": "<p>Defining <code>IsGroup.toAddSubgroup</code> should be fine though, right?</p>",
        "id": 465001488,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724587306
    },
    {
        "content": "<p>Sure, though I don't think it'll be needed for the proof.</p>",
        "id": 465001600,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587378
    },
    {
        "content": "<p>...actually, it might be. On Lemma 4 we employ properties about the factorization of polynomials on <code>x</code>, which means we need a field instance somewhere.</p>",
        "id": 465001756,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587436
    },
    {
        "content": "<p>We might be able to get away with just using the instance from <code>Nimber</code> though. That remains to be seen.</p>",
        "id": 465001920,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/464999900\">said</a>:</p>\n<blockquote>\n<p>I think either Lemma 1 or Lemma 3 is a good starting point. You can build off <a href=\"https://github.com/leanprover-community/mathlib4/tree/vi.nimber_mul\">my branch</a> which already proves nimbers are a field.</p>\n</blockquote>\n<p>How should I work with the branch? Make a branch off of it and then PR back to it?</p>",
        "id": 465002099,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724587522
    },
    {
        "content": "<p>I think it's fine if you push directly. This is supposed to be somewhat of a test branch, from which we can then extract stuff for PRs. Just do tell me if and what you start work on, so we don't end up doing the same thing twice!</p>",
        "id": 465002859,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587718
    },
    {
        "content": "<p>By the way. All of this should probably go in a different file than the existing nimber file. I'm thinking we can have SetTheory/Ordinal/Nimber/Basic.lean and SetTheory/Ordinal/Nimber/Algebraic.lean</p>",
        "id": 465002984,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724587758
    },
    {
        "content": "<p>Do we have <code>a &lt; b + c &lt;-&gt; (a &lt; b or exists d &lt; c, a = b + d)</code> (for ordinals <code>a b c</code>)?</p>",
        "id": 465007075,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724590167
    },
    {
        "content": "<p>This can be deduced from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.add_sub_cancel_of_le#doc\">docs#Ordinal.add_sub_cancel_of_le</a></p>",
        "id": 465007596,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724590319
    },
    {
        "content": "<p>Ordinal subtraction <code>a - b</code> is defined so that <code>b + (a - b) = a</code> for <code>b ≤ a</code>, and <code>a - b = 0</code> otherwise. So it explicitly gives you the value of <code>d</code> in your theorem.</p>",
        "id": 465008002,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724590382
    },
    {
        "content": "<p>We also have ordinal division and moduli, which encode the result that for any ordinals <code>x</code> and <code>y ≠ 0</code>, you can write <code>x = y * q + r</code> for <code>r &lt; y</code>.</p>",
        "id": 465008500,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724590462
    },
    {
        "content": "<p>I'm almost done with Lemma 1</p>",
        "id": 465012426,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724592998
    },
    {
        "content": "<p>Tell me when you push it to the branch!</p>",
        "id": 465026078,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724602318
    },
    {
        "content": "<p>I pushed it</p>",
        "id": 465033530,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724610135
    },
    {
        "content": "<p>I also proved lemma 3</p>",
        "id": 465072503,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724642238
    },
    {
        "content": "<p>Nice!</p>",
        "id": 465078426,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724645525
    },
    {
        "content": "<p>I've got some time tonight to work on this, I'll try to do the final part of the proof after Lemma 4.</p>",
        "id": 465093185,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724653437
    },
    {
        "content": "<p>I golfed the proofs down a bit <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 465110957,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724659456
    },
    {
        "content": "<p>I'm having a bit of trouble even writing the statement for the prerequisite lemma 4 down though.</p>",
        "id": 465111645,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724659672
    },
    {
        "content": "<p>How do we talk about \"the least polynomial with coefficients within this subset without a root under lexicographic order?\"</p>",
        "id": 465111780,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724659691
    },
    {
        "content": "<p>I <em>think</em> the relation would be <code>p ≺ q ↔ Finsupp.lex (· &gt; ·) (· &lt; ·) p q</code></p>",
        "id": 465114452,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724660168
    },
    {
        "content": "<p>Oh yeah, that's definitely it</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The lexicographic ordering on polynomials. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">polynomial_LT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">toFinsupp</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">toFinsupp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wellFounded_polynomial_LT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"n\">polynomial_LT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">InvImage</span><span class=\"bp\">.</span><span class=\"n\">wf</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">Lex</span><span class=\"bp\">.</span><span class=\"n\">wellFounded'</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"n\">lt_wf</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_wfRel</span><span class=\"bp\">.</span><span class=\"n\">wf</span>\n</code></pre></div>",
        "id": 465119985,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724661168
    },
    {
        "content": "<p>I'd like to thank <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> for having <code>Finsupp.Lex.wellFounded</code> in Mathlib, haha</p>",
        "id": 465121658,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724661524
    },
    {
        "content": "<p>That would've been a struggle otherwise</p>",
        "id": 465121680,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724661535
    },
    {
        "content": "<p>It's been quite painful to show that for any nimber, the set of polynomials with coefficients less than it is a small type. Not because it's hard, the API around <code>enum</code> and <code>typein</code> is just kind of bad.</p>",
        "id": 465163934,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724674528
    },
    {
        "content": "<p>There's some stuff I want to change I'll write out here for future reference</p>\n<ul>\n<li>Rename <code>Ordinal.out.α</code> to a much more discoverable <code>Ordinal.toType</code></li>\n<li>Make the type in <code>typein</code> and <code>enum</code> explicit</li>\n<li>Make auxiliary definitions <code>typein_lt</code> and <code>enum_lt</code> for interfacing with <code>toType</code> that avoid the instance inference issues, and having to awkwardly rewrite <code>o.toType.type = o</code> yourself</li>\n</ul>",
        "id": 465164294,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724674642
    },
    {
        "content": "<p>Just managed to show it. I think that's all I can work on this for today.</p>",
        "id": 465169788,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724675676
    },
    {
        "content": "<p>Pushed my progress onto the branch</p>",
        "id": 465170028,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724675714
    },
    {
        "content": "<p>Actually, I don't think <code>typein</code> and such are even really necessary for this proof</p>",
        "id": 465191381,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724679930
    },
    {
        "content": "<p>Something else I really need to do is add some API for <code>Small</code></p>",
        "id": 465191523,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724679951
    },
    {
        "content": "<p>This result should follow relatively easily from a <code>Small</code> instance on finsupps</p>",
        "id": 465191853,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724679992
    },
    {
        "content": "<p>Eventually we should work on getting rid of <code>blsub2</code> and all that stuff</p>",
        "id": 465192029,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724680019
    },
    {
        "content": "<p>I tried to write the proof of lemma 2 in full detail, please tell me if I'm missing something:</p>\n<p>Set <code>K = IsField.toSubfield x</code>.<br>\nSub-lemma 1 (this has to be inside of the induction):<br>\nFor every natural number <code>d ≤ m</code> and nimber <code>y &lt; x ^ₒ d</code> there exists a polynomial <code>p : K[X]</code> with degree less than <code>d</code> such that <code>y = p(x)</code>.<br>\nProof:<br>\nInduction on <code>d</code>. We can write <code>y = x ^ₒ (d - 1) *ₒ (y /ₒ (x ^ₒ (d - 1)) +ₒ y %ₒ (x ^ (d - 1))</code>. By lemma 1 this is equal to <code>x ^ₒ (d - 1) *ₒ (y /ₒ (x ^ₒ (d - 1)) + y %ₒ (x ^ (d - 1))</code>, by the large induction this is equal to <code>x ^ (d - 1) * (y /ₒ (x ^ₒ (d - 1)) + y %ₒ (x ^ (d - 1))</code>, and by the sub-lemma induction, we can write <code>y %ₒ (x ^ (d - 1)) = aeval x q</code> for <code>degree x &lt; d - 1</code>. Now set <code>p = ((y /ₒ (x ^ₒ (d - 1))) * X ^ (d - 1) + q</code>.</p>\n<p>Sub-lemma 2:<br>\nFor every natural number <code>d ≤ m</code> and polynomial <code>p : K[X]</code> with degree less than <code>d</code>, <code>p(x) &lt; x ^ₒ d</code>.<br>\nProof:<br>\nBy induction on <code>d</code>. We can write <code>p(x) = x ^ (d - 1) * a + q(x)</code> with <code>a &lt; x</code>. By the large induction, this is <code>x ^ₒ (d - 1) *ₒ a + q(x)</code>. By the induction hypothesis, <code>q(x) &lt; x ^ₒ (d - 1)</code>, so by lemma 1 this is <code>x ^ₒ (d - 1) *ₒ a +ₒ q(x) &lt; x ^ₒ (d - 1) *ₒ a +ₒ x ^ₒ (d - 1) = x ^ₒ (d - 1) *ₒ (succ a) ≤ x ^ₒ (d - 1) *ₒ x = x ^ₒ d</code>.</p>\n<p>Sub-lemma 3:<br>\nFor every nimber <code>y &lt; x ^ₒ m</code> and nimber <code>a &lt; x</code>, <code>y * a &lt; x ^ₒ m</code><br>\nProof:<br>\nBy sub-lemma 1, <code>y = p(x)</code> for <code>deg(p) &lt; m</code>. Now <code>y * a = (p*a)(x)</code>, and <code>deg(p*a) &lt; m</code>. Applying sub-lemma 2, the result follows.</p>\n<p>We start by showing that <code>x ^ₒ m = x ^ m</code>. By definition we have <code>x ^ m = x ^ (m - 1) * x = mex {a * x + x ^ (m - 1) * b + a * b | a &lt; x ^ (m - 1), b &lt; x}</code>. We will show that <code>{a * x + x ^ (m - 1) * b + a * b | a &lt; x ^ (m - 1), b &lt; x} = Set.Iio (x ^ₒ m)</code>.<br>\nBy the induction we have <code>x ^ (m - 1) = x ^ₒ (m - 1)</code></p>\n<p>For one direction of the inclusion, let there be <code>y &lt; x ^ₒ m</code>. We use sub-lemma 1 to write it as <code>aeval p x</code> for <code>degree p &lt; m</code>. Now set <code>f = X^m + p</code>, which has degree <code>m</code> and is monic. By hypothesis, <code>f</code> has a root <code>r &lt; x</code>, so we can write <code>f = (X + r) * g</code> for a monic <code>g</code>, and rewrite <code>y = x^m + f(x) = x ^ m + (x + r) * g(x) = (x ^ (m - 1) + g(x)) * x + x ^ (m - 1) * r + (x ^ (m - 1) + g(x)) * r</code>, which is exactly the form of an excludent. We have <code>r &lt; x</code>, and <code>x ^ (m - 1) + g(x) &lt; x ^ (m - 1) = x ^ₒ (m - 1)</code> by applying sub-lemma 2 to <code>g + X ^ (m - 1)</code>.</p>\n<p>For the other direction of the inclusion, we need to show <code>a * x + x ^ (m - 1) * b + a * b &lt; x ^ₒ m</code>, for <code>a &lt; x ^ₒ (m - 1), b &lt; x = x ^ₒ 1</code>. <br>\nUsing sub-lemma 1 we can write <code>a, b</code> as polynomials evaluated at <code>x</code>, and computing the degree of <code>a * X + X ^ (m - 1) * b + a * b</code> it's at most <code>m</code>, so sub-lemma 2 gives the desired conclusion.</p>\n<p>Now we have to prove <code>x ^ₒ m * y = x ^ₒ m *ₒ y</code> for <code>y &lt; x</code>. We will use induction on <code>y</code>.<br>\nBy definition <code>x ^ₒ m * y = mex {a * y + x ^ₒ m * b + a * b | a &lt; x ^ₒ m, b &lt; y}</code>, and again we will prove <code>{a * y + x ^ₒ m * b + a * b | a &lt; x ^ₒ m, b &lt; y} = Set.Iio (x ^ₒ m *ₒ y)</code>.</p>\n<p>For one direction of the inclusion, let there be <code>z &lt; x ^ₒ m *ₒ y</code>. We can write <code>z = x ^ₒ m * (z /ₒ (x ^ₒ m)) + z %ₒ (x ^ₒ m)</code>, which is an excludent, setting <code>b = z /ₒ (x ^ₒ m), a = (z %ₒ (x ^ₒ m)) / (b + y)</code> (we have <code>a &lt; x ^ₒ m</code> because <code>b + y &lt; x</code>, and as <code>x</code> is a field <code>(b + y)⁻¹ &lt; x</code>, then applying sub-lemma 3).</p>\n<p>For the other direction, we can write <code>a * y + x ^ₒ m * b + a * b = x ^ₒ m * b + a * (y + b)</code>. By the induction we have <code>x ^ₒ m * b + a * (y + b) = x ^ₒ m *ₒ b + a * (y + b)</code>. By lemma 1, this is <code>x ^ₒ m *ₒ b + a * (y + b)</code>. By sub-lemma 3, <code>a * (y + b) &lt; x ^ₒ m</code>, so <code>x ^ₒ m *ₒ b + a * (y + b) &lt; x ^ₒ m *ₒ b + x ^ₒ m = x ^ₒ m *ₒ (succ b) ≤ x ^ₒ m *ₒ y</code>.</p>",
        "id": 465219776,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724686451
    },
    {
        "content": "<p>For sub-lemmas 1 and 2, in order to use lemma 1, you need to argue that <code>x ^ₒ (d - 1)</code> is closed under addition. This follows from the induction though, as for <code>a, b &lt; x ^ₒ (d - 1)</code>, you can write <code>a + b = p(x) + q(x) = (p + q)(x) &lt; x ^ₒ (d - 1)</code> by the closure of <code>K</code> under addition.</p>",
        "id": 465259037,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724700730
    },
    {
        "content": "<p>I think it might be slightly cleaner to include the statements of sub-lemma 1 and 2 for <code>m = n</code> as part of the main induction. That way, you don't have to nest inductions.</p>",
        "id": 465259173,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724700796
    },
    {
        "content": "<p>Your proof seems correct to me. I really like that you managed to avoid having to evaluate <code>p : K[X]</code> as an ordinal, that's something I didn't really know how to deal with.</p>",
        "id": 465259940,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724701120
    },
    {
        "content": "<p>Hopefully Lemma 4 doesn't require this either.</p>",
        "id": 465260035,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724701155
    },
    {
        "content": "<p>I want to merge master, as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=pow_pos#doc\">docs#pow_pos</a> on the branch is outdated and requires a semiring. Is that OK?</p>",
        "id": 465469618,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724769006
    },
    {
        "content": "<p>I (mostly) proved the sublemmas for lemma 2</p>",
        "id": 465473640,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724770045
    },
    {
        "content": "<p>I think it should be fine merging master. Just note that I have some major refactors to <code>Ordinal</code> coming up, so moving forward it's probably best not to keep the branch up to date until it's ready to PR.</p>",
        "id": 465474083,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724770136
    },
    {
        "content": "<p>Is <code>(2 : Nimber)</code> equal to zero, or is it the ordinal <code>2</code> as a nimber?</p>",
        "id": 465657555,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724828111
    },
    {
        "content": "<p>The former</p>",
        "id": 465657807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724828218
    },
    {
        "content": "<p>Since the NatCast instance is derived from the ring structure</p>",
        "id": 465658064,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724828324
    },
    {
        "content": "<p>I proved the <code>x ^ₒ m = x ^ m</code> part of the lemma, but it's getting really slow, so I'll try to split some things to lemmas</p>",
        "id": 465670541,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724831057
    },
    {
        "content": "<p>I guess Conway would typically emphasize that number 2 is <code>*2</code> not <code>2</code>.</p>",
        "id": 465729508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1724842644
    },
    {
        "content": "<p>I'll try and continue the last part of the proof soon</p>",
        "id": 465774494,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724853229
    },
    {
        "content": "<p>Haven't had a lot of time unfortunately</p>",
        "id": 465774506,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1724853233
    },
    {
        "content": "<p>I finished the proof of lemma 2 <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 465798896,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724859060
    },
    {
        "content": "<p>Back and working! Is there a problem if I merge Mathlib? There seems to have been some large refactor recently, since I had to rebuild the entire thing when switching to the branch</p>",
        "id": 466533509,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725110218
    },
    {
        "content": "<p>Oh also, <code>o.out.α</code> for ordinals is now <code>o.toType</code></p>",
        "id": 466535880,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725110779
    },
    {
        "content": "<p>I finally got <code>algify x</code> to work, by which I mean that I proved that it is in fact a value larger than all roots of polynomials with coefficients less than <code>x</code>.</p>",
        "id": 466555313,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725116052
    },
    {
        "content": "<p>The final step of the proof requires something even larger, which is the <code>nfp</code> of <code>algify</code></p>",
        "id": 466565838,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725118312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/466533509\">said</a>:</p>\n<blockquote>\n<p>Back and working! Is there a problem if I merge Mathlib? There seems to have been some large refactor recently, since I had to rebuild the entire thing when switching to the branch</p>\n</blockquote>\n<p>There shouldn't be a problem</p>",
        "id": 466570889,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725119758
    },
    {
        "content": "<p>Just proved a bunch more lemmas on <code>algify</code>. Most notably, I now have a construction <code>algify'</code> satisfying <code>x ≤ algify' x</code> and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">mem_algify'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">coeffs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">algify'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">algify'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>With this, I should now be able to get the final induction to work</p>",
        "id": 466586435,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725126633
    },
    {
        "content": "<p>We've clearly collected a lot of auxiliary lemmas, I'll try and PR a few of them</p>",
        "id": 466587866,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725127263
    },
    {
        "content": "<p>What do you think the best way to write lemma 4 is?</p>",
        "id": 466603405,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725135769
    },
    {
        "content": "<p>We're saying that a non-algebraically complete field is the root of the least polynomial that doesn't have one. How do we write that last part?</p>\n<p>Should we use <code>hx.toSubfield</code>? Do we require the polynomial to be irreducible and monic, or just of degree 1 or greater?</p>",
        "id": 466603556,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725135873
    },
    {
        "content": "<p>I think using <code>hx.toSubfield</code> would be good. I don't think irreducibility is used in the proof, so I don't see a reason to include it. You'll have to show at some point that the minimal polynomial without a root is monic, either in lemma 4 or in the final theorem to apply lemma 4, and I think doing it in lemma 4 might be a bit cleaner.</p>",
        "id": 466633867,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725160379
    },
    {
        "content": "<p>Oh oops, just pushed a commit \"Lemma 4\" when I meant to say we're now only missing Lemma 4!</p>",
        "id": 466729797,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208246
    },
    {
        "content": "<p>I had to tweak our definitions of <code>addify</code>, <code>mulify</code>, etc. a bit in order to prove monotonicity, but I think that's for the better since I plan on deprecating <code>blsub₂</code> at some point</p>",
        "id": 466730236,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208511
    },
    {
        "content": "<p>I also strengthened <code>fieldify x</code> so that it also contains all the roots of polynomials with coefficients less than <code>x</code>, this ensures it can be used at all steps of the proof</p>",
        "id": 466730388,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208586
    },
    {
        "content": "<p>The last part of the proof employs the even stronger <code>nextField</code>, which is the <code>algify'</code> from before, i.e. the next fixed point of <code>fieldify</code></p>",
        "id": 466730614,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208698
    },
    {
        "content": "<p>Unfortunately I won't have much time to close out the proof these next few days</p>",
        "id": 466730807,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208773
    },
    {
        "content": "<p>Ah by the way, we didn't end up needing Lemma 3 in its original form, instead I used that proof to show that <code>nextField</code> is a field</p>",
        "id": 466731307,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1725208940
    },
    {
        "content": "<p>Back at this again! Merging master was pretty nasty with all the refactors that have been going on, but I got it to work.</p>",
        "id": 471170645,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726637025
    },
    {
        "content": "<p>There seems to have been some change with <code>refine</code>? This lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inv'_recOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inv'</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nimber</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">inv'_set</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>previously worked fine as <code>refine inv'_recOn a ?_ ?_ hx</code>, but now that doesn't work - I had to make <code>x</code> an explicit argument.</p>",
        "id": 471170786,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726637082
    },
    {
        "content": "<p>There's some pretty frustrating omissions in the polynomial library... do we really not have the fact that <code>p ≠ 0 → p.leadingCoeff ∈ p.coeffs</code>? Or that <code>p ≠ 0 → Monic (p.leadingCoeff⁻¹ • p)</code>?</p>",
        "id": 471181083,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726641880
    },
    {
        "content": "<p>I'll have a lot to PR once I complete the proof and start to clean it up.</p>",
        "id": 471181102,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726641889
    },
    {
        "content": "<p>Also, that a value in a field is smul-regular iff it's non-zero</p>",
        "id": 471181508,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726642060
    },
    {
        "content": "<p>That would be a nice <code>simp</code> lemma to have available</p>",
        "id": 471181531,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726642073
    },
    {
        "content": "<p>I don't know it's true that if you multiply a polynomial by the inverse of its leading coefficient you always get something monic. It would not surprise me if 3/3 were a junk value in Z/9, for example</p>",
        "id": 471190128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726645145
    },
    {
        "content": "<p>It should be true in a field, at least</p>",
        "id": 471190207,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726645178
    },
    {
        "content": "<p>Yes</p>",
        "id": 471190228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726645185
    },
    {
        "content": "<p>Should have specified that...</p>",
        "id": 471190242,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726645192
    },
    {
        "content": "<p>That lemma should probably be taking in a smul-regular assumption</p>",
        "id": 471190711,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726645347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/471190128\">said</a>:</p>\n<blockquote>\n<p>I don't know it's true that if you multiply a polynomial by the inverse of its leading coefficient you always get something monic. It would not surprise me if 3/3 were a junk value in Z/9, for example</p>\n</blockquote>\n<p>I don't think division is defined in Z/9Z</p>",
        "id": 471201883,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726648637
    },
    {
        "content": "<p>I'm starting to wonder if my statement of Lemma 4 was suboptimal. I defined a somewhat ad-hoc <code>noRoots</code> predicate to state it, but I could probably have used <code>toSubfield</code> instead.</p>",
        "id": 471202001,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726648675
    },
    {
        "content": "<p>As in, if <code>x</code> is a field, and <code>p</code> is the smallest polynomial lexicographically without a root in <code>x.toSubfield[X]</code>, then <code>p</code> casted to a polynomial <code>Nimber[X]</code> has <code>x</code> as a root.</p>",
        "id": 471202293,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726648759
    },
    {
        "content": "<p>Or actually, I don't think I even need to cast the polynomial, I can just use <code>aeval</code></p>",
        "id": 471202976,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726648981
    },
    {
        "content": "<p>It's a bit unfortunate having to refactor my proofs when they're not even finished, but I suspect writing things like this should make them slightly less painful.</p>",
        "id": 471203366,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726649104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/116395-maths/topic/Nimbers/near/471201883\">said</a>:</p>\n<blockquote>\n<p>I don't think division is defined in Z/9Z</p>\n</blockquote>\n<p>Sure, I was just being sloppy. I should have said \"It would not surprise me if <code>3 * 3⁻¹</code> is not 1 in ZMod 9\" (that's what's being proposed, except that this is a red herring anyway because Violeta is only interested in fields)</p>",
        "id": 471210629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1726651148
    },
    {
        "content": "<p>I guess this discrepancy does explain why I've been having trouble with the polynomial API, it's tailored to more general and less well-behaved cases</p>",
        "id": 471234455,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726658591
    },
    {
        "content": "<p>I think it's just that the preferred spelling of <code>p.leadingCoeff⁻¹ • p</code> is <code>normalize p</code> and then it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.monic_normalize#doc\">docs#Polynomial.monic_normalize</a></p>",
        "id": 471234705,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726658680
    },
    {
        "content": "<p>Oh, nice!</p>",
        "id": 471235550,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726659002
    }
]