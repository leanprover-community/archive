[
    {
        "content": "<p>I'm going to define proper maps (those for which preimages of compact set are compact). Should I have it extend <code>continuous_map</code>, or just have a bare <code>proper_map</code> and then separately a <code>proper_continuous_map</code>?</p>",
        "id": 276193235,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647957922
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/spectral_map\">docs#spectral_map</a> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 276193288,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647957942
    },
    {
        "content": "<p>Jireh, this isn't the right definition of proper maps in general</p>",
        "id": 276193910,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647958209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, you told me that my spectral maps were called proper maps in the real world. Are you sure there is no difference? Proper maps seem to have preimages of compact be compact while spectral maps have preimages of compact opens be compact open.</p>",
        "id": 276193963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647958238
    },
    {
        "content": "<p>I was going to say \"shouldn't proper actually mean universally closed\" but I don't remember the reason. But I'm more interested in whether proper-but-not-necessarily-continuous maps actually show up in math somewhere--I thought about this class of maps for a little while and if there's something written down about them, I might find it helpful.</p>",
        "id": 276194248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647958375
    },
    {
        "content": "<p>In Bourbaki, proper means continuous and universally closed.</p>",
        "id": 276194568,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647958529
    },
    {
        "content": "<p>Right, AFAIK everyone includes \"continuous\" in the meaning of \"proper\". I just meant that \"proper-but-not-continuous\" seems like a potentially useful concept, but it would need another name. (example: the \"identity\" map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>⨿</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1) \\amalg \\{1\\} \\to [0, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⨿</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> is continuous but not proper, while its inverse is proper-but-not-continuous)</p>",
        "id": 276195438,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647958886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/proper.20maps/near/276193963\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>, you told me that my spectral maps were called proper maps in the real world. Are you sure there is no difference? Proper maps seem to have preimages of compact be compact while spectral maps have preimages of compact opens be compact open.</p>\n</blockquote>\n<p>I thought they were called quasi-compact maps (c.f. <a href=\"https://stacks.math.columbia.edu/tag/005A\">stacks#005A</a>)</p>",
        "id": 276195675,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1647958964
    },
    {
        "content": "<p>Hmmz, I retract my claim.</p>",
        "id": 276196171,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647959173
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> how about \"preproper\" for a name? (semiserious)</p>",
        "id": 276196591,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1647959339
    },
    {
        "content": "<p>It sounds good if we can't find an existing term for the same concept.</p>",
        "id": 276197126,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647959549
    },
    {
        "content": "<p>Apparently in my notes I used the word \"prim\", but I don't think I got it from anywhere.</p>",
        "id": 276197217,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647959591
    },
    {
        "content": "<p>preproper reminds me a bit of <a href=\"https://wiki.haskell.org/Zygohistomorphic_prepromorphisms\">prepromorphisms</a></p>",
        "id": 276197400,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647959665
    },
    {
        "content": "<p>I thought Patrick's point was that the preimage of compact definition is the wrong version of proper map. Stacks does mention quasi-compact.</p>",
        "id": 276198132,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647959986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/proper.20maps/near/276196591\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> how about \"preproper\" for a name? (semiserious)</p>\n</blockquote>\n<p>Semiproper? (preserious suggestion)</p>",
        "id": 276198777,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647960254
    },
    {
        "content": "<p>Jireh, Reid is talking about both issues.</p>",
        "id": 276199822,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1647960652
    },
    {
        "content": "<p>My point is only that if, for example, we have proper = continuous and universally closed, and quasi-compact (?) = continuous and preimages of compact are compact, then it would be a bit strange to call preproper = preimages of compact are compact, because it wouldn't match (same goes for any substitute for preproper involving the word proper).</p>",
        "id": 276200906,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647961031
    },
    {
        "content": "<p>Right, and I don't know what the \"correct\" definition of \"proper-but-not-continuous\" should be</p>",
        "id": 276203440,
        "sender_full_name": "Reid Barton",
        "timestamp": 1647961886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I think the definition should be <code>tendsto f cocompact cocompact</code>, but maybe you've already figured this out :)</p>",
        "id": 276206203,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647962860
    },
    {
        "content": "<p>Yes, indeed. That's actually what I was planning on (more power to the filter library!) since I'm using it for functions vanishing at infinity anyway <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>. The whole point is basically to eventually get the C₀ functor.</p>",
        "id": 276206942,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647963140
    },
    {
        "content": "<p><del>Wouldn't <code>universally_closed</code> be \"proper-but-not-continuous\"?</del><br>\nRe-reading the conversation, I think that I misunderstood what was meant by \"proper-but-not-continuous\"!</p>",
        "id": 276208285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647963676
    },
    {
        "content": "<p>Bourbaki is slightly inconsistent on the definition of <code>proper</code>. It is defined in <em>Topologie générale</em>, chapter III.<br>\nAs <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> said, it means <em>continuous and universally closed</em> and they show that it is equivalent with various stuff, such as <em>continuous, closed and fibers are quasi-compact</em>. For locally compact (Hausdorff) spaces, this notion falls back to the fact that the preimages of compact sets are compact.</p>\n<p>Similarly, there are <em>separated maps</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f \\colon X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, those for which the diagonal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><msub><mo>×</mo><mi>X</mi></msub><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y \\times_X Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">×</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is a closed map.  They are defined in <em>Topologie algébrique</em>, following a similar definition in algebraic geometry. <br>\nAccording to whether one imposes to compact sets to Hausdorff, it makes sense to require proper maps to be separated.</p>\n<p>The basic results are elegant, their proofs are quite direct and their formalization should work without too much trouble.</p>",
        "id": 276254292,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1647983199
    },
    {
        "content": "<p>So, I think I would be interested in defining what I'm calling <em>cocompact continuous maps</em>, although I haven't seen these anywhere ever. These are continuous maps <code>f : α → β</code> which satisfy <code>tendsto f (cocompact α) (cocompact β)</code>. Quasi-compact maps (continuous with preimages of compact sets compact) are cocompact continuous maps, and the converse is true when the codomain is Hausdorff.</p>\n<p>I think there is a counterexample to the converse when the codomain is not Hausdorff, but I haven't checked the details carefully: the identity map from <code>ℝ</code> to the \"line with two origins\" (this map misses one of the origins); I think this is cocompact and continuous but the pre-image of the closed (and compact) interval [-1,1] (which includes the origin <em>not</em> in the range) is [-1,0) ∪ (0,1] which is not compact. Likely someone else can come up with an easier counterexample, but I never work with non-Hausdorff spaces.</p>\n<p>The reason I care about such maps is that they are exactly the things which play nice with the type <code>β →C₀ γ</code> of continuous maps which vanish at infinity (see <a href=\"https://github.com/leanprover-community/mathlib/pull/12907\">#12907</a>). In particular, if <code>f : β →C₀ γ</code> and <code>g : α → β</code> is a cocompact continuous map, then <code>f ∘ g : α →C₀ γ</code>.</p>\n<p>Here is the relevant introductory API for these maps. <strong>Please indicate if you think this does not belong in mathlib.</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2022 Jireh Loreaux. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Jireh Loreaux</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.continuous_function.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Cocompact continuous maps</span>\n\n<span class=\"cm\">The type of *cocompact continuous maps* are those which tend to the cocompact filter on the</span>\n<span class=\"cm\">codomain along the cocompact filter on the domain. When the domain and codomain are Hausdorff, this</span>\n<span class=\"cm\">is equivalent to many other conditions, including that preimages of compact sets are compact. -/</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"sd\">/-- A *cocompact continuous map* is a continuous function between topological spaces which</span>\n<span class=\"sd\">tends to the cocompact filter along the cocompact filter. Functions for which preimgaes of compact</span>\n<span class=\"sd\">sets are compact always satisfy this property, and the converse holds for cocompact continuous maps</span>\n<span class=\"sd\">when the codomain is Hausdorff (see `cocompact_map.tendsto_of_forall_preimage` and</span>\n<span class=\"sd\">`cocompact_map.compact_preimage`) -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">cocompact_map</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">continuous_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cocompact_tendsto'</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- `cocompact_map_class F α β` states that `F` is a type of cocompact continuous maps.</span>\n\n<span class=\"sd\">You should also extend this typeclass when you extend `cocompact_map`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">cocompact_map_class</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"bp\">$</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">continuous_map_class</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cocompact_tendsto</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">cocompact_map_class</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">cocompact_map_class</span> <span class=\"n\">F</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_t</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">cocompact_tendsto</span> <span class=\"n\">f</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">cocompact_map_class</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">cocompact_map</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">basics</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map_class</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_continuous</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.continuous_to_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">cocompact_tendsto</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.cocompact_tendsto'</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">export</span> <span class=\"n\">cocompact_map_class</span> <span class=\"o\">(</span><span class=\"n\">cocompact_tendsto</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`</span>\n<span class=\"sd\">directly. -/</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">fun_like.has_coe_to_fun</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_to_continuous_fun</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f.to_continuous_map</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">fun_like.ext</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n\n<span class=\"sd\">/-- Copy of a `cocompact_map` with a new `to_fun` equal to the old one. Useful</span>\n<span class=\"sd\">to fix definitional equalities. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f'</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f'</span><span class=\"o\">,</span>\n  <span class=\"n\">continuous_to_fun</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">f.continuous_to_fun</span><span class=\"o\">},</span>\n  <span class=\"n\">cocompact_tendsto'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">f.cocompact_tendsto'</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"sd\">/-- The identity as a cocompact continuous map. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">continuous_map.id</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">tendsto_id</span><span class=\"o\">⟩</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_id</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">cocompact_map.id</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">id_apply</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous_map.id</span> <span class=\"n\">α</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">cocompact_map.id</span> <span class=\"n\">α</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- The composition of cocompact continuous maps, as a cocompact continuous map. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">f.to_continuous_map.comp</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">cocompact_tendsto</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">cocompact_tendsto</span> <span class=\"n\">g</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">comp_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">comp_assoc</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f.comp</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">g.comp</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">id_comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map.id</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">comp_id</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">cocompact_map.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tendsto_of_forall_preimage</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_compact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">mem_cocompact.mp</span> <span class=\"n\">hs</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mem_map.mpr</span> <span class=\"o\">(</span><span class=\"n\">mem_cocompact.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">preimage_mono</span> <span class=\"n\">hts</span><span class=\"o\">⟩)</span> <span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact</span>\n<span class=\"sd\">continuous map. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">compact_preimage</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">cocompact_map</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">⦃</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_compact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_cocompact'.mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">preimage_image_preimage</span><span class=\"o\">,</span> <span class=\"n\">preimage_compl</span><span class=\"o\">]</span>\n    <span class=\"n\">using</span> <span class=\"n\">mem_map.mp</span> <span class=\"o\">(</span><span class=\"n\">cocompact_tendsto</span> <span class=\"n\">f</span> <span class=\"bp\">$</span> <span class=\"n\">mem_cocompact.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">compl_subset_compl.mpr</span>\n    <span class=\"o\">(</span><span class=\"n\">image_preimage_subset</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)⟩)),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">compact_of_is_closed_subset</span> <span class=\"n\">ht</span> <span class=\"o\">(</span><span class=\"n\">hs.is_closed.preimage</span> <span class=\"bp\">$</span> <span class=\"n\">map_continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hts</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">basics</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">cocompact_map</span>\n</code></pre></div>",
        "id": 276518033,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648145369
    },
    {
        "content": "<p>Keep up the good hom, Jireh!</p>",
        "id": 276518307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648145478
    },
    {
        "content": "<p>Since there didn't seem to be an strenuous objections: <a href=\"https://github.com/leanprover-community/mathlib/pull/12938\">#12938</a></p>",
        "id": 276643708,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1648225270
    },
    {
        "content": "<p>I've just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/6005\">#6005</a> (still WIP) setting up the basic theory of proper maps (without the \"separated\" assumption that Antoine mentionned above). Right now it just contains the equivalence universal closedness and the more concrete characterizations, I'll also add the characterization in locally compact spaces and that will make a nice first PR on the subject.</p>\n<p>Now, the real reason I wanted to revive this thread is that I actually found some interesting (I think ?) simplifications to the proofs in Bourbaki, and I didn't want my thoughts to be \"lost\" in mathlib comments. In particular, <a href=\"https://github.com/leanprover-community/mathlib4/blob/e0933acf505bcad468f6a3bbc913e15f52f15d98/Mathlib/Topology/ProperMap.lean#L137\">this lemma</a> says that, for proving that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f : X\\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> you only have to check universal closedness for <strong>one</strong> space, namey <code>Filter X</code> with the topology <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.instTopologicalSpaceFilter#doc\">docs#Filter.instTopologicalSpaceFilter</a> !</p>",
        "id": 376760815,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689792186
    },
    {
        "content": "<p>Nice!</p>",
        "id": 376762484,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689792609
    },
    {
        "content": "<p>Nice to see that my addition of topology on <code>Filter X</code> found some application!</p>",
        "id": 376763267,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689792824
    },
    {
        "content": "<p>Indeed, thanks for that! The idea was that Bourbaki uses this \"topological space defined by <code>F : FIlter X</code>\" where you add one point to the space such that converging to that point is exactly converging to the filter. That sounded annoying since we don't have that, but I realized that this is exactly <code>range pure \\union {F}</code> with the induced topology from <code>Filter X</code> (okay, as long as <code>F</code> is not already a pure filter).</p>",
        "id": 376764638,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689793181
    },
    {
        "content": "<p>Does it work with <code>Ultrafilter X</code> instead of <code>Filter X</code>?</p>",
        "id": 376765776,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1689793455
    },
    {
        "content": "<p>Oh probably, let me try</p>",
        "id": 376765978,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689793506
    },
    {
        "content": "<p>Should we add this construction and make <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OnePoint#doc\">docs#OnePoint</a> a special case?</p>",
        "id": 376766115,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689793542
    },
    {
        "content": "<p>Just asking because <code>Ultrafilter X</code> is the Stone-Cech compactification of <code>X</code> as a discrete space.</p>",
        "id": 376766156,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1689793551
    },
    {
        "content": "<p>ultrafilter is the variety, filter is the scheme (more points but you don't need them in most cases)</p>",
        "id": 376766387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1689793611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/proper.20maps/near/376766156\">said</a>:</p>\n<blockquote>\n<p>Just asking because <code>Ultrafilter X</code> is the Stone-Cech compactification of <code>X</code> as a discrete space.</p>\n</blockquote>\n<p>Oh of course, that would probably give a more satisfying explanation</p>",
        "id": 376766556,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689793661
    },
    {
        "content": "<p>Btw, should the topology on <code>Ultrafilter</code> be defined as the one coming from <code>Filter</code>? I guess there's some possible golfing here.</p>",
        "id": 376767628,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689793964
    },
    {
        "content": "<p>Indeed it does work with <code>Ultrafilter X</code>. I guess it should also work for <code>StoneCech X</code>, which is probably even more satisfying, but I've done enough general topology for today.</p>",
        "id": 376775412,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689796052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/proper.20maps/near/376764638\">said</a>:</p>\n<blockquote>\n<p>The idea was that Bourbaki uses this \"topological space defined by <code>F : FIlter X</code>\" where you add one point to the space such that converging to that point is exactly converging to the filter. That sounded annoying since we don't have that</p>\n</blockquote>\n<p>Of course we have that! This is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nhdsAdjoint#doc\">docs#nhdsAdjoint</a>. It's crucial because it left-adjoint to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nhds#doc\">docs#nhds</a>.</p>",
        "id": 376778464,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1689796866
    },
    {
        "content": "<p>I was talking about the version that adds a \"point at infinity\", but we can probably relate it to <code>nhdsAdjoint</code>.</p>",
        "id": 376779122,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1689797031
    },
    {
        "content": "<p>BTW, using (ultra)filter looks to me like the topological analogue of the valuative criterion for properness from algebraic geometry.</p>",
        "id": 376780581,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1689797401
    },
    {
        "content": "<p>Probably, you can do the \"point at infinity\" using <code>map</code>, <code>nhdsAdjoint</code>, and <code>sup</code> or <code>inf</code> (I always forget which one is which).</p>",
        "id": 376802004,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1689805229
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6005\">#6005</a> is now ready for review. I've thought about it a bit and the current proof can't really work for the compactification because I do use the specific form of neighborhoods in <code>Filter X</code>/<code>Ultrafilter X</code>. I haven't thought about it a lot more so I'm not saying it's necessarily false, just that I'm sticking with the filter/ultrafilter version for the sake of simplicity.</p>",
        "id": 377929610,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1690145489
    },
    {
        "content": "<p>Am I right that in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">IsCompact.preimage_continuous</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hs.isClosed.preimage</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isCompact</span>\n</code></pre></div>\n<p>one can't drop <code>[T2Space Y]</code>? What's a counterexample?</p>",
        "id": 386021853,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1692408685
    },
    {
        "content": "<p>Take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">Y = \\{0, 1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> the Sierpinski space (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sierpinskiSpace#doc\">docs#sierpinskiSpace</a>), <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">X = [0, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">U = (0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>=</mo><msub><mn mathvariant=\"bold\">1</mn><mi>U</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f = \\mathbf{1}_U : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7944em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">1</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is continuous, but the preimage of the compact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> which is not compact.</p>",
        "id": 386068907,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692432730
    }
]