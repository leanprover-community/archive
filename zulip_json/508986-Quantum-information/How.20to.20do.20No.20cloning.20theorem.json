[
    {
        "content": "<p>Hi everyone,</p>\n<p>I‚Äôm currently exploring the <code>QuantumInfo</code> library and experimenting with formalizing some simple quantum mechanical results (starting with the no-cloning theorem). I have a few questions about design choices and conventions in this part of the library.</p>\n<ol>\n<li>\n<p><strong>Defining my own <code>Ket</code> in the <code>Qubit</code> folder</strong>  <br>\n    I noticed that <code>Ket</code> is already defined in <code>Braket.lean</code>, but since <code>Qubit.lean</code> starts from unitary matrices (rather than abstract Hilbert-space elements), I‚Äôm working directly at the ‚Äúmatrix level.‚Äù  <br>\n    From a generalization perspective, I thought it might make sense to define a simple <code>Ket := Matrix Qubit (Fin 1) ‚ÑÇ</code> locally, so that I can directly combine it with the existing unitaries.  <br>\n    Since I‚Äôm new to working with an evolving library, I‚Äôd like to ask whether this approach is acceptable‚Äîor whether I should try to interface directly with the <code>Braket</code> version instead.</p>\n</li>\n<li>\n<p><strong>Defining a custom inner product</strong>  <br>\n    I noticed that <code>Qubit.lean</code> defines the operators (<code>X</code>, <code>Y</code>, <code>Z</code>, etc.) but doesn‚Äôt provide any notion of an inner product.  <br>\n    I therefore defined a minimal version for column vectors:</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">spBra</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œà</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ket</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Qubit</span><span class=\"w\"> </span><span class=\"n\">‚ÑÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">œà.conjTranspose</span>\n<span class=\"w\">    </span><span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">qbbraket</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"n\">œà</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ket</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚ÑÇ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spBra</span><span class=\"w\"> </span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">œà</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>I‚Äôm aware that <code>Braket.lean</code> already defines a more expressive <code>dot</code> operation, but I wanted a lightweight definition to get basic examples working and to evaluate whether it‚Äôs worth integrating at the <code>Qubit</code> level.  <br>\n    Is it reasonable to do this, or should I instead rely on the <code>Braket</code> abstractions?</p>\n<ol start=\"3\">\n<li><strong>Tensor product ambiguity between <code>Matrix.kronecker</code> and <code>CPTPMap</code></strong>  <br>\n    When I use <code>‚äó‚Çñ</code> in a theorem (even after explicitly <code>open Kronecker</code>), Lean reports an ambiguity between <code>Matrix.kronecker</code> and <code>CPTPMap</code>.  <br>\n    Since my current goal is purely linear-algebraic (no channels or CPTP maps involved), I‚Äôd like to confirm:<p>- Am I expected to use <code>CPTPMap</code> in this context?</p>\n<p>- If not, what‚Äôs the cleanest way to force Lean to interpret <code>‚äó‚Çñ</code> as the matrix version throughout this file?</p>\n</li>\n</ol>\n<p>Thanks a lot for your time ‚Äî I just want to make sure I‚Äôm following the right design philosophy before building too much on top of my local definitions.<br>\nYou can find my naive work attached, plz open it in the repo. <br>\n<a href=\"/user_uploads/3121/s4ymNRmpWyNJOLtlAequ4rz7/no-cloning.lean\">no cloning.lean</a></p>",
        "id": 544335573,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760202443
    },
    {
        "content": "<p>Hi! First thing, I would note that we recently got a version of no cloning: <a href=\"https://github.com/Timeroot/Lean-QuantumInfo/blob/6806c6483ddfbb66beb9c6056e8ae72a1ddace7e/QuantumInfo/Finite/Unitary.lean#L76\">https://github.com/Timeroot/Lean-QuantumInfo/blob/6806c6483ddfbb66beb9c6056e8ae72a1ddace7e/QuantumInfo/Finite/Unitary.lean#L76</a><br>\n but there's definitely room for more, since there are so many (really different) versions of the no-cloning theorem.</p>\n<p>I would definitely encourage you to try to use the existing types where possible. If you prove a version of no-cloning with your spBra and qbbraket, for instance, then it will make it harder for anyone <em>else</em> to use your theorem in downstream proofs, since they'll have to show that their existing hypotheses (like about an inner product of a <code>Bra</code> and <code>Ket</code>) are equivalent to your <code>h3</code> about qbbraket. And they won't be able to apply your version to an actual <code>Ket</code> without casting.</p>",
        "id": 544406790,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760281243
    },
    {
        "content": "<p>Regarding the Matrix.kronecker and CPTPMap: I guess the <code>‚äó‚Çñ</code> notation for CPTP maps should be scoped. I've also been thinking about changing it to something less ambiguous from the start.</p>\n<p>There's a bit of a mess because we have kronecker product of <code>Matrix</code>, of <code>HermitianMat</code>, of <code>MState</code>, of <code>Ket</code>, and of <code>CPTPMap</code>. (Also need to get one for unitaries.) The elaborator gets a bit confused sometimes.</p>\n<p>I would encourage you to try to state it entirely in terms of <code>Ket</code> or <code>MState</code>, and in terms of <code>ùêî</code> or <code>CPTPMap</code>, depending on what version of the theorem you want to prove. Hopefully you can avoid the notation collision then.</p>\n<p>A simple workaround is to just explicitly name the function, e.g. <code>CPTPMap.prod</code>, if you need to.</p>",
        "id": 544407049,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760281483
    },
    {
        "content": "<p>I see, thank you for sharing this. My intention to do this theorem is just to practice and learn the ways people deal with matrices. I will read about the existing code thank you.</p>",
        "id": 544407585,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760281885
    },
    {
        "content": "<p>I think I didn‚Äôt get the way operators interact with the existing Ket. That was why I didn‚Äôt use the existing def. I get it now. Cheers</p>",
        "id": 544408200,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760282488
    },
    {
        "content": "<p>Oh, shoot. Yes, there's an embarrassing fact that we don't actually have the multiplication of a unitary by a ket. (In particular, showing that it's still a ket - still correctly normalized.) <span class=\"user-mention\" data-user-id=\"578326\">@Mattias Ehatamm</span> pointed this out to me a few days ago.</p>",
        "id": 544409709,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760283662
    },
    {
        "content": "<p>Thanks! That clarifies a lot. <br>\nI saw the TODO in the current <code>Ket</code> definition about switching to <code>EuclideanSpace ‚ÑÇ d</code>, and it helped me understand why the normalization proof isn‚Äôt straightforward right now ‚Äî that change would naturally make normalization follow from unitarity, since the inner-product structure would already be built in.<br>\nI‚Äôve been experimenting locally with a small version to see how the unitary‚ÄìKet multiplication could take advantage of that TODO and fit into the updated design ‚Äî mainly to learn how things connect inside the library.</p>\n<p>Out of curiosity, do you think the plan is to update <code>Ket</code> itself soon, or is the idea to focus on adding operators first before that change?</p>",
        "id": 544436852,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760313311
    },
    {
        "content": "<p>I'm not sure... at the moment there's a lot of tech debt in the repo, as we've been pushing for a deadline to get the Stein's Lemma done. We're pretty much closing that up, and then it will be time to start tackling all of these TODO's and tech debts. Switching to EuclideanSpace will probably be an early one. You should expect it in like, a month from now? I would guess.</p>",
        "id": 544436953,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1760313443
    },
    {
        "content": "<p>That makes total sense ‚Äî thanks for the context!<br>\nSounds like a good time for me to just keep experimenting locally and get familiar with how things are structured.<br>\nI‚Äôll revisit once the EuclideanSpace update lands; it‚Äôll be nice to see how the operator fits into that new setup.</p>",
        "id": 544437263,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760313783
    },
    {
        "content": "<p>Quick update on the experiment I mentioned earlier:</p>\n<p>I tried implementing the TODO version of <code>Ket</code> (with <code>vec : EuclideanSpace ‚ÑÇ n</code>) and wrote a preliminary version of the unitary‚ÄìKet multiplication (<code>opKet</code>).<br>\nSince there isn‚Äôt yet a direct matrix multiplication API for this, I constructed the corresponding <code>unitary (EuclideanSpace ‚ÑÇ d ‚ÜíL[‚ÑÇ] EuclideanSpace ‚ÑÇ d)</code> explicitly from <code>U : Matrix.unitaryGroup d ‚ÑÇ</code> and used <code>unitary.norm_map</code> to prove the normalization.</p>\n<p>I‚Äôd be happy to refine it later once the EuclideanSpace-based <code>Ket</code> update lands ‚Äî this was mainly a learning exercise to see how all the existing structures connect together.</p>\n<p>Here is the code. Special Thanks to Andrew Yang for his tips in this proof.</p>\n<p><a href=\"/user_uploads/3121/9rY__Keuk9GowLbdz_00RJp1/new_opt_multi.lean\">new_opt_multi.lean</a></p>",
        "id": 545537315,
        "sender_full_name": "Ruize Chen",
        "timestamp": 1760697731
    }
]