[
    {
        "content": "<p>How to express reciprocal？<br>\nCheck  the \"def solution\" below. How to express \"1 / matrix1_det\" ?<br>\nIt only outputs an error \"failed to compile definition, consider marking it as 'noncomputable' because it depends on 'Real.instLinearOrderedFieldReal', and it does not have executable code\"...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.Adjugate</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Sqrt</span>\n\n<span class=\"c1\">-- set_option trace.Meta.synthInstance true</span>\n<span class=\"c1\">-- 要解释每一个名词的实际数学意义</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Matrix</span>\n\n  <span class=\"c1\">-- universe u2 u2' v2</span>\n  <span class=\"kd\">def</span> <span class=\"n\">m2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n  <span class=\"kd\">def</span> <span class=\"n\">n2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n  <span class=\"kd\">def</span> <span class=\"n\">α2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span>\n\n  <span class=\"kd\">variable</span>\n    <span class=\"c1\">-- {m2 := ℕ  } --三个类型</span>\n    <span class=\"c1\">-- {n2 : ℕ  }</span>\n    <span class=\"c1\">-- {α2 : ℝ  }</span>\n    <span class=\"c1\">-- Fintype α意思是α是有限的（即只有有限多个不同的类型元素α）。</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">n2</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- 断言α具有可判定的相等性（即对全部a b : α，a = b是可判定的）</span>\n    <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">n2</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- 交换的环，例如实数R</span>\n      <span class=\"c1\">-- 一个带有两个二元运算的集合 R 是环，即将环中的任意两个元素变为第三个的运算。</span>\n        <span class=\"c1\">-- 他们称为加法与乘法，通常记作 + 与 ⋅ ，例如 a + b 与 a ⋅ b。</span>\n      <span class=\"c1\">-- 为了形成一个群这两个运算需满足一些性质：</span>\n        <span class=\"c1\">-- 环在加法下是一个阿贝尔群（即满足交换律），</span>\n        <span class=\"c1\">-- 在乘法下为一个幺半群，使得乘法对加法有分配律，即 a ⋅ (b + c) = (a ⋅ b) + (a ⋅ c)。</span>\n        <span class=\"c1\">-- 关于加法与乘法的单位元素分别记作 0 和 1。</span>\n        <span class=\"c1\">-- 另外如果乘法也是交换的，即a ⋅ b = b ⋅ a，环 R 称为交换的。</span>\n    <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">α2</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- open Equiv Equiv.Perm Finset Function --这个不用</span>\n\n  <span class=\"c1\">-- ---/ 引入MainGoal需要定义的变量</span>\n  <span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- ---/</span>\n\n  <span class=\"c1\">-- 实际案例：</span>\n  <span class=\"kd\">def</span> <span class=\"n\">matrix1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">],</span>\n      <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">4</span><span class=\"o\">]]</span>\n  <span class=\"kd\">def</span> <span class=\"n\">matrix2</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">],</span>\n      <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">8</span><span class=\"o\">]]</span>\n  <span class=\"kd\">def</span> <span class=\"n\">matrixUnit</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">],</span>\n      <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]]</span>\n\n  <span class=\"c1\">--  def matrix3 : Matrix (Fin 2) (Fin 3) ℝ :=</span>\n  <span class=\"c1\">--   ![![1, 2, 3],</span>\n  <span class=\"c1\">--     ![4 ,5, 6]]</span>\n  <span class=\"c1\">-- #eval matrix3 1 0</span>\n\n\n  <span class=\"c1\">-- #check A * B</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">matrix1_adjugate</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">adjugate</span> <span class=\"n\">matrix1</span>\n  <span class=\"kd\">def</span> <span class=\"n\">matrix1_det</span> <span class=\"o\">:=</span> <span class=\"n\">matrix1.det</span>\n  <span class=\"c1\">-- #eval matrix1</span>\n  <span class=\"c1\">-- [ 1 2</span>\n  <span class=\"c1\">--   3 4 ]</span>\n  <span class=\"c1\">-- #eval matrix1_adjugate -- 伴随矩阵（伴随矩阵即每一项先变余子式行列式，再加正负号(定义为-1的i+j次方)，再转置）</span>\n  <span class=\"c1\">-- [ 4 -2</span>\n  <span class=\"c1\">--  -3  1 ]</span>\n  <span class=\"c1\">-- #eval (matrix1_adjugate * matrix1) -- 伴随矩阵 矩阵乘 矩阵</span>\n  <span class=\"c1\">-- [ -2  0</span>\n  <span class=\"c1\">--    0 -2 ]</span>\n  <span class=\"k\">#eval</span> <span class=\"n\">matrix1_det</span> <span class=\"c1\">-- 矩阵的行列式，是一个实数</span>\n  <span class=\"c1\">-- #eval matrix1_det • matrix1</span>\n  <span class=\"c1\">--  (-2)</span>\n  <span class=\"c1\">-- #eval matrix1_det • matrixUnit -- 矩阵的行列式 数乘 矩阵</span>\n  <span class=\"c1\">-- [ -2  0</span>\n  <span class=\"c1\">--    0 -2 ]</span>\n  <span class=\"c1\">-- 可以看出matrix1_adjugate * matrix1 和 matrix1_det • matrixUnit 结果相等</span>\n\n\n\n  <span class=\"c1\">-- Finset.sum Finset.univ的使用：</span>\n    <span class=\"kd\">def</span> <span class=\"n\">my_set</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Finset.univ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)))</span>\n    <span class=\"c1\">-- #eval my_set -- {0, 1}</span>\n    <span class=\"c1\">--   Finset.sum需要两个参数：</span>\n      <span class=\"c1\">-- 1.一个有限集合，表示对该集合中的元素进行求和。</span>\n      <span class=\"c1\">-- 2.一个返回可相加的类型（即带有has_add类型类）的函数表达式，用于指定如何将集合中的元素相加。</span>\n    <span class=\"kd\">def</span> <span class=\"n\">sum_of_numbers</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n      <span class=\"o\">:=</span> <span class=\"n\">Finset.sum</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"mi\">11</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- 也就是x为0到10自然数，f(x)=x求和</span>\n    <span class=\"c1\">-- #eval sum_of_numbers -- 55</span>\n    <span class=\"kd\">def</span> <span class=\"n\">sum_of_numbers2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n      <span class=\"o\">:=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">my_set</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- 也就是x为{0, 1}，f(x)=x求和</span>\n    <span class=\"c1\">-- #eval sum_of_numbers2 -- 1</span>\n\n<span class=\"c1\">-- cramer 的使用</span>\n  <span class=\"kd\">def</span> <span class=\"n\">matrixb</span> <span class=\"o\">:</span>  <span class=\"n\">Fin</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">6</span><span class=\"o\">]</span>\n\n  <span class=\"k\">#eval</span> <span class=\"n\">matrixb</span>\n  <span class=\"kd\">def</span> <span class=\"n\">solution</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">matrix1_det</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">cramer</span> <span class=\"n\">matrix1</span> <span class=\"n\">matrixb</span><span class=\"o\">)</span>\n  <span class=\"c1\">--  如何表示除法？</span>\n  <span class=\"k\">#eval</span> <span class=\"n\">solution</span> <span class=\"c1\">-- 解应该是x=![-4 4.5]</span>\n\n\n\n\n\n\n  <span class=\"c1\">-- 抽象证明：</span>\n <span class=\"c1\">-- 四个领域 1.adjugate 2.cramer 3.det 4.Pi.single</span>\n  <span class=\"c1\">-- 1↔2,4 2↔3,4 1↔3</span>\n\n  <span class=\"c1\">-- #check (cramer Aᵀ)  --: (n2 → α2) →ₗ[α2] n2 → α2</span>\n  <span class=\"c1\">-- 1↔2,4的桥梁</span>\n  <span class=\"kd\">lemma</span> <span class=\"n\">mul_adjugate_apply2</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">adjugate</span> <span class=\"n\">A</span> <span class=\"n\">k</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cramer</span> <span class=\"n\">A</span><span class=\"bp\">ᵀ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">j</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">test</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cramer</span> <span class=\"n\">A</span><span class=\"bp\">ᵀ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">k</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">j</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"n\">k</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">cramer</span> <span class=\"n\">A</span><span class=\"bp\">ᵀ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single</span> <span class=\"n\">k</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">j</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">SMulHomClass.map_smul</span><span class=\"o\">]</span><span class=\"c1\">---我知道了，你要知道f代表什么，f代表(cramer Aᵀ) (参数一) j</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span>\n    <span class=\"bp\">←</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">adjugate</span><span class=\"o\">,</span> <span class=\"c1\">-- 1↔2,4 伴随矩阵的定义来的。伴随矩阵即每一项先变余子式行列式，再加正负号(定义为-1的i+j次方)，再转置</span>\n    <span class=\"n\">of_apply</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">test</span><span class=\"o\">,</span>\n    <span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single_smul'</span><span class=\"o\">,</span>\n    <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n  <span class=\"c1\">-- 1↔3 的桥梁(由1↔2,4 和 2↔3,4 和 4↔null 得到)</span>\n  <span class=\"kd\">lemma</span> <span class=\"n\">mul_adjugate2</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"n\">adjugate</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">A.det</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c1\">-- have h1:= A * adjugate A -- : Matrix n n α</span>\n    <span class=\"c1\">-- have h2:= A.det • (1 : Matrix n2 n2 α2) -- : Matrix n2 n2 α2</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">k</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span>\n    <span class=\"n\">mul_apply</span><span class=\"o\">,</span>  <span class=\"c1\">-- 作用：(M * N) i k = Finset.sum Finset.univ fun j ↦ M i j * N j k</span>\n    <span class=\"c1\">-- 将 (A * adjugate A) i k</span>\n    <span class=\"c1\">-- 其中 M=&gt;A, N=&gt;adjugate A</span>\n    <span class=\"c1\">-- 变成了等号右边 (Finset.sum Finset.univ fun j ↦ A i j * adjugate A j k)</span>\n    <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">,</span> <span class=\"c1\">-- 作用：(b • x) i = b • (x i)</span>\n    <span class=\"c1\">-- 将 (det A • 1) i k</span>\n    <span class=\"c1\">-- 其中 b=&gt;det A,x=&gt;1,i=&gt;i</span>\n    <span class=\"c1\">-- 变成了 ( det A • (1 i) ) k</span>\n    <span class=\"c1\">-- * 暂时理解成OfNat.ofNat 1 就是 1的单位矩阵(1 : Matrix n n α)</span>\n    <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- 再作用一次 (b • x) i = b • (x i)</span>\n    <span class=\"c1\">-- 其中 b=&gt;det A,x=&gt;(1 i),i=&gt;k</span>\n    <span class=\"c1\">-- 变成了det A • (1 i k)</span>\n    <span class=\"n\">one_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">mul_boole</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_adjugate_apply2</span><span class=\"o\">]</span> <span class=\"c1\">-- 1↔2,4的桥梁</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sum_cramer_apply</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- have :sorry:=sorry</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.sum_pi_single</span><span class=\"o\">]</span> <span class=\"c1\">--??? Pi.singel什么意思，怎么用</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.mem_univ</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ite_true</span><span class=\"o\">]</span>\n    <span class=\"c1\">-- simp only [ne_eq, Finset.sum_pi_single, Finset.mem_univ, ite_true]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">cramer_transpose_row_self</span><span class=\"o\">]</span> <span class=\"c1\">-- 2↔3,4的桥梁 --???单独cramer Aᵀ是什么意思</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">single_apply</span><span class=\"o\">]</span> <span class=\"c1\">-- 4↔null的桥梁</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n    <span class=\"n\">done</span>\n\n  <span class=\"c1\">-- 1↔3 的桥梁</span>\n  <span class=\"kd\">theorem</span> <span class=\"n\">MainGoal</span> <span class=\"o\">[</span><span class=\"n\">Invertible</span> <span class=\"n\">A.det</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">⅟</span><span class=\"o\">(</span><span class=\"n\">det</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">adjugate</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">n2</span> <span class=\"n\">n2</span> <span class=\"n\">α2</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span>\n    <span class=\"n\">mul_smul_comm</span><span class=\"o\">,</span>\n    <span class=\"n\">mul_adjugate2</span><span class=\"o\">,</span>\n    <span class=\"n\">smul_smul</span><span class=\"o\">,</span>\n    <span class=\"n\">invOf_mul_self</span><span class=\"o\">,</span>\n    <span class=\"n\">one_smul</span><span class=\"o\">]</span>\n    <span class=\"n\">done</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">Matrix</span>\n</code></pre></div>",
        "id": 409078466,
        "sender_full_name": "chenjulang",
        "timestamp": 1703043167
    },
    {
        "content": "<p>Or How to write a fraction?</p>",
        "id": 409078572,
        "sender_full_name": "chenjulang",
        "timestamp": 1703043222
    },
    {
        "content": "<p>In simple words, i only want to write down <br>\nthe reciprocal of a determinant  \"1/(matrix1_det) \",<br>\nGet Stuck...... <span aria-label=\"face with peeking eye\" class=\"emoji emoji-1fae3\" role=\"img\" title=\"face with peeking eye\">:face_with_peeking_eye:</span></p>",
        "id": 409086857,
        "sender_full_name": "chenjulang",
        "timestamp": 1703046684
    },
    {
        "content": "<p>like this :<br>\n<a href=\"/user_uploads/3121/zrpceBsUFzfS52q3kZWlcLWh/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/zrpceBsUFzfS52q3kZWlcLWh/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/zrpceBsUFzfS52q3kZWlcLWh/image.png\"></a></div>",
        "id": 409103143,
        "sender_full_name": "chenjulang",
        "timestamp": 1703054714
    },
    {
        "content": "<p>Lean is trying to tell you what the problem is. It says \"failed to compile definition, consider marking it as 'noncomputable'\". So perhaps you should do that: either change <code>def solution</code> to  <code>noncomputable def solution</code>, or write the command <code>noncomputable section</code> at the beginning of your file. (See e.g. this old zulip thread: <a href=\"https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20definition.20noncomputable.html\">https://leanprover-community.github.io/archive/stream/113489-new-members/topic/function.20definition.20noncomputable.html</a>)</p>",
        "id": 409108785,
        "sender_full_name": "David Loeffler",
        "timestamp": 1703056524
    },
    {
        "content": "<p>Ok , i have a try</p>",
        "id": 409108961,
        "sender_full_name": "chenjulang",
        "timestamp": 1703056569
    },
    {
        "content": "<p>Seems  it dosen't work:<br>\n<a href=\"/user_uploads/3121/GscBAqEqshQQyDoh6JSiMonx/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/GscBAqEqshQQyDoh6JSiMonx/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/GscBAqEqshQQyDoh6JSiMonx/image.png\"></a></div>",
        "id": 409109775,
        "sender_full_name": "chenjulang",
        "timestamp": 1703056820
    },
    {
        "content": "<p>Any ideas?</p>",
        "id": 409115268,
        "sender_full_name": "chenjulang",
        "timestamp": 1703059007
    },
    {
        "content": "<p>The problem is that real numbers are not computable – a real number is an infinite amount of data which it is meaningless to \"write down\" -- and the #eval keyword triggers computation. (What kind of answer would you expect if you told the computer to \"evaluate\" pi?) </p>\n<p>If you change all the scalar types from <code>ℝ</code> to <code>ℚ</code> in your code, then it will work fine, because the rationals are a computable object.</p>",
        "id": 409118158,
        "sender_full_name": "David Loeffler",
        "timestamp": 1703060290
    },
    {
        "content": "<p>Get it!! Benefits a lot</p>",
        "id": 409127040,
        "sender_full_name": "chenjulang",
        "timestamp": 1703063956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"665035\">chenjulang</span> has marked this topic as resolved.</p>",
        "id": 409127118,
        "sender_full_name": "Notification Bot",
        "timestamp": 1703063989
    }
]