[
    {
        "content": "<p>Hi, I'm trying to formalise a theory where you pick a number <code>n</code>, which stands for the number of <em>agents</em> in the model, as well as equally numerous <em>items</em> in the model, and then you make further definitions that depend on all of these. In Agda, I'd do something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Agda\"><pre><span></span><code><span class=\"kr\">module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span>n<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>N<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"nf\">Agent</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Set</span>\n<span class=\"w\">  </span>Agent<span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>Fin<span class=\"w\"> </span>n\n\n<span class=\"w\">  </span><span class=\"nf\">Item</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Set</span>\n<span class=\"w\">  </span>Item<span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>Fin<span class=\"w\"> </span>n\n\n<span class=\"w\">  </span><span class=\"kr\">module</span><span class=\"w\"> </span><span class=\"n\">TheoryAboutUtilities</span><span class=\"w\"> </span><span class=\"o\">(</span>utility<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>Agent<span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span>Item<span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span>Nat<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">    </span><span class=\"cm\">{- here I can use `n`, `Agent`, `utility`, etc. -}</span>\n<span class=\"w\">    </span><span class=\"kr\">record</span><span class=\"w\"> </span>Constant<span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">      </span><span class=\"kr\">field</span>\n<span class=\"w\">        </span><span class=\"nf\">const</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>Nat\n<span class=\"w\">        </span><span class=\"nf\">.pf</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kr\">forall</span><span class=\"w\"> </span><span class=\"o\">(</span>a<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>Agent<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span>i<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>Item<span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span>utility<span class=\"w\"> </span>a<span class=\"w\"> </span>i<span class=\"w\"> </span>â‰¡<span class=\"w\"> </span>const\n</code></pre></div>\n<p>Notice that in <code>utility</code>, as well as <code>.pf</code>, I could just refer to the type of agents as <code>Agent</code>, and the system understands that it's the type of agents in the context of the broader scope that contains <code>n</code>. (BTW, normally I'd newtype the definition of <code>Agent</code> but let's keep it simple here.)</p>\n<p>However, in Lean, I have not been able to find an equivalent construction. The closest I could find is <code>variable</code> but that does not abstract away all the dependent context, and I have to write the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Agent</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">utility</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Agent</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here's the first difference: I can't just refer to the types of agents and items, I have to explicitly repeat the parameter <code>n</code> and have to be constantly aware of the entire context of their definition at all usage sites. It gets worse, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Constant</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">pf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Agent</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">utility</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">const</span>\n</code></pre></div>\n<p>This definition is buggy because I forgot to add <code>(n : Nat)</code> to <code>Constant</code>, which means that the <code>n</code> will be universally quantified at <code>pf</code> instead, which is not what I wanted to express.</p>\n<p>So for me it's a question of convenience (having to write all these parameters), abstraction (why should I care how <code>Agent</code> is defined, I just want the type and build further abstractions on top of it), and correctness (easy to make a mistake that's well-typed but means something else). I suppose this might also have consequences for universe levels (parameters vs. indices), too?</p>\n<p>Can I avoid all this and get Agda-style parameters for entire blocks/sections in Lean?</p>",
        "id": 532385806,
        "sender_full_name": "ziman",
        "timestamp": 1754086244
    },
    {
        "content": "<p>This feature used to exist in Lean 3, but in Lean 4 it was decided to be too complex, and many use cases can be expressed better using typeclasses.</p>\n<p>You mention \"why should I care how <code>Agent</code> is defined?\" Maybe that suggests that <code>Agent</code> can be an abstract type to begin with? You could add <code>[Fintype Agent]</code> or <code>[Finite Agent]</code> if you want to add the assumption the type is finite, the choice depending on how much computation you might want to do.</p>",
        "id": 532388379,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754087873
    },
    {
        "content": "<p>You could express that they have the same cardinality using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a>, and then the <code>Constant</code> structure wouldn't be peering through the abstraction boundary.</p>",
        "id": 532388534,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754087972
    },
    {
        "content": "<p>I'll experiment with that, thank you!</p>",
        "id": 532388942,
        "sender_full_name": "ziman",
        "timestamp": 1754088261
    }
]