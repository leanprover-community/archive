[
    {
        "content": "<p>Hello,</p>\n<p>I'm trying to write some lean code to work with general fields, and I want to show a goal like <br>\nx * b * 2⁻¹ * 2 = x * b<br>\nI know that 2 is not equal to zero (as a hypothesis), how do I pass this information into the simplifier or whatever so that it is able to use that fact to prove this seemingly trivial fact?</p>",
        "id": 399080628,
        "sender_full_name": "Leo Shine",
        "timestamp": 1698525012
    },
    {
        "content": "<p>try <code>field_simp [name_of_hypothesis]</code>  with the name of the hypothesis that 2 is not zero in your field</p>",
        "id": 399081618,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1698526151
    },
    {
        "content": "<p>Yes that's great thanks<br>\nIs there a way of making it work out things like 4 ≠ 0 based off 2 ≠ 0 automatically?</p>\n<p>Also is there a way of getting good error messages when you accidentally write the 2 ≠ 0 hypothesis without saying this is about the particular field you are working over?</p>\n<p>This isn't particularly helpful:</p>\n<p>type mismatch<br>\n  hnotorder2<br>\nhas type<br>\n  2 ≠ 0 : Prop<br>\nbut is expected to have type<br>\n  2 ≠ 0 : Prop</p>",
        "id": 399082191,
        "sender_full_name": "Leo Shine",
        "timestamp": 1698526754
    },
    {
        "content": "<p>The best way to ask a question to this community is to give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> . Also note <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> . From what you say, the issue is that those are different 2s (one is probably a natural) but you can just hover over a 2 or a \\ne to see the types of the terms involved.</p>",
        "id": 399083153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698527619
    },
    {
        "content": "<p>As for proving 4!=0 I would rewrite 4 as 2*2 and then use <code>exact?</code>. If you want a more specific answer then please ask the question again but this time in the form \"here is some compiling code with a <code>sorry</code>, can you suggest various ways of filling it in?\"</p>",
        "id": 399083276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698527739
    },
    {
        "content": "<p>Thanks didnt realise you could get the details of the actual types of the numbers by hovering</p>\n<p>I have managed to prove 4!=0, using mul_ne_zero, I guess I don't have a great grasp of which things Lean + tactics can do by default or whether I just have to prove things like 4!=0 given 2!=0 when they come up</p>",
        "id": 399083460,
        "sender_full_name": "Leo Shine",
        "timestamp": 1698527926
    },
    {
        "content": "<p>Yeah. Step one is to figure out the difference between a theorem (which you typically <code>rw</code> or <code>apply</code>) and a tactic, and step 1' is to understand that there are only about 50 commonly used tactics and about 10^5 theorems. Step 2 is to get the hang of what the 50 or so tactics do, and this takes time: you just learn by doing, really. The <code>norm_num</code> tactic may or may not prove 4!=0 but that all depends on how you've told it 2!=0 (hence the importance of <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s). The <code>ring</code> tactic won't, because of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>4</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/4\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/4</span><span class=\"mord mathbb\">Z</span></span></span></span>. You might get somewhere with <code>nlinarith</code> but again it might depend on exactly how you've said that the characteristic isn't 2. etc etc.</p>",
        "id": 399085897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698530616
    },
    {
        "content": "<p>I have been working precisely  on a tactic for this kind of things. This is what I have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Field.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.GroupWithZero.Units.Lemmas</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Order.Field.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FieldSimp</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"n\">Parser</span> <span class=\"n\">Tactic</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># `unify_denoms` tactic</span>\n\n<span class=\"cm\">Tactic to clear denominators in algebraic expressions, extends `field_simp`  using</span>\n<span class=\"cm\">rules that require denominators to be nonzero. The corresponding hypotheses are</span>\n<span class=\"cm\">added as new goals.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `unify_denoms` tactic tries to unify denominators in expressions, adding the</span>\n<span class=\"sd\">necessary hypothesis aabout denominators being nonzero as new goals.</span>\n<span class=\"sd\">--/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unify_denoms</span><span class=\"o\">)</span> <span class=\"s2\">\"unify_denoms\"</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"bp\">|</span> <span class=\"n\">unify_denoms</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"bp\">|</span><span class=\"o\">(</span>\n  <span class=\"n\">field_simp</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">one_div</span><span class=\"o\">]</span>         <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_add_div</span><span class=\"o\">]</span>       <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_sub_div</span><span class=\"o\">]</span>       <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_div'</span><span class=\"o\">]</span>          <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_add'</span><span class=\"o\">]</span>          <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_sub'</span><span class=\"o\">]</span>          <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_div'</span><span class=\"o\">]</span>          <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_div_mul_right</span><span class=\"o\">]</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_div_mul_left</span><span class=\"o\">]</span>  <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">)))</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The `unify_denoms'` tactic extends `unify_denoms` to work also on</span>\n<span class=\"sd\">(in)equalities.</span>\n<span class=\"sd\">--/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">unify_denoms'</span><span class=\"o\">)</span> <span class=\"s2\">\"unify_denoms'\"</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">:</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">macro_rules</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"bp\">|</span> <span class=\"n\">unify_denoms'</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"bp\">|</span><span class=\"o\">(</span>\n  <span class=\"n\">unify_denoms</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">(</span><span class=\"n\">first</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_eq_div_iff</span><span class=\"o\">]</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_le_div_iff</span><span class=\"o\">]</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_lt_div_iff</span><span class=\"o\">]</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_eq_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_le_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_lt_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_div_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_div_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">lt_div_iff</span><span class=\"o\">]</span>     <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">at</span> <span class=\"bp\">$</span><span class=\"n\">location</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">)))</span>\n</code></pre></div>\n<p>In your example, if you apply it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unify_denoms'</span>\n</code></pre></div>\n<p>it will automatically  solve the goal, at the price of leaving you with the task of proving a new goal consisting on <code>2 ≠ 0</code></p>",
        "id": 399086082,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1698530797
    },
    {
        "content": "<p>To be more precise, what is needed in your example is just the rule <code>div_eq_iff</code>  . So this works too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">field_simp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">div_eq_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>my tactic just tries a bunch of  rules for similar cases.</p>",
        "id": 399086312,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1698531101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"217253\">Leo Shine</span> <a href=\"#narrow/stream/113489-new-members/topic/Working.20with.20fields/near/399082191\">said</a>:</p>\n<blockquote>\n<p>Yes that's great thanks<br>\nIs there a way of making it work out things like 4 ≠ 0 based off 2 ≠ 0 automatically?</p>\n</blockquote>\n<p>The <code>polyrith</code> tactic can do this</p>",
        "id": 399087891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698532879
    },
    {
        "content": "<p>Even though it's false for Z/4Z? Does <code>polyrith</code> behave differently with fields?</p>",
        "id": 399088209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698533169
    },
    {
        "content": "<p>Whoops, I'm thinking of it solving <code>4 = 0</code> from <code>2 = 0</code></p>",
        "id": 399089544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698534469
    },
    {
        "content": "<p>I guess <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/CharP/Basic.html#CharP.cast_eq_zero_iff\"><code>cast_eq_zero_iff</code></a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/CharP/Basic.html#CharP\"><code>charP_iff</code></a> would be the relevant rules.</p>",
        "id": 399090527,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1698535595
    }
]