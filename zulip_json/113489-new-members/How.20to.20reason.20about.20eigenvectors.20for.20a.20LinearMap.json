[
    {
        "content": "<p>I'm trying to prove a bunch of results involving the trace of a finite dimension representation over \\C, and they usually involve reasoning one eigenvalue at a time. I've been contorting into more and more awkward constructions to do this and they all seem like I must be going about it the wrong way. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"bp\">\\</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"bp\">.</span><span class=\"n\">Eigenvalues</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- this is the type of all eigenvectors correct?</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"bp\">.</span><span class=\"n\">Eigenvalues</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- this takes an instance of the previous type to \\C ?</span>\n</code></pre></div>\n<p>We can assert for a specific <code>(z: \\C)</code> that it's an eigenvalue with <code>End.HasEigenvalue (V.ρ g) z</code>, but how do we even express to lean that the trace of <code>V.ρ g</code> is the sum of all eigenvalues? When <code>Module.End.Eigenvalues</code> is a type and not a set, even saying that is not well defined. </p>\n<p>I'd considered taking the linear map, converting it to a matrix, using a result which says that the trace is the sum of the roots of the characteristic polynomial and trying to work with those roots but the version of the fundamental theorem of algebra in lean isn't structured in terms of a sequence of roots of anything like that so it seems like that gets bogged down. </p>\n<p>The mounting complexity and work arounds to work arounds suggest I'm not framing the problem correctly. As an example of where we're trying to go, I can get a bound on each individual eigenvalue so the next lemma is a bound on the trace.</p>",
        "id": 535784125,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755927771
    },
    {
        "content": "<p>Can you write a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of a statement that you would like to prove? That's the best way of asking a question of this nature. </p>\n<p>And why are you using category theory? Are you sure you want to also introduce this extra layer of complexity? My instinct for basic representation theory is to prove everything for <code>Representation</code> first and deduce it for <code>FDRep</code> later using the <code>Representation</code> work.</p>",
        "id": 535790656,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755936638
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <br>\nUltimate goal: prove Burnsides theorem.</p>\n<p>Ultimate reason: I remember it fondly from grad school and it's a warmup for contributing other stuff.</p>\n<p>Here is a snippet with one lemma which I can prove, and two which were going to use the first lemma that I can't. I have more theorems sketched out but in some cases I can't even express the statement properly yet such as \"V.character g is an algebraic integer within ℂ\", and \"the set of irreducible characters of G form a basis for the space ℂ-linear functions from conjugacy classes of G to ℂ\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ComplexConjugate</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_norm_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">μ</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- have working proof just skipping the details here</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">char_norm_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- stuck</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">char_inv_conj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">conj</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- stuck</span>\n</code></pre></div>\n<p>Proving results about individual eigenvalues wasn't too difficult so far, but to connect that to a result about the trace is where I'm fighting with lean. Naively I'd say something like \"let S be the finite set of eigenvectors of <code>V.ρ g</code>, then <code>trace V.ρ g</code> is the sum of the elements of that set and we can make an inequality from there to prove our result about <code>V.character g</code>\". </p>\n<p>I think most of the results here wouldn't apply for a general Representation since they require finite dimension. A lot of the results could be proved for a field of char 0 with sufficient roots of unity I suppose. Brauer characters would be more general (and cool) but that's a different project.</p>",
        "id": 535857635,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755974960
    },
    {
        "content": "<p>Which <code>trace</code> is that?</p>",
        "id": 535858796,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755976448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130170\">@Ryan Smith</span> your claim in comments is incorrect because sets only contain elements with \"multiplicity 1\" by definition of a set, and you need to keep track of multiplicities to push this through. For example if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is the identity then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">S=\\{1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> so the sum is 1 regardless of the dimension of the rep. You either want to use Multisets (where multiplicities can be finite, but this is enough for you) or a sum of generalised eigenvalues <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> over an index type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> runs through the elements (which allows <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>μ</mi><mn>1</mn></msub><mo>=</mo><msub><mi>μ</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mu_1=\\mu_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">μ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> which also solves the multiplicity problem). Part of the art of formalisation is choosing the most painless path to go down, so it's probably worth looking at the API for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.trace#doc\">docs#LinearMap.trace</a> to see what is already there.</p>",
        "id": 535860205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755978341
    },
    {
        "content": "<p>Do you have an opinion as to what route do you think is a better path for making arguments about the trace of a linear map if the facts we know are some statements about each eigenvalue? I realize there are multiple ways we could go about formalizing these arguments.</p>",
        "id": 535860650,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755978959
    },
    {
        "content": "<p>I'm having trouble getting mathlib cache at the minute but you're asking the right question. My instinct is to look through the library to find theorems relating traces of linear maps or matrices to sums of (generalised) eigenvalues but to my great surprise I'm finding very little; I'm sure I'm missing something.</p>",
        "id": 535861091,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755979585
    },
    {
        "content": "<p>I went looking and didn't find a lot of the stuff I'd expect, but mathlib is still a wild jungle to me. So far the only thing I've found a result that the trace of a matrix is the sum of the roots of the charpoly, which is nice but not really what I need.</p>",
        "id": 535863857,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755983348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"eigenvalue\", \"trace\"</p>",
        "id": 535863950,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755983480
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/InnerProductSpace/Trace.html#LinearMap.IsSymmetric.trace_eq_sum_eigenvalues\">LinearMap.IsSymmetric.trace_eq_sum_eigenvalues</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/InnerProductSpace/Trace.html#LinearMap.IsSymmetric.re_trace_eq_sum_eigenvalues\">LinearMap.IsSymmetric.re_trace_eq_sum_eigenvalues</a>, and <a href=\"https://loogle.lean-lang.org/?q=%22eigenvalue%22%2C%20%22trace%22\">1 more</a></p>",
        "id": 535863951,
        "sender_full_name": "loogle",
        "timestamp": 1755983480
    },
    {
        "content": "<p>hm</p>",
        "id": 535863961,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755983498
    },
    {
        "content": "<p>These are all theorems of the form \"if a linear map satisfies some condition which makes it diagonalisable, then the trace is the sum of the eigenvalues when presented as a list (of the size we expect)\".</p>",
        "id": 535864999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755985110
    },
    {
        "content": "<p>Do we have things like \"trace is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> in char poly\" and \"sum of multiset <code>Polynomial.roots</code> is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> for a monic polynomial which <code>Polynomial.Splits</code>\" and \"every root of  char poly is an eigenvalue\"? That might be the most painless way to proceed.</p>",
        "id": 535865096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755985248
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.trace_eq_neg_charpoly_coeff#doc\">docs#Matrix.trace_eq_neg_charpoly_coeff</a></p>",
        "id": 535865421,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755985709
    },
    {
        "content": "<p>Something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/Spectrum.html#Matrix.IsHermitian.eigenvalues\">Matrix.IsHermitian.eigenvalues</a> for more general matrices would be perfect, it would make it easy to reason about the trace. I wonder why this doesn't exist in the same way.</p>\n<p>Edit: might need a hypothesis on the field but otherwise I don't see why this is only a special case</p>",
        "id": 535869018,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755991745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20reason.20about.20eigenvectors.20for.20a.20LinearMap/near/535865096\">said</a>:</p>\n<blockquote>\n<p>Do we have things like \"trace is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> in char poly\" and \"sum of multiset <code>Polynomial.roots</code> is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> for a monic polynomial which <code>Polynomial.Splits</code>\" and \"every root of  char poly is an eigenvalue\"? That might be the most painless way to proceed.</p>\n</blockquote>\n<p>The second result seems to be the missing part. We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Eigenspace/Minpoly.html#Module.End.hasEigenvalue_of_isRoot\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Eigenspace/Minpoly.html#Module.End.hasEigenvalue_of_isRoot</a> connecting roots with eigenvalues but I haven't found anything about a deg n polynomial having a multiset of roots with n elements counting multiplicities</p>",
        "id": 535873046,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755998373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20reason.20about.20eigenvectors.20for.20a.20LinearMap/near/535869018\">said</a>:</p>\n<blockquote>\n<p>Something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/Spectrum.html#Matrix.IsHermitian.eigenvalues\">Matrix.IsHermitian.eigenvalues</a> for more general matrices would be perfect, it would make it easy to reason about the trace. I wonder why this doesn't exist in the same way.</p>\n</blockquote>\n<p><code>eigenvalues</code> and <code>generalisedEigenvalues</code> are different for a nonHermitian matrix, and perhaps we should have both.</p>",
        "id": 535888983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756023621
    },
    {
        "content": "<p>It is not even clear to me what the <em>type</em> of <code>eigenvalues</code> should be for a non-diagonalisable matrix. What is the indexing type? It might have size smaller than the dimension.</p>",
        "id": 535889034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756023683
    },
    {
        "content": "<p>If there were a hypothesis that the characteristic polynomial split then the index would be the dimension and we could have the same api.</p>",
        "id": 535912238,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1756053131
    },
    {
        "content": "<p>I don't really understand what you mean. The char poly of (1,1;0,1) is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">(X-1)^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> which splits but this isn't diagonalisable. </p>\n<p>Of course any endomorphism of finite order over a char 0 field is diagonalisable so this should not be a concern for you. Maybe working with the multiset of roots of the char poly is just easier in this situation?</p>",
        "id": 535919122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756061118
    },
    {
        "content": "<p>Vaguely related: do we not have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 535920075,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756062088
    },
    {
        "content": "<p>Good question, I don't know why we don't have that. I also noticed that in RepresentationTheory/Character we have </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">char_tensor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">trace_tensorProduct'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but no direct sum</p>\n<p>Maybe you're right and a multiset of roots would be the way to go. <code>Polynomial.exists_multiset_roots</code> seems promising</p>",
        "id": 535927436,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1756070479
    },
    {
        "content": "<p>Re direct sums: I think that the idea was just to get straight to \"distinct irred characters are orthogonal\" and for that one slick way is to define tensor product rep. We're not formalising textbooks here -- we're typically formalising \"the stuff I need to do the project I'm working on\" so sometimes what's there is a bit haphazard.</p>",
        "id": 535930797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756075009
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">DistribMulAction</span><span class=\"bp\">.</span><span class=\"n\">toModuleEnd</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">det</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">ρ</span>\n</code></pre></div>",
        "id": 536244873,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756216995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20reason.20about.20eigenvectors.20for.20a.20LinearMap/near/535873046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20reason.20about.20eigenvectors.20for.20a.20LinearMap/near/535865096\">said</a>:</p>\n<blockquote>\n<p>Do we have things like \"trace is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> in char poly\" and \"sum of multiset <code>Polynomial.roots</code> is - coefficient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> for a monic polynomial which <code>Polynomial.Splits</code>\" and \"every root of  char poly is an eigenvalue\"? That might be the most painless way to proceed.</p>\n</blockquote>\n<p>The second result seems to be the missing part. We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Eigenspace/Minpoly.html#Module.End.hasEigenvalue_of_isRoot\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Eigenspace/Minpoly.html#Module.End.hasEigenvalue_of_isRoot</a> connecting roots with eigenvalues but I haven't found anything about a deg n polynomial having a multiset of roots with n elements counting multiplicities</p>\n</blockquote>\n<p>Porting that result over to matrices: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29481\">#29481</a> (with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.End.hasEigenvalue_iff_mem_spectrum#doc\">docs#Module.End.hasEigenvalue_iff_mem_spectrum</a>)<br>\nFor the charpoly (which is deg n, per <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.charpoly_degree_eq_dim#doc\">docs#Matrix.charpoly_degree_eq_dim</a>), it can be derived directly: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29478\">#29478</a><br>\nRegarding multiplicities, the algebraic multiplicity is definitional, but we can relate the geometric multiplicity: <a href=\"https://github.com/leanprover-community/mathlib4/pull/29428\">#29428</a><br>\nWe have the things about X^{n-1}: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.trace_eq_sum_roots_charpoly_of_splits#doc\">docs#Matrix.trace_eq_sum_roots_charpoly_of_splits</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.coeff_charpolyRev_eq_neg_trace#doc\">docs#Matrix.coeff_charpolyRev_eq_neg_trace</a></p>\n<p>You can prove your original lemmas using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.trace_eq_matrix_trace#doc\">docs#LinearMap.trace_eq_matrix_trace</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.charpoly_toMatrix#doc\">docs#LinearMap.charpoly_toMatrix</a></p>",
        "id": 538532252,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1757451972
    },
    {
        "content": "<p>needs cleanup, but:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- #29478</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">mem_spectrum_of_isRoot_charpoly</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"bp\">.</span><span class=\"n\">IsRoot</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">spectrum</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- #29481</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">spectrum_toMatrix</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Basis</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">spectrum</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">toMatrix</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">spectrum</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ComplexConjugate</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_norm_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">μ</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- have working proof just skipping the details here</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">char_norm_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"bp\">.</span><span class=\"n\">chooseBasis</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FDRep</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_matrix_trace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_sum_roots_charpoly</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_multiset_sum_le</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">toMatrix</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"bp\">.</span><span class=\"n\">roots</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map_congr</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_norm_one</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"bp\">.</span><span class=\"n\">hasEigenvalue_iff_mem_spectrum</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">spectrum_toMatrix</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">mem_spectrum_of_isRoot_charpoly</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">isRoot_of_mem_roots</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Free</span><span class=\"bp\">.</span><span class=\"n\">ChooseBasisIndex</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span>\n<span class=\"w\">      </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">card_roots'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">charpoly_natDegree_eq_dim</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 538536899,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1757454485
    },
    {
        "content": "<p>Can save a line or two if we transport some results from <code>Matrix</code> to <code>LinearMap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- Not in Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_sum_roots_charpoly</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">Splits</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"bp\">.</span><span class=\"n\">roots</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">⊢</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"bp\">.</span><span class=\"n\">chooseBasis</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_matrix_trace</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_sum_roots_charpoly_of_splits</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- #29478</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"bp\">.</span><span class=\"n\">hasEigenvalue_iff_isRoot_charpoly</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Free</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"bp\">.</span><span class=\"n\">IsRoot</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">ComplexConjugate</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_norm_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">μ</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- have working proof just skipping the details here</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">char_norm_bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"bp\">.</span><span class=\"n\">character</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">trace_eq_sum_roots_charpoly</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">norm_multiset_sum_le</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">charpoly</span><span class=\"bp\">.</span><span class=\"n\">roots</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">map_congr</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_norm_one</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"bp\">.</span><span class=\"n\">hasEigenvalue_iff_isRoot_charpoly</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">isRoot_of_mem_roots</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">finrank</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span>\n<span class=\"w\">      </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">card_roots'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">charpoly_natDegree</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 538546075,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1757460114
    }
]