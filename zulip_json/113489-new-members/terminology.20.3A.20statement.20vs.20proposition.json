[
    {
        "content": "<p>I'm slowly starting to acclimatise to the Lean terminology.</p>\n<p>A recent discussion about <code>Odd</code> raised the idea of it being a function that takes a number and outputs a <strong>proposition</strong>.</p>\n<p>I was wondering whether there is a difference between <strong>proposition</strong> and <strong>statement</strong>, when speaking generally (maths, logic) and not specifically about Lean.</p>\n<p>Is it the case that a proposition is a subset of statement?</p>\n<p>That propositions are true/false but statements are more general sentences using the language and grammar of mathematics and logic?</p>",
        "id": 477028122,
        "sender_full_name": "rzeta0",
        "timestamp": 1729009887
    },
    {
        "content": "<p>I've heard the idea that a proposition is a sentence that has a definite truth value. Conjunctions, implications, quantifications are all ways to construct propositions out of other propositions — we use restricted language to ensure we are always using propositions. That excludes things like \"this proposition is false\".</p>\n<p>I'm not sure what definitions of \"statement\" are out there, but if I heard \"mathematical statement\" I'd think \"proposition\".</p>",
        "id": 477030546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729010745
    },
    {
        "content": "<p>In logic, when \"statement\" is used in contrast with \"formula\", the distinction is that a \"statement\" has no free variables / it is \"closed\". In lean this is always the case, because theorems universally quantify over any parameters you pass either directly or via the <code>variable</code> command. A formula consists of many sub-formulae, but a statement is not composed out of smaller statements (at least in general), it has sub-<em>formulae</em>.</p>\n<p>Also there is a general tendency to use the term \"statement\" for the things that are actually top level goals or theorem types, rather than for just arbitrary subexpressions of type <code>Prop</code>, which may be related to the technical usage in logic just mentioned.</p>",
        "id": 477743718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729291062
    },
    {
        "content": "<p>Also, looking back at your question I see I used the term \"formula\" instead of \"proposition\"; these are basically synonymous, although we tend to use \"proposition\" or \"prop\" because lean's syntax for propositions is <code>p : Prop</code></p>",
        "id": 477743844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729291155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  - thanks for your useful explanation.</p>\n<p>I want to check I've understood with two examples:</p>\n<hr>\n<p>Consider the <code>h: Odd (14 : ℤ)</code>. Are the following true?</p>\n<ol>\n<li><code>h</code> is a proposition.</li>\n<li><code>h</code> is made up of sub-formulae, <code>Odd</code> and <code>(14 : ℤ)</code>. </li>\n<li>The formula <code>Odd</code> is not a proposition, because it is not complete enough to decide true/false.</li>\n<li>The formula <code>(14 : ℤ)</code> is a proposition, because we can decide whether it is true or false.</li>\n</ol>\n<p>Your second comment tells me that \"formula\" is synonymous with \"proposition\" . So everything in my list is a proposition and a formula. <strong>Is there anything in my example which is a \"</strong>statement<strong>\"?</strong></p>\n<hr>\n<p>Now consider <code>g: (x=3) ∧ (y=4)</code>. Are the following true?</p>\n<ol>\n<li><code>g</code> is a proposition.</li>\n<li><code>g</code> is made up of sub-formulae, <code>(x=3)</code> and <code>(y=4)</code>.</li>\n<li>The logical conjunction symbol <code>∧</code> is a connective, so not really a formula itself.</li>\n<li>Both formulae <code>(x=3)</code> and <code>(y=4)</code> are also statements, because we can decide whether they are true / false.</li>\n</ol>\n<p>Again - your second comment tells me that \"formula\" is synonymous with \"proposition\" . So everything in my list is a proposition and a formula. <strong>Is there anything in my example which is a \"</strong>statement<strong>\"?</strong></p>\n<hr>",
        "id": 477805872,
        "sender_full_name": "rzeta0",
        "timestamp": 1729343878
    },
    {
        "content": "<p><code>Odd</code> is not a formula/proposition, it is an expression. Formulae/propositions in lean are just the things with type <code>Prop</code></p>",
        "id": 477805975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729343931
    },
    {
        "content": "<p>in first order logic formulae actually have a recursive structure (i.e. <code>p /\\ q</code> is a formula whose subformulae are <code>p</code> and <code>q</code>) but in lean, which has higher order syntax, this is instead expressed using <code>And p q</code> where now there are additional sub-expressions like <code>And</code> and <code>And p</code> which are expressions that are not formulae</p>",
        "id": 477806135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729344048
    },
    {
        "content": "<p>In the first list, only 3 is true (with \"formula\" replaced by \"expression\"). (1) is false because <code>h</code> is not a proposition, it is an element of a proposition, we call these \"proofs\". <code>Odd (14 : ℤ)</code> is a proposition.</p>",
        "id": 477806313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729344220
    },
    {
        "content": "<p>For the second list: <code>g</code> is a proof, not a proposition. <code>(x=3) ∧ (y=4)</code> is a proposition/formula. It has subformulae <code>x = 3</code> and <code>y = 4</code>, and it has several additional sub-<em>expressions</em>, including <code>And</code>, <code>And (x = 3)</code>, <code>x</code>, <code>Eq x</code>, <code>x = 3</code> etc. The conjunction symbol is not a formula indeed, but in lean it is a constant called <code>And : Prop -&gt; Prop -&gt; Prop</code> and it appears as a subexpression of <code>(x=3) ∧ (y=4)</code>.</p>\n<p>Formulae <code>(x=3)</code> and <code>(y=4)</code> are not statements: using the formal logic definition this is because they are open terms, they contain free occurrences of <code>x</code> and <code>y</code> respectively, and using the colloquial definition this is because they aren't appearing as self-contained expressions as the type of a hypothesis or goal at this point.</p>",
        "id": 477806710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729344520
    },
    {
        "content": "<p>Thanks again <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<p>I am less certain than before I asked the question - which is good because it means I had false confidence in my understanding.</p>\n<p>I need to go away and think about this for a a few hours. </p>\n<p>Is there a web page / short tutorial that explains this hierarchy of expression, formulae, propositions and statements (and anything else) ?</p>",
        "id": 477806996,
        "sender_full_name": "rzeta0",
        "timestamp": 1729344779
    },
    {
        "content": "<p>nothing I can suggest off hand. Some of this complexity is because the terminology of formulae, propositions and statements comes from formal logic, which is then reinterpreted into type theory which adds additional notions and tries to identify the parts that still look kinda similar to their FOL counterparts</p>",
        "id": 477807143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729344908
    },
    {
        "content": "<p>(Actually that's not really true, the terminology really comes from <em>informal</em> mathematics, and formal logic tried to identify the parts of the formal system that look kinda like the informal notions.) This terminological evolution is how you get things like Cartesian Cubical Type Theory which I'm not sure Descartes would have approved of</p>",
        "id": 477807407,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729345181
    },
    {
        "content": "<p>I will go away for a few hours and see if that helps my brain.</p>\n<p>I may also try, in the next few days, to draw a diagram and write some explanatory text, of a few of these concepts.</p>\n<p>The idea won't be to create something that is fully encyclopaedic, but just sufficient to help beginners like myself at the beginning of their journeys with simple lean maths proofs.</p>",
        "id": 477807912,
        "sender_full_name": "rzeta0",
        "timestamp": 1729345649
    },
    {
        "content": "<p>Take this with a grain of salt as a fellow \"mostly beginner\", but my opinion would be that these sorts of questions (this and one or two recent similar ones) are not very useful to your learning, and there are I think better uses of your time. I certainly don't think the majority of people using Lean for mathematics know or want to know these specifics in terminology at this level of detail unless they're logicians or studying foundations beyond Lean. If you say \"is p \\and q a statement? an expression? a formula?\" I think 75%+ of Lean users will probably say \"I don't know, probably yes to all 3.\" I <em>do</em> think it's useful that if you see a concept that surprises you or seems novel, and if you then think that concept deserves a name, that you use and learn the name others would use for that concept. And certainly there's a bunch of terminology you'll encounter in Lean and here on the Zulip, so you should keep an eye out for those and see if you understand them or otherwise try to learn what concept they're representing -- I just don't think lots of what's here is in that category. So in particular, oversimplifying, if I were in your shoes, I would have stopped at \"Odd is a function from numbers to <code>Prop</code>\" and moved on to something more useful to know. Again, just my 0.02 trying to be helpful, feel free to ignore if you really do care to chase these rabbit holes!</p>",
        "id": 477811269,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729347709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/113489-new-members/topic/terminology.20.3A.20statement.20vs.20proposition/near/477811269\">said</a>:</p>\n<blockquote>\n<p>I certainly don't think the majority of people using Lean for mathematics know or want to know these specifics in terminology at this level of detail unless they're logicians or studying foundations beyond Lean.</p>\n</blockquote>\n<p>I've been introducing Lean to philosophy majors in South Korea. Some of them seem to care about the meanings of these terms because they've been studying formal logic, though they're unfamiliar with type theory. One of my Lean mentees was a philosophy major studying philosophy of science and artificial intelligence.</p>",
        "id": 477813282,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1729349510
    },
    {
        "content": "<p>I'm just trying to introduce proof assistants to various people!</p>",
        "id": 477814058,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1729350087
    },
    {
        "content": "<p>But I think Julian has a point. I have no idea about these technical logic terms. For me the key point is that you should know that there are four things in play: theorem statements (types in the Prop universe), theorem proofs (terms of those types), sets (types in the Type universe) and their elements (terms of those types). The statement/proof and set/element concepts are unified by the type/term idea in type theory. Everything else is just nomenclature. I'm sure it's important if you want to write tactics or whatever, but if you just want to do what rzeta0 is doing then this should be enough.</p>\n<p>Edit: I guess the reason I wrote <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">this blog post</a> <br>\n (which I just remembered the existence of) was just to explain as much of the basics as I felt one needed to know in order to turn mathematics into Lean.</p>",
        "id": 477820353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729355058
    },
    {
        "content": "<p>I agree with what's been written. </p>\n<p>I, and I suspect many other beginners, don't need a complete familiarity with formal logic terminology in order to write simple proofs in simple lean.</p>\n<p>I guess the level of knowledge should be enough to (1) feel comfortable when reading others' use of that terminology, eg the docs, and (2) to avoid misunderstandings when reading and writing your own content.</p>\n<p>Kevin, I will print out your blog and probably read it over coffee tomorrow, it looks helpful.</p>\n<p>All this started when I wrote the words: </p>\n<blockquote>\n<p><code>(13 : ℤ)</code> is intended to be a statement saying that 13 is an integer</p>\n</blockquote>\n<p>and as soon as I wrote that I realised I didn't really know how Lean people used the word statement, and that led on to the other questions about expressions, propositions, etc</p>",
        "id": 477822331,
        "sender_full_name": "rzeta0",
        "timestamp": 1729356830
    },
    {
        "content": "<p>This is actually an interesting example, because you would not be unreasonable to think that <code>13 : ℤ</code> is a statement or proposition, since people like to say that <code>:</code> is just some type theory jargon and you can substitute it for <code>∈</code> from your traditional mathematics education, and <code>13 ∈ ℤ</code> is a proposition in traditional mathematics</p>",
        "id": 477822527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729356994
    },
    {
        "content": "<p>But this is actually one place where type theory differs from traditional mathematics, because <code>(13 : ℤ)</code> is not a proposition, and it is important to realize that typing judgments don't act like propositions - they cannot be negated, they can only be asserted and checked by the type checker</p>",
        "id": 477822602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357077
    },
    {
        "content": "<p>Rather than reading <code>(13 : ℤ)</code> as \"13 is an integer\" (which is a proposition), you should read it as \"13, which is an integer, ...\" which is a noun phrase with an embedded assertion in it</p>",
        "id": 477822719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357179
    },
    {
        "content": "<p>very interesting !</p>\n<p>out of interest, if it shouldn't really be called a proposition, then what should it be called? (i realise this is a rabbit hole)</p>\n<p>a \"type assertion\" ?</p>",
        "id": 477823194,
        "sender_full_name": "rzeta0",
        "timestamp": 1729357528
    },
    {
        "content": "<p>13 is an integer :)</p>",
        "id": 477823228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357556
    },
    {
        "content": "<p>The syntax <code>(e : T)</code> is called a type ascription</p>",
        "id": 477823323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357611
    },
    {
        "content": "<p>is it useful to think of this as ≣ vs ∈</p>",
        "id": 477823351,
        "sender_full_name": "rzeta0",
        "timestamp": 1729357640
    },
    {
        "content": "<p>it lets you take any subexpression and say \"and also, that thing has this type\"</p>",
        "id": 477823353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/terminology.20.3A.20statement.20vs.20proposition/near/477823323\">said</a>:</p>\n<blockquote>\n<p>The syntax <code>(e : T)</code> is called a type ascription</p>\n</blockquote>\n<p><del>Can it also be called a judgment?</del> Never mind!</p>",
        "id": 477823376,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1729357668
    },
    {
        "content": "<p>although in practice it is also often used to disambiguate expressions, like in this case <code>Odd 13</code> could also be talking about <code>Odd (13 : Nat)</code></p>",
        "id": 477823440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357697
    },
    {
        "content": "<p>Typing judgments don't usually appear directly in lean concrete syntax, but typechecking involves validating typing judgments, and they also have a similar appearance. You usually see them written something like<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma\\vdash e:\\tau</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">Γ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊢</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span></span></span></span></p>",
        "id": 477823504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/terminology.20.3A.20statement.20vs.20proposition/near/477823440\">said</a>:</p>\n<blockquote>\n<p>although in practice it is also often used to disambiguate expressions, like in this case <code>Odd 13</code> could also be talking about <code>Odd (13 : Nat)</code></p>\n</blockquote>\n<p>so you could also read <code>(13 : ℤ)</code> linguistically as \"13 (the integer)\", by contrast to the natural number or the matrix or whatever else. But again, notice that this is a noun phrase, not a complete sentence, it doesn't make sense to assert it as a true or false thing</p>",
        "id": 477823657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729357904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> Are you the sort of person who would have read Let Over Lambda by Hoyte? He talks about designing things to have 'duality of syntax', which is where one syntactic form can have multiple related meaning depending on where it appears. In C for example, <code>a[i]</code> is both a value and lvalue, i.e. you can write <code>x = a[i]</code> to extract a value from an array, and <code>a[i] = x</code> to set a value. These are completely different if you think about it, but it feels very natural.</p>\n<p>The <code>(n : T)</code> syntax also appears in multiple places, each with related meanings, but all linked by the idea of \"is a\":</p>\n<ul>\n<li>in expressions, <code>(n : T)</code> ensures that <code>n</code> is a <code>T</code>, and it evaluates to <code>n</code></li>\n<li>in binder lists (like in a theorem statement, or after <code>fun</code> or <code>forall</code>), it declares a parameter</li>\n<li>in the InfoView or various error messages, it appears without parentheses to let you know the type of something</li>\n</ul>",
        "id": 477823865,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729358096
    },
    {
        "content": "<p>One thing that should make it clear that <code>13:  Nat</code> is not a proposition, is that you cannot use a connective to build a bigger proposition with it as a sub-proposition. The definition of what constitutes a proposition in Lean's type theory is significantly more complex than, say, in propositional or first-order logic, but one thing they share is that if <code>P</code> and <code>Q</code> are both propositions, then things like <code>P /\\ Q</code> and <code>P -&gt; Q</code> are propositions too.</p>",
        "id": 477825107,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1729359301
    },
    {
        "content": "<p>There's also the stronger reason that <code>13 : Nat</code> isn't valid syntax. But that of course this design choice is motivated by what you are saying.</p>",
        "id": 477825274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729359436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> - thanks for the further explanation, and the suggested book, which I haven't read but looks really interesting - something to add to my to-do list !</p>",
        "id": 477841085,
        "sender_full_name": "rzeta0",
        "timestamp": 1729374958
    },
    {
        "content": "<p>What mario said about \"noun phrase\" is very helpful - thanks.</p>",
        "id": 477841262,
        "sender_full_name": "rzeta0",
        "timestamp": 1729375110
    },
    {
        "content": "<p>Right: <code>(13 : ℤ)</code> means \"the integer thirteen\" not \"thirteen is an integer\".</p>",
        "id": 477847169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729380784
    },
    {
        "content": "<p>I'm reminded that a few years ago I was proposing syntax like <code>the ℤ =&gt; 13</code> (this was back in Lean 3, so it probably was <code>the ℤ, 13</code> instead) for <code>(13 : ℤ)</code>. It's nicer when the value is something big to know what the type is supposed to be ahead of time. It's a bit different from <code>show ℤ from 13</code>, which is stricter in a number of ways, and also <code>show</code> results in a <code>let_fun</code>.</p>\n<p>At least nowadays it's trivial to define it yourself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"s2\">\"the \"</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"s2\">\" =&gt; \"</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">13</span>\n</code></pre></div>",
        "id": 477852930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729386882
    },
    {
        "content": "<p>Kevin, I have now read your blog: <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory</a></p>\n<p>Thank you for sharing it. It is the first time I have even started to glimpse what \"type theory\" even means (I did maths up to a-level, nothing more).</p>\n<p>Your blog was particularly helpful because it illustrated the ideas with examples.</p>\n<p>For me, a key take away is that there are 2 universes in Lean - <code>Type</code> and <code>Prop</code>.</p>\n<p>Your discussion of the distinction between a theory and its proof was also helpful.</p>\n<p>I haven't mastered any of this, but some of the paths ahead are now clearer, at least for the next few yards.</p>",
        "id": 477913292,
        "sender_full_name": "rzeta0",
        "timestamp": 1729445953
    },
    {
        "content": "<p>(I will suppress the urge to \"umm actually\")</p>",
        "id": 477913375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729446020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/terminology.20.3A.20statement.20vs.20proposition/near/477913375\">said</a>:</p>\n<blockquote>\n<p>(I will suppress the urge to \"umm actually\")</p>\n</blockquote>\n<p>go ahead - your previous \"um actually\" explaining the difference between a \"noun phrase\" and a statement was very helpful.</p>",
        "id": 477913639,
        "sender_full_name": "rzeta0",
        "timestamp": 1729446301
    },
    {
        "content": "<p>(Today's word is \"apophasis\", to say something by saying you won't say it :-) )</p>\n<p>I think Mario might be wanting to say that there are infinitely many <code>Type</code> universes, not just one.</p>",
        "id": 477913760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729446413
    },
    {
        "content": "<p>It's a technical thing that you don't need to worry about for now. This hierarchy of universes solves the problem \"What is the type of <code>Type</code>?\". The answer in Lean's type theory is <code>Type 1</code>, whose type is <code>Type 2</code>, and so on. Trying to make the type of <code>Type</code> be <code>Type</code> itself leads to paradox.</p>",
        "id": 477913853,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729446498
    },
    {
        "content": "<p>In some systems, notably Automath, there is simply two universes <code>Prop</code> and <code>Type</code>, and there just isn't a type of <code>Type</code>.</p>",
        "id": 477913920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729446586
    },
    {
        "content": "<p>Is this picture i drew correct (enough for beginners)? </p>\n<p><a href=\"/user_uploads/3121/ZxEyiECJpQGUqHAbrFjixwWy/app_taxonomy.png\">app_taxonomy.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ZxEyiECJpQGUqHAbrFjixwWy/app_taxonomy.png\" title=\"app_taxonomy.png\"><img data-original-dimensions=\"2364x1182\" src=\"/user_uploads/thumbnail/3121/ZxEyiECJpQGUqHAbrFjixwWy/app_taxonomy.png/840x560.webp\"></a></div>",
        "id": 477915754,
        "sender_full_name": "rzeta0",
        "timestamp": 1729448391
    },
    {
        "content": "<p>Yes, there are three degrees of objects: terms, types, and universes. The empty box on the right is \"propositions\".</p>\n<p>(The only complexity beyond this is that Lean lets you treat a universe like it was a type. For example, <code>Prop</code> is also a type in the <code>Type</code> universe. I think this is something you can overlook until you realize it's something you need.)</p>",
        "id": 477916510,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729449146
    },
    {
        "content": "<p>(A keyword is \"universe polymorphism\": you can make definitions that work for types no matter which universe they come from. That way you don't have to write one definition for <code>Prop</code> and another for <code>Type</code>.)</p>",
        "id": 477916570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729449224
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  - it is reassuring that the framework is broadly correct.</p>\n<p>my next diagram will try to explain how propositions are built - that stuff about \"formulae / expressions / logical connectors aka constants like <code>And</code> / labels or aliases like <code>h:</code>\"</p>",
        "id": 477916813,
        "sender_full_name": "rzeta0",
        "timestamp": 1729449435
    },
    {
        "content": "<p>Speaking of 'duality of syntax' from earlier, in some type theories there is a difference between the concepts <code>t : Ty</code> (\"term t has type Ty\") and <code>Ty : U</code> (\"type Ty is in universe U\"). Lean combines them into a single concept, which is convenient, but it can also be confusing because there really are three broad classes of objects.</p>",
        "id": 477917173,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729449754
    },
    {
        "content": "<p>I find the fact that \"proposition\" and \"Prop\" are different things quite confusing; this is why I use \"theorem statement\" when I'm teaching. My experience with mathematicians is that they are sometimes vague about the difference between \"theorem statement\" and \"theorem proof\" when speaking informally. You can \"apply the Poincare' conjecture\" but only because it's been proved, so you're really applying the proof of the Poincare' conjecture. You can't apply the Goldbach conjecture, unless you want to add a hypothesis to your argument. </p>\n<p>@rzeta0 there are other universes much bigger than <code>Type</code>, which are usually referred to as <code>Type*</code> in Lean, or <code>Type 1, Type 2, Type 3,...</code>. But again when I'm teaching undergraduates I never mention these higher universes as they are completely unnecessary for undergraduate level mathematics; they are only there for technical reasons coming from CS/logic, and are basically only useful to mathematicians when they start doing category theory or other kinds of mathematics which start reasoning about the \"collection of all sets\" as a mathematical object. We don't get that far in my class so <code>Type</code> and <code>Prop</code> are the only universes that my students ever see.</p>",
        "id": 477921917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729453924
    },
    {
        "content": "<p>The main reason that I avoid them is that your picture has a very pleasing symmetry to it and adding the higher universes breaks the symmetry for no good pedagogical reason (at least if your main concern is undergraduate level mathematics).</p>",
        "id": 477921992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729454013
    },
    {
        "content": "<p>So I created another diagram, but am far less certain of its correctness.  I welcome replies with corrections / clarifications.</p>\n<p>Key points / questions:</p>\n<ul>\n<li>I am now avoiding the words <strong>formula</strong> and <strong>statement</strong></li>\n<li>I am now only using the words <strong>proposition</strong>, <strong>proof</strong>, <strong>expression</strong> - because I think these sufficiently cover most beginner needs - am I right?</li>\n<li>proposition is something that is true or false</li>\n<li>proof is a bunch of propositions which justify another proposition</li>\n<li>expression is any code that is recognised as correct lean/mathlib - why are <code>=</code> and `∧ not expressions?</li>\n<li>re-reading the thread I was surprised that <code>h</code> was called a proof. I see it as a \"label\" which points to a proposition. </li>\n</ul>\n<p><a href=\"/user_uploads/3121/w1a9LnU5sed8QisakuYIYE1h/app_taxonomy_expressions.png\">app_taxonomy_expressions.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/w1a9LnU5sed8QisakuYIYE1h/app_taxonomy_expressions.png\" title=\"app_taxonomy_expressions.png\"><img data-original-dimensions=\"2364x1182\" src=\"/user_uploads/thumbnail/3121/w1a9LnU5sed8QisakuYIYE1h/app_taxonomy_expressions.png/840x560.webp\"></a></div>",
        "id": 478148100,
        "sender_full_name": "rzeta0",
        "timestamp": 1729544111
    },
    {
        "content": "<p>I don't personally think it's important for a beginner to know or use the term \"expression\" (i.e. to a beginner I don't see value in the whole bottom row getting a name).</p>",
        "id": 478149277,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729544592
    },
    {
        "content": "<p>I think you're also missing the most important (IMHO) concepts, namely that <code>x = 1 \\or y = 3</code> is a proposition yes, and a type! and a <em>term</em> of that type, i.e. <code>h : x = 1 \\or y = 3</code> is a <em>proof</em> of this proposition.</p>",
        "id": 478149375,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729544639
    },
    {
        "content": "<p>Perhaps you're missing the nuance between <code>x = 1 \\or y = 3</code> and <code>h : x = 1 \\or y = 3</code>.</p>",
        "id": 478149589,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729544713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  - I am definitely missing the nuance between <code>x = 1 \\or y = 3</code> and <code>h : x = 1 \\or y = 3</code>.</p>\n<p>Would you be able to explain? (if you have the patience)</p>\n<p>I don't understand your middle paragraph about the most important concepts, perhaps I will after the explanation?</p>",
        "id": 478150694,
        "sender_full_name": "rzeta0",
        "timestamp": 1729545138
    },
    {
        "content": "<p>Remember that <code>e : T</code> is not itself syntax for an expression in lean, the syntax is <code>(e : T)</code>, but either way this is generally interpreted to be talking about <code>e</code> (but with a side remark that it has type <code>T</code>). So <code>h : x = 1 \\or y = 3</code> would be read as just <code>h</code> (which by the way has type <code>x = 1 \\or y = 3</code>), which is quite different from <code>x = 1 \\or y = 3</code> (which by the way has type <code>Prop</code>)</p>",
        "id": 478151001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729545279
    },
    {
        "content": "<p>The object <code>h</code> whose type is <code>x = 1 \\or y = 3</code> is called a proof, and the object <code>x = 1 \\or y = 3</code> whose type is <code>Prop</code> is called a proposition</p>",
        "id": 478151125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729545328
    },
    {
        "content": "<p>there is an underlying operation here, \"the type of\", which goes from <code>h</code> to <code>x = 1 \\or y = 3</code> and from <code>x = 1 \\or y = 3</code> to <code>Prop</code>. For example, \"Mario\" is of type \"Human\" and \"Human\" is of type \"Species\" and \"Species\" is of type \"Classification of living things\". Sometimes people talk about the \"is-a\" relationship for this notion: Mario is-a Human but not vice versa</p>",
        "id": 478151510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729545463
    },
    {
        "content": "<p>it is important not to confuse <em>the class</em> with <em>an element of the class</em></p>",
        "id": 478151619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729545500
    },
    {
        "content": "<p>For proofs and propositions this is possibly slightly weird and unintuitive, but the idea is that a proposition is taken to be a classification of all of its proofs. The \"elements\" of a proposition are all the \"ways it can be true\", so in particular <code>True</code> has one way to be true, named <code>trivial</code> in lean, and <code>False</code> has no ways to be true, so it is an empty class of proofs.</p>",
        "id": 478151972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729545650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  - your first paragraph I think is <strong>extremely helpful.</strong></p>\n<p>Comparing <code>3 : ℕ</code> and <code>e : T</code> and then <code>h: x&gt;5</code>to see they are the \"same\" is really helpful.</p>\n<p>It hadn't sunk in properly that <code>h</code> is an element of <code>x&gt;5</code>.</p>\n<p>But to say <code>h</code> is a proof that <code>x^2 ≥ 0</code> does feel odd until I can see what <code>h</code> actually is. </p>\n<p>Is this what <code>:=</code> does?</p>\n<p>That is, <code>h: x^2 ≥ 0 := P</code> is read as <code>h</code> is a proof of the proposition <code>x^2 ≥ 0</code>, and <code>P</code> is a more verbose elaboration of <code>h</code>, specifically, verbose enough that a proof checker can check it.</p>",
        "id": 478154327,
        "sender_full_name": "rzeta0",
        "timestamp": 1729546586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span> </p>\n<blockquote>\n<p>I think you're also missing the most important (IMHO) concepts, namely that <code>x = 1 \\or y = 3</code> is a proposition yes, and a type! and a <em>term</em> of that type, i.e. <code>h : x = 1 \\or y = 3</code> is a <em>proof</em> of this proposition.</p>\n</blockquote>\n<p>Looking back at my first diagram I can see that </p>\n<ul>\n<li><code>x = 1 \\or y = 3</code> is a proposition</li>\n<li>and a type because it is in the middle layer</li>\n<li>and that <code>h</code> is in element of that type, which is in the bottom layer (proofs)</li>\n</ul>\n<p>Can I ask why you think this is very important - I think I am missing some important implication of all this.</p>",
        "id": 478154804,
        "sender_full_name": "rzeta0",
        "timestamp": 1729546791
    },
    {
        "content": "<p>The reason I think it's super important is somewhat precisely your last realization -- namely that <code>3 : ℕ</code> is <em>the same notion</em> to Lean as <code>h: x&gt;5</code>, and that this may not match people's intuitions (mathematicians or otherwise) who are not previously familiar with a proof assistant, so it's important to make this clear <em>and</em> to give names to the concepts, and \"term\" and \"type\" are the terminology someone will hear for this. In Kevin's post (which I haven't read in awhile but I recall being very helpful) this is a bit of the punchline – in the headline \"Propositions are types, proofs are terms.\"</p>",
        "id": 478170866,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729553955
    },
    {
        "content": "<p>Thanks Julian - you are right, this is not natural to how we've been thinking about maths, so it will take time for it to sink it.</p>\n<p>At least now I don' think it is wrong - just a new way to look at it.</p>\n<p>Thanks again!</p>",
        "id": 478171294,
        "sender_full_name": "rzeta0",
        "timestamp": 1729554109
    },
    {
        "content": "<p>Is my understanding of <code>:=</code> correct, in my previous message?</p>\n<p>That it reads as \"this is proof is elaborated as\" ?</p>",
        "id": 478171439,
        "sender_full_name": "rzeta0",
        "timestamp": 1729554177
    },
    {
        "content": "<p>Like my comments about <code>e : T</code>, <code>e : T := val</code> is also not valid syntax on its own, although as <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> has mentioned with the points about duality of syntax, <code>:=</code> is used to mean related things in many contexts in lean. Most likely the place you have seen this syntax is with either <code>def</code> or <code>theorem</code> before it. <code>theorem foo : 1 = 1 := proof</code> means that we are defining a new name <code>foo</code> for the proof <code>proof</code>, which is a term whose type is <code>1 = 1</code>, that is, a proof that <code>1 = 1</code> is a true statement. After this declaration, <code>foo</code> will also be a term whose type is <code>1 = 1</code>.</p>",
        "id": 478171484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729554210
    },
    {
        "content": "<p>we read <code>def c : T := val</code> as \"Define <code>c</code> to be a name for the expression <code>val</code>, whose type is <code>T</code>.\" Thereafter we may use <code>c</code> and know that it also has type <code>T</code>, and we also know that <code>c</code> and <code>val</code> are equal to one another.</p>",
        "id": 478171875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729554390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/terminology.20.3A.20statement.20vs.20proposition/near/478151510\">said</a>:</p>\n<blockquote>\n<p>here is an underlying operation here, \"the type of\",</p>\n</blockquote>\n<p>This operation is actually available to you in lean as <code>type_of%</code>, though you should be careful of using it with <code>#check</code> since this applies <code>type_of%</code> a second time:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">          </span><span class=\"c1\">--   1 : Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">type_of</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- Nat : Type</span>\n</code></pre></div>",
        "id": 478171959,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729554448
    },
    {
        "content": "<p>I think a bunch of <span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span>'s questions come from notation seen in the infoview, or at least that's why I'm quite happy with being slightly more willy nilly about calling <code>e : T</code> a thing, and why I'm assuming that your question (<span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> ) is about seeing <code>:=</code> in the infoview rather than as something you're typing in a Lean file. I could be assuming wrong of course.</p>\n<p>But if that's where you're asking about, that's Lean telling you <em>which</em> term you have. More precisely -- when you see <code>foo : bar</code> in the infoview, that's Lean saying \"foo is a bar\" like Mario explained. <code>bar</code> here is a type -- it could be a type you've known about all your life like the natural numbers, or a \"bend your mind a bit\" type, like the type of \"proofs of x &gt; 3\" -- but if all you see is <code>foo : bar</code>... which <code>bar</code> is it? If you see <code>n : Nat</code> that says \"n is a natural number\", and there's no specific information about which number it is within <code>n</code> itself. Now you may have some <em>other</em> hypothesis <code>h : n = 37</code> -- but that is a separate <em>proof</em> that <code>n</code> equals 37. If you see the infoview say <code>n : Nat := 37</code> that's the infoview saying \"n is a natural -- and it's the number 37\" all at once. (You can get this kind of thing typically from the <code>let</code> or <code>set</code> tactics, as opposed to <code>have</code>).</p>",
        "id": 478175407,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729556152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span> I'm definitely typing it.. here 3 times:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>I will read the above comments when I wake up later :)</p>",
        "id": 478182361,
        "sender_full_name": "rzeta0",
        "timestamp": 1729559881
    },
    {
        "content": "<p>OK, then never mind my last comment.</p>",
        "id": 478183734,
        "sender_full_name": "Julian Berman",
        "timestamp": 1729560685
    },
    {
        "content": "<p>The first <code>:=</code> is a variant on the <code>def</code> / <code>theorem</code> thing I described before. <code>example : T := val</code> is equivalent to <code>def _discarded_name : T := val</code>, which is to say it makes a definition but immediately discards it. The purpose is just to check that <code>val</code> actually has type <code>T</code>.</p>",
        "id": 478183886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729560773
    },
    {
        "content": "<p>The second <code>:=</code> is part of the <code>calc</code> notation, and provides a proof for the steps of the transitivity chain. Here again the steps have the form <code>T := val</code> where <code>val</code> is asserted to have type <code>T</code>. (Once upon a time <code>calc</code> used a colon based syntax i.e. <code>T : val</code> instead but people rightfully pointed out that this is backwards, since <code>val</code> has type <code>T</code> and not vice versa.)</p>",
        "id": 478184124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729560932
    },
    {
        "content": "<blockquote>\n<p>we read <code>def c : T := val</code> as \"Define <code>c</code> to be a name for the expression <code>val</code>, whose type is <code>T</code>.\" Thereafter we may use <code>c</code> and know that it also has type <code>T</code>, and we also know that <code>c</code> and <code>val</code> are equal to one another.</p>\n<p>The first <code>:=</code> is a variant on the <code>def</code> / <code>theorem</code> thing I described before. <code>example : T := val</code> is equivalent to <code>def _discarded_name : T := val</code>, which is to say it makes a definition but immediately discards it. The purpose is just to check that <code>val</code> actually has type <code>T</code>.</p>\n</blockquote>\n<p>Thanks - this answers that question.</p>",
        "id": 478227455,
        "sender_full_name": "rzeta0",
        "timestamp": 1729584362
    }
]