[
    {
        "content": "<p>I'm working on mechanizing a lambda calculus. I have inductive types for the syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Val</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>The static semantics is defined by a typing relation, which is currently a <code>Prop</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typing</span><span class=\"bp\">.</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I have a lot of recursive definitions that tell me some property about a typed expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>But recursive calls are a huge pain, because I have to re-convince Lean that the subexpressions are typed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">M_typed</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">convince</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">typed</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">convince</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">typed</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>How would you change things to make <code>foo</code> and <code>bar</code> and <code>qux</code> easier to define? My main idea is to change <code>Typed</code> from a <code>Prop</code> to a <code>Type</code> and so I could just write something like <code>def foo : Typed M -&gt; A = ...</code> but I'm worried this could somehow bite me later in the project. For example, you can't use the <code>cases</code> tactic on a <code>Type</code>.</p>",
        "id": 496861509,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738268442
    },
    {
        "content": "<p>Err, now I realize converting it to a <code>Type</code> wouldn't be enough because there are still a <code>G</code> and a <code>T</code> getting existentially quantified. That is, I couldn't define <code>def foo : (exists G T, Typed G M T) -&gt; A</code> because <code>foo</code>'s argument would be a Prop. I guess I could use PSigma instead. But surely there's a simpler way?</p>",
        "id": 496864476,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738269679
    },
    {
        "content": "<p>you might ask for <code>G</code> and <code>T</code> to be provided explicitly to <code>foo</code>?</p>",
        "id": 496864706,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738269769
    },
    {
        "content": "<p>True! But I'd still have to construct a new <code>G</code> and <code>T</code> when I make recursive calls to <code>foo</code>, right? Ideally I could just write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M1</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M2</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 496865060,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738269919
    },
    {
        "content": "<p>could be... although maybe that's where you can write some lemmas to help?</p>",
        "id": 496865367,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270051
    },
    {
        "content": "<p>if you use the \"exists G T\" version, you'd need to provide a proof of this anyway</p>",
        "id": 496865485,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270093
    },
    {
        "content": "<p>btw you <em>can</em> use the <code>cases</code> tactic on a value of a type. for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n'</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">self_eq_add_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_const</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_false</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_right_cancel_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_eq'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_true</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 496866066,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270320
    },
    {
        "content": "<p>In case it's helpful as a case study, in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rack.PreEnvelGroupRel%27#doc\">docs#Rack.PreEnvelGroupRel'</a> I found it was easier to make a Type-valued relation for recursion purposes, and then I \"propified\" it in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rack.PreEnvelGroupRel#doc\">docs#Rack.PreEnvelGroupRel</a> (That's the same as using <code>Nonempty</code>; I don't remember why it is a custom type.)</p>",
        "id": 496866253,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738270376
    },
    {
        "content": "<p>readability?</p>",
        "id": 496866306,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270397
    },
    {
        "content": "<p>naming?</p>",
        "id": 496866320,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270401
    },
    {
        "content": "<p>there can be many good reasons</p>",
        "id": 496866360,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738270420
    },
    {
        "content": "<p>Good guesses, but we'll never know. I wrote it, and I don't remember ;-)</p>",
        "id": 496866639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738270507
    },
    {
        "content": "<p>@Edward I think that sounds similar to what I have already---for each typing rule in <code>Typed</code>, I have inversion lemmas that tell me the subexpressions are typed. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">app_inv1</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">app_inv2</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>So my definition of <code>foo</code> can go something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">M_typed</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">app_inv1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">M2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">app_inv2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It's minimal, but still tedious</p>",
        "id": 496866641,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738270507
    },
    {
        "content": "<p>@Kyle ooh cool idea!</p>",
        "id": 496867205,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738270699
    },
    {
        "content": "<p>depending on how you define <code>Typed</code>, since you're doing matching, you could <em>maybe</em> recover these values from just matching on <code>M_typed</code>?</p>",
        "id": 496868156,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738271049
    },
    {
        "content": "<p>Assuming Typed is a Type right? Because we can't match on a Prop at runtime IIRC</p>",
        "id": 496868501,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738271185
    },
    {
        "content": "<p>In that case indeed the inversion lemmas could just be replaced with getters on M_typed</p>",
        "id": 496868625,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738271244
    },
    {
        "content": "<p>Well, I'd still have to pack the proof together with witness context and type</p>",
        "id": 496868950,
        "sender_full_name": "Dan Plyukhin",
        "timestamp": 1738271374
    },
    {
        "content": "<p>yea, i don't think youll be able to avoid that</p>",
        "id": 496869067,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1738271405
    },
    {
        "content": "<p>Maybe something like that could work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span>\n<span class=\"w\">  </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">isOfType</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">is_of_type_tactic</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Typed</span><span class=\"bp\">.</span><span class=\"n\">proof</span>\n</code></pre></div>\n<p>You would have to work out good tactic, but assuming it worked, you can construct Typed just by providing Expr and Ty.</p>",
        "id": 502875845,
        "sender_full_name": "MrQubo",
        "timestamp": 1740932587
    }
]