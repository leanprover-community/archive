[
    {
        "content": "<p>This question may sound a bit vague so I'll show a specific example.</p>\n<p>Suppose we start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">MIL</span><span class=\"bp\">.</span><span class=\"n\">Common</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>At this point my goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>Now, I can see the <code>→</code> there so I know it's an implication. And to prove an implication, I need to assume its left side, and prove the rest. Which I can do by <code>intro</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Now I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>My goal is to show that <code>s</code> is a subset of some other thing.</p>\n<p>What do I do next?</p>\n<p>If I was solving this on paper, I would look up in my reference book what the definition of \"x is a subset of y\" is. Expanding that definition would tell me that it's a \"forall\". And I know that in order to prove a \"forall\", I need to \"pick\" an element — an <code>intro</code>.</p>\n<p>But I'm not solving this on paper. I'm solving this in an environment that's supposed to be more helpful — at least in the sense of looking things up. And yet, I can't actually figure out how to make it help me.</p>\n<p>Let's start by hovering:</p>\n<p><a href=\"/user_uploads/3121/LDMWXlI-Bk1xaoUOOKPy6qwZ/Screenshot-2025-02-14-at-22.34.00.png\">Screenshot 2025-02-14 at 22.34.00.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/LDMWXlI-Bk1xaoUOOKPy6qwZ/Screenshot-2025-02-14-at-22.34.00.png\" title=\"Screenshot 2025-02-14 at 22.34.00.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"978x330\" src=\"/user_uploads/thumbnail/3121/LDMWXlI-Bk1xaoUOOKPy6qwZ/Screenshot-2025-02-14-at-22.34.00.png/840x560.webp\"></a></div><p>We've learned that ... it's a subset relation. Cool. Let's hover further?</p>\n<p><a href=\"/user_uploads/3121/E7yFFF8BJjVQZ5fhaq7aX-DM/Screenshot-2025-02-14-at-22.34.43.png\">Screenshot 2025-02-14 at 22.34.43.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/E7yFFF8BJjVQZ5fhaq7aX-DM/Screenshot-2025-02-14-at-22.34.43.png\" title=\"Screenshot 2025-02-14 at 22.34.43.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1022x236\" src=\"/user_uploads/thumbnail/3121/E7yFFF8BJjVQZ5fhaq7aX-DM/Screenshot-2025-02-14-at-22.34.43.png/840x560.webp\"></a></div><p>Hmm. Okay. Maybe let's click into it?</p>\n<p><a href=\"/user_uploads/3121/FZNbPyPoYDfIDfOZXzjxq3zE/Screenshot-2025-02-14-at-22.35.25.png\">Screenshot 2025-02-14 at 22.35.25.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/FZNbPyPoYDfIDfOZXzjxq3zE/Screenshot-2025-02-14-at-22.35.25.png\" title=\"Screenshot 2025-02-14 at 22.35.25.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"968x432\" src=\"/user_uploads/thumbnail/3121/FZNbPyPoYDfIDfOZXzjxq3zE/Screenshot-2025-02-14-at-22.35.25.png/840x560.webp\"></a></div><p>Yea that's not super helpful. (Let's pretend I didn't realize I can scroll above and find something relevant there.)</p>\n<p>Anyway, implementation details, yada yada, false trail.</p>\n<p>Let's go back to my code. Perhaps I can use <code>simp</code> to \"unroll\" the definitions?</p>\n<p>Nah.</p>\n<p><a href=\"/user_uploads/3121/JuGR2AajuyqAyK39lIjhzQfi/Screenshot-2025-02-14-at-22.36.33.png\">Screenshot 2025-02-14 at 22.36.33.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JuGR2AajuyqAyK39lIjhzQfi/Screenshot-2025-02-14-at-22.36.33.png\" title=\"Screenshot 2025-02-14 at 22.36.33.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1120x542\" src=\"/user_uploads/thumbnail/3121/JuGR2AajuyqAyK39lIjhzQfi/Screenshot-2025-02-14-at-22.36.33.png/840x560.webp\"></a></div><p>So at this point I take a math book, look up the definition of a subset, and learn it's a \"forall\", so at this point <code>intro</code> is what I need.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>Which is great. My question is:</p>\n<ul>\n<li>How am I supposed to guess these things? Is there any way to reliably unroll the definition and cutesy syntax so that I can see the shape of the next thing?</li>\n<li>It seems like the computer \"knows\" the shape of the next thing (i.e. whether I should <code>constructor</code> it, <code>intro</code> it, or whatever). Is there any reason that the next reasonable thing isn't strongly suggested? I feel like I'm spending 80% of my time picking the right shape of the <code>rintro</code>s and such to capture all the nested stuff — and enough times to not miss anything — why isn't the computer doing that for me?</li>\n</ul>\n<p>Thank you!</p>",
        "id": 499844240,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739572815
    },
    {
        "content": "<p>It would be nice if hovering over subsets could give you Set-specific information.</p>\n<p>Somehow, we learn that the definition of Set's subset notation is that it's a forall (maybe in Mathematics in Lean, maybe elsewhere), and we learn that the direct proof for a subset relation is <code>intro x hx</code>. (Incidentally, in my discrete math course, this is what we've been covering this week, the definitions of basic set notations. Not in Lean! Just on paper.)</p>\n<p>It would be neat if there were some background process that could suggest next tactics. given the shape of the goal.</p>",
        "id": 499845538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739573409
    },
    {
        "content": "<p>If you know Mathlib's naming conventions, you might guess to look up <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.subset_def#doc\">docs#Set.subset_def</a></p>",
        "id": 499845700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739573502
    },
    {
        "content": "<p>(I don't see it documented in Mathlib.Data.Set.Defs that you're allowed to make use of the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Subset#doc\">docs#Set.Subset</a> without rewriting first. Generally, we try avoiding to make use of raw definitions, instead going through rewrites. It's called \"defeq abuse\" when you're not supposed to. However, we've all agreed that <code>Set.Subset</code> <em>is</em> this forall.)</p>",
        "id": 499846108,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739573685
    },
    {
        "content": "<p>(I agree with this general rant), but will mention:</p>\n<blockquote>\n<p>It seems like the computer \"knows\" the shape of the next thing (i.e. whether I should constructor it, intro it, or whatever). Is there any reason that the next reasonable thing isn't strongly suggested?</p>\n</blockquote>\n<p><code>hint</code> is a partial answer here perhaps. Specifically it will suggest <code>intro</code> in this case (with <code>import Mathlib</code>). It needs some TLC to add a few more tactics it tries, but sometimes it's useful for this kind of \"what shape is this thing, probably a tactic knows\".</p>",
        "id": 499846421,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739573832
    },
    {
        "content": "<p>A meta and unhelpful answer is that we already have the theorem in mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_subset_iff#doc\">docs#Set.image_subset_iff</a> so we don't need to be operating at this low level :-)</p>\n<p>Still, reasoning about subsets with <code>intro</code> is commonplace.</p>",
        "id": 499846711,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739573976
    },
    {
        "content": "<p>I see, so basically this could be seen as one of those \"just gotta know it\" things, with a fallback to guessing the definition name based on convention.</p>",
        "id": 499846895,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739574050
    },
    {
        "content": "<p>There's also <code>tauto_set</code> now right, can it solve this? (EDIT: looks like no)</p>",
        "id": 499847178,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739574176
    },
    {
        "content": "<p>To clarify, my question isn't necessarily about the subset relation. More like generally — when I see some notation for some abstraction in my goal, how do I unroll it down to the closest \"elementary\" thing that would dictate the next tactic. By \"elementary\" I mean quantifiers, implications, logical statements, and such.</p>",
        "id": 499847362,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739574249
    },
    {
        "content": "<p>FWIW, the \"it's hard to figure out the specific definition of something when you're using type classes\" issue is on my to-do list, but there's lots of other important stuff that is also on there :-)<br>\nPerhaps next quarter, but no guarantees yet.</p>",
        "id": 499847389,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1739574267
    },
    {
        "content": "<blockquote>\n<p>More like generally — when I see some notation for some abstraction in my goal, how do I unroll it down to the closest \"elementary\" thing that would dictate the next tactic. By \"elementary\" I mean quantifiers, implications, logical statements, and such.</p>\n</blockquote>\n<p>And to \"motivate\" this question a bit further — the compiler clearly <em>knows</em> <code>s ⊆ f ⁻¹' v</code>'s outer surface is \"forall-shaped\" because it <em>permits</em> an <code>intro</code> on it. So it's not just a matter of me finding the right substitution via <code>hint</code> or a definition via <code>rw</code>. When I <code>intro</code>, I don't specify the substitution — therefore that information <em>has</em> to be there already. So how do I access what the compiler knows?</p>",
        "id": 499847729,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739574432
    },
    {
        "content": "<p>I understood the general question (that this wasn't specific to subsets) I think -- which substitution are you referring to though? Substituting \\sub for its definition? hint suggests \"try intro, it works\", even for the original goal, isn't that the idea?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Try</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"o\">:</span>\n<span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">image_subset_iff</span><span class=\"o\">]</span>\n<span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">image_subset_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>It <em>also</em> finds the lemma Kyle mentioned (because it tries <code>exact?</code> I think too) -- but any time <code>intro</code> works <code>hint</code> will say so I think (including if that lemma didn't exist, say)</p>",
        "id": 499848384,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739574738
    },
    {
        "content": "<p>Looks like maybe <code>hint</code> is the way to go then! For me it shows <em>only</em> <code>exact image_subset_iff.mp h</code> in this case. (Which is great but defeats the point of this exercise)</p>\n<p><a href=\"/user_uploads/3121/uStgQZrLEHXNFEDUqsx1lhql/Screenshot-2025-02-14-at-23.13.29.png\">Screenshot 2025-02-14 at 23.13.29.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/uStgQZrLEHXNFEDUqsx1lhql/Screenshot-2025-02-14-at-23.13.29.png\" title=\"Screenshot 2025-02-14 at 23.13.29.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2180x658\" src=\"/user_uploads/thumbnail/3121/uStgQZrLEHXNFEDUqsx1lhql/Screenshot-2025-02-14-at-23.13.29.png/840x560.webp\"></a></div><p>I'll try it in other cases, maybe it's what I wanted.</p>",
        "id": 499848689,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739574899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 499848816,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739574960
    },
    {
        "content": "<p>Going to assume <code>hint</code> is the answer here, thank you!</p>",
        "id": 499848865,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739574966
    },
    {
        "content": "<p>What it mentions depends on what you have imported -- I tried it with <code>import Mathlib</code></p>",
        "id": 499848876,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739574971
    },
    {
        "content": "<p>Because somewhere in mathlib is a file that adds a bunch of tactics to the ones <code>hint</code> tries</p>",
        "id": 499848908,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739574987
    },
    {
        "content": "<p>And possibly that file is later in the import hierarchy than it could be</p>",
        "id": 499848926,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739574997
    },
    {
        "content": "<p>Maybe just a version issue or something.</p>\n<p>Here's what I'm getting in this example.</p>\n<p><a href=\"/user_uploads/3121/AIca1d-bAkBYGIHLN3LVnvhq/Screenshot-2025-02-14-at-23.17.57.png\">Screenshot 2025-02-14 at 23.17.57.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AIca1d-bAkBYGIHLN3LVnvhq/Screenshot-2025-02-14-at-23.17.57.png\" title=\"Screenshot 2025-02-14 at 23.17.57.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2166x1134\" src=\"/user_uploads/thumbnail/3121/AIca1d-bAkBYGIHLN3LVnvhq/Screenshot-2025-02-14-at-23.17.57.png/840x560.webp\"></a></div><p>Complete file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">hint</span>\n</code></pre></div>",
        "id": 499849168,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739575105
    },
    {
        "content": "<p>Ah fun, mine was from: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">hint</span>\n</code></pre></div>\n<p>Because I was too lazy to focus, which is surprising that there's a difference. I'm guessing there's some short circuiting happening because it finds a way to close the goal but yeah no idea why the behavior differs in these two cases.</p>",
        "id": 499850946,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739575944
    },
    {
        "content": "<p>The tactic <code>whnf</code> will reduce the outermost application until it can't be reduced anymore. In this case it should reveal the forall (not tested). This has been useful to me occasionally.</p>",
        "id": 499851174,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739576058
    },
    {
        "content": "<p>You can also just try <code>intro</code> and see if it works</p>",
        "id": 499851710,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739576331
    },
    {
        "content": "<p>(proviso: whnf can reveal what something is defeq to, but it might be defeq abuse to take advantage of it)</p>",
        "id": 499851765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739576359
    },
    {
        "content": "<p>The following lets you see the forall. Although definitely not the ideal approach, it might be helpful in other situations.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">unfold_projs</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Subset</span>\n</code></pre></div>",
        "id": 499856243,
        "sender_full_name": "Eric Paul",
        "timestamp": 1739578654
    },
    {
        "content": "<p>Ah, looks like <code>whnf</code> is <em>exactly</em> what I wanted. Thanks <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>!</p>",
        "id": 499862130,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739582176
    },
    {
        "content": "<blockquote>\n<p>it might be defeq abuse to take advantage of it</p>\n</blockquote>\n<p>Mind elaborating briefly on what can go wrong? I assume you're saying it's bad form to leave <code>whnf</code> in?</p>",
        "id": 499862225,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739582252
    },
    {
        "content": "<p>I mean \"to take advantage of the details of the definition you learn from whnf\"</p>",
        "id": 499863247,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739582898
    },
    {
        "content": "<p>I think it's worth re-emphasizing that <code>Subset</code> is a weird case where we're all okay with breaking through an encapsulation layer, but in many (most?) cases the answer to \"how do I know to use <code>intro</code> when it's not a <code>forall</code>?\" is \"you <em>don't</em> use <code>intro</code>... you use an <code>iff</code> lemma that rewrites the term to a <code>forall</code>\".</p>",
        "id": 499864901,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739583958
    },
    {
        "content": "<p>however, I also break that rule all the time, so... <span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span></p>",
        "id": 499865022,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739584013
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20do.20I.20know.20when.20to.20.60intro.60.3F/near/499862225\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>it might be defeq abuse to take advantage of it</p>\n</blockquote>\n<p>Mind elaborating briefly on what can go wrong? I assume you're saying it's bad form to leave <code>whnf</code> in?</p>\n</blockquote>\n<p>By \"defeq abuse\" we mean \"unnecessarily depending on implementation details\".</p>\n<p>In this case, it's fine. But in more complex definitions, that they use forall might be a coincidence, not a guarantee, and so your code might break if you depend on that fact.</p>",
        "id": 499866626,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739584996
    },
    {
        "content": "<p>Yes, so the answer to the bigger question of \"why doesn't the compiler tell me what it knows about the underlying definition\" is \"because you shouldn't need to know it\"</p>",
        "id": 499866796,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739585112
    },
    {
        "content": "<p>Ok that makes sense, thanks for explaining.</p>",
        "id": 499870728,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739587543
    },
    {
        "content": "<p>So I think what y'all are saying is — usually you don't actually <em>want</em> to pierce to the closest qualifier/implication because the way definitions are constructed is often an implementation detail, and so this would pierce through the abstraction in a way that is fragile, may change between the releases, and may expose other unintended details. Each piece of the library has some intended public API for interacting with it, and for higher-level math it tends to be explicit definitions and equivalence theorems. But a subset relationship is so ubiquitous that it's fine to treat it as a forall directly because even if intro didn't work on it, it would be worth special-casing it to make intro work for it — just because of how much it comes up.</p>",
        "id": 499872080,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739588381
    },
    {
        "content": "<p>When I'm teaching this stuff I say \"ok today we're doing subsets and the definition of subset is (forall...) so you're going to need to know how to change a subset goal or hypothesis into a forall, and you do that with <code>rw [subset_def]</code> and that's all the API you need to know for subsets\". Ie it's my job as the teacher to explain the API of the thing we're working with.</p>\n<p>(Later on with smart students I then show them that they can delete the rewrites and their proof still works, and explain that this is because the proof is rfl)</p>\n<p>Dan is really asking \"how do I figure out the API for [anything]\" and my usual response when a student asks this is \"find the definition in the code and read the ten lemmas that directly follow\". I think that as a general principle you're not going to find a tactic or a technique which will be able to answer this question in all cases because the answer might be arbitrarily complicated.</p>\n<p>Maybe the API for something like this should be in a docstring<br>\nsomewhere? I got sick of students asking me how to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> so I just PRed its API literally into its docstring and now nobody ever asks me how to use it.</p>",
        "id": 499893244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739606719
    },
    {
        "content": "<p>What about <code>unfold</code>?  Is that also discouraged for the same reason?</p>\n<p>I find this discussion a bit disconcerting.  I understand the point about \"defeq abuse.\"   But when teaching students to write proofs, one of the fundamental lessons I would want them to learn is the importance of definitions, and how unfolding definitions often tells you how to proceed.  I would worry about telling students that they shouldn't unfold definitions.  But perhaps the worry here is not for education, but only for something like contributions to mathlib?</p>",
        "id": 499929129,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1739637632
    },
    {
        "content": "<p>I'm guessing part of the issue here is what's considered a definition — a definition in the mathematical sense may be different from a definition that serves as an intermediate implementation detail. So the former make sense to unfold but not the latter.</p>\n<p>I liked <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s point about docstrings. I would personally appreciate if each type or especially custom notation docstrings mentioned the \"public API\" definition for unfolding that thing if one exists.</p>",
        "id": 499929635,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739638049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span> The most pernicious kind of defeq abuse is when there's no <code>unfold</code>, and a proof takes advantage of one or more definitions without any signposts. This can make proofs fragile and difficult to fix when definitions subtly change.</p>\n<p>Using <code>unfold</code> is a better situation, since at least we know which definitions a theorem depends on.</p>\n<p>I think whether to <code>unfold</code> just depends on what you're working on. The immediate theory about an object needs to know about the definition, but after that you ought to have enough of that theory to have characterized the object, letting you work with it axiomatically. In teaching, I think most cases of <code>unfold</code> could be considered doing exercises within the immediate theory.</p>",
        "id": 499930202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739638503
    },
    {
        "content": "<p>People seem to be interested in developing more NNG levels so I just spent some time playing through the game again and opening up a bunch of new issues about possible future worlds which should be easy to make. It did occur to me that rather than telling people to do <code>cases</code> on <code>h : a ≤ b</code> and to do <code>use</code> on <code>⊢ a ≤ b</code> I should tell them to do <code>rw [le_def]</code> to explicitly transform things into <code>exists</code> statements. I am in two minds about this.</p>",
        "id": 499931603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739639555
    },
    {
        "content": "<p>Most theorems involve doing <code>unfold</code> at least once, especially if it is an API lemma for a new definition. But <code>unfold</code>ing more than 2 nested layers of definition is a code smell, and a frequent mistake by new formalizers. It's basically the same issues as breaking API boundaries in programming: it increases coupling between components / parts of a proof, and also tends to make goal states larger than necessary. The solution is to either use the provided API lemmas for the layer you want to stop at, or write those lemmas if they are missing.</p>",
        "id": 499949682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739652824
    },
    {
        "content": "<p>(This is a bit of an idealized statement, there are some reasons why one may have to break the rules. But it is a good rule of thumb regardless.)</p>",
        "id": 499949748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739652878
    }
]