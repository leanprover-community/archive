[
    {
        "content": "<p>I am currently writing my first lemma in a library.</p>\n<p>In my learning thus far, theorem/lemma headers have curley brackets around variable type declarations, and round brackets for enclosing hypotheses.</p>\n<p>However, a more experienced person suggested some sample code as follows:</p>\n<p><code>lemma le_or_succ_le (a b : ℕ) : a ≤ b ∨ b + 1 ≤ a </code></p>\n<p>I was surprised to see the <code>(a b : ℕ)</code> as I would have habitually used <code>{a b : ℕ}</code>.</p>\n<p>Writing the actually lemma and then using it in other proofs works with the round brackets, not the curly brackets.</p>\n<p><strong>Question:</strong> What's the reason?</p>\n<hr>\n<p>For context, here is the standard format that I have seen many many times:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"c1\">--           ꜛ(1)      ꜛ(2)      ꜛ(3)</span>\n<span class=\"c1\">--    (1) variable types in curly brackets</span>\n<span class=\"c1\">--    (2) hypotheses in round brackets</span>\n<span class=\"c1\">--    (3) proof objective</span>\n</code></pre></div>",
        "id": 475364796,
        "sender_full_name": "rzeta0",
        "timestamp": 1728326113
    },
    {
        "content": "<p>The difference is explicit vs implicit arguments. You can use implicit arguments (curly brackets) if you can infer the earlier arguments from later ones (like <code>h</code>) in your case</p>",
        "id": 475365218,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728326267
    },
    {
        "content": "<p>Ruben - thanks for trying to help. </p>\n<p>Sadly I don't understand. Given <code>h: a &gt; b</code> I don't think I can infer the type of <code>a</code> and <code>b</code>. They could be <code>ℤ</code> or <code>ℝ</code> ?</p>",
        "id": 475366057,
        "sender_full_name": "rzeta0",
        "timestamp": 1728326544
    },
    {
        "content": "<p>Not the type, the value</p>",
        "id": 475366483,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728326692
    },
    {
        "content": "<p>If you pass the argument <code>2 &gt; 1</code>, then <code>a = 2</code> and <code>b = 1</code></p>",
        "id": 475366596,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728326729
    },
    {
        "content": "<p>Ruben - ok, so when would you use () and when would you use {}? What's the benefit of marking variables as implicit and not always using explicit ()?</p>\n<p>Going back to the example of a library lemma, </p>\n<p><code>lemma le_or_succ_le (a b : ℕ) : a ≤ b ∨ b + 1 ≤ a</code> </p>\n<p>why can't we say that the values of <code>a</code> and <code>b</code> can be inferred? Is it because there is no hypothesis?</p>\n<p>I tried reading the docs but they're too advanced for me: <a href=\"https://docs.lean-lang.org/lean4/doc/implicit.html\">https://docs.lean-lang.org/lean4/doc/implicit.html</a></p>",
        "id": 475369354,
        "sender_full_name": "rzeta0",
        "timestamp": 1728327298
    },
    {
        "content": "<p>The general benefit is that it makes it easier for the person using the lemma to pass fewer things when doing so is unambiguous.</p>",
        "id": 475382724,
        "sender_full_name": "Julian Berman",
        "timestamp": 1728331123
    },
    {
        "content": "<p>If your lemma takes 2 numbers <code>a b</code> and outputs a proof that <code>a ≤ b ∨ b + 1 ≤ a</code> and someone wants to use it and has a goal with numbers in it, how do they tell your lemma which numbers they mean to get a proof for?</p>",
        "id": 475383068,
        "sender_full_name": "Julian Berman",
        "timestamp": 1728331190
    },
    {
        "content": "<p>Whereas in your previous example with <code>{ a b : ℕ} (h: a &gt; b) : a^2 &gt; b ^2</code>, the person who wants to use your lemma is <em>already</em> signalling which numbers they want to use the lemma on, because they also have to pass a <em>proof</em> as one of the arguments, and that proof contains 2 specific numbers in it.</p>",
        "id": 475383402,
        "sender_full_name": "Julian Berman",
        "timestamp": 1728331240
    },
    {
        "content": "<p>If the <code>a b : Nat</code> were also explicit, that means when they use the lemma they have to pass those numbers <em>again</em> a second time, instead of just saying \"obviously I mean the same <code>a</code> and <code>b</code> as what's in my proof that <code>a &lt; b</code>\"</p>",
        "id": 475383605,
        "sender_full_name": "Julian Berman",
        "timestamp": 1728331280
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  - thanks for taking the time to explain. I think we're close.</p>\n<p>I've read your comments about 7 times slowly over a period of an hour and I am not quite there.  Apologies for my slow learning...</p>\n<p>Let me focus in on two of your points:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/round.20vs.20curly.20brackets.20.20in.20theorem.20header/near/475383068\">said</a>:</p>\n<blockquote>\n<p>If your lemma takes 2 numbers <code>a b</code> and outputs a proof that <code>a ≤ b ∨ b + 1 ≤ a</code> and someone wants to use it and has a goal with numbers in it, how do they tell your lemma which numbers they mean to get a proof for?</p>\n</blockquote>\n<p>To answer your question, we pass the two numbers as parameters. For example; <code>have h := Nat.le_or_succ_le n 1</code> where the two numbers are <code>n</code> and <code>1</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/round.20vs.20curly.20brackets.20.20in.20theorem.20header/near/475383402\">said</a>:</p>\n<blockquote>\n<p>Whereas in your previous example with <code>{ a b : ℕ} (h: a &gt; b) : a^2 &gt; b ^2</code>, the person who wants to use your lemma is <em>already</em> signalling which numbers they want to use the lemma on, because they also have to pass a <em>proof</em> as one of the arguments, and that proof contains 2 specific numbers in it.</p>\n</blockquote>\n<p>This is new terminology for me. I'm not sure what \"passing a proof\" means.</p>\n<p>Does it mean that the hypotheses <code>h: a &gt; b</code> must be established beforehand?</p>\n<p>Is <code>h1</code> passing the proof in the following example?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">my_lemma_sq_gt_sq_of_gt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>where <code>h1: a &gt; b</code> or possibly <code>h1: 4&gt;2</code>.</p>\n<hr>\n<p>If you have the patience, perhaps you can illustrate what \"passing those numbers again a second time\" looks like in code?</p>",
        "id": 475424815,
        "sender_full_name": "rzeta0",
        "timestamp": 1728345565
    },
    {
        "content": "<blockquote>\n<p>we pass the two numbers as parameters</p>\n</blockquote>\n<p>You are able to pass the two numbers as parameters precisely because you use parentheses. When you write parentheses, your lemma takes parameters. When you don't and write curly braces, you are telling Lean to automatically guess the value of those parameters and not let you pass them explicitly. (Strictly speaking Lean has syntax for overriding this, but that's the basic difference others were trying to mention).</p>\n<blockquote>\n<p>This is new terminology for me. I'm not sure what \"passing a proof\" means. Does it mean that the hypotheses <code>h: a &gt; b</code> must be established beforehand?</p>\n</blockquote>\n<p>I was trying to use terminology you'd be comfortable with :) ! You're comfortable with the terminology \"pass two numbers as parameters\" right? To Lean, a number and a proof are no different really, they're 2 different kinds of objects Lean knows about. When you have <code>lemma something (a : ℕ) : ...</code> you are telling lean you want a function which takes one parameter, a natural number. When you have <code>lemma something_else (h : a &gt; b) : ...</code> you are telling lean you want a function which takes one parameter, a <em>proof</em> that a is greater than b. When you call <code>something 3</code>, you passed  the Nat<code>3</code> to something. When you call <code>something_else foo</code> you passed <code>foo</code> -- which better be a <em>proof</em> of that inequality (the terminology here is \"a term of type <code>a &gt; b</code>\"). So by passing a proof all I meant was passing parameters, same as you're familiar with with numbers.</p>\n<blockquote>\n<p>Is <code>h1</code> passing the proof in the following example?</p>\n</blockquote>\n<p>Yes, if <code>h1 : a &gt; b</code>, but the syntax is generally going to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">my_lemma_sq_gt_sq_of_gt</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>or if you still are more comfortable with tactics,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">my_lemma_sq_gt_sq_of_gt</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>\n<p>(The square brackets <code>[h1]</code> is part of the syntax for the <code>rw</code> tactic.)</p>\n<blockquote>\n<p>perhaps you can illustrate what \"passing those numbers again a second time\" looks like in code?</p>\n</blockquote>\n<p>Does this simplification help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pow_two</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_lt_mul_of_lt_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo_too_explicit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pow_two</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pow_two</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_lt_mul_of_lt_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h34</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">less_annoying</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">h34</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">more_annoying</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo_too_explicit</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">h34</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n</code></pre></div>\n<p>It's simply annoying to have to pass <code>3</code> and <code>4</code> in <code>foo_too_explicit</code>, because <code>h34</code> already contains all the information needed about which <code>a</code> and <code>b</code> we're talking about.</p>",
        "id": 475435679,
        "sender_full_name": "Julian Berman",
        "timestamp": 1728350475
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  - this is <strong>incredibly helpful</strong> :)</p>\n<p>I could not find such a clear illustration of the point and wonder if there is value in pinning your reply, or copying to some documentation somewhere? </p>\n<p>This is the kind of clarification that many beginners will find very helpful.</p>\n<hr>\n<p>(and to be clear the square brackets means a <strong>list</strong> is expected, eg a list of hypotheses or proofs as you all them?)</p>",
        "id": 475507626,
        "sender_full_name": "rzeta0",
        "timestamp": 1728376126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> has marked this topic as resolved.</p>",
        "id": 475507634,
        "sender_full_name": "Notification Bot",
        "timestamp": 1728376130
    },
    {
        "content": "<p>No, square brackets are for a different form of implicit parameters, called instance parameters.</p>\n<p>Curly-brace-implicit parameters can be inferred from the other, explicit, parameters - like <code>a</code>  and <code>b</code>  can be inferred from parameter <code>h</code> in  the previous examples.</p>\n<p>Square-bracket-implicit parameters are parameters that cannot be inferred from the others, but that Lean should find by some other mechanism. Typically, this includes standard algebraic structures on a type: you can write a lemma that assumes type G has some group structure, and will include some hypothesis <code>[Group G]</code>; then when you try to use this lemma with, say, the reals, Lean will figure you probably mean the usual additive group structure. This cannot be an implicit parameter, because there will typically exist more than one group structure on a given type; but Lean has mechanisms to make it find, or even generate, the right structure.</p>\n<p>(I am far from an expert on this, but <strong>Mathematics in Lean</strong>, among other documentation books, explains this in way more detail)</p>",
        "id": 475524610,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1728381596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> All this is wonderfully explained in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html?highlight=implici#implicit-arguments\">Theorem Proving in Lean</a> (search in this page for \"implicit arguments\") and in the <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html\">Chapter</a> about type classes. I think that this kind of questions all have very good answer in that book, which could be seen as a must-read if one is willing to start using Lean in Math.</p>",
        "id": 475527109,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1728382397
    },
    {
        "content": "<p>Thanks Filippo - I did link to that book above to say I found the writing too advanced. (I don't have a degree in cs or maths)</p>",
        "id": 475533409,
        "sender_full_name": "rzeta0",
        "timestamp": 1728384783
    },
    {
        "content": "<p>I see, no problem. Of course you can also ask questions about the book while reading it, if you find it interesting but hard.</p>",
        "id": 475533524,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1728384833
    },
    {
        "content": "<p>Thanks. I'm working through Macbeths' course (half way through) which I find has an easier gradient to climb.</p>",
        "id": 475533669,
        "sender_full_name": "rzeta0",
        "timestamp": 1728384877
    },
    {
        "content": "<p>Excellent source as well!</p>",
        "id": 475533726,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1728384904
    },
    {
        "content": "<p>(and separately I've worked through prof Jay Cummings books on proofs, Dr Keith Devlin's Thining in Mathematics course, and Prof Hamkin's intro to proofs,  and <strong>very slowly</strong> working through Terence Tao's Analysis I <a href=\"https://analysis-solutions.blogspot.com/p/terence-taos-analysis-i.html\">https://analysis-solutions.blogspot.com/p/terence-taos-analysis-i.html</a> +) </p>\n<p>\\+ will have errors, as i do't have a teacher / mentor, only stack exchange which is far from ideal!</p>\n<p>( and here is my \"writing as I learn\" lean <a href=\"https://leanfirststeps.blogspot.com/p/contents.html\">https://leanfirststeps.blogspot.com/p/contents.html</a> )</p>",
        "id": 475534123,
        "sender_full_name": "rzeta0",
        "timestamp": 1728385059
    }
]