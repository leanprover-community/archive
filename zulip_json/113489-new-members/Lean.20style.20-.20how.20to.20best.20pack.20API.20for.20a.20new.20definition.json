[
    {
        "content": "<p>Say I am in the middle of a long proof and want to introduce a new local definition <code>let x' = ...&lt;something in terms of x,y,z...&gt;</code>. If I also decide to build a mini API of lemmas - <code>have (h: &lt;some prop about x' and x,y,z&gt;): &lt;some other prop about x',x,y,z&gt;</code>. I prove it using <code>unfold</code>, but then for the rest of the proof I try not to use unfold and just these lemmas. This works reasonably well, and I have done it in the past for long proofs.</p>\n<p>What I am unclear, is if the proof gets even longer, and I want to extract something about x' and it's APIs to a stand-alone lemma, how to pass the original definition and APIs. Should I try to pack them in a structure? Or maybe capture the definition in a single <code>_def</code> lemma that fully captures the definition and pass that around?</p>\n<p>Here is somewhat contrived example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">double_pos</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- some proof</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">doubleX_def</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">doubleX</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">doubleX</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">doubleX</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"n\">hs</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"c1\">-- rest of proof</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 538987862,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757656905
    },
    {
        "content": "<p>If the proof starts to get really long, often you'd promote the <code>let</code> to a <code>def</code></p>",
        "id": 539146514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757703350
    },
    {
        "content": "<p>And then replace the <code>have</code> with lemmas about that def</p>",
        "id": 539146539,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757703362
    },
    {
        "content": "<p>I see so something like this </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SquaredSet</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- unfolds allowed here, this is the API</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SquaredSet_pos</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">SquaredSet</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">SquaredSet</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"c1\">-- end of SquaredSet API</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- some proof</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SquaredSet</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">  </span><span class=\"c1\">-- no unfolds here use API</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SquaredSet_pos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:=</span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- rest of proof</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 539178457,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757720170
    },
    {
        "content": "<p>similar yes</p>",
        "id": 539178539,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757720222
    },
    {
        "content": "<p>Note that <code>SquaredSet</code> is in mathlib as <code>X ^ 2</code> with <code>open scoped Pointwise</code></p>",
        "id": 539181255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757721983
    },
    {
        "content": "<p>(also note that <a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a> tells you to capitalize it as <code>squaredSet</code>)</p>",
        "id": 539181342,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757722020
    },
    {
        "content": "<p>Is <code>X ^ 2</code> under Pointwise the set of squares or the set of products on two elements from <code>X</code>?</p>",
        "id": 539201478,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1757736017
    },
    {
        "content": "<p>Oh, the example doesn't matter at all, I just wrote some contrived <code>let := ...</code></p>",
        "id": 539201683,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757736074
    },
    {
        "content": "<p>My point is in regular programming when I have a messy bunch of code, I know how to refactor it - find repeated expressions - extract to variables and function (with local or global scope). Modern IDEs even provide these basic refactoring for some languages.</p>\n<p>However, in theorem proving land it is not so simple, once you pull out some expressions you have to manually keep unfolding it all proofs, which almost defeats the purpose. So one has to also declare some API lemmas with the factored out definition, but I don't have good sense how to package these API + definition, for a clean refactoring.</p>",
        "id": 539202353,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757736255
    },
    {
        "content": "<p>If you come across a definition which looks useful then factor it out and make some API and yes you're allowed to unfold. Alternatively if the API is always \"unfold and then use API for what you got\" then maybe an <code>abbrev</code> is in order.</p>",
        "id": 539254226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1757752328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Lean.20style.20-.20how.20to.20best.20pack.20API.20for.20a.20new.20definition/near/539201478\">said</a>:</p>\n<blockquote>\n<p>Is <code>X ^ 2</code> under Pointwise the set of squares or the set of products on two elements from <code>X</code>?</p>\n</blockquote>\n<p>We have instances for both!</p>",
        "id": 539266506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757765204
    },
    {
        "content": "<p>(and so also, I don't know)</p>",
        "id": 539266518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757765220
    },
    {
        "content": "<p>It depends on what you <code>open</code></p>",
        "id": 539268614,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757767332
    },
    {
        "content": "<p>Does it?</p>",
        "id": 539279881,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757777886
    },
    {
        "content": "<p>I hope it does</p>",
        "id": 539280505,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757778542
    }
]