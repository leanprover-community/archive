[
    {
        "content": "<p>Hi All, I've got a question relating to a personal project. Hopefully this is the right place to ask, but please direct me elsewhere if not.</p>\n<p>I'm developing a simple game involving Boolean formulas and satisfiability, and I'm trying to use Lean to prove certain properties about the rules of the game. I'd like to follow standard Lean style (using this guide: <a href=\"https://leanprover-community.github.io/contribute/naming.html\">https://leanprover-community.github.io/contribute/naming.html</a>), but I'm not sure if I'm doing it right.</p>\n<p>For a definition like this, is <code>lowerCamelCase</code> correct (applying rules 3 and 4 from the guide)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Terminal formula: satisfiability is trivially determined.</span>\n\n<span class=\"sd\">A formula is terminal when the game ends - either all clauses are satisfied</span>\n<span class=\"sd\">(empty formula means Affirmative wins) or an empty clause exists (Negative wins).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"bp\">.</span><span class=\"n\">isTerminal</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">formula</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">formula</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">formula</span><span class=\"bp\">.</span><span class=\"n\">hasEmptyClause</span>\n</code></pre></div>\n<p>And is <code>UpperCamelCase</code> correct here because it is a <code>Prop</code> (rule 2), or should it be <code>snake_case</code> because it's a \"term of type <code>Prop</code>\" (applying rule 1)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Relation defining when one formula has strictly fewer literals than another.</span>\n\n<span class=\"sd\">This serves as our termination measure: every valid game operation on a nonterminal</span>\n<span class=\"sd\">formula produces a formula with a lower literal count, and natural number ordering</span>\n<span class=\"sd\">is well-founded.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HasLowerLiteralCount</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Formula</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">InvImage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">literalCount</span>\n</code></pre></div>",
        "id": 523814661,
        "sender_full_name": "Eric Rogstad",
        "timestamp": 1749754274
    },
    {
        "content": "<p>These two seem correct</p>",
        "id": 523814789,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749754330
    },
    {
        "content": "<p>Yeah these are right</p>",
        "id": 523814803,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749754339
    },
    {
        "content": "<p><code>snake_case</code> is if you have an <code>h : p : Prop</code></p>",
        "id": 523814863,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1749754370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"309210\">Eric Rogstad</span> <a href=\"#narrow/channel/113489-new-members/topic/Dot.20notation.2C.20capitalization.2C.20and.20naming.20conventions/near/523814661\">said</a>:</p>\n<blockquote>\n<p>And is <code>UpperCamelCase</code> correct here because it is a <code>Prop</code> (rule 2), or should it be <code>snake_case</code> because it's a \"term of type <code>Prop</code>\" (applying rule 1)?</p>\n</blockquote>\n<p><code>snake_case</code> applies to \"terms of terms of type <code>Prop</code>\", so we get <code>FermatLastTheorem : Prop</code> and <code>proof_of_fermat_last_theorem : FermatLastTheorem</code>.</p>",
        "id": 523815002,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749754435
    },
    {
        "content": "<p>Hmm, so my <code>HasLowerLiteralCount</code> is actually a function that produces a prop though, right?</p>",
        "id": 523815092,
        "sender_full_name": "Eric Rogstad",
        "timestamp": 1749754485
    },
    {
        "content": "<p>But then does that actually mean that Rule 3 applies:</p>\n<blockquote>\n<p>Functions are named the same way as their return values (e.g. a function of type <code>A → B → C</code> is named as though it is a term of type <code>C</code>).</p>\n</blockquote>\n<p>... and then since the return type is <code>Prop</code>, then I'd go to Rule 2:</p>\n<blockquote>\n<p><code>Prop</code>s and <code>Type</code>s (or <code>Sort</code>) (inductive types, structures, classes) are in <code>UpperCamelCase</code>. There are some rare exceptions: some fields of structures are currently wrongly lower-cased (see the example for the class <code>LT</code> below).</p>\n</blockquote>\n<p>... which would tell me to use <code>UpperCamelCase</code>?</p>",
        "id": 523815314,
        "sender_full_name": "Eric Rogstad",
        "timestamp": 1749754597
    },
    {
        "content": "<p>Thanks! Btw, meta question, which perhaps you've implicitly answered, but is this the right place to ask these kinds of newbie questions?</p>",
        "id": 523815670,
        "sender_full_name": "Eric Rogstad",
        "timestamp": 1749754743
    },
    {
        "content": "<p>Oh, another object level question — if <code>Formula.isTerminal</code> had returned a <code>Prop</code> rather than a <code>Bool</code>, would that mean it should be <code>Formula.IsTerminal</code> instead? And if so, is it weird to mix dot notation with <code>UpperCamelCase</code>, or is that normal?</p>",
        "id": 523815920,
        "sender_full_name": "Eric Rogstad",
        "timestamp": 1749754854
    },
    {
        "content": "<p>Dot notation with upper camel case is normal, for example in mathlib we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.Prime#doc\">docs#Nat.Prime</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.LeftInverse#doc\">docs#Function.LeftInverse</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Subsingleton#doc\">docs#Set.Subsingleton</a></p>",
        "id": 523816820,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749755202
    }
]