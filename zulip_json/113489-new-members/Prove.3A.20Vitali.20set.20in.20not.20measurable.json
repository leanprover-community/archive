[
    {
        "content": "<p>I'm in a course about Lean 4, but had no previous experience. Up to now, I worked halfway through the <em>Mathematics in Lean</em> book from the <em>Leanprover community</em>.</p>\n<p>My assignment is to formalise the proof that the Vitali set is not Lebesgue measurable, as can be found in <a href=\"https://en.wikipedia.org/wiki/Vitali_set#Construction_and_proof\">https://en.wikipedia.org/wiki/Vitali_set#Construction_and_proof</a> . I can use Mathlib up to a \"reasonable extent\", but I don't really know how to properly start. My idea is to construct the Vitali set via def using an instance of an equivalence relation, and then show that both assigning zero or a positive number to the set leads to a contradiction (by_contra). Currently I am at a loss as to how concretely formalise the equivalence relation, the set, and the Lebesgue measure. Can someone point me towards relevant Mathlib objects or references without giving the answer completely away?</p>",
        "id": 509641485,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743584945
    },
    {
        "content": "<p>Is your course lecturer ok about you asking this kind of question? </p>\n<p>Concretely formalising the equivalence relation shouldn't be too hard. What did you try?</p>",
        "id": 509648521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743586918
    },
    {
        "content": "<p>Just mentioning that this has already been done with Mathlib, there is an open PR about it.</p>",
        "id": 509655606,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1743589150
    },
    {
        "content": "<p>Thank you both for your quick responses. Yes, the lecturer pointed us specifically to this forum. </p>\n<p><span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span>, I have found the version by Ching-Tsun Chou,  thanks for pointing it out. My intention is of course to come up with my own version, and to need as little \"inspiration\" as possible. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> thank you for your willingness to help. I will try harder before asking a dozen trivial questions, but will probably soon return back to the board.</p>",
        "id": 509667564,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743592754
    },
    {
        "content": "<p><a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members\">#new members</a> is a fine place to ask trivial questions.</p>",
        "id": 509671272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743593815
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 509688736,
        "sender_full_name": "Eric Paul",
        "timestamp": 1743598273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.3A.20Vitali.20set.20in.20not.20measurable/near/509671272\">schrieb</a>:</p>\n<blockquote>\n<p><a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members\">#new members</a> is a fine place to ask trivial questions.</p>\n</blockquote>\n<p>In that case I'll happily take you up on your offer. At the moment, I'm struggling with the two notions</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n</code></pre></div>\n<p>where I just cannot find the correct imports and syntax. <br>\nSpecifically trouble bring me <code>∑ n, volume (A n)</code> and <code>(x - y) ∈ ℚ</code> (as well as <code>ℚ ∩ (Icc -1 1)</code>). </p>\n<p>Currently I've installed Mathlib.Tactic, Mathlib.Data.Real.Basic, Mathlib.Util.Delaborators, Mathlib.Data.Set.Function, and Mathlib.MeasureTheory.Measure.Lebesgue.Basic. Can someone help me out?</p>",
        "id": 509753272,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743614274
    },
    {
        "content": "<p>Have you tried <code>import Mathlib</code>? (assuming your computer can withstand it)</p>",
        "id": 509753519,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743614344
    },
    {
        "content": "<p><code>import Mathlib</code>works, but I think the problem lies more within my lack of knowledge for the correct syntax</p>",
        "id": 509753948,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743614500
    },
    {
        "content": "<p>You will need to write <code>open MeasureTheory</code> at the start of your file most likely</p>",
        "id": 509754173,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743614572
    },
    {
        "content": "<p>I would give you more detailed instructions, but you need to provide us with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (this is a link, please read)</p>",
        "id": 509754276,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743614607
    },
    {
        "content": "<p><code>sigma_additivity</code> is not what you want, because your sets are not disjoint (nor measurable), and you certainly never want to write <code>axiom</code>.</p>\n<p>In the definition of <code>equiv</code>, Lean probably interpretys <code>0</code> and <code>1</code> as terms of <code>ℕ</code>, not terms of <code>ℝ</code>, so the <code>Icc 0 1 : Set ℕ</code> and in that case <code>Icc 0 1 = {0, 1}</code> which is not what you want. You can tell Lean these should be real numbers by doing <code>(Icc 0 1 : Set ℝ)</code>.</p>\n<p>At the same time, <code>ℚ</code> is a type, not a set, so you can't write <code>∈ ℚ</code>. You'll want <code>x - y ∈ Set.range (Rat.cast : ℚ → ℝ)</code>.</p>",
        "id": 509754287,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743614610
    },
    {
        "content": "<p>But yes, please give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 509754336,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743614626
    },
    {
        "content": "<p>Right, apologies. Here is my MWE (I spare you the rest of the document for now)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">warningAsError</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">monotony</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">translation_invariance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">A</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">normalised</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"c1\">-- lemma : equiv really an equivalence relation</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n</code></pre></div>",
        "id": 509754983,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743614828
    },
    {
        "content": "<p>Why are you using <code>axiom</code>?</p>",
        "id": 509755829,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743615077
    },
    {
        "content": "<p><code>\\Q</code> is a type, not a set, so <code>(x - y) \\in  \\Q</code> makes no sense. Lean uses type theory not set theory. You can make subsets of a type but <code>\\Q</code> is not a subset of <code>\\R</code>, it's a distinct type equipped with a function to <code>\\R</code>.</p>",
        "id": 509756928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743615450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.3A.20Vitali.20set.20in.20not.20measurable/near/509755829\">schrieb</a>:</p>\n<blockquote>\n<p>Why are you using <code>axiom</code>?</p>\n</blockquote>\n<p>So I don't have to write <code>:= by sorry</code></p>",
        "id": 509757526,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743615665
    },
    {
        "content": "<p>adding axioms is dangerous, because if you add them and they are inconsistent (as yours were), then you can easily prove false.</p>",
        "id": 509758846,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743616087
    },
    {
        "content": "<p>e.g., your <code>normalised</code> and <code>sigma_additivity</code> together are sufficient to prove <code>False</code>. (after you make the sigma additivity compile by using <code>∑'</code> instead of <code>∑</code>)</p>",
        "id": 509758922,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743616121
    },
    {
        "content": "<p>Gotcha, I switched to lemmas and added <code>(h : ∀ i j, i ≠ j → A i ∩ A j = ∅)</code></p>",
        "id": 509759545,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743616304
    },
    {
        "content": "<p>You can write that as <code>Pairwise (Disjoint on A)</code> and it will give you access to more API.</p>",
        "id": 509759889,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743616403
    },
    {
        "content": "<p>I know you probably already understand, but just to give you an example:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>proof of false</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n\n<span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">normalised</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ENNReal.ofReal</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ENNReal.one_ne_top</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iUnion</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n</div></div>",
        "id": 509760186,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743616488
    },
    {
        "content": "<p>I'm sorry, but what does \"access to more API\" mean?</p>",
        "id": 509760908,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1743616702
    },
    {
        "content": "<p>if you use a hypothesis in \"standard form\", more lemmas will have that exact thing as a hypothesis so you don't have a complicated side condition every time you want to use lemmas</p>",
        "id": 509761139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743616769
    },
    {
        "content": "<p>it's very often the case that there is more than one way to say something, and the library tries to pick one variation in each case and use it canonically in all relevant lemmas</p>",
        "id": 509761353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743616819
    },
    {
        "content": "<p>e.g., this is how it is phrased in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.measure_iUnion#doc\">docs#MeasureTheory.measure_iUnion</a></p>",
        "id": 509761619,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743616898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"895359\">Marvin Sigg</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.3A.20Vitali.20set.20in.20not.20measurable/near/509757526\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.3A.20Vitali.20set.20in.20not.20measurable/near/509755829\">schrieb</a>:</p>\n<blockquote>\n<p>Why are you using <code>axiom</code>?</p>\n</blockquote>\n<p>So I don't have to write <code>:= by sorry</code></p>\n</blockquote>\n<p>If you do <code>:= by exact?</code> and it finds a lemma, then now you know what it's called. If it doesn't find a lemma, there's a chance you stated it wrong.</p>",
        "id": 509764177,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743617727
    },
    {
        "content": "<p>And by \"wrong\" this might mean \"mathematically incorrectly\" or it might just mean \"in an unidiomatic way\".</p>",
        "id": 509764512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743617851
    },
    {
        "content": "<p>Hi folks, hope you're doing well. I wanted to ask if someone could give me a hint as how to implement the choice function, since the Vitali set relies on it. Here's what I got so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">warningAsError</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n\n<span class=\"c1\">-- what we expect the measure to fulfill</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">monotony</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">translation_invariance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">normalised</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">volume</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- equivalence relation for Vitali set</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"c1\">-- lemma : need to show that equiv really an equivalence relation</span>\n\n<span class=\"c1\">-- define a bijection from the naturals to the rationals between -1 and 1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">}</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ξ_inj</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">ξ_surj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">η</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ξ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- one element from each equivalence class by axiom of choice. This is where I'm struggling.</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 510776187,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744064038
    },
    {
        "content": "<p>Can you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 510776486,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744064207
    },
    {
        "content": "<p><code>noncomputable def M0</code> doesn't work for me on the web editor.</p>",
        "id": 510776522,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744064228
    },
    {
        "content": "<p>This is what I'm asking. I want to codify that there is exactly one element from each equivalence class in <code>M0</code>, so if for any <code>x</code>in <code>M0</code> there exists a <code>y</code>in <code>M0</code> such that they are equivalent, they must be equal. <br>\nEdit: I now realise that this only means that there exists at most one representative (as opposed to the required 'there exists exactly one representative'). It's quite tricky to think of a way to codify that for any equivalence class there is a representative in <code>M0</code>.</p>",
        "id": 510777154,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744064519
    },
    {
        "content": "<p>I guess <code>∀ x ∈ Icc 0 1, ∃ y ∈ M0, equiv x y</code></p>",
        "id": 510777518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744064740
    },
    {
        "content": "<p>or <code>∀ x ∈ Icc 0 1, ∃! y ∈ M0, equiv x y</code> to do existence and uniqueness in one go</p>",
        "id": 510777591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744064777
    },
    {
        "content": "<p>You should drop the hypotheses <code>hx</code> and <code>hy</code> from <code>equiv</code>, they will just get in the way</p>",
        "id": 510777674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744064835
    },
    {
        "content": "<p>this theorem statement is still not right, as you are using <code>volume</code> from the library rather than having it as a hypothesis. This means it's about lebesgue measure specifically, rather than any function which satisfies the four properties</p>",
        "id": 510778173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065145
    },
    {
        "content": "<p>if you want it to be about lebesgue measure, then you can remove the lemmas since they are already proved</p>",
        "id": 510778214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065183
    },
    {
        "content": "<p>here is maybe a simpler setup:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- equivalence relation for Vitali set</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"c1\">-- lemma : need to show that equiv really an equivalence relation</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"n\">out</span>\n</code></pre></div>",
        "id": 510778554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065367
    },
    {
        "content": "<p>this is a bit more lean idiomatic in using quotients rather than equivalence classes</p>",
        "id": 510778589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065393
    },
    {
        "content": "<p>We define <code>equiv</code> to be an equivalence relation directly on the set <code>Icc 0 1</code> as a type, and then take the quotient wrt that equivalence relation to get the type <code>Quot equiv</code>. <code>Quot.out</code> uses the axiom of choice to reverse the quotient map and get an element of <code>Icc 0 1</code> back out and this is coerced to a <code>ℝ</code></p>",
        "id": 510778697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065478
    },
    {
        "content": "<p>(we actually don't need to show it is really an equivalence relation to make this definition)</p>",
        "id": 510778809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744065525
    },
    {
        "content": "<p>Hello everyone, deadline is nearing but I've also made progress. My question is regarding the sum over all \"siblings\" of the Vitali set; I keep getting syntax errors, specifically</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">shiftRange</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vitaliSet'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"bp\">.</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vitaliSet'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">shiftRange</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">3495</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">2833</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>My MWE is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">warningAsError</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Rat</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">naiveMeasure</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n<span class=\"w\">  </span><span class=\"n\">monotony</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">B</span>\n<span class=\"w\">  </span><span class=\"n\">translation_invariance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">normalised</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">sigma_additivity</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"n\">naiveMeasure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">naiveMeasure</span><span class=\"bp\">.</span><span class=\"n\">μ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">iseqv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vitaliSet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">equiv</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">shiftRange</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∩</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vitaliSet'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">vitaliSet</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">vitaliUnion</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">shiftRange</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">vitaliSet'</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">sigma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">naiveMeasure</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">vitaliUnion</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">shiftRange</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vitaliSet'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Can someone help me out here? My goal is to avoid the messy stuff with the bijection between the naturals and the rationals between -1 and 1, if at all possible.</p>",
        "id": 512427766,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744757870
    },
    {
        "content": "<p><code>tsum</code> doesn't work on props</p>",
        "id": 512428679,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744758248
    },
    {
        "content": "<p>As a workaround, you can sum over an if then else</p>",
        "id": 512428745,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744758283
    },
    {
        "content": "<p>Could you give me a basic example of summing over an if then else?</p>",
        "id": 512429002,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744758410
    },
    {
        "content": "<p><code>∑' i, if i ∈ shiftRange then μ (vitaliSet' i) else 0</code></p>",
        "id": 512431161,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744759656
    },
    {
        "content": "<p>I see, thank you already. However, now the error message \"failed to synthesize<br>\nDecidable (i ∈ shiftRange)\" crops up, which I've never seen before.</p>",
        "id": 512431323,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744759745
    },
    {
        "content": "<p>That has to do with how if then else statements work, since everything is noncomputable anyways I think you should just <code>open scoped Classical</code>.</p>",
        "id": 512432158,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744760295
    },
    {
        "content": "<p>If you do somehow manage to obtain an instance of <code>Decidable (i ∈ shiftRange)</code> that's not just <code>Classical.propDecidable</code> you might run into some problems though.</p>",
        "id": 512432776,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744760746
    },
    {
        "content": "<p>One last thing, how do I use the notion of infinity, which is an acceptable output of the measure function? Naively typing <code>∞</code> yields the error message <code>expected token</code>. What is the meaningful way of equating the measure of, say the whole real number line, to infinity?</p>",
        "id": 512437870,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744764229
    },
    {
        "content": "<p>Are you working with <code>ENNReal</code> or <code>EReal</code>?</p>",
        "id": 512441854,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744766987
    },
    {
        "content": "<p>If you are, then <code>⊤</code> will be infinity</p>",
        "id": 512441865,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744766996
    },
    {
        "content": "<p>I just noticed you have <code>structure naiveMeasure</code> in your example instead of using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure#doc\">docs#MeasureTheory.Measure</a>. Is there a reason for that?</p>",
        "id": 512442013,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744767092
    },
    {
        "content": "<p>Thank you!<br>\nI wanted to have as naive an approach as possible, mirroring the time we learned about Vitali in lecture for the first time. But no, there's not a specific reason</p>",
        "id": 512478721,
        "sender_full_name": "Marvin Sigg",
        "timestamp": 1744787256
    },
    {
        "content": "<p>If you <code>open scoped ENNReal</code>, then you can write <code>∞</code>.</p>",
        "id": 512961899,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1744946295
    }
]