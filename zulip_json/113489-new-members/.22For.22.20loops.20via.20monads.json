[
    {
        "content": "<p>Hi,</p>\n<p>It is a bit difficult for me to give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for this question, as it is very specific to the libraries I am using, but perhaps someone could give more general advice.</p>\n<p>I am trying to write a monadic function which includes a for loop.<br>\nThe Lean reference manual gives the following example, which is close to what I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">satisfyingIndices</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">out</span>\n</code></pre></div>\n<p>My function differs from this in two ways:</p>\n<ol>\n<li>The type should not be an <code>Array Nat</code>, but rather <code>m a</code>, where <code>m</code> is the monad I am using.</li>\n<li>I need to use the monadic bind of <code>m</code> within the function.  But when I use the usual syntactic sugar <code>let x ← f y</code> (where <code>f y</code> creates a term of type <code>m a</code>), the type of x is not <code>a</code>, as I would expect, but rather <code>m a</code>. My best guess is that the <code>let x ← ...</code>notation is overloaded since I am sort of using two monads at once: <code>Id</code> and <code>m</code>.</li>\n</ol>\n<p>So, I guess my question is:</p>\n<ol>\n<li>Is it necessary to use <code>Id.run</code> to have a for loop?</li>\n<li>If it's not necessary, is there something functionality I need to add to my monad <code>m</code> that would allow me to use for loops within <code>m</code>?</li>\n<li>If it is necessary, how to I specify the <code>let x ← ...</code> notation to refer to my monad <code>m</code>, rather than the identity monad?</li>\n</ol>\n<p>I'm sorry that this is quite vague, but I would appreciate any help. As you can probably tell, I am very new to monads and don't really know what I am doing at this stage.</p>",
        "id": 532816764,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754355989
    },
    {
        "content": "<p>Just omit the <code>Id.run</code></p>",
        "id": 532816916,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/.22For.22.20loops.20via.20monads/near/532816916\">said</a>:</p>\n<blockquote>\n<p>Just omit the <code>Id.run</code></p>\n</blockquote>\n<p>I tried this, but got the error: \"invalid 'for_in%' notation, expected type is not of of the form <code>M α</code>\"</p>",
        "id": 532816963,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754356156
    },
    {
        "content": "<p>what is your expected type</p>",
        "id": 532817107,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356302
    },
    {
        "content": "<p>Here's a version of the function, just in case there is some obvious syntax error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n<span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>Here <code>m</code> is my monad, and <code>f</code> is a function that produces a term of type <code>m Nat</code>(I changed the function names to make it more readable).</p>",
        "id": 532817496,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754356661
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">my_func</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>",
        "id": 532817592,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356752
    },
    {
        "content": "<p>Of course, if your <code>m</code> already has a <code>Monad</code> instance you don't have to add it as a hypothesis here</p>",
        "id": 532817636,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356804
    },
    {
        "content": "<p>Hmm...I still get the \"invalid <code>for_in%</code> notation\" error at the <code>for h: i in [1:l.size] do</code> line.</p>",
        "id": 532817699,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754356870
    },
    {
        "content": "<p>What is your monad?</p>",
        "id": 532817791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356947
    },
    {
        "content": "<p>Are you returning a <code>m a</code>?</p>",
        "id": 532817802,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754356955
    },
    {
        "content": "<p>I'm using the SLang monad from the SampCert library, which is defined like this:</p>\n<p><a href=\"/user_uploads/3121/WZ2sY04NnS8AblDMsSXvDiIp/Screenshot-2025-08-04-182258.png\">Screenshot 2025-08-04 182258.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WZ2sY04NnS8AblDMsSXvDiIp/Screenshot-2025-08-04-182258.png\" title=\"Screenshot 2025-08-04 182258.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1739x322\" src=\"/user_uploads/thumbnail/3121/WZ2sY04NnS8AblDMsSXvDiIp/Screenshot-2025-08-04-182258.png/840x560.webp\"></a></div><p>And I have instantiated it as a LawfulMonad.</p>\n<p>Since <code>l</code> is an <code>Array α</code>, <code>return l</code> should give a term of <code>SLang Array α</code> (I just hovered over it to confirm this), which is what I specified in the type signature.</p>",
        "id": 532818165,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754357253
    },
    {
        "content": "<p>Curiously, I just took out the type annotation, so that my first line looks like this:</p>\n<p><code>def my_func  [LawfulMonad SLang] {α: Type} (l:Array α) := do</code><br>\nAnd now everything seems to work...but I'm not sure why (I <em>should</em> be outputting an <code>SLang (Array α)</code> in any case).</p>\n<p>In fact, I just typed in #check my_func and got what I expected: <code>[inst : LawfulMonad SLang] → {α : Type} → Array α → SLang (Array α)</code></p>\n<p>So I'm not sure why removing the type annotation made any difference.</p>",
        "id": 532818523,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754357560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"932451\">Robert Shlyakhtenko</span> <a href=\"#narrow/channel/113489-new-members/topic/.22For.22.20loops.20via.20monads/near/532818165\">said</a>:</p>\n<blockquote>\n<p>Since <code>l</code> is an <code>Array α</code>, <code>return l</code> should give a term of <code>SLang Array α</code> (I just hovered over it to confirm this), which is what I specified in the type signature.</p>\n</blockquote>\n<p>Are you sure it was <code>SLang Array α</code> and not <code>SLang (Array α)</code>?</p>",
        "id": 532818979,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754357822
    },
    {
        "content": "<p>Yes, it should be <code>SLang (Array α)</code>, but I only made the typo here, not in my code :)</p>",
        "id": 532840688,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754374211
    },
    {
        "content": "<p>I played with it some more, and the behavior is the same: as soon as I get rid of the type annotation in the first line, everything starts to work. Not sure why...</p>",
        "id": 532948783,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754410647
    },
    {
        "content": "<p>that's so weird</p>",
        "id": 532949948,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754411071
    },
    {
        "content": "<p>It would be great if you had a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 532949983,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754411083
    },
    {
        "content": "<p>It's a bit hard to provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but what you have said so far has already been really helpful and should be enough for me -- thanks a lot!</p>",
        "id": 533030590,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754460460
    },
    {
        "content": "<p>I do have a related question.</p>\n<p>Suppose I write <code>let j ← f i,</code> where <code>f : Nat \\rightarrow m Nat.</code> Can I infer any properties about <code>j</code>, based on the possible output of <code>f</code>? <br>\nIn my specific example, the monad is <code>SLang</code>, so <code>f: SLang Nat</code> is a function <code>f : Nat -&gt; ENNReal</code>. Now I have a function <code>UniformSample: Nat -&gt; SLang Nat</code> where <code>UniformSample n</code> is the Uniform distribution on <code>[0, n)</code>. <br>\nThus, <code>UniformSample n j = 0</code> if <code>j &gt;= n</code>, and <code>UniformSample n j = 1/n</code> if <code>j &lt; n</code>. <br>\nNow, if I understand correctly how monads work, this means that <code>let j ← UniformSample n</code> gives me a <code>j : Nat</code>, and <em><code>j</code> should have the property that <code>j &lt; n</code></em> (I wrote the definition of the SLang bind above). </p>\n<ol>\n<li>Is my understanding correct?</li>\n<li>If so, is it possible to state this as a theorem? (I am not sure how I would write this...)</li>\n</ol>",
        "id": 533030674,
        "sender_full_name": "Robert Shlyakhtenko",
        "timestamp": 1754460512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"932451\">Robert Shlyakhtenko</span> <a href=\"#narrow/channel/113489-new-members/topic/.22For.22.20loops.20via.20monads/near/533030674\">said</a>:</p>\n<blockquote>\n<p>I do have a related question.</p>\n<p>Suppose I write <code>let j ← f i,</code> where <code>f : Nat \\rightarrow m Nat.</code> Can I infer any properties about <code>j</code>, based on the possible output of <code>f</code>? <br>\nIn my specific example, the monad is <code>SLang</code>, so <code>f: SLang Nat</code> is a function <code>f : Nat -&gt; ENNReal</code>. Now I have a function <code>UniformSample: Nat -&gt; SLang Nat</code> where <code>UniformSample n</code> is the Uniform distribution on <code>[0, n)</code>. <br>\nThus, <code>UniformSample n j = 0</code> if <code>j &gt;= n</code>, and <code>UniformSample n j = 1/n</code> if <code>j &lt; n</code>. <br>\nNow, if I understand correctly how monads work, this means that <code>let j ← UniformSample n</code> gives me a <code>j : Nat</code>, and <em><code>j</code> should have the property that <code>j &lt; n</code></em> (I wrote the definition of the SLang bind above). </p>\n<ol>\n<li>Is my understanding correct?</li>\n<li>If so, is it possible to state this as a theorem? (I am not sure how I would write this...)</li>\n</ol>\n</blockquote>\n<p>The way to do this is to have <code>f</code> return a <code>m (Fin n)</code> instead of <code>m Nat</code>. There is not a way to infer properties of <code>j</code> the way you wrote it since <code>j</code> is a free variable.</p>",
        "id": 533072836,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754476490
    }
]