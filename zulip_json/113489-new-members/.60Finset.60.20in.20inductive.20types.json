[
    {
        "content": "<p>Lean complains when I use <code>Finset</code> (from mathlib) in my inductive type as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As far as I understand the issue is that the elaborator doesn't know how to deal with the opaque <code>Quotient</code> used in <code>Finset</code>, while if I used something like <code>List</code> instead everything is transparent and can be checked for positivity. Am I right? I can't see why <code>Finset</code> couldn't work in principle.</p>\n<p>Should I bite the bullet and use <code>List</code> instead of <code>Finset</code> or is there a more elegant workaround?</p>",
        "id": 517871298,
        "sender_full_name": "Oskar Goldhahn",
        "timestamp": 1747152616
    },
    {
        "content": "<p>This is something the kernel itself doesn't support. The way the kernel checks nested inductive types is that it 'unfolds' the inductives until it gets a recursive inductive type, then if the result passes the tests, the original type is admitted.</p>\n<p>Quotient types aren't inductive types however, so they can't be similarly 'unfolded'. I think the main way to do this is to use <code>List</code> and then either wrap <code>Foo</code> in an appropriate quotient, or if you're able to normalize the order of the <code>List</code>, to take a subtype with a strictly-increasing condition.</p>",
        "id": 517911370,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747165939
    },
    {
        "content": "<p>Note that quotient inductive types are one thing that the QPF framework can validate (people mostly think about the coinductive types part, but it allows arbitrary combinations of inductive types, coinductive types and quotients without unfolding anything, which is a super powerful combination)</p>",
        "id": 519388455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747748434
    }
]