[
    {
        "content": "<p>Hi everybody, I'm learning Lean prover and trying to understand things behind it rather than just using Lean to prove math theorems. Here's what bothers me, I'll use a comparision to explain what it is:</p>\n<p>In group theory, we start with axioms first, then we take constructions as examples of ways to build a group.</p>\n<p><strong>Product Group</strong>: Given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo separator=\"true\">,</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G, H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> are groups, we have  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>×</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G \\times H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> is a group.</p>\n<p><strong>Presentation of a group</strong>: Given set of generators <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and set of relations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> among those generators, we have a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>S</mi><mi mathvariant=\"normal\">∣</mi><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">G = ( S | R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>But they are just particular methods of building a group. I can understand that from some <em>materials</em>, I can build up groups. However, is there any methods of building a group out there? Is that all? (well, technically all groups can be represented by (S|R) but that's not what I mean) I can keep working with groups like that, but I want to understand a group with axiomatic approach or something like: a group is blah blah and nothing else will be a group.</p>\n<p>In Lean (or CIC), as far as I know, there're <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2023/Part_B/threekindsoftypes.html\">several methods</a> to build up types:</p>\n<ul>\n<li>Pi type</li>\n<li>Inductive type</li>\n<li>Quotient type</li>\n</ul>\n<p>It doesn't matter how many methods. Is there <em>any official definition</em> of <strong>what a type is</strong>? Or the official definition of what type is, is: It's either a Pi type or an inductive type or combination of them?</p>\n<p>I read docs, a few tutorials and books introducting Lean and CIC but couldn't find any clear statement/clue. It's always like: Hey, this one thing is called a type. This another thing is called a type. This is also called a type. Did I miss something? Or is there any book/article on this sort of concern?</p>\n<p>Thank you</p>",
        "id": 466723642,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725205500
    },
    {
        "content": "<p>The most general definition is probably \"anything that has type <code>Sort u</code> for any <code>u</code> according to the type checking algorithm is a type. But that's not a particularly helpful one.</p>",
        "id": 466724060,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1725205665
    },
    {
        "content": "<p>thanks. I think it's a property of types or a good way to think about them rather than a definition.</p>",
        "id": 466725219,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725206139
    },
    {
        "content": "<p>I would say generally a type is \"anything can take the type role in a judgement\". Type theory by itself doesn't give a definition of what are your options for that though, instead that is left to axioms. The types you mentioned, Pi types, inductive types and quotient types, are all generally defined through axioms that are believed to be consistent and useful.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"344401\">Cuong Tran</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466723642\">said</a>:</p>\n<blockquote>\n<p>a group is blah blah and nothing else will be a group</p>\n</blockquote>\n<p>You won't get the equivalent of this for types in most type theories, since many prefer to remain open to further extensions.</p>",
        "id": 466727093,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725206771
    },
    {
        "content": "<p>as far as i know, you can still describe type theory like \"there are types X and elements Y such that bla bla\" though? while still remaining open to extensions? just like you can extend groups to fields?</p>",
        "id": 466727866,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725207036
    },
    {
        "content": "<p>You can find a formal definition of a \"Lean type\" in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>",
        "id": 466728541,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725207368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466728541\">said</a>:</p>\n<blockquote>\n<p>You can find a formal definition of a \"Lean type\" in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>\n</blockquote>\n<p>thanks a lot. this is very helpful. seems like what I was looking for.</p>",
        "id": 466729861,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725208302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344401\">Cuong Tran</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466729861\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466728541\">said</a>:</p>\n<blockquote>\n<p>You can find a formal definition of a \"Lean type\" in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>\n</blockquote>\n<p>thanks a lot. this is very helpful. seems like what I was looking for.</p>\n</blockquote>\n<p>The definition preseented in that paper is what Giacomo and I said basically</p>",
        "id": 466730260,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1725208529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466727866\">said</a>:</p>\n<blockquote>\n<p>as far as i know, you can still describe type theory like \"there are types X and elements Y such that bla bla\" though? while still remaining open to extensions?</p>\n</blockquote>\n<p>Yes, but you have to remove the \"and nothing else will be ...\" part from the statement then, which is what effectively prevents extensions.</p>",
        "id": 466731740,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1725209094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466730260\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"344401\">Cuong Tran</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466729861\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466728541\">said</a>:</p>\n<blockquote>\n<p>You can find a formal definition of a \"Lean type\" in <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a></p>\n</blockquote>\n<p>thanks a lot. this is very helpful. seems like what I was looking for.</p>\n</blockquote>\n<p>The definition preseented in that paper is what Giacomo and I said basically</p>\n</blockquote>\n<p>I mean I was looking for a formal mathematical definition of type in Lean, at least, not a common use of the word \"type\". Unlike <code>group</code> in group theory, there's a widely accepted definition, type theory is a broad term that refers to lot of things. I totally get that fact. I was looking for specific &amp; concrete definition of the type concept that backs Lean. Sorry if the initial question was misleading.</p>",
        "id": 466732970,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725209613
    },
    {
        "content": "<p>Would you mind saying what you consider to be the official mathematical definition of a set is?</p>",
        "id": 466736671,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725211494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type/near/466736671\">said</a>:</p>\n<blockquote>\n<p>Would you mind saying what you consider to be the official mathematical definition of a set is?</p>\n</blockquote>\n<p>I don't think there's an official math definition of anything, only widely accepted for the usefulness. And in each specific theory, there's an approach for that concept. As far as I know ZFC on top of underlying FOL is the most popular one and everything in the domain is considered as 'set'.</p>",
        "id": 466738185,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725212216
    },
    {
        "content": "<p>But with ZFC, to talk about any particular set, you need to choose a model of ZFC which is… a set.</p>",
        "id": 466738433,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725212302
    },
    {
        "content": "<p><a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type.20in.20Lean/near/466738433\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type\">#new members &gt; Official definition of type</a> by <span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span>.</p>",
        "id": 466738497,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725212322
    },
    {
        "content": "<p>yes, but that was a different thing and I think off topic here. I guess logicians talk about that circular phenomenon all the time.</p>",
        "id": 466739264,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725212599
    },
    {
        "content": "<p>My point is that if you take a set to be anything which has a well-defined interpretation in any model of set theory, and replace the word set with type, then you have your defn</p>",
        "id": 466739422,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725212664
    },
    {
        "content": "<p>So you can then ask about the axioms of type theory, and that’s something you can find in Mario’s thesis mentioned above</p>",
        "id": 466739614,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725212755
    },
    {
        "content": "<p>(For leans’s type theory)</p>",
        "id": 466739680,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1725212770
    },
    {
        "content": "<blockquote>\n<p>Or the official definition of what type is, is: It's either a Pi type or an inductive type or combination of them?</p>\n</blockquote>\n<p>This isn't quite it. If I remember correctly, the types that you can define in Lean without extra axioms are PI Types, Inductive Types, Quotient Types, and Universe Types, but that doesn't mean you can't postulate the existence of more. For example, if you were to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>then <code>MyType</code> is now a type. (No properties of <code>MyType</code> are assumed. You can't prove that <code>MyType</code> contains exactly 2 elements, but you also can't prove that it <em>doesn't</em> contain exactly 2 elements.)</p>\n<p>Henrik Böving's definition is probably closest to correct. A type is a term <code>a</code> for which we derive the judgement <code>a : Sort u</code> for some universe level <code>u</code>. But as mentioned, this isn't particularly insightful. Also, then you have to ask the question \"what is a term\"?</p>",
        "id": 466740277,
        "sender_full_name": "Niels Voss",
        "timestamp": 1725213050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type.20in.20Lean/near/466739422\">said</a>:</p>\n<blockquote>\n<p>My point is that if you take a set to be anything which has a well-defined interpretation in any model of set theory, and replace the word set with type, then you have your defn</p>\n</blockquote>\n<p>ah yes, thanks. I understand 'common sense' about type like I understand common sense about set. Just wondered what was the type in Lean. Like even Set is a common thing, there's different versions for <code>set</code> like ZF, ZFC, Grothendieck universe, class theory etc. I want to know which discipline are we in. Same question here for type. Each theory always have mathematical precise definition for it. Seems like Mario thesis is the answer here. I guess my question is misleading that I was asking for what type is generally or I expected a widely accepted definition of type.</p>",
        "id": 466740602,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725213189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type.20in.20Lean/near/466740277\">said</a>:</p>\n<blockquote>\n<p><code>axiom MyType : Type</code></p>\n</blockquote>\n<p>new here so not 100% sure but I guess <code>axiom MyType : Type</code> is the same as <code>inductive MyType</code>. Sorry if I'm talking non-sense.</p>\n<p>Yes, \"what a term is\" is also a question I wondered. Calculus of construction is a pure type system (PTS), which means there's no difference between term and type, there's only 1 sort. But I'll try to figure this out.</p>",
        "id": 466743002,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725214235
    },
    {
        "content": "<blockquote>\n<p>new here so not 100% sure but I guess <code>axiom MyType : Type</code> is the same as <code>inductive MyType</code></p>\n</blockquote>\n<p>Not quite. <code>inductive MyType</code> defines a type which you can prove is empty/not inhabited, meaning you can construct a term <code>a : MyType -&gt; False</code>. (The reason you can prove it to be empty is because when you define this type, you get a function <code>MyType.rec</code> which lets you show that.) <code>axiom MyType : Type</code> creates a type where you can't prove that it is inhabited (it is impossible construct a term <code>a : MyType</code>), but you also can't prove that it is <em>not</em> inhabited (it is also impossible to construct a term <code>a : MyType -&gt; False</code>). The reason for this is that you don't get a <code>MyType.rec</code> that would let you prove the latter.</p>\n<p>I think it's a bit clearer if we consider something simpler, say, <code>axiom n : Nat</code>. This is basically adds the axiom \"there exists a natural number <code>n</code>\" to the axiom system. But this axiom is kind of useless, since it doesn't let you prove anything that you couldn't already prove. <code>axiom n : Nat</code> <em>does not</em> add an extra natural number to the system outside of the <code>[0,infinity)</code> we already had. Instead, it postulates the existence of a natural <code>n</code> of which no other properties are assumed. It is neither possible to show that <code>n = 0</code> nor to show that <code>n ≠ 0</code>.</p>\n<p>As a side note, since <code>n</code> was declared with an axiom, if you decide to make any term whose value depends on the value of <code>n</code> (say, for example, you declared <code>def m : Nat := n + n</code>) then you have to mark that definition as <code>noncomputable</code> because Lean can't generate code to compute <code>m</code>. This is the same reason that you have to mark definitions with values that depend on <code>Classical.choice</code> as <code>noncomputable</code>.</p>",
        "id": 466747166,
        "sender_full_name": "Niels Voss",
        "timestamp": 1725216666
    },
    {
        "content": "<blockquote>\n<p>Yes, \"what a term is\" is also a question I wondered.</p>\n</blockquote>\n<p>I am unfortunately not qualified to answer this question. My best guess is that terms are not given a hard definition, but rather there is assumed to be a collection of terms that follow certain axioms. (A model of Lean specifies what the collection of terms is). This is pretty similar to how ZFC doesn't actually define the word \"set\" but instead just assumes the existence of a collection of sets (which becomes the domain of discourse for the ∀ and ∃ symbols) that follow certain properties.</p>\n<p>There is this link that describes what constitutes a valid expression: <a href=\"https://leanprover.github.io/reference/expressions.html\">https://leanprover.github.io/reference/expressions.html</a> (Warning: this is for Lean 3), and for every valid expression there is a corresponding term. I am not sure about the converse, that is, if every term corresponds to an expression.</p>",
        "id": 466750260,
        "sender_full_name": "Niels Voss",
        "timestamp": 1725218153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/stream/113489-new-members/topic/Official.20definition.20of.20type.20in.20Lean/near/466747166\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>new here so not 100% sure but I guess <code>axiom MyType : Type</code> is the same as <code>inductive MyType</code></p>\n</blockquote>\n<p>Not quite. <code>inductive MyType</code> defines a type which you can prove is empty/not inhabited, meaning you can construct a term <code>a : MyType -&gt; False</code>. (The reason you can prove it to be empty is because when you define this type, you get a function <code>MyType.rec</code> which lets you show that.) <code>axiom MyType : Type</code> creates a type where you can't prove that it is inhabited (it is impossible construct a term <code>a : MyType</code>), but you also can't prove that it is <em>not</em> inhabited (it is also impossible to construct a term <code>a : MyType -&gt; False</code>). The reason for this is that you don't get a <code>MyType.rec</code> that would let you prove the latter.</p>\n<p>I think it's a bit clearer if we consider something simpler, say, <code>axiom n : Nat</code>. This is basically adds the axiom \"there exists a natural number <code>n</code>\" to the axiom system. But this axiom is kind of useless, since it doesn't let you prove anything that you couldn't already prove. <code>axiom n : Nat</code> <em>does not</em> add an extra natural number to the system outside of the <code>[0,infinity)</code> we already had. Instead, it postulates the existence of a natural <code>n</code> of which no other properties are assumed. It is neither possible to show that <code>n = 0</code> nor to show that <code>n ≠ 0</code>.</p>\n<p>As a side note, since <code>n</code> was declared with an axiom, if you decide to make any term whose value depends on the value of <code>n</code> (say, for example, you declared <code>def m : Nat := n + n</code>) then you have to mark that definition as <code>noncomputable</code> because Lean can't generate code to compute <code>m</code>. This is the same reason that you have to mark definitions with values that depend on <code>Classical.choice</code> as <code>noncomputable</code>.</p>\n</blockquote>\n<p>Yes, you were right. <code>inductive</code> without constructors is like definition of <code>False</code>, we can prove <code>False</code>. That's the reason why I wish to know a comprehensive list of all possible kinds of types and which one is essentially which one.</p>",
        "id": 466804507,
        "sender_full_name": "Cuong Tran",
        "timestamp": 1725247697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344401\">Cuong Tran</span> has marked this topic as resolved.</p>",
        "id": 466804784,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725247824
    }
]