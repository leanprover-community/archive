[
    {
        "content": "<p>I'm trying to understand patterns for dealing with existence and choice.</p>\n<p>I have this little example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">y₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y₂</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PairSet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pairSetToFun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">IsFunctional</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"n\">hf1</span><span class=\"w\"> </span><span class=\"n\">hf2</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hf1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf2</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun_funToPairSet_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">pairSetToFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hyex</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hyex</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hyex</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hy'</span>\n</code></pre></div>\n<p>My question is, why does <code>hy'</code> satisfy the last lemma, but <code>hy</code> doesn't?<br>\nHow to think about this?</p>\n<p>The proof state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">hyex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hyex</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>I'm honestly confused why <code>hy'</code> satisfies the goal at all — the goal and <code>hy'</code> read different to me.</p>\n<p>What am I missing?</p>",
        "id": 529491811,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752855326
    },
    {
        "content": "<p>(Note that your first <code>noncomputable def</code> should be <code>theorem</code>)</p>",
        "id": 529492101,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752855452
    },
    {
        "content": "<p>Maybe this helps?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun_funToPairSet_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">pairSetToFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hyex</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hyex</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hyex</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">funToPairSet</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hy'</span><span class=\"w\"> </span><span class=\"bp\">⊢</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">pairSetToFun</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hy'</span>\n</code></pre></div>",
        "id": 529492348,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752855569
    },
    {
        "content": "<p>Notice that <code>hy'</code> and the goal are both <code>Exists.choose</code> applied to a proof. Since they're proofs, for them to be the same, they just need to have equivalent types (by proof irrelevance).</p>",
        "id": 529492466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752855617
    },
    {
        "content": "<p>In one case you have <code>∃ y, funToPairSet f x y</code> and in the other you have <code>∃ y, y = f x</code>, and by definition of <code>funToPairSet</code> these are the same.</p>",
        "id": 529492534,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752855643
    },
    {
        "content": "<p>(Side note: there's always going to be a bit of an \"impedance mismatch\" here, between native functions and functions-as-a-set-of-pairs, because native functions have some kind of computational content, but the set-of-pairs perspective doesn't actually say what the value is for a given input. It doesn't matter in the end for reasoning, but it's an interesting difference.)</p>",
        "id": 529493006,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752855828
    },
    {
        "content": "<p>OK, mechanically I think this makes sense.</p>\n<p>Is there also a conceptual way to think about this? Like, how do I make sense of the fact that the same existential has two different ways to obtain \"a value with a hypothesis\" out of it, but only choice works in this case?</p>",
        "id": 529493063,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752855851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> it's because choose is a function</p>",
        "id": 529493209,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752855911
    },
    {
        "content": "<p>a function is required to give the same output every time</p>",
        "id": 529493218,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752855916
    },
    {
        "content": "<p>so even though it's arbitrary, it's a fixed arbitrary choice</p>",
        "id": 529493234,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752855924
    },
    {
        "content": "<p>Ah, so we're kind of lifting the existential \"up\" to a point if multiple places in code share access to it, they can also obtain a stronger result (choice would give us same value for it). Whereas if the <code>pairSetToFun</code> function wasn't defined via that choosing existential, we wouldn't have that way to coordinate later?</p>",
        "id": 529493363,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752855990
    },
    {
        "content": "<p>it seems like your interpretation of choice is the opposite of mine</p>",
        "id": 529493475,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752856037
    },
    {
        "content": "<p>your <code>pairSetToFun</code> was defined using the same <code>choose</code> as the <code>hyex.choose_spec</code> in your proof</p>",
        "id": 529493605,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752856094
    },
    {
        "content": "<p>same choose on same proof gives same result</p>",
        "id": 529493626,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752856105
    },
    {
        "content": "<p>(yes, it's the same proof, because all proofs are the same)</p>",
        "id": 529493649,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752856116
    },
    {
        "content": "<p>Do you like continuation-passing style / callbacks <span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span>?</p>\n<p>When you're in a proof, you can think of the pattern matching notation as setting up a callback, rather than \"actually\" getting any values out. The rest of the proof from that point is the callback, and it says \"if someone were to give us a witness, then this is why the conclusion follows\", but that doesn't mean that there <em>is</em> a witness in hand.</p>\n<p>Maybe: proofs are evidence that a proposition is true, but the proofs themselves are opaque objects that we don't inspect. (With <code>Exists.intro</code> we provide a witness to provide the evidence that the existential is true, but we've thrown that witness into the void and never expect to \"read\" it ever again.)</p>",
        "id": 529493669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856128
    },
    {
        "content": "<p>If we want to \"actually\" get the value, which is what a top-level definition must be, an actual value, then we can't use this callback approach. We need the value now, not in the imagined later point in time when someone gives us a witness.</p>\n<p>The choice function makes a choice ahead of time for a witness, that way we \"actually\" have one when we need it.</p>",
        "id": 529493898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856243
    },
    {
        "content": "<blockquote>\n<p>same choose on same proof gives same result</p>\n</blockquote>\n<p>Right, so I think that's what I meant... Let me try to rephase it.</p>\n<p>If I got it right, when you just \"read\" an existential, each \"read\" is independent and nothing \"ties\" those reads together. So if you want multiple \"reads\" to be coordinated, you have to \"read\" ahead of time, and <code>choice</code> is a way to do that. Everybody doing <code>choice</code> on the same existential will \"read\" the same value. So it would be possible to use that fact when reducing expressions that have the same choice on both sides.</p>\n<p>Does that make sense?</p>",
        "id": 529494160,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752856366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20choice.20more.20powerful.20than.20exists.20hypothesis.3F/near/529494160\">said</a>:</p>\n<blockquote>\n<p>when you just \"read\" an existential, each \"read\" is independent and nothing \"ties\" those reads together.</p>\n</blockquote>\n<p>That's a way I've thought about it before as well, and it gives you all the intuition you need.</p>",
        "id": 529494393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856468
    },
    {
        "content": "<p>Hm would it be a reasonable analogy to say that destructuring an existential is like chaining a <code>then(val =&gt; ...)</code> to some Promise (i.e. monadically adding more computation to it) while <code>choice</code> is like actually like getting a reference to that Promise so you can pass it around? Not sure if I'm stretching the analogy too far.</p>",
        "id": 529494568,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752856540
    },
    {
        "content": "<p>I guess I'm struggling to imagine what <code>choice</code> would mean in the CPS world — usually if you do CPS, you don't have the option of \"actually\" getting the value</p>",
        "id": 529494789,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752856626
    },
    {
        "content": "<p>Yes, it's exactly like chaining promises.</p>\n<p>The <code>choice</code> function though is giving the actual value that <em>some</em> promise resolves to. Not necessarily this <code>Exists</code>.</p>",
        "id": 529494796,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856629
    },
    {
        "content": "<p>Interesting,  so I guess <code>choice</code> is like a loophole that forces the collapse. And for consistency it must collapse the same way for everyone</p>",
        "id": 529494931,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752856687
    },
    {
        "content": "<p>And it collapses in the same way for everyone because it's a function, so equal inputs means equal outputs.</p>",
        "id": 529495037,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20choice.20more.20powerful.20than.20exists.20hypothesis.3F/near/529494789\">said</a>:</p>\n<blockquote>\n<p>I guess I'm struggling to imagine what <code>choice</code> would mean in the CPS world — usually if you do CPS, you don't have the option of \"actually\" getting the value</p>\n</blockquote>\n<p>Choice is a way of magically spawning in a value since there's no other way to \"actually\" get it out</p>",
        "id": 529495052,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752856747
    },
    {
        "content": "<p>Re chaining promises, if you look at the type of <code>Exists.casesOn</code>, the <code>intro</code> argument is the continuation argument:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span>\n<span class=\"c1\">-- Exists.casesOn.{u} {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p)</span>\n<span class=\"c1\">--  (intro : ∀ (w : α) (h : p w), motive (Exists.intro w h)) : motive t</span>\n</code></pre></div>\n<p>I mentioned in your other thread that this type can be simplified to something equivalent but easier to read:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn'</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span>\n</code></pre></div>\n<p>(No need for the value returned by the continuation to depend on <code>t</code>.)</p>",
        "id": 529495311,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856863
    },
    {
        "content": "<p>That's to say, the <code>have ⟨w,h⟩ := t; b</code> is the same as <code>t.casesOn fun w h =&gt; b</code></p>",
        "id": 529495458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752856928
    },
    {
        "content": "<p>(Hopefully this last line connects it up to <code>Promise</code> well enough.)</p>",
        "id": 529495987,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752857160
    },
    {
        "content": "<p>I'm reminded that I've heard that continuation-passing style is somehow related to classical logic.</p>\n<p>If we had call-with-current-continuation, then we could use <code>Exists.casesOn</code> to extract a witness:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">call_with_cc</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>\n<p>So, I suppose it must be at least as powerful as <code>Classical.choice</code>.</p>",
        "id": 529496371,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752857324
    },
    {
        "content": "<p>OK yeah this is very helpful, thank you!</p>\n<p>A big aha moment tbh.</p>",
        "id": 529497077,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752857626
    },
    {
        "content": "<p>In a sense, is choice strictly more powerful than destructuring? Are there any things I can prove with destructuring but <em>not</em> with choice for the same existential?</p>",
        "id": 529497978,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752858091
    },
    {
        "content": "<p>Oh, neat, call-with-cc can be made to actually work here (which by the way is <a href=\"https://en.wikipedia.org/wiki/Peirce%27s_law\">Pierce's law</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">call_with_cc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isEmpty_or_nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">call_with_cc</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"w\"> </span><span class=\"n\">w</span>\n</code></pre></div>",
        "id": 529498679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752858396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20choice.20more.20powerful.20than.20exists.20hypothesis.3F/near/529497978\">said</a>:</p>\n<blockquote>\n<p>In a sense, is choice strictly more powerful than destructuring?</p>\n</blockquote>\n<p>I believe choice is strictly more powerful.</p>\n<p>Destructuring is just the mechanism that's built into the theory of inductive types. It's also the \"natural\" one (e.g. it's the elimination rule for natural deduction)</p>",
        "id": 529498935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752858497
    },
    {
        "content": "<p>(Oops, I got tricked with my <code>_</code>'s. This is a purely <code>Prop</code> version... I leave it as an exercise to make a version that actually works, if that's possible! Especially one that does the <code>Exists</code> version of <code>Classical.indefiniteDescription</code>.)</p>",
        "id": 529500010,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752859007
    },
    {
        "content": "<p>Fixed it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">call_with_cc</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">isEmpty_or_nonempty</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim'</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">indefiniteDescription</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">call_with_cc</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">indefiniteDescription</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose_spec'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose'</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- unfold Exists.choose' indefiniteDescription call_with_cc</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 529501504,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752859670
    },
    {
        "content": "<p>To summarize it for myself, here's how I would explain it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">funToPairSet_functional</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"c1\">-- ∃ y, ...</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Option 1: Destructuring</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy1</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- not provable (who said they're equal?)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Option 2: Choice</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y1'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hy1'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y2'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hy2'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y_exists</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y1'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y2'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- trivially true! \"canonical\" rabbit for this hat</span>\n</code></pre></div>",
        "id": 529523330,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752870807
    },
    {
        "content": "<p>with a caveat that uniqueness would make the first case provable</p>",
        "id": 529523393,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1752870847
    }
]