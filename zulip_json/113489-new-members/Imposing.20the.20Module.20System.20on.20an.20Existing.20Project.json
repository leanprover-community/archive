[
    {
        "content": "<p>Notes from the rather painful experience of superimposing the new module system on an existing project, <em>in a way that left everything else unchanged.</em></p>\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code><span class=\"gh\"># Lean 4.27 Module System: Failure Modes and Best Practices</span>\n\nLessons learned from migrating the Designer (~1064 modules) and CDK (~457 modules) codebases to the Lean 4.27 module system.\n\n<span class=\"gu\">## The Module Header</span>\n\nEvery <span class=\"sb\">`.lean`</span> file must begin with the <span class=\"sb\">`module`</span> keyword, followed by imports, followed by <span class=\"sb\">`@[expose] public section`</span>:\n\n```lean\nmodule\npublic import Designer.Language.Types.Tipe\npublic import Lean.Data.Json\n\n@[expose] public section\n\nnamespace CDK.Compiler.Bridges\n</code></pre></div>\n<p><strong>Rules:</strong><br>\n* <code>module</code> must be the first non-comment token in the file<br>\n* All imports use <code>public import</code> (not bare <code>import</code>)<br>\n* <code>@[expose] public section</code> opens the block where all definitions live<br>\n* Re-export aggregator modules have no definitions — just imports and the empty section</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Re-export aggregator: combines ToJson + FromJson under a single import</span>\n<span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">CDK.Realms.SAM.ToJson</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">CDK.Realms.SAM.FromJson</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n</code></pre></div>\n<hr>\n<h2>Failure Mode 1: Private Declarations</h2>\n<h3>Symptom</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unknown</span><span class=\"w\"> </span><span class=\"n\">identifier</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">readFileIfExists'</span>\n</code></pre></div>\n<p>A function that was accessible before migration is now invisible to callers in the same or other modules.</p>\n<h3>Cause</h3>\n<p>Inside <code>@[expose] public section</code>, <code>private</code> means <strong>truly private</strong> — not just file-private as in pre-4.27 Lean. The declaration is invisible to all other <code>public</code> declarations, even within the same section.</p>\n<h3>Fix</h3>\n<p>Remove <code>private</code> from all <code>def</code>, <code>theorem</code>, <code>lemma</code>, <code>instance</code>, <code>abbrev</code>, <code>structure</code>, and <code>inductive</code> declarations inside <code>@[expose] public section</code>. If a function was previously <code>private</code> for namespace hygiene, use more specific naming instead.</p>\n<p>Watch for the <code>@[inline] private def</code> variant — a bulk <code>sed</code> targeting <code>^private def</code> will miss it.</p>\n<h3>Scale</h3>\n<p>This affected ~240 declarations across 84 files in CDK alone. Automate with:</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"c1\"># Catches most cases</span>\nsed<span class=\"w\"> </span>-E<span class=\"w\"> </span>-i<span class=\"w\"> </span><span class=\"s1\">''</span><span class=\"w\"> </span><span class=\"s1\">'s/^([[:space:]]*)private (def|theorem|lemma|instance|abbrev|structure|inductive)/\\1\\2/g'</span><span class=\"w\"> </span>file.lean\n\n<span class=\"c1\"># Also catch attribute-prefixed cases like @[inline] private def</span>\nsed<span class=\"w\"> </span>-E<span class=\"w\"> </span>-i<span class=\"w\"> </span><span class=\"s1\">''</span><span class=\"w\"> </span><span class=\"s1\">'s/^([[:space:]]*@\\[[^\\]]*\\]) private (def|theorem|lemma|instance)/\\1 \\2/g'</span><span class=\"w\"> </span>file.lean\n</code></pre></div>\n<hr>\n<h2>Failure Mode 2: Same-Package Native IR Missing</h2>\n<h3>Symptom</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">native</span><span class=\"w\"> </span><span class=\"n\">implementation</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">external</span><span class=\"w\"> </span><span class=\"n\">declaration</span>\n<span class=\"w\">  </span><span class=\"bp\">'</span><span class=\"n\">lp_CDK_Compiler_Bridges_PythonV2_Data_PyVal_print</span><span class=\"bp\">._</span><span class=\"n\">closed1'</span>\n</code></pre></div>\n<p>The prefix matches your own package (here <code>lp_CDK_</code>).</p>\n<h3>Cause</h3>\n<p>When module A defines a function with <code>@[expose]</code> and module B (same package) calls that function at compile time (in <code>#eval</code>, <code>#guard</code>, or <code>@[reducible]</code> contexts), B needs the native compiled code. In 4.27, <code>public import</code> provides the type signatures but not necessarily the native IR.</p>\n<h3>Fix</h3>\n<p>Add <code>import all</code> for the module that defines the missing function, alongside the existing <code>public import</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">module</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">CDK.Compiler.Bridges.PythonV2.Data.PyVal</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">CDK.Compiler.Bridges.PythonV2.Data.PyVal</span><span class=\"w\">   </span><span class=\"c1\">-- provides native IR</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n</code></pre></div>\n<p><code>import all</code> forces Lean to link the full native implementation of every <code>@[expose]</code> declaration from that module.</p>\n<h3>When You Need It</h3>\n<ul>\n<li>Any file that calls <code>@[expose]</code> functions at compile time (<code>#eval</code>, <code>#guard</code>)</li>\n<li>Any file that uses <code>@[expose]</code> functions in positions requiring reduction (instance synthesis, <code>simp</code>, <code>decide</code>)</li>\n<li>Test files almost always need it</li>\n</ul>\n<hr>\n<h2>Failure Mode 3: Cross-Package Native IR Missing</h2>\n<h3>Symptom</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Could</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"n\">native</span><span class=\"w\"> </span><span class=\"n\">implementation</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">external</span><span class=\"w\"> </span><span class=\"n\">declaration</span>\n<span class=\"w\">  </span><span class=\"bp\">'</span><span class=\"n\">lp_Designer_Utils_Json_mkObjOmitNull</span><span class=\"bp\">._</span><span class=\"n\">closed1'</span>\n</code></pre></div>\n<p>The prefix is a <strong>different</strong> package (here <code>lp_Designer_</code> from a CDK file).</p>\n<h3>Cause</h3>\n<p><code>import all</code> only works <strong>within</strong> a single package. If CDK code calls a Designer <code>@[expose]</code> function at compile time, there is no way to link the native IR — the Designer shared library isn't available to CDK's compilation.</p>\n<h3>Fix Options</h3>\n<p><strong>Option A (recommended): Move compile-time code to the defining package.</strong> If the <code>#eval</code> or <code>#guard</code> only tests Designer types, put those tests in the Designer test suite, not CDK.<br>\n<strong>Option B: Remove inline tests from core files.</strong> <code>#eval</code> and <code>#guard</code> in non-test files are the usual trigger. They produce no definitions — they're purely compile-time assertions. Move them to same-package test files where <code>import all</code> can provide the necessary native IR, or to the upstream package's test suite.<br>\n<strong>Option C: <code>precompileModules = true</code> in <code>lakefile.toml</code>.</strong> This compiles the upstream package to a shared library (<code>.so</code>/<code>.dylib</code>), making its native IR available cross-package. However, this changes build semantics and can slow incremental builds significantly.</p>\n<h3>What Does NOT Work</h3>\n<ul>\n<li><code>import all Designer.Some.Module</code> from CDK — this has no effect cross-package</li>\n<li>Adding more <code>public import</code> statements — these provide types, not native code</li>\n</ul>\n<hr>\n<h2>Failure Mode 4: Name Shadowing After Private Removal</h2>\n<h3>Symptom</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">⟦</span><span class=\"n\">Sub</span><span class=\"bp\">⟧</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>A definition that previously had a unique name (because <code>private</code> scoped it) now collides with a Lean builtin or Mathlib name.</p>\n<h3>Cause</h3>\n<p>Removing <code>private</code> from <code>def Sub</code> exposes it to the global namespace, where Lean's builtin <code>Sub : Type → Type</code> (subtraction typeclass) takes priority. The local definition becomes shadowed.</p>\n<h3>Fix</h3>\n<p>Rename the definition to something that won't collide:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Before (fails: clashes with builtin Sub)</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟪.</span><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">stdName</span><span class=\"bp\">⟫</span>\n<span class=\"c1\">-- After</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">seqSub</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟪.</span><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">stdName</span><span class=\"bp\">⟫</span>\n</code></pre></div>\n<h3>High-Risk Names</h3>\n<p>Watch for these Lean builtins that commonly shadow user definitions: <code>Sub</code>, <code>Add</code>, <code>Mul</code>, <code>Neg</code>, <code>Inv</code>, <code>Div</code>, <code>Mod</code>, <code>And</code>, <code>Or</code>, <code>Not</code>, <code>True</code>, <code>False</code>, <code>Zero</code>, <code>One</code>, <code>List</code>, <code>Option</code>, <code>Prod</code>, <code>Sum</code>, <code>Fin</code>, <code>Nat</code>, <code>Int</code>.</p>\n<hr>\n<h2>Failure Mode 5: Inline Tests Blocking Compilation</h2>\n<h3>Symptom</h3>\n<p>A core (non-test) file fails to build because of a <code>#eval</code> or <code>#guard</code> deep in the file, even though all the actual definitions are fine.</p>\n<h3>Cause</h3>\n<p><code>#eval</code> and <code>#guard</code> execute at compile time. If they transitively call any function whose native IR is unavailable (see Failure Modes 2 and 3), the entire file fails to build — taking all downstream dependents with it.</p>\n<h3>Fix</h3>\n<p>Keep <code>#eval</code> and <code>#guard</code> exclusively in test files (<code>Test/</code> directory). Core files should contain only definitions, instances, and theorems.</p>\n<p>This is good practice regardless of the module system: inline tests create fragile compilation dependencies and make it harder to isolate build failures.</p>\n<h3>Identifying Inline Tests</h3>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code><span class=\"c1\"># Find all #eval and #guard in non-test files</span>\ngrep<span class=\"w\"> </span>-rn<span class=\"w\"> </span><span class=\"s1\">'#eval\\|#guard'</span><span class=\"w\"> </span>CDK/CDK/<span class=\"w\"> </span>--include<span class=\"o\">=</span><span class=\"s1\">'*.lean'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>grep<span class=\"w\"> </span>-v<span class=\"w\"> </span><span class=\"s1\">'/Test/'</span><span class=\"w\"> </span><span class=\"p\">|</span><span class=\"w\"> </span>grep<span class=\"w\"> </span>-v<span class=\"w\"> </span><span class=\"s1\">'/Evolving/'</span>\n</code></pre></div>\n<h2>GiveG</h2>\n<h2>Best Practices Summary</h2>\n<h3>File Structure</h3>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">module</span><span class=\"w\">                                    </span><span class=\"c1\">-- always first</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"w\">                 </span><span class=\"c1\">-- all imports are public</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"w\">                    </span><span class=\"c1\">-- only when native IR needed</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">expose</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span><span class=\"w\">                  </span><span class=\"c1\">-- opens the public block</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">My</span><span class=\"bp\">.</span><span class=\"n\">Namespace</span>\n<span class=\"c1\">-- definitions here, no private keyword</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">My</span><span class=\"bp\">.</span><span class=\"n\">Namespace</span>\n</code></pre></div>\n<h3>Decision Tree for <code>import all</code></h3>\n<ol>\n<li>Does this file use <code>#eval</code> or <code>#guard</code>? → Likely needs <code>import all</code></li>\n<li>Does the target module live in the <strong>same</strong> package? → <code>import all</code> will work</li>\n<li>Does the target module live in a <strong>different</strong> package? → <code>import all</code> won't help; move the test or use <code>precompileModules</code></li>\n</ol>\n<h3>Migration Checklist</h3>\n<ul>\n<li>Add <code>module</code> as first token in every <code>.lean</code> file</li>\n<li>Convert all <code>import</code> to <code>public import</code></li>\n<li>Add <code>@[expose] public section</code> after imports</li>\n<li>Remove all <code>private</code> from declarations inside <code>@[expose] public section</code></li>\n<li>Scan for name collisions with Lean builtins after <code>private</code> removal</li>\n<li>Move all <code>#eval</code>/<code>#guard</code> from core files to test files</li>\n<li>Add <code>import all</code> in test files that call <code>@[expose]</code> functions</li>\n<li>Verify no cross-package <code>#eval</code>/<code>#guard</code> remain in core files</li>\n<li>Run <code>lake clean &amp;&amp; lake build</code> as final verification</li>\n</ul>\n<h3>Automation</h3>\n<p>The <code>modularize.py</code> script handles the bulk mechanical transformation (adding <code>module</code>, converting imports, wrapping in <code>@[expose] public section</code>). The failure modes above are what it <strong>cannot</strong> handle — they require semantic understanding of the code.</p>",
        "id": 573845876,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1771027602
    }
]