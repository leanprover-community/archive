[
    {
        "content": "<p>I am now generating complete pure terms via the Rust --aeneas--&gt; Lean toolchain... one nice feature of the translation: because terms are pure, unit tests (of the form <code>assert!(f foo == bar)</code> can be executed at type-checking time using the simplifier, rather than be left as run-time errors...</p>\n<p>this means that I now have goals of the form :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">hm</span> <span class=\"bp\">←</span>\n      <span class=\"k\">do</span>\n        <span class=\"k\">let</span> <span class=\"n\">slots</span> <span class=\"bp\">←</span>\n          <span class=\"k\">if</span>\n                <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">32</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_fwd.proof_1</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"bp\">&gt;</span>\n                  <span class=\"n\">USize.ofNatCore</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">USize.size</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n              <span class=\"k\">do</span>\n              <span class=\"k\">let</span> <span class=\"n\">slots0</span> <span class=\"bp\">←</span>\n                <span class=\"n\">vec_push_back</span> <span class=\"o\">(</span><span class=\"n\">hashmap_list_t</span> <span class=\"n\">UInt64</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vec_new</span> <span class=\"o\">(</span><span class=\"n\">hashmap_list_t</span> <span class=\"n\">UInt64</span><span class=\"o\">))</span> <span class=\"n\">hashmap_list_t.HashmapListNil</span>\n              <span class=\"k\">let</span> <span class=\"n\">n0</span> <span class=\"bp\">←</span>\n                <span class=\"n\">USize.checked_sub</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">32</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_fwd.proof_1</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n                    <span class=\"o\">(</span><span class=\"n\">USize.ofNatCore</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">USize.size</span><span class=\"o\">))</span>\n              <span class=\"n\">hashmap_hash_map_allocate_slots_loop_fwd</span> <span class=\"n\">UInt64</span> <span class=\"n\">slots0</span> <span class=\"n\">n0</span>\n            <span class=\"k\">else</span> <span class=\"n\">result.ret</span> <span class=\"o\">(</span><span class=\"n\">vec_new</span> <span class=\"o\">(</span><span class=\"n\">hashmap_list_t</span> <span class=\"n\">UInt64</span><span class=\"o\">))</span>\n        <span class=\"k\">let</span> <span class=\"n\">i</span> <span class=\"bp\">←</span>\n          <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">32</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"bp\">&lt;</span> <span class=\"n\">USize.size</span> <span class=\"k\">then</span> <span class=\"n\">result.ret</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">32</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"mi\">32</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"bp\">&lt;</span> <span class=\"n\">USize.size</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n            <span class=\"k\">else</span> <span class=\"n\">result.fail</span> <span class=\"n\">error.integerOverflow</span>\n        <span class=\"k\">let</span> <span class=\"n\">i0</span> <span class=\"bp\">←</span> <span class=\"n\">USize.checked_div</span> <span class=\"n\">i</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_fwd.proof_3</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n        <span class=\"n\">result.ret</span>\n            <span class=\"o\">{</span>\n              <span class=\"n\">hashmap_hash_map_num_entries</span> <span class=\"o\">:=</span>\n                <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_with_capacity_fwd.proof_1</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n              <span class=\"n\">hashmap_hash_map_max_load_factor</span> <span class=\"o\">:=</span>\n                <span class=\"o\">({</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_fwd.proof_2</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n                  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">isLt</span> <span class=\"o\">:=</span> <span class=\"n\">hashmap_hash_map_new_fwd.proof_3</span> <span class=\"o\">}</span> <span class=\"o\">}),</span>\n              <span class=\"n\">hashmap_hash_map_max_load</span> <span class=\"o\">:=</span> <span class=\"n\">i0</span><span class=\"o\">,</span> <span class=\"n\">hashmap_hash_map_slots</span> <span class=\"o\">:=</span> <span class=\"n\">slots</span> <span class=\"o\">}</span>\n  <span class=\"bp\">&lt;&lt;</span> <span class=\"bp\">...</span> <span class=\"n\">much</span> <span class=\"n\">more</span> <span class=\"bp\">...</span> <span class=\"bp\">&gt;&gt;</span>\n  <span class=\"bp\">=</span> <span class=\"n\">result</span> <span class=\"o\">()</span>\n</code></pre></div>\n<p>ideally, I would like a magic flag for <code>simp</code> that reduces everything and runs the entire computation on the simplifier... possibly with tweaks such as \"ok to unfold these recursive functions\"... (this is my F* habit speaking here)</p>\n<p>here's where I'm at:</p>\n<ul>\n<li>reading <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html\">https://leanprover.github.io/theorem_proving_in_lean4/tactics.html</a>, I couldn't find such a \"reduce everything\" mode, so I resorted to listing all of the functions one by one (as a temporary thing: if there's a better way, I'd love to know, because this is not sustainable, there are dozens of such functions)</li>\n<li>even so, trying to reduce this term, if I do <code>simp [ LT.lt ]</code>, I exceed the recursion limit</li>\n<li>to debug the recursion limit error, I tried running several <code>unfold</code> manually to see where the problem lies, and ended up stuck on System.Platform.getNumBits which (intentionally) does not reduce... I guess I could add an instance of <a href=\"http://LT.lt\">LT.lt</a> for USize that first checks if it's &lt; 2^32, and otherwise falls back to the comparison to System.Platform.getNumBits ()... but at this stage, I figured out I could use advice on how to best achieve all of the above</li>\n</ul>\n<p>side remark:</p>\n<ul>\n<li>generally, is there a list of important tactics that one might want to use? I've read <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html\">https://leanprover.github.io/theorem_proving_in_lean4/tactics.html</a> but I guess I'd be looking for a directory of tactics (rather than grepping through the Lean source)</li>\n</ul>\n<p>thanks!</p>",
        "id": 325266200,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675285077
    }
]