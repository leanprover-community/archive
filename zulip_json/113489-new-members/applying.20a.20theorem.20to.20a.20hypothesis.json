[
    {
        "content": "<p>Section 2.2 in Mathematics in Lean, it says to apply a theorem <code>add_left_cancel</code> to a hypothesis <code>h</code> is to do   <code>rw [add_left_cancel h]</code>, previously , in Section 2.1, it shows we can use the <code>at</code> syntax like <code>rw [mul_comm d a] at hyp</code> , so any reason that <code>rw [add_left_cancel] at h</code> gives an error?</p>",
        "id": 485426683,
        "sender_full_name": "KEW",
        "timestamp": 1733006776
    },
    {
        "content": "<p>you can't rewrite with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=add_left_cancel#doc\">docs#add_left_cancel</a> by itself, as it's not an equality or iff... it's a function / implication</p>",
        "id": 485427199,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1733007361
    },
    {
        "content": "<p>could you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? it's hard to help without knowing what <code>h</code> is in this context</p>",
        "id": 485427293,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1733007440
    },
    {
        "content": "<p>The two forms are very different in what they do, or try to do. <code>rw [thm h]</code> or  <code>apply thm h</code> is something you use when theorem <code>thm</code> requires some hypothesis, and <code>h</code> can serve as this hypothesis.  For instance, <code>add_left_cancel</code> has type <code>n + m = n + k → m = k</code>: it requires a hypothesis of the form <code>n + m  = n + k</code>, and it then yields a proof of <code>m = k</code>; since this is an equality, <code>add_left_cancel h</code> (where <code>h</code> has the required form) can be used with <code>rw</code>.</p>\n<p>The other form, <code>rw [thm] at h</code> or <code>apply thm at h</code>, tries to use <code>thm</code> to change hypothesis <code>h</code> (instead of the current goal, which is the default when no <code>at h</code> is present).</p>",
        "id": 485427296,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1733007443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/applying.20a.20theorem.20to.20a.20hypothesis/near/485427296\">said</a>:</p>\n<blockquote>\n<p>The two forms are very different in what they do, or try to do. <code>rw [thm h]</code> or  <code>apply thm h</code> is something you use when theorem <code>thm</code> requires some hypothesis, and <code>h</code> can serve as this hypothesis.  For instance, <code>add_left_cancel</code> has type <code>n + m = n + k → m = k</code>: it requires a hypothesis of the form <code>n + m  = n + k</code>, and it then yields a proof of <code>m = k</code>; since this is an equality, <code>add_left_cancel h</code> (where <code>h</code> has the required form) can be used with <code>rw</code>.</p>\n<p>The other form, <code>rw [thm] at h</code> or <code>apply thm at h</code>, tries to use <code>thm</code> to change hypothesis <code>h</code> (instead of the current goal, which is the default when no <code>at h</code> is present).</p>\n</blockquote>\n<p>thanks for the answer, still my question is why can't I use <code>add_left_cancel</code> to change <code>h</code>,  using the example in the book, </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mul_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mul_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_left_cancel</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>that would be using <code>add_left_cancel</code> to re-write <code>h : a * 0 + a * 0 = a * 0 + 0</code> into <code>h : a * 0  = 0</code> which then allows me to do <code>exact h</code>. But I guess the reason is the type of the theorem <code>add_left_cancel</code> which expects a hypothesis as you explained</p>",
        "id": 485430441,
        "sender_full_name": "KEW",
        "timestamp": 1733010825
    },
    {
        "content": "<blockquote>\n<p>that would be using <code>add_left_cancel</code> to re-write <code>h : a * 0 + a * 0 = a * 0 + 0</code> into <code>h : a * 0 = 0</code></p>\n</blockquote>\n<p>No, that's not what is happening there.  <code>rw [add_left_cancel h]</code> doesn't mean \"change <code>h</code> to something else\", it means \"prove the equality <code>a * 0 = 0</code> using <code>add_left_cancel</code> applied to <code>h</code>, and then change all <code>a * 0</code> in the <em>goal</em> to <code>0</code>\".</p>",
        "id": 485430629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733011020
    },
    {
        "content": "<p>It's hard to help without a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but you can try putting <code>#check add_left_cancel h</code> before the <code>rw</code> and see if that helps explain what happens</p>",
        "id": 485430668,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1733011069
    },
    {
        "content": "<p><code>add_left_cancel</code> is a <em>function</em>, or an <em>implication</em>. It eats a proof and spits out another proof. <code>rw</code> eats an <em>equality</em> like <code>a * 0 = 0</code>. The concepts <code>P -&gt; Q</code> (an implication) and <code>x = y</code> (an equality) are very different things, and are used in different ways and by different things in Lean.</p>",
        "id": 485430722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733011101
    },
    {
        "content": "<p>Got it. Thanks!</p>",
        "id": 485444725,
        "sender_full_name": "KEW",
        "timestamp": 1733025637
    }
]