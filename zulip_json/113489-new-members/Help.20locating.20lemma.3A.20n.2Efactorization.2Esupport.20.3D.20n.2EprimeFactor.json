[
    {
        "content": "<p>Hi all — I’m fairly new to working directly with the <code>factorization</code> API, and I’m trying to prove a simple lemma that I suspect already exists somewhere in mathlib.</p>\n<p>My current goal is to show that if a prime doesn’t divide <code>n</code>, then it doesn’t appear in the support of the factorisation. Concretely:</p>\n<p><code>lemma factorization_eq_zero_of_not_mem_primeFactors     {n p : ℕ} (hp : p ∉ n.primeFactors) :     n.factorization p = 0 := by   ...</code></p>\n<p>I thought there might be a lemma characterising the support, something like:</p>\n<p><code>n.factorization.support = n.primeFactors</code></p>\n<p>or at least a <code>mem_support_iff</code> specialised to the number-theory setting, but I can’t find anything obvious.</p>\n<p>For reference, I’m working with mathlib pinned at:</p>\n<p><code>30ceb3260d7d7536</code></p>\n<p>If anyone can point me to the right lemma or the recommended approach, I’d be very grateful.<br>\nThanks</p>",
        "id": 561387862,
        "sender_full_name": "Bob Jefferson",
        "timestamp": 1764675231
    },
    {
        "content": "<p>There are a few ways to search for lemmas.</p>\n<ol>\n<li><code>exact?</code> tactic</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">factorization_eq_zero_of_not_mem_primeFactors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">primeFactors</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">factorization</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact?</span>\n</code></pre></div>\n<p>will search for a few seconds, and replies in the infoView with <code>Try this: exact Finsupp.not_mem_support_iff.mp hp</code>, you can click on it, and it will replace the <code>exact?</code> word.</p>",
        "id": 561404540,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764680183
    },
    {
        "content": "<ol start=\"2\">\n<li>Loogle, you can search for theorems</li>\n</ol>\n<ul>\n<li>Containing specific set of constants: <a href=\"https://loogle.lean-lang.org/?q=Nat.primeFactors%2C+Nat.factorization\">https://loogle.lean-lang.org/?q=Nat.primeFactors%2C+Nat.factorization</a></li>\n<li>Containing a specific subterm: <a href=\"https://loogle.lean-lang.org/?q=Nat.factorization+%3F_+%3F_+%3D+0\">https://loogle.lean-lang.org/?q=Nat.factorization+%3F_+%3F_+%3D+0</a></li>\n</ul>",
        "id": 561405669,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764680445
    },
    {
        "content": "<p>Many thanks — this is very useful. I’ll try <code>exact?</code> together with Loogle to see what my pinned mathlib version actually provides. I’m specifically checking whether something like <code>Nat.primeFactors_eq_toFinset</code> exists in my snapshot; it appears to be present in newer mathlib but may not be available in the version I’m pinned to. If it isn’t, I’ll consider cloning the project and updating my pin. If that doesn't work I'll just construct a local lemma along the same lines. Appreciate the help!</p>",
        "id": 561407180,
        "sender_full_name": "Bob Jefferson",
        "timestamp": 1764680816
    },
    {
        "content": "<p>Indeed, loogle as a web service works with the up to date mathlib, and it is generally recommended to keep Lean up to date (but I am also guilty of keeping quite an old version on my computer). By the way, another local ways of searching for tactics are other questionmark tactics.</p>\n<ol start=\"3\">\n<li><code>simp?</code> doesn't work in your case but can be useful to see what <code>simp</code> used when it did something</li>\n<li><code>rw??</code>, if you write this tactic, shift-click on <code>n.factorization p</code> in the infoview, and wait for a few seconds, you get several suggestions such as</li>\n</ol>\n<ul>\n<li><code>Multiset.count p (Finsupp.toMultiset n.factorization)]()</code></li>\n<li><code>[if p ∈ n.factorization.support then n.factorization p else 0]()</code></li>\n</ul>",
        "id": 561409844,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764681560
    },
    {
        "content": "<p>Thanks again, that’s really helpful.</p>\n<p>I’m on a slightly older mathlib pin, so I don’t have some of the newer<br>\nprimeFactors_eq_… lemmas, but your suggestions with exact?, simp? and<br>\nespecially rw?? are exactly what I needed. Being able to point rw?? at<br>\nn.factorization p and see the “if p ∈ support then … else 0” shape (and the<br>\nmultiset view) gives me a clear route to prove the lemma I want in my<br>\ncurrent environment, even without upgrading mathlib right away.</p>",
        "id": 561412354,
        "sender_full_name": "Bob Jefferson",
        "timestamp": 1764682175
    },
    {
        "content": "<p>Is this what you're asking for in the title?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">factorization</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">primeFactors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is true by definition, since <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.factorization#doc\">docs#Nat.factorization</a> looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">factorization</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">primeFactors</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">mem_support_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_or</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 561559772,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764734889
    },
    {
        "content": "<p>Also your lemma is very close to being true by definition of a finitely supported function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">factorization_eq_zero_of_not_mem_primeFactors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">primeFactors</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">factorization</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Finsupp</span><span class=\"bp\">.</span><span class=\"n\">notMem_support_iff</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n</code></pre></div>\n<p>and it'll probably work on any Mathlib version (though the name of the theorem might differ)</p>",
        "id": 561559830,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764734928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"941396\">Bob Jefferson</span> <a href=\"#narrow/channel/113489-new-members/topic/Help.20locating.20lemma.3A.20n.2Efactorization.2Esupport.20.3D.20n.2EprimeFactor/near/561387862\">said</a>:</p>\n<blockquote>\n<p>For reference, I’m working with mathlib pinned at:</p>\n<p><code>30ceb3260d7d7536</code></p>\n</blockquote>\n<p>There is no such Mathlib commit: <a href=\"https://github.com/leanprover-community/mathlib4/commit/30ceb3260d7d7536\">https://github.com/leanprover-community/mathlib4/commit/30ceb3260d7d7536</a></p>",
        "id": 561559886,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1764734987
    },
    {
        "content": "<p>Hi, just a quick note to say thank you.  Your observation that<br>\n<code>n.factorization.support = n.primeFactors</code> <em>definitionally</em> was exactly the breakthrough I needed.</p>\n<p>I had been preparing to build a whole bridge via <code>divisors</code>, <code>mem_divisors</code>, etc., but your reminder that the support of <code>Nat.factorization</code> is already set to <code>primeFactors</code> meant the lemma</p>\n<p><code>lemma factorization_eq_zero_of_not_mem_primeFactors …</code></p>\n<p>was essentially immediate from <code>Finsupp.notMem_support_iff</code>.</p>\n<p>That single insight massively simplified the design of my multiplicative-functions mini-library, and the τ multiplicativity file now builds cleanly. Really appreciated — thank you for taking the time to reply and point me in the right direction.</p>",
        "id": 561752856,
        "sender_full_name": "Bob Jefferson",
        "timestamp": 1764796433
    }
]