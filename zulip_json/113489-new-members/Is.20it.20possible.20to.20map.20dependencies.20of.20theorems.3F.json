[
    {
        "content": "<p>I was chatting to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> a few weeks ago about the \"blueprint\" thing and how it relies on a bunch of manual work to keep up-to-date. Since that point, I've been wondering about something.</p>\n<p>How difficult would it be to have a tool that can automatically map dependencies between theorems, and generate something akin to a blueprint? I don't mean including <em>all</em> theorems (since that would lead to a crazy explosion). But I was imagining some opt-in like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">blueprint_node</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">some_theorem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">blabla</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>And then theorems with <code>@[blueprint_node]</code> get automatically pulled into the visualization, with the graph representing which proofs depend on validity of which proofs. Theorems without the annotation are still considered in the relationship graph but don't appear as explicit nodes (so it's like they're \"transparent\" and only the transitive relationships between <code>@[blueprint_node]</code>s are visible).</p>\n<p>So maybe you run some tool like <code>./generate-graph MyFile.lean</code> and it finds all <code>@[blueprint_node]</code>s recursively and emits some HTML. Maybe there's also some way to break them into different pages, to generate LaTeX from docstrings, or whatever. The main idea is just that the source of truth is the code itself.</p>\n<p>My question is</p>\n<p>1) Whether this idea is bad in some way.<br>\n2) How feasible is something like this with today's Lean metaprogramming facilities. Would anything get in the way? Is this a couple days, a couple weeks, or a couple months of implementation work?</p>",
        "id": 538025900,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757187114
    },
    {
        "content": "<p>The main use of a blueprint is <em>before</em> you have the formal proofs to derive the dependencies from, though</p>",
        "id": 538026669,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757187816
    },
    {
        "content": "<p>Hmm yeah.. Makes sense <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>\n<p>Maybe there is a middle ground between having <code>sorry</code>s and working proofs? The main advantage I'm thinking of is that the system is driven entirely by code. Even if the actual proofs are duds waiting to be filled in.</p>\n<p>For example, you could have something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">blueprint_node</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">theorem1</span><span class=\"w\"> </span><span class=\"n\">param1</span><span class=\"w\"> </span><span class=\"n\">param2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">blabla</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">blueprint_node</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">theorem2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">blabla</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">theorem1</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Some nodes can then gradually start to get filled out, while the blueprint is responsive to those changes. As collision with the \"real world\" inevitably changes some of the graph, it automatically gets updated.</p>",
        "id": 538026902,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757188092
    },
    {
        "content": "<p>Okay, but what if you haven't formalized the statement of theorem1? :)</p>",
        "id": 538026946,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757188131
    },
    {
        "content": "<p>That can still be a dud with just a name, right?</p>",
        "id": 538026983,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757188150
    },
    {
        "content": "<p>And a docstring.</p>",
        "id": 538027009,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757188186
    },
    {
        "content": "<p>So you can start with nodes that are <code>sorry</code>s all over the place but express the dependency between them in code by <code>have :=</code> with <code>sorry</code>s as arguments. This gets you the initial blueprint with relationships. Then you can start filling it out in any order, slowly fleshing out the bits inside. As the shape changes or proofs actually get proven, all arrows are updated in sync with the code.</p>",
        "id": 538027084,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757188260
    },
    {
        "content": "<p>It does sound interesting, but I wonder how well it would work in practice</p>",
        "id": 538027120,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757188291
    },
    {
        "content": "<p>Yeah, I don't know! The best way to find out may be to just try it, hence the second question â€” how \"close\" is this to doable with Lean's metaprogramming? If it's not an insane amount of work, I might as well try this to learn some Lean. But if it's very \"against the grain\" of how Lean works, it may not be the best idea.</p>",
        "id": 538027186,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757188344
    }
]