[
    {
        "content": "<p>In <a href=\"https://hackage.haskell.org/package/hvect-0.4.0.0/docs/Data-HVect.html\">haskell</a>, or <a href=\"https://www.idris-lang.org/docs/idris2/current/contrib_docs/docs/Data.HVect.html\">Idris</a>, there are so called \"heterogeneous vectors\" where one statically tracks the size and the types of elements</p>\n<p>I think there are no such data type in Lean (?)<br>\nShould I write it my self, which of the following two style is more idiomatic in Lean (or are they equally easy / painful) ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Vector</span>\n\n<span class=\"c1\">-- Heterogeneous vector style 1</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">HVect</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n   <span class=\"bp\">|</span> <span class=\"n\">Nil</span>  <span class=\"o\">:</span> <span class=\"n\">HVect</span> <span class=\"mi\">0</span> <span class=\"o\">⟨</span> <span class=\"o\">[],</span> <span class=\"n\">simp</span> <span class=\"o\">⟩</span>\n   <span class=\"bp\">|</span> <span class=\"n\">Cons</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">HVect</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">ts</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">HVect</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">::</span><span class=\"n\">ts</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]⟩</span>\n\n<span class=\"c1\">-- Heterogeneous vector style 2</span>\n<span class=\"kd\">def</span> <span class=\"n\">HVector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"kt\">Type</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ts</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Nil</span> <span class=\"o\">:</span> <span class=\"n\">HVector</span> <span class=\"mi\">0</span> <span class=\"o\">⟨[],</span> <span class=\"n\">p</span> <span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">0</span><span class=\"o\">)⟩)</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">exfalso</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_lt_antisymm</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_le</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">HVector</span> <span class=\"n\">n</span> <span class=\"o\">⟨</span><span class=\"n\">ts</span><span class=\"o\">,</span> <span class=\"n\">tsp</span><span class=\"o\">⟩</span> <span class=\"bp\">→</span> <span class=\"n\">HVector</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(⟨</span><span class=\"n\">α</span> <span class=\"o\">::</span> <span class=\"n\">ts</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">tsp</span><span class=\"o\">⟩</span> <span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">(⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ip</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)⟩)</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">i</span>  <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">|</span><span class=\"n\">i</span><span class=\"o\">)</span>\n      <span class=\"bp\">.</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n      <span class=\"bp\">.</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.succ_lt_succ_iff.mp</span>  <span class=\"n\">ip</span>\n        <span class=\"n\">exact</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 400578152,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699290745
    },
    {
        "content": "<p>Typically mathlib uses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Heterogeneous vector style 2.5</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">HVector</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ts</span> <span class=\"n\">i</span>\n</code></pre></div>",
        "id": 400585540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699293718
    },
    {
        "content": "<p>(Note that this <code>HVector</code> type has different runtime characteristics from <code>HVect</code>, if you care about using these in programs. <code>HVector</code> is a closure and if you're not careful you can have long chains of unforced computations. <code>HVect</code> is eager. On the other hand, <code>HVector</code> is probably more pleasant to prove things about -- <code>HVector</code> is sort of the abstract interface for a heterogenous vector -- and you can generalize <code>Fin n</code> to an arbitrary indexing type.)</p>",
        "id": 400599472,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699299761
    }
]