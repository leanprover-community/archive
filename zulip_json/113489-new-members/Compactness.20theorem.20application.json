[
    {
        "content": "<p>I'm trying to prove that if a first order theory has arbitrarily large finite models then it has an infinite model using the compactness theorem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">FirstOrder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">compactness_app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">ModelType</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">ModelType</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">withConstants</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">L''</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">L'</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">distinctness</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"bp\">.</span><span class=\"n\">distinctConstantsTheory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L''</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L'</span><span class=\"bp\">.</span><span class=\"n\">lhomWithConstants</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">onTheory</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">distinctness</span>\n</code></pre></div>\n<p>I'm having trouble getting <code>T'</code>;  can't use <code>T</code> in the <code>let T'</code> line. Please help.</p>",
        "id": 547034003,
        "sender_full_name": "Janitha Aswedige",
        "timestamp": 1761374876
    },
    {
        "content": "<p>I think you want your <code>T'</code> defined to be the union of <code>T</code> and the collection of inequalities <code>a_n≠a_m</code> right?</p>",
        "id": 547035947,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1761377015
    },
    {
        "content": "<p>So first of all, I don't think it is necessary to define <code>L''</code> if you ultimately just want a language that is equal to the union of <code>L</code> and a sequence of constants <code>a_n</code>, because <code>L.withConstants</code> have already done that for you.</p>",
        "id": 547036171,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1761377245
    },
    {
        "content": "<p>Yes, we want <code>a_n \\neq a_m </code>.</p>\n<p>You mean this is enough?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">compactness_app</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Language</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">ModelType</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">ModelType</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">withConstants</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">distinctness</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">distinctConstantsTheory</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"bp\">.</span><span class=\"n\">Theory</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">lhomWithConstants</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">onTheory</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">distinctness</span>\n</code></pre></div>",
        "id": 547036502,
        "sender_full_name": "Janitha Aswedige",
        "timestamp": 1761377566
    },
    {
        "content": "<p>I believe so, also you should not get any warnings now.</p>",
        "id": 547036664,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1761377734
    },
    {
        "content": "<p>Yes there are no warnings. :)</p>",
        "id": 547036706,
        "sender_full_name": "Janitha Aswedige",
        "timestamp": 1761377776
    },
    {
        "content": "<p>There's a warning in the code you provide above because the type of <code>(L'.lhomWithConstants ℕ).onTheory</code> is <code>L'.Theory→ L'[[ℕ]].Theory</code>, and your <code>T</code> is of type <code>L.Theory</code>not <code>L'.Theory</code>. The type mismatch is the source of warning.</p>",
        "id": 547036840,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1761377954
    },
    {
        "content": "<p>I thought <code>L'</code> was not enough. That's why I had written <code>L''</code> as the sum initially.</p>",
        "id": 547036959,
        "sender_full_name": "Janitha Aswedige",
        "timestamp": 1761378089
    },
    {
        "content": "<p>The equation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.withConstants\">Language.withConstants</a> is <code>L.sum FirstOrder.Language.constantsOn α</code> so I believe <code>L'</code> has already included <code>L</code>.</p>",
        "id": 547037150,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1761378324
    },
    {
        "content": "<p>got it!</p>",
        "id": 547037564,
        "sender_full_name": "Janitha Aswedige",
        "timestamp": 1761378773
    }
]