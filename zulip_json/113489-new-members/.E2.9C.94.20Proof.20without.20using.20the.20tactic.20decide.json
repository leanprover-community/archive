[
    {
        "content": "<p>Hello, I had some experience with lean in the past but mostly with theorem proving in mathematics.<br>\nIt has been a while since I used lean. I'm trying to prove that the array x is sorted without using the decide tactic <br>\nto understand how one would go about proving such a thing. </p>\n<p>Suppose I replace Nat with a type with an undecidable LT, I cannot use decide, instead I will have to prove it for all possible values of i and j which satisfy i &lt; j.<br>\nIs there a tactic which lets me do that (for finite arrays of course)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Let Î± be a type with a linear order</span>\n<span class=\"c1\">-- Let sortedArray Î± be the type of arrays of Î± that are sorted in increasing order</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- x is an instance of SortedArray</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x_sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">âŸ¨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"bp\">âŸ©</span>\n\n<span class=\"c1\">-- lets prove it without using decide</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x_sorted'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">âŸ¨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">hij</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">âŸ©</span>\n</code></pre></div>",
        "id": 471235443,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726658960
    },
    {
        "content": "<p>i think <code>fin_cases i</code> (which you can import from <code>Mathlib.Tactic.FinCases</code>) should help with this</p>",
        "id": 471236390,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726659274
    },
    {
        "content": "<p>Thank you, I will try that. I've been trying to not import mathlib, but I will look into the <code>fin_cases</code> implementation maybe.</p>",
        "id": 471237617,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726659697
    },
    {
        "content": "<p>You can change <code>sorted</code> to <code>array.toList.Pairwise (Â· &lt; Â·)</code> and then <code>simp</code> can do it</p>",
        "id": 471238561,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726659995
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LT</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">Â·</span><span class=\"o\">))</span>\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y_sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortedArray</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">  </span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (a &lt; b âˆ§ a &lt; c) âˆ§ b &lt; c</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 471238730,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726660055
    },
    {
        "content": "<p>That's great. As I understand it, <code>Array</code> behaves just like a wrapper around <code>List</code> when it comes to theorem proving.<br>\nSince Arrays are more performant with O(1) lookup and better memory allocation, wouldn't defining <code>SortedArray</code> using <code>.toList</code> degrade the performance?</p>",
        "id": 471240166,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726660529
    },
    {
        "content": "<p><code>sorted</code> doesn't have computational content, as a Prop, so it's erased in compilation and shouldn't affect performance</p>",
        "id": 471240425,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726660616
    },
    {
        "content": "<p>I see. Thanks for the explanation.</p>",
        "id": 471240705,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726660701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Proof.20without.20using.20the.20tactic.20decide/near/471236390\">said</a>:</p>\n<blockquote>\n<p>i think <code>fin_cases i</code> (which you can import from <code>Mathlib.Tactic.FinCases</code>) should help with this</p>\n</blockquote>\n<p>Unfortunately this creates unprovable goals since it removes context (example: in the case <code>i = 1</code> and <code>j = 0</code> it replaces <code>i</code> and <code>j</code> with <code>1</code> and <code>0</code> in the goal but does not add the context that <code>i = 1</code> and <code>j = 0</code> so that I can escape this case using <code>hij</code>).</p>",
        "id": 471252605,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726664236
    },
    {
        "content": "<p>it does change <code>hij</code> to <code>1 &lt; 0</code> in that case, right? so <code>contradiction</code> does close the case?</p>",
        "id": 471256264,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726665181
    },
    {
        "content": "<p>Oh you are right. Thank you.</p>",
        "id": 471256541,
        "sender_full_name": "Karthik ðŸ¦‹",
        "timestamp": 1726665254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421677\">Karthik ðŸ¦‹</span> has marked this topic as resolved.</p>",
        "id": 471266869,
        "sender_full_name": "Notification Bot",
        "timestamp": 1726667976
    }
]