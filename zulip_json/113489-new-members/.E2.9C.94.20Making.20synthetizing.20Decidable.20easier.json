[
    {
        "content": "<p>I wrote a proof to one of the examples from <em>The Mechanics..</em> using the <code>use-exact</code> line, and then tried to repeat the same with <code>decide</code>, and got <br>\n<code>failed to synthesize Decidable (∃ a b, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b)</code>, even though it looks like something that could be done (perhaps a little bit of help). Then I got the same for <code>native_decide</code>.</p>\n<p>Is there a way for me to add a synthetising layer that gives <code>decide</code> / <code>native_decide</code> a better chance of synthetizing <code>Decidable</code>?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\nimport Lean\n\nexample : ∃ a b : ℤ, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b := by\n  use 3, 1\n  exact\n\nexample : ∃ a b : ℤ, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b := by\n  decide\n</code></pre></div>\n</div></div>",
        "id": 483461619,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732101964
    },
    {
        "content": "<p><code>decide</code> isn't designed to be a magic problem solving tool for everything, really it is only for solving simple structural problems</p>",
        "id": 483461832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732102049
    },
    {
        "content": "<p>Typically I would only expect it to work when your binder quantification is obviously finite, but after applying the inequalities your search space is still infinite</p>",
        "id": 483461984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732102092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483461832\">schrieb</a>:</p>\n<blockquote>\n<p><code>decide</code> isn't designed to be a magic problem solving tool for everything, really it is only for solving simple structural problems</p>\n</blockquote>\n<p>Of course (magic would be not enough fun).</p>\n<p>So there'd be, in principle, an opportunity for a tool that makes one's binder quantification explicitly (or somewhat explicitly) finite? </p>\n<p>I learnt a bit about <code>decide</code> / <code>native_decide</code> / <code>Decidable</code>. Could you tell me where I can learn more about the binding process? I'd just have a look at the code.</p>",
        "id": 483462818,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732102383
    },
    {
        "content": "<p>There is nothing special about the binders in <code>decide</code>; just try <code>#synth</code>ing some obviously finite searches to see what's going on</p>",
        "id": 483462989,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732102444
    },
    {
        "content": "<p>Ok, so where can I learn more about the process of <code>#synth</code>ing? Where do I start? I'd just learn directly from the code.</p>",
        "id": 483463214,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732102530
    },
    {
        "content": "<p>I think I have it. It's <code>Lean/Meta/SynthInstance.lean</code>, but feel free to correct me.</p>",
        "id": 483465010,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732103197
    },
    {
        "content": "<p>So it looks like for, say, <code>Decidable (P ∧ Q)</code>, we'd first look for an instance (I guess there we must have lots of different instances with long names that we don't need to remember), then the instance is applied to the goal (potentially generating a tree of goals), and then we do the same for every sub-goal (and use cached instances whenever possible). Once everything is resolved, the final instance is constructed.</p>\n<p>So to make synthetizing better one could:</p>\n<ul>\n<li>a bigger set of <code>instances</code>, perhaps generating them in the background based on what's available already,</li>\n<li>run <code>synth</code> in parallel with multiple workers,  concurrent goal processing</li>\n<li>better prioritize and select <code>instances</code></li>\n<li>perhaps not all constraints need to be solved at all times, perhaps some delay could be an option</li>\n<li>simplify goals? solve simpler versions of the problem first (sometimes)?</li>\n</ul>\n<p>I hope that makes sense. If not, I'd love to learn why (I'm still learning).</p>",
        "id": 483467232,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732103964
    },
    {
        "content": "<p>I don't think you need to look at the details of <code>#synth</code> either; the example I had in mind was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- set_option pp.explicit true --optional</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which tells you it is using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decidableBallLT#doc\">docs#Nat.decidableBallLT</a></p>",
        "id": 483472805,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732105896
    },
    {
        "content": "<p>I had already started using <code>#synth</code> (Daniel Weber recommended it some time ago). But I didn't realize I can access all these instances through the docs like this. Thank you! </p>\n<p>Now I'll be able to debug much faster. This is great.</p>\n<p>So, that's how I can get to the list of <code>instances</code>. Now, given that <code>decide</code> can't synthetize an instance in the (relatively easy) case,  I was thinking about writing a simple <code>decide_deep</code> that would cover more cases.  A bit like <code>bv_decide</code>for fixed-width BitVec, but for problems, say, from <em>The Mechanics of Proof</em>. A small step towards better search and better synthetization.</p>\n<p>Would that make sense?</p>",
        "id": 483475919,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732106892
    },
    {
        "content": "<p>You don't need a deeper decide. You need to provide an instance of Decidable for your goal shape.</p>",
        "id": 483476175,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1732106971
    },
    {
        "content": "<p>And I think your problem is that your goal shape isn't possible to abstract. So you'd then be proving <code>Decidable</code> for your particular goal, which is silly because then you may as well just prove your goal is true.</p>",
        "id": 483476583,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732107089
    },
    {
        "content": "<p>A Decidable instance _is_ an algorithm. Either one that works on a proposition directly, or relies on an equivalent proposition and it's Decidable, via decidable_of_iff</p>",
        "id": 483476594,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1732107091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483476175\">schrieb</a>:</p>\n<blockquote>\n<p>You don't need a deeper decide. You need to provide an instance of Decidable for your goal shape.</p>\n</blockquote>\n<p>So the next step dev would be generating instances of <code>Decidable</code>s. I even wrote a blog post about using diffusion models for this kind of case. <br>\n<a href=\"https://buildermath.substack.com/p/intuition-machine\">https://buildermath.substack.com/p/intuition-machine</a></p>\n<p>Given that synthetization is not really a problem, having a deeper network of <code>Decidable</code> instances would be the way to go. </p>\n<p>(Please always feel free to correct me -- I might be wrong)</p>\n<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span></p>",
        "id": 483477142,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732107236
    },
    {
        "content": "<p>For a concrete example of why a general decidable wouldn't work here is the theoretical impossibility for the following:<br>\nDecidablePred fun T : TuringMachine, Exists k : Nat, T.stepsToHalt = k</p>",
        "id": 483477223,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1732107249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483476583\">said</a>:</p>\n<blockquote>\n<p>And I think your problem is that your goal shape isn't possible to abstract.</p>\n</blockquote>\n<p>To elaborate on this remark; <code>(∀ x &lt; 10, x^2 ≠ 37)</code> fits the pattern <code>(∀ x &lt; n, P x)</code>, and this is decidable with algorithm \"just enumerate all numbers less than n\".</p>\n<p>Taking your <code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b)</code>, we could try this against the pattern <code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ P a b)</code>, but <code>Decidable (∃ a b, 0 &lt; b ∧ b &lt; a ∧ P a b)</code> is impossible to implement because there is no terminating algorithm for searching this infinite space</p>",
        "id": 483477933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732107455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483477933\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483476583\">said</a>:</p>\n<blockquote>\n<p>And I think your problem is that your goal shape isn't possible to abstract.</p>\n</blockquote>\n<p>To elaborate on this remark; <code>(∀ x &lt; 10, x^2 ≠ 37)</code> fits the pattern <code>(∀ x &lt; n, P x)</code>, and this is decidable with algorithm \"just enumerate all numbers less than n\".</p>\n<p>Taking your <code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b)</code>, we could try this against the pattern <code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ P a b)</code>, but <code>Decidable (∃ a b, 0 &lt; b ∧ b &lt; a ∧ P a b)</code> is impossible to implement because there is no terminating algorithm for searching this infinite space</p>\n</blockquote>\n<p>This is very helpful.</p>\n<p>But the domain being infinite doesn't automatically render the problem <code>undecidable?</code> How do we know that there's no terminating algorithm for searching this particular space?</p>\n<p>In order to determine the truth, we need to be able to  construct a terminating algorithm (or am I wrong?) If that's the case, then any <code>synth</code> algorithm would somehow be a function of the ability to terminate the algorithm?</p>\n<p>In the article I wrote my thinking was: through <em>generative construction</em> one could find the fastest (energy-based diffusion and newer) ways of constructing algorithms (in this case, <code>Decidable</code> instances, which -as Yakov mentioned- are algorithms) that can conclusively determine the truth value of many statements (even in infinite spaces) in <em>finite time.</em></p>",
        "id": 483481128,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732108427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483481128\">said</a>:</p>\n<blockquote>\n<p>But the domain being infinite doesn't automatically render the problem <code>undecidable?</code> How do we know that there's no terminating algorithm for searching this particular space?</p>\n</blockquote>\n<p>In most cases, if you have an infinite domain then there is a relatively straightforward way of using it to enumerate turing machine partial evaluations and prove formally that it is undecidable because it implies a solution to the halting problem. In this case, if you had a decision procedure for <code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ P a b)</code> then I could take <code>P a b</code> to be \"turing machine M halts in at most <code>b</code> steps\" and then this existential statement is equivalent to the halting problem for M.</p>",
        "id": 483482112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732108758
    },
    {
        "content": "<p>I guess the point is - this pattern could be decidable for a number of concrete <code>P</code>, but not for a general <code>P</code> without any restrictions</p>",
        "id": 483482648,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732108930
    },
    {
        "content": "<p>For this particular problem (<code>(∃ a b, 0 &lt; b ∧ b &lt; a ∧ a - b ∣ a + b)</code> with no abstraction), it is of course decidable because any statement which is true is decidable and you have a proof of it</p>",
        "id": 483482814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732108991
    },
    {
        "content": "<p>but this is obviously not a very useful way to use decide to prove your problem</p>",
        "id": 483482881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732109017
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isTrue</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 483483169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1732109120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/Making.20synthetizing.20Decidable.20easier/near/483483169\">schrieb</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isTrue</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is insanely beautiful (and could be taken to the next level). <span aria-label=\"thank you\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"thank you\">:thank_you:</span></p>",
        "id": 483483821,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732109340
    },
    {
        "content": "<p>I need to learn more about <code>Decidable</code>. Thank you for sharing all these insights.</p>",
        "id": 483484597,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732109594
    },
    {
        "content": "<p>I think the takeaway here is actually that you need to evaluate whether <code>Decidable</code> is really the hammer to pick up for every problem, by learning more about tools which <em>aren't</em> <code>decide</code>!</p>",
        "id": 483493052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1732112040
    },
    {
        "content": "<p>Tbh I am just starting so I am simply not good at <code>decide</code>. So none of the proofs (or almost none) is using <code>decide</code>.  But I like that direction.</p>\n<p>For now <code>decide</code> does not work for me very well (this problem would be a good example of this) -- but I guess that'll change, too.</p>\n<p>My goal was to try to understand why <code>decide</code> did not work for this problem.</p>",
        "id": 483495138,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732112590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> has marked this topic as resolved.</p>",
        "id": 483538532,
        "sender_full_name": "Notification Bot",
        "timestamp": 1732124152
    }
]