[
    {
        "content": "<p>What is a good way to resolve <code>(0,0) ≠ (2,1)</code> ?</p>\n<p>There are two differences between vanilla lean+mathlib and MoP:</p>\n<ul>\n<li>in MoP the custom tactic <code>numbers</code> works, but <code>norm_num</code> doesn't, even though <code>numbers</code> is supposed to be a weakened version of <code>norm_num</code></li>\n<li>the <code>by_contra</code> method I tried below works in live.lean but not MoP. (I find it strange it doesn't need further code.)</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- numbers tactic from MoP works</span>\n<span class=\"w\">  </span><span class=\"c1\">-- norm_num doesn't</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"c1\">-- this works in live.lean but not MoP !</span>\n<span class=\"w\">  </span><span class=\"c1\">-- no additional code needed, eg to find ¬P and P hypotheses then `contradiction`</span>\n</code></pre></div>\n<p>So given things have changed since MoP, what is the <strong>recommended</strong> way to resolve that goal?</p>",
        "id": 501214109,
        "sender_full_name": "rzeta0",
        "timestamp": 1740188351
    },
    {
        "content": "<p>I would go with <code>simp</code> or <code>decide</code></p>",
        "id": 501214396,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740188636
    },
    {
        "content": "<p><code>decide</code> definitely works, <code>intro h; cases h</code> seems to as well</p>",
        "id": 501214734,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740188900
    },
    {
        "content": "<p>Does <code>nofun</code> work?</p>",
        "id": 501216988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740190655
    },
    {
        "content": "<p>Thanks for the replies, I'll wait for more and see which are \"beginner\" enough for me.</p>\n<p>Believe it or not, I actually have not learned <code>simp</code> despite using <code>dsimp</code> to unfold definitions. </p>\n<p>I haven't learned <code>decide</code> nor <code>nofun</code>.</p>\n<p>I have used <code>intro</code> and <code>cases</code> so that is worth me playing with.</p>",
        "id": 501218657,
        "sender_full_name": "rzeta0",
        "timestamp": 1740192128
    },
    {
        "content": "<p>I think the reason why <code>norm_num</code> doesn't work here is because it's about numbers, and technically the goal is about pairs.</p>\n<p>If you break it down to the individual components using extensionality then it does work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Prod.ext_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 501223829,
        "sender_full_name": "Chris Wong",
        "timestamp": 1740196955
    },
    {
        "content": "<p>Though if this weren't an exercise, I would indeed go with <code>nofun</code> or <code>decide</code>, as simple statements deserve simple proofs.</p>",
        "id": 501224004,
        "sender_full_name": "Chris Wong",
        "timestamp": 1740197138
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 501242494,
        "sender_full_name": "suhr",
        "timestamp": 1740213365
    },
    {
        "content": "<p><code>example : (0,0) ≠ (2,1) := by decide</code> also works.</p>",
        "id": 501242561,
        "sender_full_name": "suhr",
        "timestamp": 1740213433
    },
    {
        "content": "<p>Here's how to prove it without <code>decide</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">noConfusion</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Hopefully your tutorial allows you to use <code>congrArg</code> and <code>Nat.noConfusion</code>, otherwise I don't quite see a point in such a tutorial.</p>",
        "id": 501242986,
        "sender_full_name": "suhr",
        "timestamp": 1740213840
    },
    {
        "content": "<p>About the <code>obtain</code>: <br>\nIt does not in general give you <code>a = b</code> and <code>c = d</code> from <code>(a, c) = (b, d)</code> (which I imagine is what you are looking for). For example this fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>I'm guessing that MoP thinks this is confusing for beginners so they weakened <code>obtain</code> and made it always fail.</p>",
        "id": 501250528,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1740220163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/channel/113489-new-members/topic/proving.20.280.2C0.29.20.E2.89.A0.20.282.2C1.29/near/501250528\">said</a>:</p>\n<blockquote>\n<p>It does not in general give you <code>a = b</code> and <code>c = d</code> from <code>(a, c) = (b, d)</code></p>\n</blockquote>\n<p>indeed, if you think about it, it does not make sense to match on an equality with a constructor with two variables, as <code>Eq.refl</code> only has one argument, even if it states an equality of 2-tuples. Indeed, the error message suggests that what <code>obtain</code> does when you try anyway, is <code>cases</code> on the equality</p>",
        "id": 501253017,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740222152
    },
    {
        "content": "<p>which then in the <code>(0,0) ≠ (2,1)</code> case will try unifying <code>0</code> with <code>2</code> (and <code>0</code> with <code>1</code> too), and note that there is no such case possible (rather than not knowing if it is true or not, as in the <code>(a,b)</code> case), leaving you with all goals solved.</p>",
        "id": 501253157,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740222266
    },
    {
        "content": "<p>Is the <code>obtain</code> thing another example of <code>rcases</code> syntax being overly permissive? I remember a recent thread on this.</p>",
        "id": 501258358,
        "sender_full_name": "Chris Wong",
        "timestamp": 1740226316
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> - thanks for exploring <code>obtain</code>.  The following is a quite from the MoP course which seems to suggest I do use <code>obtain</code>... </p>\n<blockquote>\n<p>To write these proofs in Lean, notice the use of the tactic <code>obtain</code> in the injectivity problem to convert the hypothesis of a equality in a product type,<br>\n<code>hm : (m1 + 1, 2 - m1) = (m2 + 1, 2 - m2)</code><br>\nto two hypotheses of equality in the two components of the product:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hm'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"n\">hm''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">m2</span>\n</code></pre></div>\n<p>This is consistent with how you should think about equality in a product type: two ordered pairs are equal if the two left parts are equal <em>and</em> the two right parts are equal. So we use the same tactic, with the same syntax, as for the logical operator “and”.<br>\n..<br>\n..<br>\nThe tactic <code>obtain</code> is used similarly in the non-surjectivity problem to break down the hypothesis of equality in a product type<br>\n<code>hm : (m + 1, 2 - m) = (0, 1)</code><br>\n</p>\n</blockquote>\n<p>Perhaps I'm reading this wrong - but I interpret it to mean that <code>(a,b)=(c,d)</code> should be seen as a conjunction <code>a=c ∧ b=d</code> and <code>obtain</code> can split these into two.</p>",
        "id": 501263201,
        "sender_full_name": "rzeta0",
        "timestamp": 1740229371
    },
    {
        "content": "<p>Well, it appears that <code>obtain</code> does not work like this on live lean. It is true that equality of tuples behaves this way, as evidenced by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.ext_iff#doc\">docs#Prod.ext_iff</a>, but it seems <code>obtain</code> is not able to get there.</p>",
        "id": 501264920,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740230396
    },
    {
        "content": "<p>Thanks Edward.</p>\n<p>In my mind I still haven't arrived at a \"beginner\" yet canonical way to do this. I'll keep watching the replies.</p>\n<p>It feels like one of those \"easy things should be easy\" that some languages/frameworks excel at.</p>",
        "id": 501272325,
        "sender_full_name": "rzeta0",
        "timestamp": 1740234877
    },
    {
        "content": "<p>Here's a very elementary approach.  Not the quickest, but elementary:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">calc</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 501274561,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1740236592
    },
    {
        "content": "<p>An easy was is to note that if you apply a function to two values, and they give different results, the original values must also be different:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ne_of_apply_ne</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 501275210,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740237018
    },
    {
        "content": "<p>here's another way that just uses <code>cases</code> and mysteriously proves it without any actual case handling!<br>\n*edit: oops! Julian found this one first^^*</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 501275657,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1740237361
    },
    {
        "content": "<p>(the reason why <code>cases</code> and <code>obtain</code> solve this on live is precisely what i explained above)</p>",
        "id": 501275927,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740237550
    },
    {
        "content": "<p>do we think Lean should be enhanced to allow:</p>\n<ul>\n<li><code>norm_num</code> to resolve numerically instantiated expressions like <code>(0,1) = (0,1)</code> and <code>(0,1) ≠ (0,2)</code></li>\n<li><code>obtain</code> to treat algebraic expressions <code>(a,b)=(c,d)</code> as <code>a = c ∧ b = d</code></li>\n</ul>",
        "id": 501276125,
        "sender_full_name": "rzeta0",
        "timestamp": 1740237702
    },
    {
        "content": "<p>To me neither seem immediately attractive, because in my brain this doesn't look enough like numerals to think <code>norm_num</code> is appropriate, and because <code>obtain</code> is for splitting apart structures, and equality isn't a structure. I think your definition of beginner is again too strict personally, and that the right approach here is to add <code>decide</code> to your toolkit, to me at least it seems very beginner friendly, it corresponds to something like \"this proof is a concrete calculation, so do it and then you'll be convinced Lean\".</p>",
        "id": 501277029,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740238365
    },
    {
        "content": "<p>I believe that beginners should be taught basics rather than fluff. From this perspective, a beginner should know how to use terms and also know some essential functions on commonly used types.</p>\n<p>For equality such functions are <code>rfl</code>, <code>Eq.subst</code>, <code>Eq.symm</code>, <code>Eq.trans</code>, <code>Eq.subst</code> and <code>congrArg</code>. For pairs, it's <code>Pair.fst</code> and <code>Pair.snd</code>. For natural numbers, it's <code>Nat.zero</code>, <code>Nat.succ</code>, <code>Nat.recOn</code> and <code>Nat.noConfusion</code>.</p>\n<p>It seems to be a rather unpopular opinion though, since most tutorials do not even mention <code>congrArg</code>.</p>",
        "id": 501279222,
        "sender_full_name": "suhr",
        "timestamp": 1740240046
    },
    {
        "content": "<p>ok - I'll take some time to learn about <code>decide</code></p>",
        "id": 501286218,
        "sender_full_name": "rzeta0",
        "timestamp": 1740245710
    },
    {
        "content": "<p>I don't 100% agree with <span class=\"user-mention\" data-user-id=\"394485\">@suhr</span>, but I do think that \"congruence\" and \"extensionality\" are fundamental concepts – if you want to relate equality of a whole to equality on parts, then you should be looking for those keywords.</p>",
        "id": 501318802,
        "sender_full_name": "Chris Wong",
        "timestamp": 1740272888
    }
]