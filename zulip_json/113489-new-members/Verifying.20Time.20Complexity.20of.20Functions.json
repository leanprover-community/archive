[
    {
        "content": "<p>As an exercise, I wanted to do this:</p>\n<blockquote>\n<p>I want to write a function that takes n : Nat as input and returns a List of String of the given size<br>\nBut with some additional requirements:</p>\n<p>a) n between 100 and 200 must not be accepted.<br>\n  b) If n &gt; 5, then the second element of the list must be \"foo\".<br>\n  c) The implemented function's time complexity must not be higher than O(n).</p>\n<p>The challenge is to get Lean to provably satisfy all of these requirements.</p>\n</blockquote>\n<p>Discussing back and forth with an LLM, I came up with <a href=\"https://live.lean-lang.org/#codez=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\">this implementation</a> using a Monad to keep counting ticks for computational cost.</p>\n<p>Is this a good / idiomatic solution? How would the experts accomplish this?</p>",
        "id": 565240880,
        "sender_full_name": "Nilesh",
        "timestamp": 1766551036
    },
    {
        "content": "<p>You might find this (very long) thread relevant: <a class=\"message-link\" href=\"/#narrow/channel/513188-CSLib/topic/Proposal.20on.20Time.20Complexity/near/541407869\">#CSLib &gt; Proposal on Time Complexity @ ðŸ’¬</a></p>",
        "id": 565241394,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1766551543
    },
    {
        "content": "<p>My opinion is that this is not a good solution. Even the paper that introduced it calls it a lightweight approach</p>",
        "id": 565241528,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766551673
    },
    {
        "content": "<p>You can see my points in the thread many times. Roughly : </p>\n<ol>\n<li>It leaves the model implicit and makes it possible to mix up different models.</li>\n<li>It is not compositional. You have to explicitly mark each occurrence of the code you care about with a tick explicitly. There is, by definition, no notion of \"correct\" marking. </li>\n<li>It is very easy to sneak in zero cost calls using pure, just discard the cost computation.</li>\n<li>It does not allow reasoning about complexity relations between different standard/custom models and oracles.</li>\n<li>It is a reviewing nightmare as algorithms get complex.</li>\n</ol>",
        "id": 565241669,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766551816
    },
    {
        "content": "<p>It can however serve as a building block for a better solution</p>",
        "id": 565241693,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766551842
    },
    {
        "content": "<p>Which I am working on. I'll finish it near the new year when I have time.</p>\n<p>Btw, the explicit annotation (cost monad) based approach is easily two decades old. There is one POPL 2008 paper, though I am guessing it was already internal knowledge by then. Every newcomer to lean interested in doing complexity seems to rediscover it. You can save a few steps by defining the Time Monad as a Writer monad.</p>",
        "id": 565241789,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766551930
    }
]