[
    {
        "content": "<p>Finally got past the boring stuff in MoP and reached Chapter 8 - Functions, which introduces what it calls \"finite inductive types\" with the following first example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">athos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">porthos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">aramis</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n</code></pre></div>\n<p>My central question is: <strong>What is inductive about it?</strong></p>\n<p>(secondary question&gt; what is <code>deriving DecidableEq</code>.. it's not explained)</p>\n<p>To me it looks like a <strong>finite set</strong>. And what we do with it is define functions which map from elements of this set to elements of this set. We don't do anything that looks inductive or recursive  with it?</p>",
        "id": 499962529,
        "sender_full_name": "rzeta0",
        "timestamp": 1739665140
    },
    {
        "content": "<p><code>deriving DecidableEq</code> creates a <code>DecidableEq Musketeer</code> instance for you automatically. That lets you do computations like <code>x = Musketeer.athos</code> in programs, or in <code>#eval</code>.</p>",
        "id": 499962790,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665377
    },
    {
        "content": "<p>It's called an inductive type because it's using the <code>inductive</code> command. It's a general framework for creating new types, and they are known as inductive types. They let you make types that represent trees for example, and they each give you some induction principle to prove things about the types.</p>",
        "id": 499962923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665514
    },
    {
        "content": "<p>In this case, Musketeer is a boring inductive type that doesn't have any recursion. There's no simpler framework than <code>inductive</code>, so it's just a non-recursive inductive type. (Seems like an oxymoron, but in math there's no harm being situated in a more general framework. Yes, it would be like saying \"consider the recursively defined function <code>def f (x : Nat) : Nat := x + 1</code>. Just because there's no recursion doesn't mean it's <em>wrong</em>, but it would be admittedly a bit perverse.)</p>\n<p>Sometimes people call these \"enum types\".</p>",
        "id": 499963002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665569
    },
    {
        "content": "<p>You can think of <code>Musketeer</code> as being a finite set, but only as far as you think of <code>Nat</code> as being a set. They're types, to be accurate.</p>",
        "id": 499963192,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665771
    },
    {
        "content": "<p>If you want, an \"inductive type\" is a type that you can do pattern matching on using <code>match</code>. They're made out of data that you can break apart.</p>",
        "id": 499963292,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665841
    },
    {
        "content": "<p>Thanks - this is very helpful.</p>\n<p>I now understand that the general framework is indicative but we can create type that don't have to use induction/recursion.</p>\n<p>And yes, thanks also for clarifying that it is a type, not a set!</p>\n<p>An enum type makes sense to me.</p>",
        "id": 499963364,
        "sender_full_name": "rzeta0",
        "timestamp": 1739665921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> has marked this topic as resolved.</p>",
        "id": 499963406,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739665924
    },
    {
        "content": "<p>Here's roughly the code that <code>deriving DecidableEq</code> generates. Maybe (parts of) it goes well with chapter 8 content:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">athos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">porthos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">aramis</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">athos</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">porthos</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">aramis</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">athos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">porthos</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">aramis</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">athos</span><span class=\"w\"> </span><span class=\"c1\">-- junk value</span>\n\n<span class=\"sd\">/-- `ofConsIdx` is a left inverse of `toConsIdx` -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx_toConsIdx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx_inj_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx_toConsIdx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">ofConsIdx_toConsIdx</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- Calculate `m = m'` by calculating `m.toConsIdx = m'.toConsIdx` instead. -/</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">Musketeer</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Musketeer</span><span class=\"bp\">.</span><span class=\"n\">toConsIdx_inj_iff</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 499963822,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739666369
    },
    {
        "content": "<p>thanks - I'm not an expert in this but that code definitely looks like the supporting code for an \"enum type\" to enable equality testing via assigned numerals.</p>",
        "id": 499966758,
        "sender_full_name": "rzeta0",
        "timestamp": 1739669130
    }
]