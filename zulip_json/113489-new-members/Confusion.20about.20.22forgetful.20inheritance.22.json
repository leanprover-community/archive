[
    {
        "content": "<p>I am reading <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html#basics\">Chapter 7.1 of Mathematics in Lean</a> and I am struggling to understand the solution to the bad diamond presented here.</p>\n<p>If I understand correctly, the problem is that</p>\n<ul>\n<li>Z is a Ring, and any ring R forms a Module R R, with ring multiplication as SMul.smul</li>\n<li>Z is an Abelian group, and any Abelian group A forms a Module Z A, with zsmul as SMul.smul</li>\n</ul>\n<p>Now, ring multiplication and zsmul may not immediately be the same thing definitionally.</p>\n<p>However, the solution is to add things to the additive monoid class (making a new <code>AddMonoid₄</code>). I am confused why this helps. I come from an OOP background so there may have been some special mechanism that I am missing to understand, since if extends is similar to OOP's inheritance, <code>AddMonoid₄</code> extending <code>AddSemigroup₃</code> does not change <code>AddSemigroup₃</code> (is that the case in Lean?).</p>\n<p>Many thanks!</p>",
        "id": 482731165,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731728050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"750932\">The-Anh Vu-Le</span> <a href=\"#narrow/channel/113489-new-members/topic/Confusion.20about.20.22forgetful.20inheritance.22/near/482731165\">said</a>:</p>\n<blockquote>\n<p>I am reading <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Hierarchies.html#basics\">Chapter 7.1 of Mathematics in Lean</a> and I am struggling to understand the solution to the bad diamond presented here.</p>\n<p>If I understand correctly, the problem is that</p>\n<ul>\n<li>Z is a Ring, and any ring R forms a Module R R, with ring multiplication as SMul.smul</li>\n<li>Z is an Abelian group, and any Abelian group A forms a Module Z A, with zsmul as SMul.smul</li>\n</ul>\n<p>Now, ring multiplication and zsmul may not immediately be the same thing definitionally.</p>\n<p>However, the solution is to add things to the additive monoid class (making a new <code>AddMonoid₄</code>). I am confused why this helps. I come from an OOP background so there may have been some special mechanism that I am missing to understand, since if extends is similar to OOP's inheritance, <code>AddMonoid₄</code> extending <code>AddSemigroup₃</code> does not change <code>AddSemigroup₃</code> (is that the case in Lean?).</p>\n<p>Many thanks!</p>\n</blockquote>\n<p>I think from an OOP perspective, it isnt the same, more similar would be instances.</p>\n<p>This might help, <a href=\"https://lean-lang.org/doc/reference/latest/The-Lean-Language/Type-Classes/#type-classes\">https://lean-lang.org/doc/reference/latest/The-Lean-Language/Type-Classes/#type-classes</a></p>\n<p>This also discusses it from a more programmatical perspective:</p>\n<p><a href=\"https://lean-lang.org/functional_programming_in_lean/type-classes/polymorphism.html\">https://lean-lang.org/functional_programming_in_lean/type-classes/polymorphism.html</a></p>\n<p>Edit: I vaguely recall forgetful inheritance being a forgetful functor between monoidal categories, i can't actually find where the macro for extends is defined though.</p>\n<p>Also from an OOP perspective the following passage from 7. Inductive Types in Theorem Proving with Lean may be helpful:</p>\n<p>\"In fact, in Lean's library, every concrete type other than the universes and every type constructor other than dependent arrows is an instance of a general family of type constructions known as <em>inductive types</em>.\"</p>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html\">https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html</a></p>",
        "id": 482731417,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1731728317
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 482731667,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1731728547
    },
    {
        "content": "<p>Then, how does <code>AddMonoid₄</code> help? I have gone through the text many times but cannot understand.</p>",
        "id": 482733701,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731730442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"750932\">The-Anh Vu-Le</span> <a href=\"#narrow/channel/113489-new-members/topic/Confusion.20about.20.22forgetful.20inheritance.22/near/482733701\">said</a>:</p>\n<blockquote>\n<p>Then, how does <code>AddMonoid₄</code> help? I have gone through the text many times but cannot understand.</p>\n</blockquote>\n<p>I was just trying to provide parallels to OOP -- to answer your question unfortunately would require someone who has gone through all of MIL ( I mostly use FPIL and TPIL).</p>\n<p>One thing to note about that passage, is it appears they explain it in some detail in a paragraph further up:<br>\n\"<br>\nBut the diamond we created with modules is definitely bad. The offending piece is the <code>smul</code> field which is data, not a proof, and we have two constructions that are not definitionally equal. The robust way of fixing this issue is to make sure that going from a rich structure to a poor structure is always done by forgetting data, not by defining data. This well-known pattern as been named “forgetful inheritance” and extensively discussed in <a href=\"https://inria.hal.science/hal-02463336\">https://inria.hal.science/hal-02463336</a>.<br>\n\"<br>\nSo to answer why it helps, is not trivial.</p>\n<p>This might be helpful, using an analogical example with a different versions of addition on Nat.</p>\n<p><a href=\"https://lean-lang.org/functional_programming_in_lean/dependent-types/pitfalls.html\">https://lean-lang.org/functional_programming_in_lean/dependent-types/pitfalls.html</a></p>\n<p>Otherwise, youd have to be a bit more narrow with your question.</p>\n<p>Edit: Note by diamond they refer to the \"diamond problem\" <br>\n<a href=\"https://en.wikipedia.org/wiki/Multiple_inheritance\">https://en.wikipedia.org/wiki/Multiple_inheritance</a><br>\nso your question is really how forgetful inheritance helps with the diamond problem. Might be a complicated answer.</p>",
        "id": 482734329,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1731731065
    },
    {
        "content": "<p>Thank you for all the pointers. After some thinking, my question should be: After implementing the solution (forgetful inheritance) with classes/instances related to <code>AddMonoid₄</code>, how will Lean synthesize a <code>Module ℤ ℤ</code> instance? (before the solution, it picks <code>abGrpModule ℤ</code> arbitrarily)</p>",
        "id": 482786353,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731776822
    },
    {
        "content": "<p>Do you know about the difference between <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2024/Part_B/equality.html\">syntactic, definitional and propositional equality</a>? What we do _not_ want to happen in mathlib is that typeclass inference makes random selections depending on exactly how various questions were asked, and you end up with <code>rw [h]</code> failing when <code>h : 1 • a = a</code> and the goal has <code>1 • a</code> in, but the rewrite fails with an obscure error message because it turned out that the two <code>1 • a</code>s are <em>equal</em>, but <em>the proof isn't <code>rfl</code></em>. The issue is that <code>rw</code> works up to syntactic equality. What the chapter is explaining is that if you ensure that all routes that the typeclass inference system finds back to <code>smul</code> give exactly the same answer (not just answers that we can prove are the same, but answers which are exactly the same) then this problem does not arise. So the answer to the last question you asked is \"it doesn't matter, because all attempts to do this give equal answers, for a very strong notion of equality\".</p>",
        "id": 482789423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731779543
    },
    {
        "content": "<p>Thanks! I understand that. What I don't seem to get is how adding AddMonoid_4 would help since why would having an additional class having any effect on the existing things?</p>",
        "id": 482792088,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731781928
    },
    {
        "content": "<p>I agree that this is explained in a bit of a confusing manner. I think the precise answer to your question is \"it doesn't\". But the text says \"This story then continues with incorporating a <code>zsmul</code> field into the definition of groups and similar tricks.\" and once this field is also there, you can override the Z-action on Z.</p>",
        "id": 482794943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1731784477
    },
    {
        "content": "<p>Correct me if I'm wrong, this means that the provided \"solution\" is not yet complete. What one should do is to </p>\n<ul>\n<li>add the <code>zsmul</code> field to <code>AddMonoid₄</code> (defined based on the field <code>nsmul</code> also in there),  </li>\n<li>\n<ul>\n<li>create an <code>AddCommGroup₄</code> class (requiring creating <code>AddGroup₄</code> class and <code>AddCommMonoid₄</code> class based on this <code>AddMonoid₄</code>),  and </li>\n</ul>\n</li>\n<li>define a new <code>abGrpModule</code> instance of <code>Module₁ ℤ A</code> based on this new <code>AddCommGroup₄</code>?<br>\nEdit: maybe at the last step, you need to modify <code>Module₁</code> class itself to rely on <code>AddCommGroup₄</code></li>\n</ul>",
        "id": 482805814,
        "sender_full_name": "The-Anh Vu-Le",
        "timestamp": 1731794587
    }
]