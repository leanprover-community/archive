[
    {
        "content": "<p>I have a minimal recreation of what I need to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">→</span><span class=\"n\">Test</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Test</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>But I get the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"kn\">mutual</span><span class=\"w\"> </span><span class=\"n\">block</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">either</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">elements</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">block</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">/</span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">declarations</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">they</span><span class=\"w\"> </span><span class=\"n\">must</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"bp\">/</span><span class=\"n\">theorems</span><span class=\"bp\">/</span><span class=\"n\">abbrevs</span>\n</code></pre></div>\n<p>How would I be able to mutually define a recursive type and function at the same time? They really cant be separated, and <code>f</code> is a recursive function so I don't think I could rewrite it inside <code>Test.mk</code>.</p>",
        "id": 535184965,
        "sender_full_name": "Op From The Start",
        "timestamp": 1755629009
    },
    {
        "content": "<p>I don't think Lean supports this kind of inductive-recursive definition</p>",
        "id": 535185079,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755629063
    },
    {
        "content": "<p>Do you know if there is another proof language that would support this?</p>",
        "id": 535185259,
        "sender_full_name": "Op From The Start",
        "timestamp": 1755629124
    },
    {
        "content": "<p>Can I ask what exactly you're trying to express?</p>",
        "id": 535185306,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755629149
    },
    {
        "content": "<p>you might be able to get away with a subtype</p>",
        "id": 535185382,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755629179
    },
    {
        "content": "<p>The surreal numbers.<br>\nI tried a method by omitting the predicate and then trying to add it back in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">PreNo</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">→</span><span class=\"n\">PreNo</span><span class=\"o\">)</span><span class=\"bp\">→</span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"bp\">→</span><span class=\"n\">PreNo</span><span class=\"o\">)</span><span class=\"bp\">→</span><span class=\"n\">PreNo</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">No</span>\n<span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PreNo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rightm</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">leftm</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">No</span>\n</code></pre></div>\n<p>But then I don't have left and right sets of <code>No</code>, I have left and right sets of <code>PreNo</code>.</p>",
        "id": 535185595,
        "sender_full_name": "Op From The Start",
        "timestamp": 1755629296
    },
    {
        "content": "<p>Maybe you can take a look at how they were defined in the CGT repo:<br>\n<a href=\"https://github.com/vihdzp/combinatorial-games/blob/9101d97e2bf29ad1e448b3651bd44f11eddee471/CombinatorialGames/Surreal/Basic.lean#L294-L297\">link</a></p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The type of surreal numbers. These are the numeric games quotiented by the antisymmetrization</span>\n<span class=\"sd\">relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient, the order becomes a total order. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Surreal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Antisymmetrization</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"w\"> </span><span class=\"n\">Numeric</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 535186126,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755629546
    }
]