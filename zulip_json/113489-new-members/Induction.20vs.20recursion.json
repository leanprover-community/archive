[
    {
        "content": "<p>I'm still struggling to get my head around how to perform proofs by induction, sadly. I've defined the set {0..n} and am trying to prove that it's an interval in N. In Agda this is extremely easy because I can perform recursive calls, but in Lean I haven't yet been able to find a proof of the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">range</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- but the inductive hypothesis doesn&#39;t apply!</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span>\n  <span class=\"n\">cc</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>In Agda, this is very easy; you just let it normalise your definitions, and whenever it gets stuck, you pattern-match on whatever it's stuck on, and eventually it bottoms out at a single lemma \"n is in {0..n}\" and a recursive call to <code>range_closed</code>; I can define the entire thing in 92 lines with no standard library and no thought required (<a href=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\" title=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\">https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a</a>, actual content is lines 69 through 92), though admittedly my definition of \"finite set\" leaves much to be desired.</p>\n<p>Presumably it is similarly easy in Lean, but it doesn't match my intuition at all. I know in theory there's a way to replace my desired recursive call with an appeal to an appropriately-constructed inductive hypothesis, and I can probably find the general method if I think hard for an hour, but what's stopping Lean from doing these structurally-decreasing recursive calls itself?</p>",
        "id": 196985536,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589021459
    }
]