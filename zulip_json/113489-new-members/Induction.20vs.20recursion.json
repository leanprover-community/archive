[
    {
        "content": "<p>I'm still struggling to get my head around how to perform proofs by induction, sadly. I've defined the set {0..n} and am trying to prove that it's an interval in N. In Agda this is extremely easy because I can perform recursive calls, but in Lean I haven't yet been able to find a proof of the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">range</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- but the inductive hypothesis doesn&#39;t apply!</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span>\n  <span class=\"n\">cc</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>In Agda, this is very easy; you just let it normalise your definitions, and whenever it gets stuck, you pattern-match on whatever it's stuck on, and eventually it bottoms out at a single lemma \"n is in {0..n}\" and a recursive call to <code>range_closed</code>; I can define the entire thing in 92 lines with no standard library and no thought required (<a href=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\" title=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\">https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a</a>, actual content is lines 69 through 92), though admittedly my definition of \"finite set\" leaves much to be desired.</p>\n<p>Presumably it is similarly easy in Lean, but it doesn't match my intuition at all. I know in theory there's a way to replace my desired recursive call with an appeal to an appropriately-constructed inductive hypothesis, and I can probably find the general method if I think hard for an hour, but what's stopping Lean from doing these structurally-decreasing recursive calls itself?</p>",
        "id": 196985536,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589021459
    },
    {
        "content": "<p>can you give some hint about Agda <code>with</code>?</p>",
        "id": 196986657,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023128
    },
    {
        "content": "<p>Is this <code>match ... with ...</code>?</p>",
        "id": 196986670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023161
    },
    {
        "content": "<p>Everything in your Agda code was easy to read until the last definition, where things got really weird. Maybe this is related to your problem <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 196986678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023188
    },
    {
        "content": "<p>What happened to <code>range_contains</code>?</p>",
        "id": 196986998,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023619
    },
    {
        "content": "<p>I assume <code>record {}</code> is the proof of <code>True</code>?</p>",
        "id": 196987085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023770
    },
    {
        "content": "<p>Things are obviously going to be somewhat harder because the definition of <code>contains</code> for an actual finite set won't compute the way it does in your code, I think</p>",
        "id": 196987144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023827
    },
    {
        "content": "<p>Or much harder</p>",
        "id": 196987430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024220
    },
    {
        "content": "<p>I thought for a while your Agda proof was not correct.</p>",
        "id": 196987435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024228
    },
    {
        "content": "<p>The more I read it, the less I understand...</p>",
        "id": 196987495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024311
    },
    {
        "content": "<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>",
        "id": 196987587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024452
    },
    {
        "content": "<p>Anyways, the tactic proof can be repaired by starting with</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"n\">generalizing</span> <span class=\"n\">a</span> <span class=\"n\">aIn</span> <span class=\"n\">v</span> <span class=\"n\">vLess</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>(<code>with n IH</code> just gives better names to the new variables)</p>",
        "id": 196987907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024896
    },
    {
        "content": "<p><code>generalizing ...</code> means basically <code>revert</code> all the variables, apply <code>induction</code>, then re-<code>intros</code> them in all the cases. That way you get an induction hypothesis that can be applied to any <code>a</code>, ....</p>",
        "id": 196987935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024963
    },
    {
        "content": "<p>Also, I guess as a high-level comment, surely it's better strategy to just prove that <code>a ∈ range n</code> is equivalent to <code>a &lt;= n</code> first, rather than embark on an inductive proof of this statement that involves three variables directly</p>",
        "id": 196988189,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\">said</a>:</p>\n<blockquote>\n<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>\n</blockquote>\n<p>Aren't <code>n</code>, <code>a</code> and <code>v</code> all <code>0</code> at that point?</p>",
        "id": 196988308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589025437
    },
    {
        "content": "<p>it might be my inability to read this syntax, but I thought that line 84 is the counterpart to line 82, depending on the outcome of a=0</p>",
        "id": 196988442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025644
    },
    {
        "content": "<p>I think the structure is:</p>\n<ul>\n<li>split on a = 0 (not by pattern matching but with the <code>ℕDecideEquality</code> thing--but somehow Agda also decides that <code>a=0</code>, maybe this is what I missed later)<ul>\n<li>when <code>a=0</code>, split on the proof of <code>v&lt;=a</code></li>\n<li>when <code>a!=0</code>, split on <code>ℕDecideEquality v 0</code></li>\n</ul>\n</li>\n</ul>",
        "id": 196988585,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025844
    },
    {
        "content": "<p>Well, this is the <code>n=0</code> case</p>",
        "id": 196988603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025906
    },
    {
        "content": "<p>Like I think the <code>...</code> on line 85 corresponds to the <code>... | inr a!=0</code> on line 84, otherwise I can't make sense of it</p>",
        "id": 196988616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025947
    },
    {
        "content": "<p>I get this for the translation of 79-86 to lean syntax</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">rangeClosed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">contains</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">contains</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"n\">a</span> <span class=\"n\">cont</span> <span class=\"n\">v</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"n\">a</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">v</span><span class=\"bp\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">inl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">exFalso</span> <span class=\"o\">(</span><span class=\"n\">notLessZero</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"bp\">ℕ</span><span class=\"n\">DecideEquality</span> <span class=\"n\">v</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">cont</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cont</span>\n    <span class=\"kn\">end</span>\n  <span class=\"kn\">end</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 196988795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026275
    },
    {
        "content": "<p>Does it work?</p>",
        "id": 196988959,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026495
    },
    {
        "content": "<p>Or did you manage to type all this without feedback from lean?</p>",
        "id": 196988966,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026528
    },
    {
        "content": "<p>The only way I can imagine <code>cont : contains ℕDecideEquality (range n) a</code> has type <code>contains ℕDecideEquality (range n) v</code> here is that Agda actually decided this case is impossible</p>",
        "id": 196989020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026600
    },
    {
        "content": "<p>or I guess that it reduced both of these types to <code>False</code>... that is more plausible</p>",
        "id": 196989029,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026628
    },
    {
        "content": "<p>No feedback</p>",
        "id": 196989038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026647
    },
    {
        "content": "<p>I still don't understand how it could do that though</p>",
        "id": 196989041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026652
    },
    {
        "content": "<p>I'm working on a compiling version</p>",
        "id": 196989046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026676
    },
    {
        "content": "<p>but the lean definitions are different in a few places, unless I replicate the whole definition from nothing as was done in the original</p>",
        "id": 196989097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026710
    },
    {
        "content": "<p>I guess I don't know how matching on <code>ℕDecideEquality a 0</code> actually works. It seems like for the Agda code to work, it needs to have already unfolded the definition of the type of <code>cont</code> to see that it contains <code>ℕDecideEquality a 0</code>, so that it can be replaced by a constructor in the branches</p>",
        "id": 196989169,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026855
    },
    {
        "content": "<p>I'm pretty sure that it's just like <code>obtain rfl | h := decidable.em (a = 0)</code></p>",
        "id": 196989186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589026912
    },
    {
        "content": "<p>But in that case, in your Lean translation, <code>    | a, cont, v, h, inr (h₂ : v ≠ 0) := cont</code> is clearly a type error right?</p>",
        "id": 196989258,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589026991
    },
    {
        "content": "<p>Oh, actually it might not be, if that's simultaneously matching on the <code>ℕDecideEquality a 0</code> inside the definition of <code>contains</code></p>",
        "id": 196989311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027060
    },
    {
        "content": "<p>in lean you would have to <code>unfold contains</code> first</p>",
        "id": 196989318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027076
    },
    {
        "content": "<p>I think that must be what is happening but I don't know how Agda knows to do that</p>",
        "id": 196989319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589027085
    },
    {
        "content": "<p>I mean it cannot unfold everything in scope as far as possible before matching on anything, right? Or can it?</p>",
        "id": 196989344,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589027132
    },
    {
        "content": "<p>\"The user said it typechecks, so by golly I'll make it typecheck\"</p>",
        "id": 196989393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589027172
    },
    {
        "content": "<p>Here is how I might prove the original lemma:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_iff</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">of_le_succ</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_of_le</span> <span class=\"n\">le_of_eq</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mem_range_iff_le</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">range</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">range</span><span class=\"o\">,</span> <span class=\"n\">IH</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">le_succ_iff</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_range_iff_le</span> <span class=\"n\">at</span> <span class=\"err\">⊢</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"n\">vLess</span> <span class=\"n\">aIn</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 196990462,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589028874
    },
    {
        "content": "<p>obviously I relied a bit on the standard library, but not heavily</p>",
        "id": 196990467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589028888
    },
    {
        "content": "<p>I don't mind the use or not of the standard library - I'm not trying to whinge or anything, and the point wasn't \"oh look I've been coding for two years in Agda after spending months getting used to it, why am I finding Lean less intuitive waaaah\"</p>",
        "id": 196992350,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589031934
    },
    {
        "content": "<p>I'm aware that Agda, like all theorem proving environments, is completely unreadable :P Agda by default automatically unfolds everything as far as possible before presenting it to you, although you don't have to fill \"unfolded\" holes with \"unfolded\" terms - you can fill a hole that Agda is showing to you as fully unfolded, using a nice compact term</p>",
        "id": 196992515,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589032180
    },
    {
        "content": "<p>Well, I don't totally agree with the first statement. I think the proof I wrote above is a lot easier to understand, even putting concrete syntax aside--simply because it follows the correct conceptual strategy for a human</p>",
        "id": 196992575,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032226
    },
    {
        "content": "<p>I believe you when you say your proof was easy to write without thinking (I know the Agda emacs mode has some fancy auto refine/hole filling stuff), but it resulted in something quite difficult to understand</p>",
        "id": 196992592,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032260
    },
    {
        "content": "<p>It goes to show that machines producing proofs that humans cannot understand is not some science fiction thing.</p>",
        "id": 196992603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589032288
    },
    {
        "content": "<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>",
        "id": 196992952,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589032812
    },
    {
        "content": "<p>Honestly I struggle to see that there's anything to prove here at all - I wouldn't say there's a \"correct strategy for a human\" beyond saying \"induction, the rest is trivial\", so I don't feel particularly moved by \"it follows the correct conceptual strategy for a human\". It may very well be that Lean makes for better-structured proofs on actual real problems, but then to me the structure of a formally-checked proof is dictated more by the lemmas which are chained together than by the internal structure of any particular theorem's proof. Possibly that's just my Agda heritage talking.</p>",
        "id": 196993054,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033040
    },
    {
        "content": "<p>But my Agda proof has a structure that is fairly clear when you get past the syntax: \"induct on n; clear the base case. Check if v = n; if so, we're done straight away. If not, induct down, although booo fiddly edge case if a = n already.\"</p>",
        "id": 196993158,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589033158
    },
    {
        "content": "<p>I disagree rather thoroughly with all this, but I'm not sure there is anything constructive to say. It looks like \"alien mathematics\" again.</p>",
        "id": 196993220,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589033242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196992952\">said</a>:</p>\n<blockquote>\n<p>(Random aside: can it really be true that <code>le_total</code> has the most useful type signature? Surely, surely <code>a &lt;= b</code> or <code>b &lt; a</code> is a more useful phrasing?)</p>\n</blockquote>\n<p>All of the variations on these statements exist: <code>le_or_lt</code>, <code>lt_or_le</code>, <code>lt_trichotomy</code>, etc</p>",
        "id": 196993223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033248
    },
    {
        "content": "<p>I think I see where you are speaking from, it reminds me of how most list lemmas are proven. But once you have a decent nontrivial equality relation it becomes easier to prove things by <code>rw</code> and <code>simp</code> instead rather than using induction for everything</p>",
        "id": 196993314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589033385
    }
]