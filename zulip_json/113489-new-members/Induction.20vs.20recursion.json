[
    {
        "content": "<p>I'm still struggling to get my head around how to perform proofs by induction, sadly. I've defined the set {0..n} and am trying to prove that it's an interval in N. In Agda this is extremely easy because I can perform recursive calls, but in Lean I haven't yet been able to find a proof of the following:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">range</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">insert</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">range_closed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aIn</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vLess</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">range</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">aIn</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- but the inductive hypothesis doesn&#39;t apply!</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">right</span><span class=\"o\">,</span>\n  <span class=\"n\">cc</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>In Agda, this is very easy; you just let it normalise your definitions, and whenever it gets stuck, you pattern-match on whatever it's stuck on, and eventually it bottoms out at a single lemma \"n is in {0..n}\" and a recursive call to <code>range_closed</code>; I can define the entire thing in 92 lines with no standard library and no thought required (<a href=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\" title=\"https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a\">https://gist.github.com/Smaug123/b5b2407176328756189d5f5e8918f03a</a>, actual content is lines 69 through 92), though admittedly my definition of \"finite set\" leaves much to be desired.</p>\n<p>Presumably it is similarly easy in Lean, but it doesn't match my intuition at all. I know in theory there's a way to replace my desired recursive call with an appeal to an appropriately-constructed inductive hypothesis, and I can probably find the general method if I think hard for an hour, but what's stopping Lean from doing these structurally-decreasing recursive calls itself?</p>",
        "id": 196985536,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589021459
    },
    {
        "content": "<p>can you give some hint about Agda <code>with</code>?</p>",
        "id": 196986657,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023128
    },
    {
        "content": "<p>Is this <code>match ... with ...</code>?</p>",
        "id": 196986670,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023161
    },
    {
        "content": "<p>Everything in your Agda code was easy to read until the last definition, where things got really weird. Maybe this is related to your problem <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 196986678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023188
    },
    {
        "content": "<p>What happened to <code>range_contains</code>?</p>",
        "id": 196986998,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023619
    },
    {
        "content": "<p>I assume <code>record {}</code> is the proof of <code>True</code>?</p>",
        "id": 196987085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023770
    },
    {
        "content": "<p>Things are obviously going to be somewhat harder because the definition of <code>contains</code> for an actual finite set won't compute the way it does in your code, I think</p>",
        "id": 196987144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589023827
    },
    {
        "content": "<p>Or much harder</p>",
        "id": 196987430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024220
    },
    {
        "content": "<p>I thought for a while your Agda proof was not correct.</p>",
        "id": 196987435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024228
    },
    {
        "content": "<p>The more I read it, the less I understand...</p>",
        "id": 196987495,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024311
    },
    {
        "content": "<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>",
        "id": 196987587,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024452
    },
    {
        "content": "<p>Anyways, the tactic proof can be repaired by starting with</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"n\">generalizing</span> <span class=\"n\">a</span> <span class=\"n\">aIn</span> <span class=\"n\">v</span> <span class=\"n\">vLess</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>(<code>with n IH</code> just gives better names to the new variables)</p>",
        "id": 196987907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024896
    },
    {
        "content": "<p><code>generalizing ...</code> means basically <code>revert</code> all the variables, apply <code>induction</code>, then re-<code>intros</code> them in all the cases. That way you get an induction hypothesis that can be applied to any <code>a</code>, ....</p>",
        "id": 196987935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589024963
    },
    {
        "content": "<p>Also, I guess as a high-level comment, surely it's better strategy to just prove that <code>a ∈ range n</code> is equivalent to <code>a &lt;= n</code> first, rather than embark on an inductive proof of this statement that involves three variables directly</p>",
        "id": 196988189,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\" title=\"#narrow/stream/113489-new-members/topic/Induction.20vs.20recursion/near/196987587\">said</a>:</p>\n<blockquote>\n<p>On line 86, we know <code>n</code> is <code>0</code>, <code>a</code> is not <code>0</code>, <code>v</code> is not <code>0</code>. How can we use <code>cont</code> as the proof?</p>\n</blockquote>\n<p>Aren't <code>n</code>, <code>a</code> and <code>v</code> all <code>0</code> at that point?</p>",
        "id": 196988308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589025437
    },
    {
        "content": "<p>it might be my inability to read this syntax, but I thought that line 84 is the counterpart to line 82, depending on the outcome of a=0</p>",
        "id": 196988442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025644
    },
    {
        "content": "<p>I think the structure is:</p>\n<ul>\n<li>split on a = 0 (not by pattern matching but with the <code>ℕDecideEquality</code> thing--but somehow Agda also decides that <code>a=0</code>, maybe this is what I missed later)<ul>\n<li>when <code>a=0</code>, split on the proof of <code>v&lt;=a</code></li>\n<li>when <code>a!=0</code>, split on <code>ℕDecideEquality v 0</code></li>\n</ul>\n</li>\n</ul>",
        "id": 196988585,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025844
    },
    {
        "content": "<p>Well, this is the <code>n=0</code> case</p>",
        "id": 196988603,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025906
    },
    {
        "content": "<p>Like I think the <code>...</code> on line 85 corresponds to the <code>... | inr a!=0</code> on line 84, otherwise I can't make sense of it</p>",
        "id": 196988616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589025947
    }
]