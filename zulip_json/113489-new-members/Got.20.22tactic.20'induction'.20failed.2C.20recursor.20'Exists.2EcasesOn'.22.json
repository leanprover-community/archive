[
    {
        "content": "<p>Hi all, I thought I can directly prove <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Classical.html#Classical.axiomOfChoice\">axiom of choice</a> within lean's type system (which is obviously not the case). <a href=\"https://live.lean-lang.org/#code=theorem%20axiom_of_choice%20%7B%CE%B1%20%3A%20Sort%20u%7D%20%7B%CE%B2%20%3A%20%CE%B1%20%E2%86%92%20Sort%20v%7D%20%7Br%20%3A%20(x%20%3A%20%CE%B1)%20%E2%86%92%20%CE%B2%20x%20%E2%86%92%20Prop%7D%0A%20%20(h%20%3A%20%E2%88%80%20(x%20%3A%20%CE%B1)%2C%20%E2%88%83%20(y%20%3A%20%CE%B2%20x)%2C%20r%20x%20y)%20%3A%0A%20%20%E2%88%83%20(f%20%3A%20(x%20%3A%20%CE%B1)%20%E2%86%92%20%CE%B2%20x)%2C%20%E2%88%80%20(x%20%3A%20%CE%B1)%2C%20r%20x%20(f%20x)%20%3A%3D%20by%0A%20%20let%20g%3A%20(x%20%3A%20%CE%B1)%20%E2%86%92%20%CE%B2%20x%20%3A%3D%20fun%20x%20%E2%86%A6%20by%0A%20%20%20%20let%20%E2%9F%A8y%2C%20rxy%E2%9F%A9%20%3A%3D%20h%20x%0A%0Atheorem%20thm%20%7B%CE%B1%20%3A%20Sort%20u%7D%20%7B%CE%B2%20%3A%20%CE%B1%20%E2%86%92%20Sort%20v%7D%20%7Br%20%3A%20(x%20%3A%20%CE%B1)%20%E2%86%92%20%CE%B2%20x%20%E2%86%92%20Prop%7D%0A%20%20(h%20%3A%20%E2%88%80%20(x%20%3A%20%CE%B1)%2C%20%E2%88%83%20(y%20%3A%20%CE%B2%20x)%2C%20r%20x%20y)%20(x%20%3A%20%CE%B1)%20%3A%0A%20%20%E2%88%83%20(y%20%3A%20%CE%B2%20x)%2C%20r%20x%20y%20%3A%3D%20by%0A%20%20let%20%E2%9F%A8y%2C%20rxy%E2%9F%A9%20%3A%3D%20h%20x%0A%20%20exact%20%E2%9F%A8y%2C%20rxy%E2%9F%A9%0A%0A%0A\">Here was my attempt</a>. Given the condition <code>h: ∃ (y : β x), r x y)</code> I was trying to define a function <code>f</code> and use <code>let ⟨y, rxy⟩ := h</code> inside the function to get an instance of <code>y</code>. But then I got the following error :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">recursor</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn'</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">eliminate</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I guess there is some restriction that prevent me from destructing <code>∃</code> inside a plain function (which is kind of surprising to me because I thought every theorem is also a function).</p>\n<p>My question: What exactly is this restriction that prevented me from doing so? Is it completely done with Lean's type system? Or is it some additional rule?</p>",
        "id": 465914460,
        "sender_full_name": "James",
        "timestamp": 1724911281
    },
    {
        "content": "<p>You need to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a> which is exactly AC in this case again</p>",
        "id": 465916048,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724911923
    },
    {
        "content": "<p>The concept that prevents you from extracting from a Prop to a Type of related to that's known as \"large elimination\"</p>",
        "id": 465917160,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1724912280
    },
    {
        "content": "<p>When you try to destructure a value you're actually using a recursor on it. In this case that's <code>Exists.casesOn</code> which has the following signature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>Notice how its <code>motive</code> has type <code>Exists p → Prop</code>. </p>\n<p>The way the desugaring is done makes it so that <code>motive</code> must be chosen so that the value you ultimately want to produce will have type <code>motive h</code> (where <code>h</code> was your <code>h: ∃ (y : β x), r x y)</code>). But <code>motive h</code> must live in <code>Prop</code>, so effectively you can only destructure <code>∃</code> in a scope that produces a value of a type that is <code>Prop</code>. This has nothing to do with whether you are in a \"normal function\" or a theorem, though a theorem does additionally force you to produce a value of a type that is <code>Prop</code> anyway.</p>",
        "id": 465931919,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1724917070
    }
]