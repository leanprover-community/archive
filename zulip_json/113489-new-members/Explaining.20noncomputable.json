[
    {
        "content": "<p>I noticed that a couple of Lean defs have the tag noncomputable, and recently Lean has given me a warning that my def needs the noncomputable tag because it depends on a noncomputable def. Can you explain what is meant by noncomputable? I noticed, for example, real.has_pow is noncomputable. Is that because Lean can't calculate the expression like e^e the same as it could calculate 2^2 = 4?</p>",
        "id": 289351223,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1657643536
    },
    {
        "content": "<p>It means that it is not computable even if in principle, for example because something depends on the axiom of choice</p>",
        "id": 289351468,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657643661
    },
    {
        "content": "<p>The definition of real numbers as equivalence classes of something for example is not computable (I think)</p>",
        "id": 289351532,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657643700
    },
    {
        "content": "<p>What does \"calculate the expression e^e\" mean?</p>",
        "id": 289351546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657643706
    },
    {
        "content": "<p>So there is no algorithm to say if s given real number is equal to zero</p>",
        "id": 289351574,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657643724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Explaining.20noncomputable/near/289351546\">said</a>:</p>\n<blockquote>\n<p>What does \"calculate the expression e^e\" mean?</p>\n</blockquote>\n<p>I meant, as an example, you can say in Lean</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>but there is no way of saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">real.exp</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">real.exp</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 289351773,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1657643815
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/real.has_pow\">docs#real.has_pow</a></p>",
        "id": 289351829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657643843
    },
    {
        "content": "<p>Apparently it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.cpow\">docs#complex.cpow</a> (which underlies <a href=\"https://leanprover-community.github.io/mathlib_docs/find/real.has_pow\">docs#real.has_pow</a>) that invokes decidability of equality.</p>",
        "id": 289351903,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657643875
    },
    {
        "content": "<p>I guess you can see that it must be noncomputable because 0^0=1 and 0^y=0 if y isn't 0, so the even the function 0^x isn't computable.</p>",
        "id": 289352108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1657643941
    },
    {
        "content": "<p>The difference is that in <code>2+2 = 4</code> (as natural numbers) you can unfold everything and then you see that both sides become <code>succ succ succ succ 0</code>. For reals you can not just do that. <code>norm_num</code> is a smart tactic, so sometimes it can prove stuff even if they're not computable I think (using <code>simp</code>)</p>",
        "id": 289352592,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644124
    },
    {
        "content": "<p>But <code>2+2=4</code> can be also proved by <code>refl</code>, unfolding the definitions</p>",
        "id": 289352700,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644175
    },
    {
        "content": "<p>Yea, I was running into problems where norm_num just returned false, which made sense due to the type casting. Does noncomputable make the math any different, or is it more just a tag that Lean needs?</p>",
        "id": 289352709,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1657644178
    },
    {
        "content": "<p>If you add <code>noncomputable theory </code>at the beginning the math becomes more \"standard\"</p>",
        "id": 289352815,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644238
    },
    {
        "content": "<p>Ok, I will give that a try, thank you!</p>",
        "id": 289353001,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1657644326
    },
    {
        "content": "<p><code>noncomputable</code> is a way that Lean keeps track of which definitions should be compiled (by the VM compiler) into a more efficient representation (for the VM). You should more or less only care about whether or not a definition is <code>noncomputable</code> if you care about evaluating it using <code>#eval</code> or evaluating it from within the implementation of some tactic.</p>",
        "id": 289353047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644353
    },
    {
        "content": "<p>In mathlib it's useful to try to be computable when possibile to prove stupid stuff. For example I once spent literally hours proving that the finite set <code>{1, 3, 5, 15}</code> has four elements and then someone told me <code>refl</code> can do it. It can because everything is computable so we can say to Lean \"just look\"</p>",
        "id": 289353105,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> That example's not the same kind of computability as what <code>noncomputable</code> is about</p>",
        "id": 289353172,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644397
    },
    {
        "content": "<p>Ops, I am sorry</p>",
        "id": 289353282,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644440
    },
    {
        "content": "<p>There are at least three ways Lean can compute something, I think. One is the elaborator doing expression reduction (which honors things like the <code>reducible</code>/<code>semireducible</code>/<code>irreducible</code> attributes), another is the Lean kernel itself doing expression reduction (which doesn't honor these -- everything is essentially <code>reducible</code> I believe), and the third is the VM after VM compilation (which is not guaranteed to evaluate things correctly, but it sure tries)</p>",
        "id": 289353442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644498
    },
    {
        "content": "<p>Oh sure, this about decidability! I must be still jetlagged</p>",
        "id": 289353502,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644530
    },
    {
        "content": "<p>(My understanding is that the original Lean evaluator was just the expression reducer, and <code>noncomputable</code> was used to keep track of which definitions could actually reduce all the way. From what I remember, one of the reasons for the VM besides speed is that it gets around the fact that <code>eq.rec</code> terms don't always reduce.)</p>",
        "id": 289353805,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"474115\">@Max Bobbin</span> in any case you can safely ignore this warning if you want to do standard mathematics</p>",
        "id": 289353942,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657644758
    },
    {
        "content": "<p>Oh right, and a fourth type of \"evaluation\" is <code>decidable</code> via <code>dec_trivial</code>, where you use the typeclass system to search for a proof using whatever instances happen to lie around.</p>",
        "id": 289354009,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644789
    },
    {
        "content": "<p>Ok, cool. Thank you. This is helpful, I think my problems are more type casting related then. I just wanted to make sure noncomputable wasn't the problem</p>",
        "id": 289354025,
        "sender_full_name": "Max Bobbin",
        "timestamp": 1657644797
    },
    {
        "content": "<p>I guess a fifth type is <code>norm_num</code> (and <code>simp</code>) which pretty much doesn't care about whether something is <code>noncomputable</code> since it just operates on the terms themselves and applies rules (\"<code>norm_num</code> plugins\"). It evaluates terms more in the Mathematica or Sage sense, symbolically.</p>",
        "id": 289354289,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657644921
    },
    {
        "content": "<p>Is there a reason why I could want some of my definitions to be computable? I cannot come up with an example (within the context of proving theorems) where that could be useful.</p>",
        "id": 463238268,
        "sender_full_name": "jsodd",
        "timestamp": 1724013763
    },
    {
        "content": "<p>Some possible reasons:</p>\n<ul>\n<li>You want to be able to quickly evaluate the definition with <code>#eval</code> to check it on small examples, without having to  build a large library of lemmas first</li>\n<li>You actually want to write a program using the operations you just proved were correct (and perhaps don't care about their efficiency)</li>\n<li>You don't actually care about \"computability\", but the correlated concept of \"kernel-reducibility\". If your definition is kernel-reducible, then the <code>decide</code> tactic can often prove things about it for you.</li>\n</ul>",
        "id": 463238754,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724013985
    },
    {
        "content": "<p><code>noncomputable</code> can serve as a proxy for \"will this fail to be kernel reducible\", but that's not what it's for, and there are both false positives and false negatives with that.</p>",
        "id": 463238940,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724014141
    },
    {
        "content": "<p>What do you mean by fail to be kernel reducible? Fail to reduce to a canonical term?</p>",
        "id": 463238984,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1724014181
    },
    {
        "content": "<p>A nice example of that is <code>Nat.sqrt</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\">  </span><span class=\"c1\">-- true (computable)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds (kernel-reducible)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"c1\">-- true (computable)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- fails (not kernel-reducible)</span>\n</code></pre></div>",
        "id": 463239287,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724014326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, can you construct the converse: something non-computable but kernel-reducible?</p>",
        "id": 463239468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724014434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> One example is <code>Eq.rec</code> that depends on reducing types (pops up frequently from people defining Decidable instances using <code>rw</code>). It's perfectly fine as a computable algorithm, but fails to reduce.</p>",
        "id": 463240083,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724014593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I was thinking about for example having a <code>let</code> with a noncomputable value that's only used inside a proof, but here's another example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"c1\">-- 0</span>\n</code></pre></div>",
        "id": 463240682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724014761
    },
    {
        "content": "<p>Are computability and decidability the same thing?</p>",
        "id": 463241117,
        "sender_full_name": "jsodd",
        "timestamp": 1724014864
    },
    {
        "content": "<p><code>instance : Decidable P</code> is a way of providing an algorithm to decide <code>P</code>, but nothing forces the algorithm you provide to be computable (if not, <code>#eval</code> fails) or kernel-reducible (if not, <code>decide</code> fails)</p>",
        "id": 463241401,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724014933
    },
    {
        "content": "<p>No <span class=\"user-mention\" data-user-id=\"743246\">@jsodd</span>. Computability in the <code>noncomputable</code> sense is just whether the compiler is able to take your definition and translate it to C. <code>Decidable</code> is a framework for lifting individual terms of <code>Prop</code> to <code>Bool</code>.</p>",
        "id": 463241557,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724014984
    },
    {
        "content": "<p>They're related in that, hopefully, these <code>Bool</code> computations are computable in both the kernel reducibility and the <code>noncomputable</code> sense to support both <code>decide</code> and anyone who wants to use the proposition in <code>if</code> statements in programs. (And it's not actually <code>Bool</code>, but some proof-carrying version of <code>Bool</code>, but that's just a detail)</p>",
        "id": 463241872,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724015069
    },
    {
        "content": "<p>So computability implies decidability, while for noncomputable we either prove decidability somehow or go classical?</p>",
        "id": 463241941,
        "sender_full_name": "jsodd",
        "timestamp": 1724015105
    },
    {
        "content": "<p>It doesn't make sense to say computability implies decidability on the face of it. A particular expression describing a natural number can be turned into a computer program or not, but in what sense is a natural number decidable?</p>",
        "id": 463242044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724015202
    },
    {
        "content": "<p>Understood. But if we only speak of <code>Prop</code>? Then both concepts make sense, right?</p>",
        "id": 463242147,
        "sender_full_name": "jsodd",
        "timestamp": 1724015291
    },
    {
        "content": "<p>A <code>Prop</code> is always computable, because it has no runtime representation</p>",
        "id": 463242183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724015327
    },
    {
        "content": "<p>The computable operation is the conversion to <code>Boo1</code>, but that's not a <code>Prop</code> any more!</p>",
        "id": 463242220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724015353
    },
    {
        "content": "<p>A proposition is decidable if there is a computable <code>Bool</code>-valued algorithm that evaluates to or reduces to <code>true</code> iff the proposition is true. It's not the proposition itself that's computable, but this auxiliary algorithm.</p>",
        "id": 463242322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724015446
    },
    {
        "content": "<p>Without any restrictions on how long this algorithm may run?</p>",
        "id": 463242405,
        "sender_full_name": "jsodd",
        "timestamp": 1724015504
    },
    {
        "content": "<p>I am trying to ask whether I'd need to supplement such algorithm with some kind of proof that it terminates within finite time to make something computable</p>",
        "id": 463242745,
        "sender_full_name": "jsodd",
        "timestamp": 1724015775
    },
    {
        "content": "<p>If you're able to define the function at all in Lean, then it terminates (unless you opt out using <code>partial</code>, but <code>partial</code> definitions are not useful for math). Lots of times the \"equation compiler\" is able to construct the definition for you and fill in the necessary arguments, but sometimes you need a <code>termination_by</code> clause to help it out.</p>",
        "id": 463243223,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724016182
    },
    {
        "content": "<p>This part isn't about <code>noncomputable</code> — there are strong restrictions on what definitions can do to prevent paradoxes. (It ends up preventing you from writing Y combinators for example. You can use it to \"construct\" terms of any type by instead doing an infinite loop.)</p>",
        "id": 463243315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724016261
    },
    {
        "content": "<p>In fact, you're allowed to have \"computable\" functions that never return:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>but you can see that if you remove <code>partial</code> it's rejected.</p>",
        "id": 463243545,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724016478
    },
    {
        "content": "<p>Okay, I understand it better now. Thank you very much! But getting back to my original question, what's the \"guideline\"? It feels as though there's little reason to even try making computable definitions, and the examples above suggest (to me) that the only benefit of keeping things computable (or kernel-reducible) is that sometimes lean can close some goals by computing the thing directly... This is not convincing enough</p>",
        "id": 463244134,
        "sender_full_name": "jsodd",
        "timestamp": 1724016959
    },
    {
        "content": "<p>Anyway, I understand that it all depends on the purposes for which one uses lean. I'm just trying to see what can be gained from computable definitions. If nothing except for direct computational proofs, then I can relax again <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 463244348,
        "sender_full_name": "jsodd",
        "timestamp": 1724017198
    },
    {
        "content": "<p>There are different opinions here, but I think that for most math it's not useful to worry about whether or not your definitions are noncomputable. It often causes difficulties for little (or no?) gain.</p>\n<p>One big project is that for the last 2-3 years we've been switching from <code>Fintype</code> to <code>Finite</code> in a lot of theory in mathlib. The first has computational content, and the second doesn't. It saves needing to worry about properly handling DecidableEq and Fintype instances to avoid eq-but-not-defeq problems.</p>",
        "id": 463245063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724017793
    },
    {
        "content": "<p>Hmm... Should I use <code>Finite</code> then, if I don't care about computations in lean?</p>",
        "id": 463245338,
        "sender_full_name": "jsodd",
        "timestamp": 1724017874
    },
    {
        "content": "<p>Yeah, though there's still some \"impedance mismatch\" when you're working with Finset, since a lot of that is in terms of Fintype.</p>",
        "id": 463245402,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724017903
    },
    {
        "content": "<p>One common example of where ignoring computability often makes things harder is when working with quotients: there is a temptation to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.out#doc\">docs#Quotient.out</a> to pick an arbitrary value under the quotient, and then work with that, but actually it often is less work in the long run to use the computable <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.lift#doc\">docs#Quotient.lift</a>.</p>",
        "id": 463248535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724019142
    },
    {
        "content": "<p>I think that example isn't about computability though, it's that it's \"mathematically wrong\" to use <code>.out</code>, since definitions are cleaner when you don't rely on choosing arbitrary representatives, instead relying on universal properties.</p>",
        "id": 463248847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724019465
    },
    {
        "content": "<p>(Though being able to rely on the reduction rule for <code>.lift</code> is a nice benefit!)</p>",
        "id": 463248896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724019485
    },
    {
        "content": "<p>I mention that example since most early run-ins with computability are around <code>Exists.some</code> and <code>Quotient.out</code>, and as a warning that \"I don't care about computability\" isn't always a sufficient reason to use these.</p>",
        "id": 463249318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724019873
    }
]