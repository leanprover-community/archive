[
    {
        "content": "<p>What tactics are there that would solve the goal to yield the:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">isLt</span>\n</code></pre></div>\n<p>automatically? It's relatively simple now but it took me quite some time to figure out what lemmas and structures to use to get it to work. The typical tactics like <code>linarith</code> or <code>aesop</code> don't seem to fair well at this. Any I'm missing? It seems like fairly trivial proof that it should be automatable. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"bp\">.</span><span class=\"n\">width</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"bp\">.</span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">256</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"n\">UInt256</span><span class=\"bp\">.</span><span class=\"n\">width</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evm_mulmod</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">UInt256</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_trans</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">isLt</span>\n<span class=\"w\">    </span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 479363739,
        "sender_full_name": "Philogy",
        "timestamp": 1730151447
    },
    {
        "content": "<p>Your file isn't a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, <code>UInt256</code> doesn't exist in ordinary Lean</p>",
        "id": 479364626,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730151976
    },
    {
        "content": "<p>(We ask that people give a working example so that we can copy/paste it and try to give a precise answer.)</p>",
        "id": 479364780,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730152068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/Tactic.20for.20solving.20simple.20inequalities.3F/near/479364626\">said</a>:</p>\n<blockquote>\n<p>Your file isn't a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, <code>UInt256</code> doesn't exist in ordinary Lean</p>\n</blockquote>\n<p>The definition of <code>UInt256</code> is in my example?</p>",
        "id": 479364921,
        "sender_full_name": "Philogy",
        "timestamp": 1730152140
    },
    {
        "content": "<p>Oh i oversaw that sorry</p>",
        "id": 479365007,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730152197
    },
    {
        "content": "<p>The only simplification I could think of would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">isLt</span>\n<span class=\"w\">        </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>If you were to stay in the bitvec fragment you could also use bv_decide though that might be a bit of a sledgehammer for such a simple problem</p>",
        "id": 479365331,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730152388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/Tactic.20for.20solving.20simple.20inequalities.3F/near/479365331\">said</a>:</p>\n<blockquote>\n<p>The only simplification I could think of would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">isLt</span>\n<span class=\"w\">        </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>If you were to stay in the bitvec fragment you could also use bv_decide though that might be a bit of a sledgehammer for such a simple problem</p>\n</blockquote>\n<p>Ah thanks, didn't know about the <code>omega</code>, is there a page of tactics like <code>omega</code>, <code>linarith</code>, <code>aesop</code> that help with automating the theorem-proving process?</p>\n<p>Also FYI I found that the following also works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">      </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ne_zero</span>\n<span class=\"w\">        </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 479365762,
        "sender_full_name": "Philogy",
        "timestamp": 1730152623
    },
    {
        "content": "<p>Ah I guess omega also knows about the size of BitVecs mhm</p>",
        "id": 479365804,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730152656
    },
    {
        "content": "<p>there is an ever growing page of built in tactics in the reference manual <a href=\"https://lean-lang.org/doc/reference/latest/\">https://lean-lang.org/doc/reference/latest/</a> but linarith and aesop aren't built in</p>",
        "id": 479365889,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730152693
    },
    {
        "content": "<p>How is that document not linked on the main site?.. I've been going off Lean 3's reference manual this whole time!</p>",
        "id": 479370566,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730154809
    },
    {
        "content": "<p>(It's in a public preview <span class=\"user-mention\" data-user-id=\"767265\">@Alex Mobius</span>: <a href=\"#narrow/channel/113486-announce/topic/Introducing.20the.20Lean.20Language.20Reference/near/478091276\">https://leanprover.zulipchat.com/#narrow/channel/113486-announce/topic/Introducing.20the.20Lean.20Language.20Reference/near/478091276</a>)</p>",
        "id": 479371047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730155002
    }
]