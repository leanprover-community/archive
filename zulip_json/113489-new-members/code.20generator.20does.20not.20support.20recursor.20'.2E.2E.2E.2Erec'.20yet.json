[
    {
        "content": "<p>To better understanding recursors, I wrote the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Weekend</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sunday</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weekend</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">saturday</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Weekend</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Weekend</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">weekend</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"c1\">-- Weekend.rec 0 6 : Weekend → ℕ</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Weekend</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">weekend</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"n\">Weekend</span><span class=\"bp\">.</span><span class=\"n\">saturday</span><span class=\"w\"> </span><span class=\"c1\">-- 6</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Weekend</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">weekend</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"n\">Weekend</span><span class=\"bp\">.</span><span class=\"n\">saturday</span>\n<span class=\"c1\">-- code generator does not support recursor 'Foo.Weekend.rec' yet,</span>\n<span class=\"c1\">-- consider using 'match ... with' and/or structural recursion</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Foo</span>\n</code></pre></div>\n<p>In practice, I certainly will use <code>match ... with</code>.  But I am wondering what the technical reasons are for not (yet) supporting the way <code>f</code> is defined above.</p>",
        "id": 449924137,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720456860
    },
    {
        "content": "<p>The reason is that recursors allow for  surprising performance. If you run e.g. <code>List.rec</code> to e.g. implement <code>isEmpty</code> you will forcibly have to iterate through the entire list. That's because the <code>cons</code> case forcibly requires you to provide the result of applying the function recursively already, even if you don't use it. Note that a simple use def analysis that eliminates this recursive call if it is not required does not suffice here because maybe your <code>cons</code> case contains an if-then-else that only accesses the recursive call in one situation etc. Furthermore you would probably also expect that the recursive call would be only done once instead of multiple times whenever you refer to the recursive result, so simply bubbling the call to its use sites would also not be correct.</p>\n<p>So in summary there is a non trivial transformation required to turn code using recursors into code that probably doesn't have surprising performance characteristcs.</p>",
        "id": 449931346,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720458673
    },
    {
        "content": "<p>You can also consult <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Non-dependent.20recursor\">#lean4 &gt; Non-dependent recursor</a>.</p>",
        "id": 450094149,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720512063
    },
    {
        "content": "<p>Thank you for the pointer. The part about recCompiled being a workaround is something that I still don't quite understand; (i.e. I don't understand why it is a workaround that works.) Could I DM you for insights?</p>",
        "id": 450143250,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720525154
    },
    {
        "content": "<p>Thank you Riccardo. Learning the ropes!</p>",
        "id": 450143923,
        "sender_full_name": "Kajani Kaunda",
        "timestamp": 1720525328
    },
    {
        "content": "<p>Does <code>match ... with</code> make use of <code>.rec</code>?</p>",
        "id": 450183496,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720534154
    },
    {
        "content": "<p>Yes and no, the way that the code generator/logic Schism works is as follows: Lean initially does some pre processing on your <code>def</code> before turning it into something called a <code>PreDefinition</code>. At this point the code is still using <code>match</code> syntax and some other goodies but is already a bit desugared. Then the dataflow splits into two parts:</p>\n<ol>\n<li>One part goes to the code generator, the code generator turns the <code>match</code> into a case split on data that is available at runtime and does the recursive calls directly etc.</li>\n<li>The other part goes into the logic, this is the component you interact with when proving things. This code path turns <code>match</code> into a construct that is based on recursors because recursors are primitive parts of the axioms that Lean operates with. This version is then the one that is actually used in all the proofs, type checking, etc.</li>\n</ol>",
        "id": 450185470,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720534726
    },
    {
        "content": "<p>I'm inclined to say no, but maybe an expert can weigh in.</p>",
        "id": 450185480,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720534734
    },
    {
        "content": "<p>Oh, there you are <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 450185526,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720534752
    },
    {
        "content": "<p>Note that this approach is not necessarily the thing you <em>must</em> do, for example Coq uses a different desugaring of <code>match</code> that has different properties.</p>",
        "id": 450185816,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720534822
    },
    {
        "content": "<p>Interesting. I didn't know I am going down into a rabbit hole.</p>",
        "id": 450186178,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720534936
    },
    {
        "content": "<p>The way I see it is <code>match</code> performs pattern-matching to try and define a function <code>T -&gt; X</code> (or more generally a dependent function <code>(t : T) -&gt; F t</code> for some type family <code>F : T -&gt; Type</code>), while <code>T.rec</code> can be viewed as a function that returns a function from <code>T</code> to <code>X</code> (or more generally a dependent function). In that sense, <code>T.rec</code>. gives you a method that may or may not work to define your function. Pattern-matching can <em>in principle</em> be used to define a function out an inductive type and indeed it is used in the definition of the function returned by <code>T.rec</code>.</p>",
        "id": 450186664,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720535092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/stream/113489-new-members/topic/code.20generator.20does.20not.20support.20recursor.20'.2E.2E.2E.2Erec'.20yet/near/450143250\">said</a>:</p>\n<blockquote>\n<p>Thank you for the pointer. The part about recCompiled being a workaround is something that I still don't quite understand; (i.e. I don't understand why it is a workaround that works.) Could I DM you for insights?</p>\n</blockquote>\n<p>If you have a particular example of an inductive type <code>T</code> in mind, I think you can probably define a function <code>T.rec'</code> by hand, and then use that to construct dependent functions out of <code>T</code>.</p>",
        "id": 450187409,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720535310
    },
    {
        "content": "<blockquote>\n<p>and indeed it is used in the definition of the function returned by <code>T.rec</code>.</p>\n</blockquote>\n<p>No, <code>T.rec</code> is a primitive in Lean, it does not carry a definition, it is a postulate that is auto generated for each inductive based on the rules of the type theory. On the logic side you cannot desugar more than <code>T.rec</code></p>",
        "id": 450187592,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720535380
    },
    {
        "content": "<p>I think I just need a bit of time to digest all the dependent type theory stuff. It's all new to me.</p>",
        "id": 450187596,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720535381
    },
    {
        "content": "<p>Just to clarify this <span class=\"user-mention\" data-user-id=\"513540\">@Flo (Florent Schaffhauser)</span> , the logic of Lean has no clue what a <code>match</code> is, <code>match</code> is merely surface level syntax. The logic only knows what recursors are and how they are supposed to compute. The elaborator (which is the component that reduces surface level syntax down to core logic terms) knows how to turn a <code>match</code> into one or multiple calls to a recursor.</p>",
        "id": 450188674,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720535708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/code.20generator.20does.20not.20support.20recursor.20'.2E.2E.2E.2Erec'.20yet/near/450187592\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>and indeed it is used in the definition of the function returned by <code>T.rec</code>.</p>\n</blockquote>\n<p>No, <code>T.rec</code> is a primitive in Lean, it does not carry a definition, it is a postulate that is auto generated for each inductive based on the rules of the type theory. On the logic side you cannot desugar more than <code>T.rec</code></p>\n</blockquote>\n<p>Yes, but what I meant is, if you take for instance <code>List.rec</code>, then the dependent function <code>f : (L : List R) -&gt; F L</code> that it induces, starting from a term <code>h1 : F List.nil</code> and a function <code>h2 : (a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l),</code> should be defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 450189849,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720536060
    },
    {
        "content": "<p>It has the same computation rules yes (mostly because this quite literally lowers to an application of <code>List.rec</code> to h1 and h2), but it is not defined in this way.</p>",
        "id": 450190234,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720536191
    },
    {
        "content": "<p>I see, thanks!</p>",
        "id": 450190279,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720536214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/code.20generator.20does.20not.20support.20recursor.20'.2E.2E.2E.2Erec'.20yet/near/450188674\">said</a>:</p>\n<blockquote>\n<p>Just to clarify this <span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> , the logic of Lean has no clue what a <code>match</code> is, <code>match</code> is merely surface level syntax. The logic only knows what recursors are and how they are supposed to compute. The elaborator (which is the component that reduces surface level syntax down to core logic terms) knows how to turn a <code>match</code> into one or multiple calls to a recursor.</p>\n</blockquote>\n<p>Oh, I see! This explains why the keyword <code>match</code> was always a bit mysterious <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Thanks for the explanation <span aria-label=\"thank you\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"thank you\">:thank_you:</span></p>",
        "id": 450190691,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720536332
    },
    {
        "content": "<p>So there is a bit of magic behind match. Good to know.</p>",
        "id": 450191175,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720536473
    },
    {
        "content": "<p>Right, if I understand correctly, the magic is what <span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> was explaining  above: <a href=\"#narrow/stream/113489-new-members/topic/code.20generator.20does.20not.20support.20recursor.20'.2E.2E.2E.2Erec'.20yet/near/450185470\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/code.20generator.20does.20not.20support.20recursor.20'.2E.2E.2E.2Erec'.20yet/near/450185470</a></p>",
        "id": 450191660,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720536606
    },
    {
        "content": "<p>If you use <code>set_option pp.match false</code> you can turn off match expression pretty printing. Each <code>match</code> is a special function (known as a \"matcher\", fittingly enough) that logically is backed by a recursor but which the compiler knows how to compile.</p>",
        "id": 450228163,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720544162
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def List.head.{u} : {α : Type u} → (as : List α) → as ≠ [] → α :=</span>\n<span class=\"cm\">fun {α} x x_1 ↦</span>\n<span class=\"cm\">  match x, x_1 with</span>\n<span class=\"cm\">  | a :: tail, x =&gt; a</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">head</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def List.head.{u} : {α : Type u} → (as : List α) → as ≠ [] → α :=</span>\n<span class=\"cm\">fun {α} x x_1 ↦ List.head.match_1 (fun x x ↦ α) x x_1 fun a tail x ↦ a</span>\n<span class=\"cm\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"bp\">.</span><span class=\"n\">match_1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def List.head.match_1.{u_1, u_2} : {α : Type u_1} →</span>\n<span class=\"cm\">  (motive : (x : List α) → x ≠ [] → Sort u_2) →</span>\n<span class=\"cm\">  (x : List α) →</span>\n<span class=\"cm\">  (x_1 : x ≠ []) →</span>\n<span class=\"cm\">  ((a : α) → (tail : List α) → (x : a :: tail ≠ []) → motive (a :: tail) x) →</span>\n<span class=\"cm\">  motive x x_1 :=</span>\n<span class=\"cm\">fun {α} motive x x_1 h_1 ↦</span>\n<span class=\"cm\">  List.casesOn (motive := fun x ↦ (x_2 : x ≠ []) → motive x x_2) x (fun x ↦ absurd ⋯ x)</span>\n<span class=\"cm\">    (fun head tail x ↦ h_1 head tail x) x_1</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 450229201,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720544455
    }
]