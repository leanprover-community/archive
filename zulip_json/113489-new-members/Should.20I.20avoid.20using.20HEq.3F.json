[
    {
        "content": "<p>When I first dived into Lean I got very excited about dependent types and put values in all of my types. Unfortunately this led to intractable messes of casts and type conversion functions in my theorems and inductives when trying to express propositions about relationship of various types which are not definitionally equal. E.g. <code>Vec (4+2) a = Vec (3 * 2) a</code>. So I removed the values from all my data-carrying <code>Type</code>s <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>\n<p>Afterwards however I came across <a href=\"https://lean-lang.org/doc/reference/latest/Basic-Propositions/Propositional-Equality/#HEq\">heterogenous equality</a>. Although I've seen it mentioned a few times (can't remember exactly where, sorry) that heterogenous equality is quite hairy in Lean so to avoid it whenever possible.</p>\n<p>I'd like to understand a bit more about this. Why is <code>HEq</code> fiddly? Is it indeed recommended to stay away from it and stick to making my data-carrying types \"dumb\" so values of that type can always be compared with <code>Eq</code>? Are there any use cases <code>HEq</code> _is_ recommended for? Thanks <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span></p>",
        "id": 555166317,
        "sender_full_name": "aron",
        "timestamp": 1762964823
    },
    {
        "content": "<p>The short answer is that heterogeneous equality is not well behaved and it's usually better to avoid it (for example there is no functional extensionality).</p>",
        "id": 555166873,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762964961
    },
    {
        "content": "<p>Usually you should even avoid <em>equality</em> of types: you can think that two types are <em>literally the same thing</em> (like <code>Nat</code> and <code>â„•</code>) or totally distinct. So ignore the fact that you can prove <code>A = B</code> if the proof is not <code>rfl</code>.</p>",
        "id": 555167241,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762965058
    },
    {
        "content": "<p>The reason <code>HEq</code> is so bad is that it says the types are equal when usually what you want is that you have an indexed type family and you want to say the indices are equal</p>",
        "id": 555167882,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762965222
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> in my use cases I usually make the type index surface some property of the value that I care about. So no it's not about asserting that the indices are equal but indeed that the <em>values</em> are equal. If the values are equal their types will be equal too, but often not definitionally so.</p>",
        "id": 555172423,
        "sender_full_name": "aron",
        "timestamp": 1762966239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> sorry can you expand a little more on what \"not well behaved\" means? And what functional extensionality means in this context?</p>",
        "id": 555173225,
        "sender_full_name": "aron",
        "timestamp": 1762966369
    },
    {
        "content": "<p>For example the analogue of  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=congr#doc\">docs#congr</a> is false for heterogeneous equality.</p>",
        "id": 555173490,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762966421
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> yeah I usually don't care about asserting equality between types â€“ it only comes up because I want to equate two <em>values</em> of types that I know are the same, but Lean doesn't (not without me proving it first)</p>",
        "id": 555173746,
        "sender_full_name": "aron",
        "timestamp": 1762966468
    },
    {
        "content": "<p>This is what I mean: it's much better to think that type that Lean doesn't realize are equal are actually distinct.</p>",
        "id": 555173955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762966512
    },
    {
        "content": "<p>Right. But... that means it's practically impossible to use dependent types for data. Which... means you're basically forbidden from using dependent types â€“ at least for anything other than props</p>",
        "id": 555174758,
        "sender_full_name": "aron",
        "timestamp": 1762966691
    },
    {
        "content": "<p>Which feels like being told Christmas is cancelled <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 555174864,
        "sender_full_name": "aron",
        "timestamp": 1762966718
    },
    {
        "content": "<p>I am not sure I understand what you mean here. For sure sometimes you have to introduce equivalences that on paper you don't see, but it's not at all impossible</p>",
        "id": 555175312,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762966816
    },
    {
        "content": "<p>For example it is surely possible to work with lists</p>",
        "id": 555175668,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1762966872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555174758\">said</a>:</p>\n<blockquote>\n<p>you're basically forbidden from using dependent types</p>\n</blockquote>\n<p>well, we have tried very hard to use (better imo) alternatives exactly because of this. This is exactly the reason why 3-5=0 and 1/0=0. We've learnt that dependent types are bad (for good reasons) and we've tried very hard to make everything independent.</p>\n<p>What is the appeal of dependent types to you?</p>",
        "id": 555176153,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762966966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555172423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> in my use cases I usually make the type index surface some property of the value that I care about. So no it's not about asserting that the indices are equal but indeed that the <em>values</em> are equal. If the values are equal their types will be equal too, but often not definitionally so.</p>\n</blockquote>\n<p>Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 555177727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1762967365
    },
    {
        "content": "<p><span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span> I had a similar experience trying to use types like this. In the end I was able to prove what I wanted but I ended up with weird lemma like <a href=\"https://github.com/wwylele/PentagonalNumberTheorem/blob/021cc74a97f232feb577bb2979def700ec8b2387/PentagonalNumber/Old.lean#L763-L767\">this</a></p>",
        "id": 555178967,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1762967619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555174758\">said</a>:</p>\n<blockquote>\n<p>Right. But... that means it's practically impossible to use dependent types for data. Which... means you're basically forbidden from using dependent types â€“ at least for anything other than props</p>\n</blockquote>\n<p>Structures can have Prop fields, so you can have dependent types for some data. If you want more dependent types though, then you should use a HoTT prover rather than Lean.</p>",
        "id": 555181178,
        "sender_full_name": "suhr",
        "timestamp": 1762968154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555173490\">said</a>:</p>\n<blockquote>\n<p>For example the analogue of  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=congr#doc\">docs#congr</a> is false for heterogeneous equality.</p>\n</blockquote>\n<p>Out of curiosity, what would that analogue be? (the documentation says it would be false for dependent types but I'm not even sure if that's the same issue)</p>",
        "id": 555186645,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1762969572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"726077\">@Philippe Duchon</span> I would guess that the following is consistent but unprovable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">dCongr</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hâ‚</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">â‰</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hâ‚‚</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â‰</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â‰</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>(from h1 and h2 you can deduce that <code>(A -&gt; C) = (A -&gt; D)</code>, but it is independent (of Lean) that this implies <code>C = D</code>)</p>",
        "id": 555188422,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762970058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555174864\">said</a>:</p>\n<blockquote>\n<p>Which feels like being told Christmas is cancelled <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>\n</blockquote>\n<p>I completely understand and had much the same reaction.</p>",
        "id": 556660232,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1763272108
    },
    {
        "content": "<p>Using categorical idioms helps here; you still have to avoid type equality, <em>but</em> you can have heavily dependently typed data without tearing your hair out, by instead keeping track of the <em>precise sense</em> in which two objects are 'equivalent' and using that instead. In fact, you can prove that this is precisely the reason that <code>HEq</code> is 'badly behaved': <code>@HEq Î± Î² a b</code> amounts to a proof <code>h</code> that <code>Î± = Î²</code>, packaged with a proof that <code>cast h a = b</code>, and since Lean has proof irrelevance you lose everything about the proof <code>h</code> you used other than its type. In particular, that means that once you go from e.g. <code>C = D</code> in <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> 's example to <code>(A -&gt; C) = (A -&gt; D)</code>, you can't go back; so <code>HEq</code> is erasing important context behind your back if you use it carelessly.</p>",
        "id": 556660577,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1763272546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/555176153\">said</a>:</p>\n<blockquote>\n<p>What is the appeal of dependent types to you?</p>\n</blockquote>\n<p>While I can't speak for aron, personally it's a combination of \"ultimate form of type safety\" which itself is a big part of the appeal of Lean as a programming language as a whole; the <em>theoretical</em> power and convenience of having extremely precise type information and proof-by-reflection/proof-by-case-analysis; and the simple fact that they <em>constantly</em> come up naturally any time you start trying to build any kind of automatic proof-of-correctness-checker in many, many domains, so I certainly came to it with quite a lot of built-up instances of \"man I really wish this language allowed dependent types\" in my history.</p>",
        "id": 556660699,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1763272731
    },
    {
        "content": "<p>The solution to all issues with <code>HEq</code>, btw, is \"telescopic equality\" (also called <code>PathP</code> in the cubical context). It was <a href=\"https://sf.snu.ac.kr/publications/heq.pdf\">described by Chung-Kil Hur</a> and amounts to using equalities of dependent pairs <code>âŸ¨i, aâŸ© = âŸ¨j, bâŸ©</code>, where <code>i, j : A</code>, <code>B : A â†’ Type</code>, <code>a : B i</code>, <code>b : B j</code>. This implies <code>HEq a b</code>, but crucially keeps around the proof of index equality that cannot be recovered from <code>B i = B j</code>. I started some <a href=\"https://github.com/Vtec234/lean4-seq\">extremely simple experiments</a> with this, but it would be amazing to see a proper library.</p>",
        "id": 556664329,
        "sender_full_name": "ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’",
        "timestamp": 1763276682
    },
    {
        "content": "<p>I can't find any practical example of where <code>Vec</code> would be better to use than <code>List</code>. Instead of <code>v : Vec n Î±</code>, you can just have <code>l : List Î±</code> and a proof <code>l.length = n</code>. And you can even state some less trivial property about the length then just equality.</p>",
        "id": 556664417,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763276807
    },
    {
        "content": "<p>I am using heavily dependently typed terms because I think they are the simplist way to express the ideas I am transcribing proofs about in Lean (that is simply typed lambda calculus)</p>",
        "id": 556674221,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763288063
    },
    {
        "content": "<p>I think I have been using some of the ideas <span class=\"user-mention\" data-user-id=\"128280\">@ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> mentioned (\"telescopic equality\") in working with my dependent types also because it seemed to be the simplest way to express my ideas in Lean</p>",
        "id": 556674867,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763288486
    },
    {
        "content": "<p>I was also formalizing simply typed lambda calculus in Lean with dependant types, it looked great while doing simple stuff, but turned out too be hard to work with when I moved to more complicated algorithms.</p>",
        "id": 556678264,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763291416
    },
    {
        "content": "<p>Does HoTT make such use of dependent types easier?</p>",
        "id": 556678960,
        "sender_full_name": "IlmÄrs CÄ«rulis",
        "timestamp": 1763292136
    },
    {
        "content": "<p>I recall a comment made by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> where he said that he uses lean because it has dependent types and quotients. Meanwhile every topic I've witnessed boils down to \"Avoid dependent types\".</p>\n<p>Which is absolutely hilarious, it's like saying: \"A is the best because it has property b and property b is bad.\" <br>\nI guess the only real uses for dependent types is something that goes into prop.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exampleGoodDepType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>If I understand correctly, exampleGoodDepType are the only \"good\" dependent types?</p>",
        "id": 556687093,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763301586
    },
    {
        "content": "<p>Dependent data is difficult because of all the coherence you need to show</p>",
        "id": 556687145,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763301631
    },
    {
        "content": "<p>Dependent proofs however are always definitionally coherent</p>",
        "id": 556687164,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763301650
    },
    {
        "content": "<p>So is the \"only good feature\" types that map into prop? How do simple type systems express exampleGoodDepType then?</p>",
        "id": 556687252,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763301724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725717\">metakuntyyy</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/556687093\">said</a>:</p>\n<blockquote>\n<p>I recall a comment made by @Kevin Buzzard where he said that he uses lean because it has dependent types and quotients. Meanwhile every topic I've witnessed boils down to \"Avoid dependent types\".</p>\n</blockquote>\n<p>The intent of this comment has been twisted a little. I use dependent types all the time, there's nothing wrong with them. What's wrong is asking pathological questions about them such as asking if two dependent types are equal, or using HEq etc. I stay away from the pathological questions and whilst I need dependent types have never explicitly used HEq in my work; I don't need that because it doesn't come up in e.g. the proof of FLT.</p>",
        "id": 556688056,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763302398
    },
    {
        "content": "<p>HEq is fine if you know additionally that the indices are equal</p>",
        "id": 556688135,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763302453
    },
    {
        "content": "<p>that's why it's used internally by the <code>cases</code> tactic</p>",
        "id": 556688158,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763302469
    },
    {
        "content": "<p>but if you don't know that then it tells you nothing</p>",
        "id": 556688225,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763302527
    },
    {
        "content": "<p>But what would a simple example be. I guess the question to <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> is what theorem or definition makes him happy that he's doing in lean and not in a simply typed language. The definition can be as simple as possible.</p>\n<p>And to <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> what would one simple example be where HEq is fine. It reminds me of <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/Mathlib.3A.20the.20Missing.20Manuals/with/554302345\">#mathlib4 &gt; Mathlib: the Missing Manuals</a>  where <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> is working on updating the documentation according to the divio design. </p>\n<p>I'm in favour of having a good compiled document that describes just design decisions to help one understand topics better. However I must note that documentation has massively improved in the last year or so. I've read the full reference manual on my drive home. It was actually a pleasant read as it was a very nicely compiled document with about 200 pages worth of information that I otherwise wouldn't get.</p>",
        "id": 556688712,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763303003
    },
    {
        "content": "<p>Here's an example where HEq is useful <a href=\"#narrow/channel/270676-lean4/topic/Puzzle.3A.20Decidable.20HEq/near/536803714\">https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/Puzzle.3A.20Decidable.20HEq/near/536803714</a></p>",
        "id": 556689035,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763303305
    },
    {
        "content": "<p>Thanks, that's helpful.</p>",
        "id": 556689498,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763303757
    },
    {
        "content": "<p>The killer example for dependent types is homological algebra. Here we have abelian groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (or objects in a category) indexed by the naturals or integers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>, and with maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>â†’</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">A_i\\to A_{i+1}.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span> Our dependent type problems were solved by just defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>:</mo><msub><mi>A</mi><mi>i</mi></msub><mo>â†’</mo><msub><mi>A</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_{ij}:A_i\\to A_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">ij</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">â†’</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i,j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> and demanding that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d_{ij}=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">ij</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>=Ì¸</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">j\\not=i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\">î€ </span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>. This is a bit of a hack but it has worked absolutely fine (we have a usable theory of group cohomology, I know this because I've been using it in the class field theory repo).</p>",
        "id": 556692314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763306108
    },
    {
        "content": "<p>Very nice. Thank you both for your answers.</p>",
        "id": 556692385,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763306153
    },
    {
        "content": "<p>Do you know where I can find the code? I'd like to study it a bit.</p>",
        "id": 556692877,
        "sender_full_name": "metakuntyyy",
        "timestamp": 1763306504
    },
    {
        "content": "<p>Well <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HomologicalComplex#doc\">docs#HomologicalComplex</a> is the type</p>",
        "id": 556692989,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763306580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658873\">IlmÄrs CÄ«rulis</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/556678960\">said</a>:</p>\n<blockquote>\n<p>Does HoTT make such use of dependent types easier?</p>\n</blockquote>\n<p>Understanding HoTT should make it easier in some ways to use dependent types in Lean, but the same solutions should be easier in Lean than in HoTT because of proof irrelevance. Proof irrelevance makes some things easier and some things harder: in HoTT if A, B are types and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi><mo>:</mo><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">p, q : A = B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> then to prove that <code>cast p x = cast q x</code> it may be necessary to prove <code>p=q</code>. In Lean you get this for free by proof irrelevance. It would be possible to translate many HoTT constructions into Lean, many of them would simplify or become degenerate but many would still be useful.</p>\n<p>Robert Maxton says \"so <code>HEq</code> is erasing important context behind your back if you use it carelessly\", which is true, but as long as you don't use it \"destructively\" (i.e. you remember the original equality and you deploy it when necessary rather than forgetting it by weakeneing it to heterogeneous equality) it should be okay.</p>",
        "id": 556693267,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1763306803
    },
    {
        "content": "<p>When Robert Maxton says:</p>\n<blockquote>\n<p>Using categorical idioms helps here; you still have to avoid type equality, <em>but</em> you can have heavily dependently typed data without tearing your hair out, by instead keeping track of the <em>precise sense</em> in which two objects are 'equivalent' and using that instead.</p>\n</blockquote>\n<p>this is true in some sense but taken literally it is false because two types are equal in at most one way and so one does not have to keep track of how or why they are equal. so this point needs some clarification.</p>\n<p>One point which is relevant is that if <code>P : A -&gt; Type</code> and <code>p : a = b</code> then <code>P a = P b</code> but you probably still need to keep around the theorem that <code>a = b</code>.</p>\n<p>That is, if <code>x : P a</code> and <code>y : P b</code>, assuming you prove that casting <code>x</code> across <code>p</code> is equal to <code>y</code>, you might want to work with <code>heq x y</code> instead. From this you can recover that <code>P a = P b</code>, but <code>P</code> need not be injective in general, so you cannot necessarily recover <code>p: a = b</code> from this, and so you have really lost something in that reasoning step.</p>\n<p>(Whoops, I guess this is really what Wojciech said earlier, that one should keep around the proofs of equality on indices for the dependent types - sorry for the redundancy.)</p>",
        "id": 556693618,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1763307074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">ğš ğš˜ğš“ğšŒğš’ğšğšŒğš‘ ğš—ğšŠğš ğš›ğš˜ğšŒğš”ğš’</span> <a href=\"#narrow/channel/113489-new-members/topic/Should.20I.20avoid.20using.20HEq.3F/near/556664329\">said</a>:</p>\n<blockquote>\n<p>The solution to all issues with <code>HEq</code>, btw, is \"telescopic equality\" (also called <code>PathP</code> in the cubical context). It was <a href=\"https://sf.snu.ac.kr/publications/heq.pdf\">described by Chung-Kil Hur</a> and amounts to using equalities of dependent pairs <code>âŸ¨i, aâŸ© = âŸ¨j, bâŸ©</code>, where <code>i, j : A</code>, <code>B : A â†’ Type</code>, <code>a : B i</code>, <code>b : B j</code>. This implies <code>HEq a b</code>, but crucially keeps around the proof of index equality that cannot be recovered from <code>B i = B j</code>. I started some <a href=\"https://github.com/Vtec234/lean4-seq\">extremely simple experiments</a> with this, but it would be amazing to see a proper library.</p>\n</blockquote>\n<p>I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> worked on something like this before</p>",
        "id": 556702839,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1763315285
    }
]