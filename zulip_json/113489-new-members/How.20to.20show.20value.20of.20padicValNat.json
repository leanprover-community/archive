[
    {
        "content": "<p>[updated statement to fix order of arguments]<br>\nHow to show the following simple fact</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>this is my first time trying out <code>padicValNat</code> so I could be missing easy stuff.</p>",
        "id": 508767611,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1743171702
    },
    {
        "content": "<p>this is false, as evidenced by using <code>native_decide</code></p>",
        "id": 508772076,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743172868
    },
    {
        "content": "<p>i.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">native_decide</span>\n</code></pre></div>",
        "id": 508772195,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743172908
    },
    {
        "content": "<p>does <code>decide</code> not work?</p>",
        "id": 508772247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743172920
    },
    {
        "content": "<p>no, i think because <code>Nat.find</code> doesn't have a reducible definition?</p>",
        "id": 508772412,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743172957
    },
    {
        "content": "<p>ah I see I had flipped the order of 48 and 3</p>",
        "id": 508772497,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1743172983
    },
    {
        "content": "<p>thanks for <code>native_decide</code> solution, but as the tactic warns, this adds compiler to trusted. any way to avoid that?</p>",
        "id": 508772840,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1743173057
    },
    {
        "content": "<p>maybe we should replace uses of <code>Nat.find</code> with <code>Nat.findBounded</code> where possible</p>",
        "id": 508773406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173216
    },
    {
        "content": "<p>where <code>Nat.findBounded</code> has a constructive upper limit and is defined by recursion on nat</p>",
        "id": 508773525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173247
    },
    {
        "content": "<p>my guess is that essentially all uses of <code>Nat.find</code> are actually expressible with <code>Nat.findBounded</code></p>",
        "id": 508773712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173290
    },
    {
        "content": "<p>maybe we could/should redefine <code>Nat.find</code> via <code>partial_fixpoint</code>?</p>",
        "id": 508774268,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743173448
    },
    {
        "content": "<p>does that help?</p>",
        "id": 508774809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173595
    },
    {
        "content": "<p>it's not a partial function, and I think the fixpoint combinator used by <code>partial_fixpoint</code> is strictly harder to deal with in the kernel than <code>Acc.rec</code></p>",
        "id": 508775049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173652
    },
    {
        "content": "<p>(BTW I tried using <code>with_unfolding_all decide</code> here, but it still doesn't work because that forces unfolding of proofs and the proof of well foundedness in this case uses some axiom)</p>",
        "id": 508775236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173700
    },
    {
        "content": "<p>hm, seems the alternative definition used for <code>csimp</code> works better in <code>decide</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">Padics</span><span class=\"bp\">.</span><span class=\"n\">PadicVal</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">padicValNat</span><span class=\"bp\">.</span><span class=\"n\">padicValNat_eq_maxPowDiv</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">with_unfolding_all</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 508776057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743173914
    },
    {
        "content": "<p><span aria-label=\"hmm\" class=\"emoji emoji-1f928\" role=\"img\" title=\"hmm\">:hmm:</span></p>",
        "id": 508776425,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743174003
    },
    {
        "content": "<p>maybe we should add this as a <code>Decidable</code> instance then?</p>",
        "id": 508776638,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743174049
    },
    {
        "content": "<p>well no, it's a terrible decision procedure</p>",
        "id": 508777144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174178
    },
    {
        "content": "<p>well not terrible but it would need modification first</p>",
        "id": 508777217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174195
    },
    {
        "content": "<p>this should just have a norm_num extension</p>",
        "id": 508777274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174214
    },
    {
        "content": "<p>especially since it's easier to verify the result than to calculate it</p>",
        "id": 508777451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174248
    },
    {
        "content": "<p>it's a bit annoying that the definitional property of <code>padicValNat</code> isn't a theorem?</p>\n<blockquote>\n<p>For <code>p ≠ 1</code>, the <code>p</code>-adic valuation of a natural <code>n ≠ 0</code> is the largest natural number <code>k</code> such that <code>p^k</code> divides <code>n</code>.</p>\n</blockquote>\n<p>The closest I can find is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat_dvd_iff#doc\">docs#padicValNat_dvd_iff</a></p>",
        "id": 508778861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174613
    },
    {
        "content": "<p>I assume you can get at this theorem via <code>multiplicity</code></p>",
        "id": 508778939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743174637
    },
    {
        "content": "<p>Here's a better proof, which should be roughly how the norm_num extension works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">padicValNat_def'</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">finiteMultiplicity_iff</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">multiplicity_eq_iff</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">padicValNat</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 508782505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743175525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20show.20value.20of.20padicValNat/near/508773525\">said</a>:</p>\n<blockquote>\n<p>where <code>Nat.findBounded</code> has a constructive upper limit and is defined by recursion on nat</p>\n</blockquote>\n<p>You mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.findGreatest#doc\">docs#Nat.findGreatest</a> ? EDIT: No, but same vibes</p>",
        "id": 508798190,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743179550
    },
    {
        "content": "<p>See also <a href=\"#narrow/stream/113489-new-members/topic/Is.20this.20provable.20without.20using.20native_decide.3F\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Is.20this.20provable.20without.20using.20native_decide.3F</a></p>",
        "id": 508799631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1743179942
    }
]