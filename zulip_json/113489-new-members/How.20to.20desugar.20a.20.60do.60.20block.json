[
    {
        "content": "<p>Hi, I was wondering what tactic you use do desugar / simplify an assumption which is a call of a function which contains a large do block?</p>\n<p>It has a bunch of left arrow statements, such as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I'm wondering how I turn the <code>do</code> into the underlying bind and even better untop of that simplify things like <code>Except.ok y &gt;&gt;= (fun x =&gt; x ... )</code> to <code>(y ...)</code> directly, thanks!</p>",
        "id": 464173196,
        "sender_full_name": "Philogy",
        "timestamp": 1724275451
    },
    {
        "content": "<p>If you set <code>set_option pp.notation false</code>, you can see the bind operations. It's just pretty printed with <code>do</code>.</p>",
        "id": 464173443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724275573
    },
    {
        "content": "<p>To simplify things like <code>Except.ok y &gt;&gt;= f</code>, it's best to write the missing simplification lemmas</p>",
        "id": 464173533,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724275616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20desugar.20a.20.60do.60.20block/near/464173443\">said</a>:</p>\n<blockquote>\n<p>If you set <code>set_option pp.notation false</code>, you can see the bind operations. It's just pretty printed with <code>do</code>.</p>\n</blockquote>\n<p>That makes sense, could you help me out getting the fully universe polymorphic variant of the lemma to work? I could only get the typechecker to be ok with it if <code>α</code> and <code>β</code> were from the same universe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"w\"> </span><span class=\"n\">u_3</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ok_bind_simp</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(let alone making this generic over monads)</p>",
        "id": 464246896,
        "sender_full_name": "Philogy",
        "timestamp": 1724300011
    },
    {
        "content": "<p>Also definining:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ok_bind_simp</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Also now that I've written this theorem how do I apply it? <code>simp</code> and <code>simp_all</code> don't seem to find a way to apply it?</p>",
        "id": 464250416,
        "sender_full_name": "Philogy",
        "timestamp": 1724300800
    },
    {
        "content": "<p>Looks like I didn't need the lemma <code>simp_all [bind, Except.bind, Builtin.call]</code> (<code>Builtin.call</code>) is a thing related to me worked.</p>\n<p>Is there a tactic that simplifies, computes and expands all open function definitions?</p>",
        "id": 464251629,
        "sender_full_name": "Philogy",
        "timestamp": 1724301076
    },
    {
        "content": "<p>Here's a formulation that's useful for simp, and I think I got the universes as general as possible.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok_bind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 464257194,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302269
    },
    {
        "content": "<p>This would also be useful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">error_bind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 464257400,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302312
    },
    {
        "content": "<p>Rule of thumb: for simp lemmas you don't want equality hypotheses between a variable and a term — just substitute the variable in.</p>",
        "id": 464257686,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302373
    },
    {
        "content": "<p>(I checked universe generality by replacing <code>Type u</code> and <code>Type v</code> with <code>Type _</code> and hovering over <code>Except.ok_bind</code> to see the type of the resulting declaration.)</p>",
        "id": 464257818,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20desugar.20a.20.60do.60.20block/near/464257818\">said</a>:</p>\n<blockquote>\n<p>of the resulting declaration.)</p>\n</blockquote>\n<p>Do alpha and beta need to inhabit the same type universe for the definition to work?</p>",
        "id": 464259151,
        "sender_full_name": "Philogy",
        "timestamp": 1724302744
    },
    {
        "content": "<p>Yeah, I found that out by using <code>Type _</code></p>",
        "id": 464259629,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302910
    },
    {
        "content": "<p>I see, in regards to simplification, is there any tactic that just expands and simplifies any available definitions in your scope? My proof ended up looking like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ast_square_eq_op_square</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"n\">equiv_no_err</span><span class=\"w\"> </span><span class=\"n\">square_plus_one</span><span class=\"w\"> </span><span class=\"n\">sq_ops</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"n\">pure</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">enum</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">ListMap</span><span class=\"bp\">.</span><span class=\"n\">set_by_key</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ListMap</span><span class=\"bp\">.</span><span class=\"n\">get_by_key?</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">index_of?</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Symbols</span><span class=\"bp\">.</span><span class=\"n\">apply_assign</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Symbols</span><span class=\"bp\">.</span><span class=\"n\">eval_expr</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Ast</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">ok_with_err</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">equiv_no_err</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sq_ops</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">compile_assign</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">as_ops</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">square_plus_one</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Builtin</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">square_plus_one</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">eval_ops</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Builtin</span><span class=\"bp\">.</span><span class=\"n\">call</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Stack</span><span class=\"bp\">.</span><span class=\"n\">dup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Stack</span><span class=\"bp\">.</span><span class=\"n\">pop</span>\n<span class=\"w\">  </span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 464259895,
        "sender_full_name": "Philogy",
        "timestamp": 1724302963
    },
    {
        "content": "<p>Using universe level variables is a way to ensure you have the amount of universe polymorphism you're expecting, but if you use <code>_</code> then Lean will give you the most-general version automatically.</p>",
        "id": 464259913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724302966
    },
    {
        "content": "<p>You shouldn't need to unfold <code>pure</code> and <code>bind</code>. Needing to unfold lots of definitions is usually indicating missing simp lemmas. People around here call this \"missing API\"</p>",
        "id": 464260065,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303006
    },
    {
        "content": "<p>But, yes, there are some simp config options for unfolding definitions. A shorthand to get one of them is <code>simp!</code></p>",
        "id": 464260260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303044
    },
    {
        "content": "<p>There's also <code>simp (config := { ground := true })</code>, but that doesn't seem to apply here. That's meant for \"ground terms\", i.e. terms with no metavariables or free variables. The purpose of this is to use <code>simp</code> to reduce terms more efficiently than whnf could (and, importantly, beyond what whnf could), I believe.</p>",
        "id": 464260949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20desugar.20a.20.60do.60.20block/near/464260065\">said</a>:</p>\n<blockquote>\n<p>You shouldn't need to unfold <code>pure</code> and <code>bind</code>. Needing to unfold lots of definitions is usually indicating missing simp lemmas. People around here call this \"missing API\"</p>\n</blockquote>\n<p>Hmm, I'd assume so, do I create my own library of lemmas to simplify common functions? Or is there some tactic library I can use? I have Aesop and Mathlib imported at the top level along with a specific import or two from the lib.</p>\n<p>Your help is very appreciated btw <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 464261612,
        "sender_full_name": "Philogy",
        "timestamp": 1724303344
    },
    {
        "content": "<p>Even though there's <em>lots</em> of material in the libraries, there are <em>lots</em> of gaps in the libraries, and believe it or not, given how basic bind lemmas for <code>Except</code> should be, it seems like you're doing something that no one's done before (or at least, no one whose been here in your situation has contributed the lemmas back!)</p>\n<p>The way development works is that you collect lots of these simplification lemmas and (hopefully, if you're kind enough to slog through the nontrivial effort of contributing) eventually create PRs to help the next person.</p>\n<p>But, yes, you should make a library of these simple lemmas, at least for your own project.</p>",
        "id": 464262252,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303632
    },
    {
        "content": "<p>If you do end up with a library of Except lemmas (etc), feel free to ping me and I can try to see where in Lean, Batteries, or Mathlib they could go.</p>",
        "id": 464262407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303729
    },
    {
        "content": "<p>It's possible that there is automation that can do this automatically, but I'm not aware of it at the moment. Hopefully, if there is, someone will chime in.</p>",
        "id": 464262543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724303835
    },
    {
        "content": "<p>Do you think there could be a simpler way to register new <code>simp</code> lemmas? In the current way it seems like you'd have to manually unwrap the definition for every function you'd want to define a lemma for.</p>",
        "id": 464271114,
        "sender_full_name": "Philogy",
        "timestamp": 1724307268
    },
    {
        "content": "<p>Sometimes you can add <code>@[simp]</code> to a definition (or, in your own files, write <code>attribute [simp] theDefinition</code>), and other times <code>@[simps]</code> is useful for generating a number of lemmas.</p>",
        "id": 464271523,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724307394
    },
    {
        "content": "<p>this theorem already exists as <code>pure_bind</code> I think, you just have to apply the fact that <code>Except.ok</code> is <code>pure</code></p>",
        "id": 464271666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1724307454
    },
    {
        "content": "<p>Ah, so if you write a simp lemma that <code>Except.ok z = pure z</code> then this will automatically apply</p>",
        "id": 464271827,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724307549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20desugar.20a.20.60do.60.20block/near/464271523\">said</a>:</p>\n<blockquote>\n<p>Sometimes you can add <code>@[simp]</code> to a definition (or, in your own files, write <code>attribute [simp] theDefinition</code>), and other times <code>@[simps]</code> is useful for generating a number of lemmas.</p>\n</blockquote>\n<p>Awesome, yeah adding <code>@[simp]</code> to my own definitions and the following defs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok_bind</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Except</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find?</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">enum</span>\n</code></pre></div>\n<p>Let me reduce my proof from the above abomination to just:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ast_square_eq_op_square</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"n\">equiv_no_err</span><span class=\"w\"> </span><span class=\"n\">square_plus_one</span><span class=\"w\"> </span><span class=\"n\">sq_ops</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">equiv_no_err</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">square_plus_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sq_ops</span><span class=\"w\"> </span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 464280289,
        "sender_full_name": "Philogy",
        "timestamp": 1724310277
    },
    {
        "content": "<p>In terms of contributing back the lemmas the <code>Except.ok_bind</code> would just go into prelude and adding the simp tags to all the list definitions should do the trick, right?</p>",
        "id": 464280536,
        "sender_full_name": "Philogy",
        "timestamp": 1724310323
    },
    {
        "content": "<p>You do have to be careful with <code>attribute [simp]</code> for definitions, since they're not always the right lemmas, and also if they just eliminate the definition (like <code>List.enum.eq_1</code> does) then you have to think about what you want as the simp normal form.</p>\n<p>There's also the consideration for how the lemma should be phrased. For example, with <code>List.find?</code>, the equation lemma that is added to simp is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">as</span>\n</code></pre></div>\n<p>There are actually already some simp lemmas in the prelude for this, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.find%3F#doc\">docs#List.find?</a>_cons_of_pos and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.find%3F#doc\">docs#List.find?</a>_cons_of_neg, which are conditional simp lemmas that only apply if <code>p a</code> can be decided.</p>",
        "id": 464473151,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724357662
    }
]