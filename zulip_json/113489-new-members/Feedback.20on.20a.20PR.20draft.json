[
    {
        "content": "<p>I thought I'd try to make an occasional small contribution to mathlib4. The Stone-Cech compactification seems like it could use some additions, so I thought I'd try working on that. <a href=\"https://github.com/leanprover-community/mathlib4/pull/7750\">Here</a> is one small fact about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span>. There are some opportunities for futher work in this direction too.</p>\n<p>How does it look at a glance? Seems like quite a bit  of work compared to the proof on the paper, but I couldn't easily golf it further. I do have some specific questions about certain parts of that proof, but I thought I'd first ask if this looks anywhere near ok first.</p>",
        "id": 397376925,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697659722
    },
    {
        "content": "<p>It looks quite reasonable yes, I'll make some line by line comments on the PR</p>",
        "id": 397377189,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697659858
    },
    {
        "content": "<p>If you want to merge this to mathlib you should open a PR from a branch on the mathlib repository, not from a fork. See <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>",
        "id": 397377811,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1697660139
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> , feedback much appreciated! I see that there are quite a few formatting issues. There was no automatic lean formatter the last time I checked. Is that still the case?</p>",
        "id": 397377946,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697660186
    },
    {
        "content": "<p>Yes unfortutely we don't have an auto-formatter, just some simple python scripts in  <code>scripts/lint-style.sh</code> that you can use (they can fix some very simple formatting errors for you, but not many)</p>",
        "id": 397378077,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1697660264
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span>, I used to have access to mathlib in Lean3 times, but I didn't seem to automatically have one for mathlib4</p>",
        "id": 397378180,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697660308
    },
    {
        "content": "<p>Happy to open a PR there though if I'm added</p>",
        "id": 397378242,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697660350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/Feedback.20on.20a.20PR.20draft/near/397378077\">said</a>:</p>\n<blockquote>\n<p>Yes unfortutely we don't have an auto-formatter, just some simple python scripts in  <code>scripts/lint-style.sh</code> that you can use (they can fix some very simple formatting errors for you, but not many)</p>\n</blockquote>\n<p>Too bad, having a job as a SWE I couldn't imagine getting through a week without <code>prettier</code>. It is what it is, I guess</p>",
        "id": 397378443,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697660451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"492938\">@Matias Heikkilä</span>  Invite sent.</p>",
        "id": 397378886,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1697660665
    },
    {
        "content": "<p>I this would a be a suitable place to ask a couple of specific questions, I would like to know what's going on here</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">ULift.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>It's not something I could have ever come up with myself, I saw <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> writing that elsewhere, and just fiddled around with it until it did what I wanted. Given the following lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Homeomorph.ulift.symm.compactSpace</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">T2Space</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Homeomorph.ulift.symm.t2Space</span>\n</code></pre></div>\n<p>I can sort of undrstand that we are identifying <code>Icc 0 1</code> as a space with some properties we need, but I don't know what <code>ULift.{u}</code> even means. I see the docstring, but unfortunately I don't really understand it  :D</p>",
        "id": 397379102,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697660769
    },
    {
        "content": "<p><code>ULift</code> is just a way to lift a type from one universe level to another. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ULift#doc\">docs#ULift</a></p>",
        "id": 397379249,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697660849
    },
    {
        "content": "<p>Do you know about universes?</p>",
        "id": 397379347,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1697660887
    },
    {
        "content": "<p>So, if you want to construct the \"interval\" as an object of the category <code>Top.{u}</code> of topological spaces whose underlying type is at universe level <code>u</code>, then you will need to use such a <code>ULift</code>.</p>",
        "id": 397379363,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697660898
    },
    {
        "content": "<p>There is a brief discussion about universes at the following link, in case it helps: <a href=\"https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html?highlight=universes#types-as-objects\">https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html?highlight=universes#types-as-objects</a></p>",
        "id": 397379629,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1697661032
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> , perhaps I should read a bit to be able to make better questions</p>",
        "id": 397379762,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697661103
    },
    {
        "content": "<p>I can \"sort of\" get that we are identifying the same thing in a different way there, but I think I'll need to get a bit deeper into it before I could produce anything useful without copying other people's code.</p>",
        "id": 397380190,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697661308
    },
    {
        "content": "<p>I'll work through your comments <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, and open an improved version of the same thing as a PR in the mathlib4 repo as suggested by Rémy above.</p>",
        "id": 397380426,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697661459
    },
    {
        "content": "<p>Ok moved things <a href=\"https://github.com/leanprover-community/mathlib4/pull/7754\">here</a> and linked the not-implemented comments from the other PR</p>",
        "id": 397383072,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697662914
    },
    {
        "content": "<p>If you are used to thinking about mathematics set-theoretically then probably you never used universes, which are inaccessible cardinals in set theory. Most mathematicians never need to leave universe 0, which can be thought of as the class of all sets. But in Lean universes are there so people use them just because they're there.</p>",
        "id": 397387977,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697665973
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, that’s indeed my case. A nice learning opportunity here</p>",
        "id": 397427900,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1697690330
    },
    {
        "content": "<p>I think the only other thing worth saying is that lean's universes are much easier to grok than set theory's inaccessible cardinals. Lean's universes come from the fact that the system simply demands that every single term most have a type, so the type of pi is the reals, and the type of the reals is <code>Type</code>, but then the type of <code>Type</code> has to be a thing so it's <code>Type 1</code>, and the type of <code>Type 1</code> is <code>Type 2</code> etc. That's why they're there, to satisfy an axiom of the system. And you can't have the type of <code>Type</code> being <code>Type</code> or else you can do an analogue of Russell's \"set of all sets that don't contain themselves\" and get a contradiction. So these <code>Type n</code> worlds are just bigger and bigger models of mathematics and the way mathlib is developed the theorems are all valid in all of them, but you have to use these <code>ULift</code> functions to move between them</p>",
        "id": 397446295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697700901
    },
    {
        "content": "<p>I reconsidered this a little bit, and thought that instead of proving an isolated fact about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span>, it would perhaps be better to take a step back and make a bigger improvement in this file: The space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span> comes with a natural map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">e : X \\to \\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span>, but in order to get many of the interesting topology facts about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span> you need this map to be an embedding. I think that, while mathlib currently has that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> is an embedding for a discrete <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, the general case is missing.</p>\n<p>I was able to force my way through <a href=\"https://github.com/leanprover-community/mathlib4/compare/master...mapehe:mathlib4:stone-cech-embedding#diff-2a6e4cb9e091ae059c58aee98c2b41490bf3da03d951473ce856c40a23363bffR601-R604\">a really messy proof</a> proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> is an embedding in the usual generality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, which is actually kinda cool, because the quotient construction it uses seems pretty nonstandard to me. While the proof is very low quality code, I thought it’s not worth it to try and improve it in isolation. I thought I’d use it as a reference, gradually build the same result in better organized PRs and dig out the useful lemmas that are atm scattered around randomly. I guess an upside of having even a messy proof is that it perhaps explains a bit what I’m trying to do.</p>\n<p>Thoughts? For starters I sketched a <a href=\"https://github.com/leanprover-community/mathlib4/pull/7926\">definition</a> of the “usual generality” mentioned above.</p>",
        "id": 398518504,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698249780
    },
    {
        "content": "<p>We don't really want this map to be an embedding in general, we want its universal property (which is <code>stoneCechExtend</code>and its properties).</p>",
        "id": 398531283,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698254485
    },
    {
        "content": "<p>And the construction that is currently in Mathlib is rather directly tailored to guarantee this universal property in a very clean way. It also has the advantage of being very parallel to the construction of the completion of a uniform space (which is a completely analogous result, exhibiting complete and separated spaces as a reflexive subcategory, just as Stone-Cech does for compact separated spaces).</p>",
        "id": 398531661,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698254653
    },
    {
        "content": "<p>Thanks for the feedback. It’s well known that this universal property characterises <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>β</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">\\beta X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">βX</span></span></span></span> up to homeomorphism for “<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>T</mi><mn>3.5</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_{3.5}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3.5</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> spaces”. This is actually what I originally wanted to add, but I couldn’t get the proof to work without <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span></span></span></span> being an embedding. So I wondered if, without altering the construction at all, it’s an embedding for this same class of spaces. This indeed seems to be the case</p>",
        "id": 398535612,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698256462
    },
    {
        "content": "<p>I don’t know if there is some easy other way to get this uniqueness I have overlooked</p>",
        "id": 398535727,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698256519
    },
    {
        "content": "<p>I don't understand what you mean. What would be the statement of that characterization? The obvious statement follows by abstract non-sense as usual so I guess you mean something else.</p>",
        "id": 398536290,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698256758
    },
    {
        "content": "<p>I probably just mean the obvious statement <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> well I did get through the embedding proof though, could there be anything worthwhile in that?</p>",
        "id": 398540762,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698258628
    },
    {
        "content": "<p>i.e. a proof for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">denseEmbedding_stoneCechUnit</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T1Space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompletelyRegularSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">DenseEmbedding</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">stoneCechUnit</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">StoneCech</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">CompletelyRegularSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T1Space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">completely_regular</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">Disjoint</span> <span class=\"n\">K</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ℝ</span><span class=\"o\">)),</span> <span class=\"n\">EqOn</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">∧</span> <span class=\"n\">EqOn</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"n\">K</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 398546668,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698261167
    },
    {
        "content": "<p>Having a criterion ensuring the map into Stone-Cech is an embedding sounds interesting in its own right. It will probably need to live in a different file because that file currently probably doesn't import real numbers. This is a nice aspect of the construction in Mathlib: the Stone-Cech compactification lives purely in general topology, there is no need to build real numbers first.</p>",
        "id": 398546697,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698261184
    },
    {
        "content": "<p>Your definition of <code>CompletelyRegularSpace</code> looks very weird. Why writing <code>Disjoint K {x}</code> instead of <code>x \\notin K</code>? Or <code>EqOn f 0 {x}</code> instead of <code>f x = 0</code>??</p>",
        "id": 398546881,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698261268
    },
    {
        "content": "<p>Using bundled continuous functions is also clearly the wrong choice here.</p>",
        "id": 398546953,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698261299
    },
    {
        "content": "<p><code>C(α, ℝ)</code> is meant to be use only if you want extra structure on this type (for instance a topology), not when you want to talk about a single continuous function.</p>",
        "id": 398547035,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698261340
    },
    {
        "content": "<p>Thanks again for the feedback. This definition is based on the statement of theorem <code>exists_continuous_zero_one_of_closed</code>. I can see how it's unnecessarily complicated in this case though, and I probably clinged too hard to the bit of similarity these situations have.</p>",
        "id": 398548272,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698261913
    },
    {
        "content": "<p>I was planning to break this into smaller PRs. I'm hoping it's then possible to bring it to mathlib-level quality with reasonable amount of reviewer feedback</p>",
        "id": 398549616,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698262572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492938\">Matias Heikkilä</span> <a href=\"#narrow/stream/113489-new-members/topic/Feedback.20on.20a.20PR.20draft/near/398540762\">said</a>:</p>\n<blockquote>\n<p>I probably just mean the obvious statement <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> well I did get through the embedding proof though, could there be anything worthwhile in that?</p>\n</blockquote>\n<p>I think that discussing \"the obvious statement\" without ever stating it isn't very productive, so I wrote some Lean code. I put everything in <code>Type</code> to avoid distracting universe issues. First I define what it means that a compact separated <code>Y</code> has the universal property of a compactification of <code>X</code>. Then I build a homeomorphism between any two such compactifications <code>Y</code> and <code>Y'</code>, using only the definition (this is the abstract non-sense proof I was referring to). It would be easy to prove there is only one such homeomorphism compactible with the <code>j</code> maps. Then I prove that Stone-Cech has this property. Is that the uniqueness that you wanted?</p>",
        "id": 398553753,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698264457
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">CompactificationData</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n  <span class=\"n\">j_cont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">j</span>\n  <span class=\"n\">extend</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span>\n  <span class=\"n\">cont_extend</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">extend</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span>\n  <span class=\"n\">extend_extends</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">extend</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"bp\">∘</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n  <span class=\"n\">unique_extend</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g_extends</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cont_g</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">extend</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CompactificationData</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CompactificationData.compare</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">Y'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Y'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Y'</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CompactificationData</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactificationData</span> <span class=\"n\">X</span> <span class=\"n\">Y'</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Homeomorph</span> <span class=\"n\">Y</span> <span class=\"n\">Y'</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">set</span> <span class=\"n\">toMap</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n    <span class=\"n\">set</span> <span class=\"n\">fromMap</span> <span class=\"o\">:</span> <span class=\"n\">Y'</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">fromMap</span> <span class=\"bp\">∘</span> <span class=\"n\">toMap</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"k\">from</span> <span class=\"n\">congrFun</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">unique_extend</span> <span class=\"n\">j_cont</span> <span class=\"o\">(</span><span class=\"n\">Function.comp.left_id</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"n\">continuous_id</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">unique_extend</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">extend_extends</span><span class=\"o\">,</span> <span class=\"n\">extend_extends</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span><span class=\"o\">)</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">set</span> <span class=\"n\">toMap</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n    <span class=\"n\">set</span> <span class=\"n\">fromMap</span> <span class=\"o\">:</span> <span class=\"n\">Y'</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"n\">extend</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"n\">j_cont</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">toMap</span> <span class=\"bp\">∘</span> <span class=\"n\">fromMap</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"k\">from</span> <span class=\"n\">congrFun</span> <span class=\"n\">this</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">unique_extend</span> <span class=\"n\">j_cont</span> <span class=\"o\">(</span><span class=\"n\">Function.comp.left_id</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y'</span><span class=\"o\">))</span> <span class=\"n\">continuous_id</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">unique_extend</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.comp.assoc</span><span class=\"o\">,</span> <span class=\"n\">extend_extends</span><span class=\"o\">,</span> <span class=\"n\">extend_extends</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span><span class=\"o\">)</span>\n  <span class=\"n\">continuous_toFun</span> <span class=\"o\">:=</span> <span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span>\n  <span class=\"n\">continuous_invFun</span> <span class=\"o\">:=</span> <span class=\"n\">cont_extend</span> <span class=\"n\">j_cont</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">StoneCechData</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CompactificationData</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">StoneCech</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">stoneCechUnit</span>\n  <span class=\"n\">j_cont</span> <span class=\"o\">:=</span> <span class=\"n\">continuous_stoneCechUnit</span>\n  <span class=\"n\">extend</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"bp\">↦</span> <span class=\"n\">stoneCechExtend</span> <span class=\"n\">hf</span>\n  <span class=\"n\">cont_extend</span> <span class=\"o\">:=</span> <span class=\"n\">continuous_stoneCechExtend</span>\n  <span class=\"n\">extend_extends</span> <span class=\"o\">:=</span> <span class=\"n\">stoneCechExtend_extends</span>\n  <span class=\"n\">unique_extend</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">Z</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">cont_g</span>\n    <span class=\"n\">beta_reduce</span>\n    <span class=\"n\">apply</span> <span class=\"n\">stoneCech_hom_ext</span> <span class=\"n\">cont_g</span> <span class=\"o\">(</span><span class=\"n\">continuous_stoneCechExtend</span> <span class=\"n\">hf</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">stoneCechExtend_extends</span> <span class=\"n\">hf</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 398553769,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698264468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"492938\">Matias Heikkilä</span> <a href=\"#narrow/stream/113489-new-members/topic/Feedback.20on.20a.20PR.20draft/near/398549616\">said</a>:</p>\n<blockquote>\n<p>I was planning to break this into smaller PRs. I'm hoping it's then possible to bring it to mathlib-level quality with reasonable amount of reviewer feedback</p>\n</blockquote>\n<p>I'm sure this will work.</p>",
        "id": 398554910,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1698265025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/Feedback.20on.20a.20PR.20draft/near/398553753\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"492938\">Matias Heikkilä</span> <a href=\"#narrow/stream/113489-new-members/topic/Feedback.20on.20a.20PR.20draft/near/398540762\">said</a>:</p>\n<blockquote>\n<p>I probably just mean the obvious statement <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> well I did get through the embedding proof though, could there be anything worthwhile in that?</p>\n</blockquote>\n<p>I think that discussing \"the obvious statement\" without ever stating it isn't very productive, so I wrote some Lean code. I put everything in <code>Type</code> to avoid distracting universe issues. First I define what it means that a compact separated <code>Y</code> has the universal property of a compactification of <code>X</code>. Then I build a homeomorphism between any two such compactifications <code>Y</code> and <code>Y'</code>, using only the definition (this is the abstract non-sense proof I was referring to). It would be easy to prove there is only one such homeomorphism compactible with the <code>j</code> maps. Then I prove that Stone-Cech has this property. Is that the uniqueness that you wanted?</p>\n</blockquote>\n<p>This seems to be the thing I was originally interested in, yes. Thanks for the Lean code too!</p>",
        "id": 398555711,
        "sender_full_name": "Matias Heikkilä",
        "timestamp": 1698265416
    }
]