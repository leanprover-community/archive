[
    {
        "content": "<p>I am still at the beginning of doing Lean proofs,  and am trying to balance clarity and brevity.  I am also trying to make things performant, so that if other portions need to use the code I write, my code should not be the bottleneck.</p>\n<p>With <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> of type Natural,  the statement I am using for practice is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>4</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><msup><mo stretchy=\"false\">)</mo><mi>n</mi></msup><mo>&gt;</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">(4/3)^n &gt; n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">4/3</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">n&gt;7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span>.  What would be more clear (more performant): trying to prove this statement, or trying to prove the (visibly) equivalent statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>4</mn><mi>n</mi></msup><mo>&gt;</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">4^n &gt; (n+1)3^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7035em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">4</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord\">3</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">n&gt;7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">7</span></span></span></span>?  Also,  how would a proof that the statements are equivalent look in Lean?  (My primary use case would involve the former statement,<br>\nbut I can be persuaded to modify my use case to use the latter.)</p>\n<p>As an aside, is there a proof of these statements \"not using induction\", meaning the induction is buried in a library somewhere and that one can reference a tool like \"This exponential function h(n) eventually gets and stays bigger than this linear function g(n), and a computable witness is n0\", so that the tool can return n0 (and a proof that h(n)&gt;g(n) when n&gt;= n0) given simple exponential expression for h and simple linear expression for g.\"  I am aware of (but not familiar with) linarith for certain comparisons involving linear functions, and I am not expecting a high powered tool that can handle an arbitrary exponential expression.</p>",
        "id": 538532650,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1757452171
    },
    {
        "content": "<p>I prefer 4/3 here given it is all constants. I might consider it differently if variables are inside the fraction</p>",
        "id": 538533287,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1757452521
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 538533366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757452544
    },
    {
        "content": "<p>If you want to stick with Nat instead of using the rationals, then <code>4^n &gt; (n + 1)*3^n</code> is a better statement. To go back and forth, there are tools such as <code>qify</code> to make this Nat statement into a rational one and then perhaps <code>field_simp</code> to clear denominators.</p>",
        "id": 538533758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757452675
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">qify</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">div_pow</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lt_div_iff₀</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 538534049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757452873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930113\">J. J. Issai (project started by GRP)</span> <a href=\"#narrow/channel/113489-new-members/topic/Benefits.20.28or.20not.3F.29.20of.20avoiding.20division.20and.20subtraction/near/538532650\">said</a>:</p>\n<blockquote>\n<p>so that the tool can return n0</p>\n</blockquote>\n<p>This sort of tool usually doesn't exist (yet). There are theorems sometimes that give that such numbers exist, but not what the number is. If the number exists, sometimes you can have Lean exhaustively find such a number, in very concrete situations.</p>",
        "id": 538534156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757452942
    },
    {
        "content": "<p>For biconditionals, the examples I have seen were split into forward and backward implications.  Where can I learn about  handling  both at the same time? I guess I am asking for a library of equivalences to use.</p>",
        "id": 538534784,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1757453294
    },
    {
        "content": "<p>The tactics I suggested rewrote both sides of the biconditional until they were the same. Yes, you can prove forwards and backwards implications, and that's the definition of biconditionals (so it's a proof technique you can always rely on), but tactics like <code>rw</code> can rewrite anything in the goal.</p>",
        "id": 538535113,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757453480
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  and <span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> .  I shall study this further.</p>",
        "id": 538535448,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1757453650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930113\">J. J. Issai (project started by GRP)</span> <a href=\"#narrow/channel/113489-new-members/topic/Benefits.20.28or.20not.3F.29.20of.20avoiding.20division.20and.20subtraction/near/538532650\">said</a>:</p>\n<blockquote>\n<p>As an aside, is there a proof of these statements \"not using induction\", meaning the induction is buried in a library somewhere and that one can reference a tool like \"This exponential function h(n) eventually gets and stays bigger than this linear function g(n), and a computable witness is n0\", so that the tool can return n0 (and a proof that h(n)&gt;g(n) when n&gt;= n0) given simple exponential expression for h and simple linear expression for g.\"  I am aware of (but not familiar with) linarith for certain comparisons involving linear functions, and I am not expecting a high powered tool that can handle an arbitrary exponential expression.</p>\n</blockquote>\n<p>I think <code>grind</code> can do most of that, but only for Nat-valued exponential and linear functions. For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">69</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>However, this short proof no longer works if you change the exponential function to something like <code>(3 : ℚ) ^ n</code>.</p>",
        "id": 538545813,
        "sender_full_name": "Anthony Wang",
        "timestamp": 1757459859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"910779\">Anthony Wang</span> <a href=\"#narrow/channel/113489-new-members/topic/Benefits.20.28or.20not.3F.29.20of.20avoiding.20division.20and.20subtraction/near/538545813\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"930113\">J. J. Issai (project started by GRP)</span> <a href=\"#narrow/channel/113489-new-members/topic/Benefits.20.28or.20not.3F.29.20of.20avoiding.20division.20and.20subtraction/near/538532650\">said</a>:</p>\n<blockquote>\n<p>As an aside, is there a proof of these statements \"not using induction\", meaning the induction is buried in a library somewhere and that one can reference a tool like \"This exponential function h(n) eventually gets and stays bigger than this linear function g(n), and a computable witness is n0\", so that the tool can return n0 (and a proof that h(n)&gt;g(n) when n&gt;= n0) given simple exponential expression for h and simple linear expression for g.\"  I am aware of (but not familiar with) linarith for certain comparisons involving linear functions, and I am not expecting a high powered tool that can handle an arbitrary exponential expression.</p>\n</blockquote>\n<p>I think <code>grind</code> can do most of that, but only for Nat-valued exponential and linear functions. For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">69</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>However, this short proof no longer works if you change the exponential function to something like <code>(3 : ℚ) ^ n</code>.</p>\n</blockquote>\n<p>I will give this a try.  How do I extract the proof from the results of using trivial and grind? (I want to produce a specific set of steps based on tactics like rw and calc and have, and I certainly don't mind having Lean give me these steps.)</p>",
        "id": 538948632,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1757627978
    },
    {
        "content": "<p>You can prefix tactics with <code>show_term</code> to see exactly what low-level proof they generated. (You can also use <code>by?</code> to see that for an entire tactic script.)</p>\n<p>However, tactics like <code>grind</code> do not create very interpretable proofs. That tactic in particular is optimized to prove things quickly and produce proofs that can be efficiently verified by the Lean kernel.</p>",
        "id": 538949625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757628610
    },
    {
        "content": "<p>The <a href=\"https://github.com/nomeata/lean-calcify\">calcify</a> tactic is able to try to convert proofs generated by <code>rw</code> and <code>simp</code> into <code>calc</code> proofs. To use it you have to include it in your project. (You can either add it to your lakefile, or I think you might be able to copy the single file <a href=\"https://github.com/nomeata/lean-calcify/blob/master/Calcify.lean\">https://github.com/nomeata/lean-calcify/blob/master/Calcify.lean</a> somewhere in your project and import it; it doesn't have any dependencies.)</p>",
        "id": 538949763,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1757628704
    }
]