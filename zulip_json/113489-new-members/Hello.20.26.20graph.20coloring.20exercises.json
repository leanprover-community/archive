[
    {
        "content": "<p>Hello, <br>\nmy name is Marcin Pilipczuk, I'm doing graph algorithms and graph theory at University of Warsaw. </p>\n<p>I started looking into Lean a while ago and, after completing some basic tutorials, I decided the best way to learn is to formalize some basic graph theory that is not yet in mathlib. Because of the multigraph and contraction discussions, I decided to avoid it while learning and focused on graph coloring, because it's a simple graph theory. </p>\n<p>I'm trying to use SimpleGraph from mathlib and the coloring, independent set, and clique definitions there. </p>\n<p>I started easy with a lemma \"number of vertices &lt;= chromatic number * independence number\" and immediately entered some Set vs Finset hell that makes me suspect I'm doing something wrong or, at least, against some basic design decisions I do not understand. Let me copy-paste my code so far, I would be very helpful with some hint how to proceed. (I guess the answer is some sort of RTFM, but I don't know where to look.) Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Fintype</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Some unimportant stuff needed because SimpleGraph can be infinite -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">finite_graph_chromaticNumber_ne_top</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber_ne_top_iff_exists</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">colorable_of_fintype</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">size_le_chromaticNumber_times_indepNumber</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hcol</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Colorable</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">colorable_of_chromaticNumber_ne_top</span><span class=\"w\"> </span><span class=\"n\">finite_graph_chromaticNumber_ne_top</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> Define optimum set of colors and coloring -/</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">opt_colors</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_opt_sufficient</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">opt_colors</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">opt_colors</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">opt_coloring</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Coloring</span><span class=\"w\"> </span><span class=\"n\">opt_colors</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hcol</span><span class=\"bp\">.</span><span class=\"n\">toColoring</span><span class=\"w\"> </span><span class=\"n\">h_opt_sufficient</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> Each color class is of size at most the independence number -/</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_cc_small</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↥</span><span class=\"n\">opt_colors</span><span class=\"o\">},</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">opt_coloring</span><span class=\"bp\">.</span><span class=\"n\">colorClass</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">opt_coloring</span><span class=\"bp\">.</span><span class=\"n\">colorClass</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cc_f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_cc_indep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsIndepSet</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">isIndepSet_iff</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">opt_coloring</span><span class=\"bp\">.</span><span class=\"n\">color_classes_independent</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> This fails if cc is replaced by cc_f -/</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_cc_indep</span><span class=\"bp\">.</span><span class=\"n\">card_le_indepNum</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> This works if h_cc_indep has cc_f instead of cc -/</span>\n<span class=\"w\">   </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> to be continued -/</span>\n</code></pre></div>",
        "id": 555427768,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1763057780
    },
    {
        "content": "<p>No this is not an RTFM question (also hi we met at Adfocs this year. I brought those hagoromo colour chalks for your lecture )</p>",
        "id": 555454933,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763066728
    },
    {
        "content": "<p>I am not on a machine  right now so I can’t solve your sorry right away. But try using Set and Set.encard</p>",
        "id": 555455542,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763066982
    },
    {
        "content": "<p>Instead of Finset</p>",
        "id": 555455560,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763066988
    },
    {
        "content": "<p>Hi, thanks for the reply! (Also, at ADFOCS you met my brother, Michał, not me ;-))</p>\n<p>I see that I was not specific about my question. I have troubles not in \"sorry\" but in finishing the \"h_cc_indep\" proof and \"h_cc_small\" proof; at the moment it does not work. Please look at the last two \"exact\" statements. The last one does not work because h_cc_indep is a statement about a Set cc, while it wants a Finset. On the other hand, if I change the h_cc_indep statement to speak about cc_f (i.e., a Finset), the penultimate exact does not work because color_classes_independent speaks about Sets. </p>\n<p>(The sorry in the end hides quite a bit, and I'm still working there.)</p>",
        "id": 555457234,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1763067620
    },
    {
        "content": "<p>I’ll give a more concrete response in about <del>30-40 mins</del> 2 hours then</p>",
        "id": 555457651,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763067743
    },
    {
        "content": "<p>Thanks a lot! (And no rush, it's 10PM here, I will be back in the morning.)</p>",
        "id": 555459188,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1763068288
    },
    {
        "content": "<p>So using <code>rw?</code> where indicated below, the first hit is a lemma that coerces the Finset -&gt; Set conversion to fix your proof of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_cc_indep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsIndepSet</span><span class=\"w\"> </span><span class=\"n\">cc_f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">isIndepSet_iff</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">coe_toFinset</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- rw? here</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">opt_coloring</span><span class=\"bp\">.</span><span class=\"n\">color_classes_independent</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>so the next exact goes through. As you noticed, the SimpleGraph lemma <code>card_le_indepNum</code> that you wanted to use required a Finset, while <code>G.IsIndepSet</code> takes a Set by default (or above a Finset also works with a coercion automatically added for you). I would say that generally hitting cases where you may have to convert Set/Finset may sometimes occur, especially in SimpleGraph where many lemmas are specialized for finite graphs.</p>",
        "id": 555462566,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1763069627
    },
    {
        "content": "<p>I actually wonder why you need the Finset N in the first place. Let me see if I can factor that out and write a simpler proof</p>",
        "id": 555466621,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763071310
    },
    {
        "content": "<p>Ideally, you should stick with either Set or Finset to avoid juggling both. If you need to convert one to another, because e.g. lemma you want to use needs Finset, but you're working with Set, then it's easier to separate conversion in a separate lemma. If e.g. you're working with Finset, but some function returns Set, than it's a bit more work, because you not only have to do conversion in definition, you also need to do conversion in every theorem about that definition.</p>\n<p>Instead of <code>Finset.range</code> I recommend using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> type for colorings (although it doesn't matter in this case).</p>\n<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.colorable_chromaticNumber_of_fintype#doc\">docs#SimpleGraph.colorable_chromaticNumber_of_fintype</a> to obtain <code>G.Colorable G.chromaticNumber.toNat</code>.</p>\n<p>It's easier to just use <code>G.chromaticNumber.toNat</code> instead of <code>G.chromaticNumber</code> in the statement as you're working only with finite graphs. Working with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat#doc\">docs#ENat</a> is kinda PITA.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">IsIndepSet</span><span class=\"bp\">.</span><span class=\"n\">ncard_le_indepNum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsIndepSet</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">finite_or_infinite</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">ncard_eq_toFinset_card</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">IsIndepSet</span><span class=\"bp\">.</span><span class=\"n\">card_le_indepNum</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">coe_toFinset</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">tc</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_le_mul_card_image_of_ncard_le</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_le_mul_card_image_of_maps_to</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">Hf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ncard_eq_toFinset_card'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">size_le_chromaticNumber_times_indepNumber</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Coloring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">colorable_chromaticNumber_of_fintype</span><span class=\"bp\">.</span><span class=\"n\">toColoring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_cc_small</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">colorClass</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ncard</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">colorClass</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_cc_indep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">IsIndepSet</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">isIndepSet_iff</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">color_classes_independent</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_cc_indep</span><span class=\"bp\">.</span><span class=\"n\">ncard_le_indepNum</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_le_mul_card_image_of_ncard_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_cc_small</span>\n</code></pre></div>",
        "id": 555486704,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763081788
    },
    {
        "content": "<p>Thanks a lot for all the answers, I have learned a lot :)</p>\n<p>A side remark: I see that my life would be significantly easier if SimpleGraph did not try to speak about infinite graphs (so, say, chromaticNumber will be a Nat not an ENat etc.). <br>\nIf I'm planning to stick to finite graphs only, is there a good way to leave such problems behind?<br>\nOr the correct way is to sort out the boring unwanted \"infinite case\" regularly?</p>",
        "id": 555526399,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1763108023
    },
    {
        "content": "<p>If you're working only with finite graphs you can specialize to the finite case. Otherwise if you do want the additional level of generality it shouldn't be too hard to find the right lemmas (or if it is, it may mean something simple is missing) e.g. to convert <code>G.chromaticNumber</code> to <code>G.chromaticNumber.toNat</code> in your example  I wrote the statement I wanted as a have and used apply? twice</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">size_le_chromaticNumber_times_indepNumber</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_toNat</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- found with apply?</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">finite_graph_chromaticNumber_ne_top</span><span class=\"w\"> </span><span class=\"c1\">-- found with exact?</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>then it's easy to compress it to a single</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">size_le_chromaticNumber_times_indepNumber</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">indepNum</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">ENat</span><span class=\"bp\">.</span><span class=\"n\">coe_toNat</span><span class=\"w\"> </span><span class=\"n\">finite_graph_chromaticNumber_ne_top</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 555528196,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1763108690
    },
    {
        "content": "<p>My understanding of the Mathlib design is to have things done at the maximum generality level, with lots of intermediate levels in the hierarchy of structures. Some notions can clearly be defined for potentially infinite <code>SimpleGraph</code>, but I believe most graph theorists only work with finite graphs, so it would probably be a good idea to either have a <code>FiniteSimpleGraph</code> structure, or many theorems that work with a <code>SimpleGraph V</code> together with a <code>[Fintype V]</code> assumption.</p>\n<p>(Another difficulty is that working with finiteness is not that easy, plus there are several different ways of specifying finiteness -- and as a beginner, I find it hard to know which one is the right one)</p>",
        "id": 555528558,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1763108820
    },
    {
        "content": "<p>and perhaps it would be nice to have this upstream just to make using e.g. <code>exact?</code>  ergonomic as it was above</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">finite_graph_chromaticNumber_ne_top</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">chromaticNumber_ne_top_iff_exists</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">colorable_of_fintype</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 555529191,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1763109037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/555528558\">said</a>:</p>\n<blockquote>\n<p>(...) so it would probably be a good idea to either have a <code>FiniteSimpleGraph</code> structure, or many theorems that work with a <code>SimpleGraph V</code> together with a <code>[Fintype V]</code> assumption.</p>\n</blockquote>\n<p>My understanding is that SimpleGraph lemmas choose the latter option. I will try to follow with this design decision.</p>",
        "id": 555531765,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1763109888
    },
    {
        "content": "<p>You might also want to have the Fintype on the neighbourSet of all vertices. Lean lets you write something like <code>[\\for all v : V, Finite (G.neighborSet v)]</code></p>",
        "id": 555558105,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763117623
    },
    {
        "content": "<p>It sounds counterintuitive but lean cannot (yet) immediately infer the edge relation being finite from the vertex set being finite.</p>\n<p>I think this is because in principle you could define the edge relation using undecidable problems (like  checking if two real numbers are equal)</p>",
        "id": 555558325,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763117685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/555558325\">said</a>:</p>\n<blockquote>\n<p>It sounds counterintuitive but lean cannot (yet) immediately infer the edge relation being finite from the vertex set being finite.</p>\n<p>I think this is because in principle you could define the edge relation using undecidable problems (like  checking if two real numbers are equal)</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.fintypeEdgeSet#doc\">docs#SimpleGraph.fintypeEdgeSet</a> does require <code>DecidableRel G.Adj</code>, but I think it should be possible to get <code>Finite G.edgeSet</code> (but not <code>Fintype</code>) even without decidability</p>",
        "id": 555622673,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1763135502
    },
    {
        "content": "<p>You would need the fintype to get a list that you can iterate on</p>",
        "id": 555637245,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1763139573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/555637245\">said</a>:</p>\n<blockquote>\n<p>You would need the fintype to get a list that you can iterate on</p>\n</blockquote>\n<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.ofFinite#doc\">docs#Fintype.ofFinite</a>. But you can only use it when proving <code>Finite G.edgeSet</code>, not <code>Fintype G.edgeSet</code>, because it's noncomputable.</p>",
        "id": 555645485,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1763142461
    },
    {
        "content": "<p>Thanks once again for all previous answers, they were very helpful. I continued with the exercises (meanwhile deciding that I need to go back to learning and read more in-depth about the core mechanics of Lean, so I read most of the \"Hitchhiker's guide to logical verification\"). </p>\n<p>I got stuck now at some other subtle typing problem that I'm unable to resolve. Can you give me some hints or pointers?</p>\n<p>I defined the concept of degeneracy:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">    </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d</span>\n</code></pre></div>\n<p>I proved a few lemmas about it and the \"subgraph of a d-degerate graph is d-degenerate\" turns out to be particularly challenging because of the number of types flying around. First, I gave up on pushing decidability through the entire proof (I admit I don't feel I fully understand this concept in Lean, and I'm not sure I care). <br>\nSecond, and more importantly, I'm stuck at the end with strange issues - I commented in Lean what the prover reports.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">degeneracy_subgraph_monotone</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h_Gdeg</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"n\">h_Kbot</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_K'bot</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">ne_bot_iff_nonempty_verts</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">ne_bot_iff_nonempty_verts</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_Kbot</span>\n<span class=\"w\">    </span><span class=\"n\">aesop_graph</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h_Gdeg</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"w\"> </span><span class=\"n\">h_K'bot</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv_mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv_deg</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hv_image</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hv_mem</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_in_K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hv_image</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx_in_K</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hv_deg</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_Kverts_equal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop_graph</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_neiSets_equal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_nei_iff_nei'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">aesop_graph</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">      </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">          </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">          </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">notMem_subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">neighborSet_subset_verts</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h₃</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_degrees_equal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">K'</span><span class=\"bp\">.</span><span class=\"n\">finset_card_neighborSet_eq_degree</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">finset_card_neighborSet_eq_degree</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_neiSets_equal</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"c1\">--  ⊢ #(image Subtype.val (K.neighborSet x).toFinset) = Fintype.card ↑(K.neighborSet x)</span>\n<span class=\"w\">      </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">card_eq_of_equiv_fintype</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">      </span><span class=\"c1\">--  ⊢ ↥(image Subtype.val (K.neighborSet x).toFinset) ≃ ↑(K.neighborSet x)</span>\n<span class=\"w\">      </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">h_degrees_equal</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Lean error:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Tactic `rewrite` failed: Did not find an occurrence of the pattern</span>\n<span class=\"w\">    </span><span class=\"c1\">--    K.degree x</span>\n<span class=\"w\">    </span><span class=\"c1\">-- in the target expression</span>\n<span class=\"w\">    </span><span class=\"c1\">--    K.degree x ≤ d</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For the first sorry, I dont know how to conclude, and the suggestions from apply? does not seem helpful for me. For the second one, I suspect some very subtle typing problem, because at first glance the error code seems absurd :)</p>\n<p>(If anybody prefers to look in github at the code, here is <a href=\"https://github.com/malcin541/chi_boundedness\">the repo</a>.)<br>\nThanks in advance.</p>",
        "id": 563469437,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765544724
    },
    {
        "content": "<p>I'll take a look at the repo, but it also really helps us when you post a minimal working example ( <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>)</p>",
        "id": 563472016,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765545527
    },
    {
        "content": "<p>Are you sure you aren't running into a <code>Subgraph</code> to <code>SimpleGraph</code> coercion error?</p>",
        "id": 563472615,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765545675
    },
    {
        "content": "<p>There are two ways to do this coercion at present both of which are highly suboptimal and reflect limitations of the SimpleGraph API not providing a vertex set and having a separate subgraph type in the first place</p>",
        "id": 563472815,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765545734
    },
    {
        "content": "<p>For the sorry at the bottom basically if you look at the explicit parameter list, you are probably running into a typeclass instance problem (or the Graph parameter to degree is wrong)</p>",
        "id": 563472948,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765545779
    },
    {
        "content": "<p>I'll download the repo and check my instincts here</p>",
        "id": 563473083,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765545818
    },
    {
        "content": "<p>Minor point ; If you are calling <code>import Mathlib</code> you don't need the other importants. They are redundant</p>",
        "id": 563473870,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765546065
    },
    {
        "content": "<p>Indeed, for the second sorry, <code>K.degree x</code> in <code>h_degrees_equal</code> is described as:<br>\n<code>@SimpleGraph.Subgraph.degree (↑H.verts) H.coe K x (K.instFintypeElemNeighborSetOfVertsOfDecidablePredMemSet x) : ℕ</code><br>\nwheas the one in the goal is <br>\n<code>@SimpleGraph.Subgraph.degree (↑H.verts) H.coe K x (Subtype.fintype (Membership.mem (K.neighborSet x))) : ℕ</code></p>",
        "id": 563474043,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765546115
    },
    {
        "content": "<p>the ugly workaround is to forcefeed the correct instance to <code>h_degrees_equal</code>, by writing it as <code>@h_degrees_equal ... ... ...</code></p>",
        "id": 563477324,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547048
    },
    {
        "content": "<p>and then you will almost certainly run into the fact that the instance is type incorrect so you have to derive a new fintype instance</p>",
        "id": 563477449,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547088
    },
    {
        "content": "<p>I learnt the hardway not to work with Fintypes like this (Well <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>  taught me quite a bit actually)</p>",
        "id": 563477560,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547114
    },
    {
        "content": "<p>Have you tried using the <code>IsSubgraph</code> predicate instead of using a <code>Subgraph</code>? That will save you some coercions in this theorem</p>",
        "id": 563477699,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563477699\">said</a>:</p>\n<blockquote>\n<p>Have you tried using the <code>IsSubgraph</code> predicate instead of using a <code>Subgraph</code>? That will save you some coercions in this theorem</p>\n</blockquote>\n<p>No, this may be a very good advice. I will try. Thanks.</p>",
        "id": 563478083,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765547262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563472815\">said</a>:</p>\n<blockquote>\n<p>There are two ways to do this coercion at present both of which are highly suboptimal and reflect limitations of the SimpleGraph API not providing a vertex set and having a separate subgraph type in the first place</p>\n</blockquote>\n<p>Does this indicate that I should ditch SimpleGraph and start playing with Graph (that appeared in Mathlib between my previous post a month ago and now :))?</p>",
        "id": 563478527,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765547375
    },
    {
        "content": "<p>No not really.</p>",
        "id": 563478589,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547386
    },
    {
        "content": "<p>The scale of API that exists for SimpleGraph is not matched by Graph</p>",
        "id": 563478677,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547408
    },
    {
        "content": "<p>What's missing in <code>SimpleGraph V</code> is a vertex set. I do this weird trick where I work entirely within <code>Subgraph</code>s (using the trivial Subgraph of an ambient SimpleGraph when required)</p>",
        "id": 563478853,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547451
    },
    {
        "content": "<p>But it also has limitations.</p>",
        "id": 563479148,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547529
    },
    {
        "content": "<p>There has been a lot of discussion, and I still maintain that <code>SimpleGraph V</code> should be refactored independent of what happens to <code>Graph</code> since in TCS we rarely venture into multigraphs (outside some weird intermediate constructions)</p>",
        "id": 563479434,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547610
    },
    {
        "content": "<p>For your problem this shouldn't matter though</p>",
        "id": 563479581,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765547651
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"972923\">@Marcin Pilipczuk</span> : may I make a PR to your repo within the next half an hour?</p>",
        "id": 563481414,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765548126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563481414\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"972923\">Marcin Pilipczuk</span> : may I make a PR to your repo within the next half an hour?</p>\n</blockquote>\n<p>Sure, thanks a lot!</p>",
        "id": 563481546,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765548160
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"972923\">@Marcin Pilipczuk</span> : Isn't the definition of degeneracy \"A graph has degenerecy <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> if in all subgraphs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span>, <strong>all</strong>  vertices of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> have degree <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">\\leq d </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>\", not just some vertex?</p>",
        "id": 563490051,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765550609
    },
    {
        "content": "<p>Ah sorry, I had a different definition in my mind</p>",
        "id": 563490512,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765550733
    },
    {
        "content": "<p>I think the definition is correct, <a href=\"https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)\">see wiki</a>. Equivalently, there is an order on the vertex set such that every vertex has at most d neighbors earlier in the order.</p>",
        "id": 563490727,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765550811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563479434\">said</a>:</p>\n<blockquote>\n<p>There has been a lot of discussion, and I still maintain that <code>SimpleGraph V</code> should be refactored independent of what happens to <code>Graph</code> since in TCS we rarely venture into multigraphs (outside some weird intermediate constructions)</p>\n</blockquote>\n<p>This is a tangential topic, but spectral graph theory naturally works on multigraphs (and has many applications in TCS), and I found multigraphs (at least, parallel edges) natural if you work with edge cuts and network flows. In the latter setting, you often contract some parts of the graph that you know are not separated by the solution you are looking for; you need to preserve edge multiplicities in this process to preserve cut costs. </p>\n<p>But yes, in many parts there is no reason to think about multigraphs, for example in almost all questions regarding vertex colorings. So I guess I agree with your final conclusion (with my newbie experience so far :)).</p>",
        "id": 563491828,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1765551081
    },
    {
        "content": "<p>Oh I agree about the flows stuff (I actually have a half baked flow repo that is public, to test my new definition of a Walk)</p>",
        "id": 563493520,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765551543
    },
    {
        "content": "<p>But I am also not sure we can't just use homomorphisms to preserve all that information</p>",
        "id": 563493662,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765551578
    },
    {
        "content": "<p>The multigraphs there are usually pictorial devices we use to represent the idea that we store the data of the contracted vertices. When implementing them we would also probably just use some disjoint set structure for vertices where a bunch of vertices point to a new collective vertex. We wouldn't actually create a new multigraph and copy all that information over.</p>",
        "id": 563493887,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765551628
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 563500320,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765553155
    },
    {
        "content": "<p>Issue resolved. I made a PR to Marcin's repository : <a href=\"https://github.com/malcin541/chi_boundedness/pull/1\">https://github.com/malcin541/chi_boundedness/pull/1</a></p>\n<p>To all (apart from me and Marcin) : Please don't discuss this PR here, since Marcin wants to make his own attempt before reading this code. My DM is open for discussing it.</p>",
        "id": 563525418,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765559845
    },
    {
        "content": "<p>The <code>SimpleGraph.Subgraph.coeSubgraph</code> API is very underdeveloped. Here is some additional material that will help with the original approach (vs Shreyas's, which, sensibly, uses IsSubgraph instead of the DTT hell of subtypes), plus a small redefinition of <code>IsDegenerate</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">    </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">map_hom_bot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- copied proof from SimpleGraph.Subgraph.map_hom_top</span>\n<span class=\"w\">  </span><span class=\"n\">aesop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">Relation</span><span class=\"bp\">.</span><span class=\"n\">Map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">edge_vert</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">degree_coeSubgraph</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"bp\">.</span><span class=\"n\">Subgraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">G'</span><span class=\"bp\">.</span><span class=\"n\">coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">degree</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">coeSubgraph</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">finset_card_neighborSet_eq_degree</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">transitivity</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">neighborSet</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Embedding</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Relation</span><span class=\"bp\">.</span><span class=\"n\">Map</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">toFinset_card</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Here's the monotonicity theorem, behind a spoiler tag.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">degeneracy_subgraph_monotone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G.Subgraph</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"n\">H.coe</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fintype.ofFinite</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">hK</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">K.verts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimpleGraph.Subgraph.coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">verts</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Set.Finite.subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set.toFinite</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph.Subgraph.coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hK</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph.Subgraph.coeSubgraph_injective</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H.coeSubgraph</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">  </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>\n</div></div>",
        "id": 563530938,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765561479
    },
    {
        "content": "<p>I am not actually sure this is DTT hell. We get those in walks. This is some combination of coercion hell and multiple instances for the same typeclass not being reported by lean as a potential source of error</p>",
        "id": 563532208,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765561940
    },
    {
        "content": "<p>Like I think rw and rewrite should be able to tell when the mismatch occurs in a typeclass instance and say “look you have two instances … and .. for this typeclass, maybe that is an error”</p>",
        "id": 563532525,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765562070
    },
    {
        "content": "<p>Shreyas, if coercions and subtypes aren't DTT hell, then not much is left. This seems like splitting hairs for something that's not a technical definition anyway.</p>",
        "id": 563532829,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562186
    },
    {
        "content": "<p>I didn't run into any multiple instance problems in what I wrote for what it's worth. Possibly it's because I switched as quickly as possible to <code>Finite</code> as I could, in a way I'd already learned to avoid <code>Fintype</code> issues.</p>",
        "id": 563533119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562292
    },
    {
        "content": "<p>Fair. To continue my message about error messages :  Another source of errors  is when th user gives an instance declaration in their theorem statement but lean can already infer the instance. Then the error gets cryptic. But lean knows when it has inferred an instance. It also knows that the clash of values in rewrite is for a typeclass instance. The error message should say “look I used my inferred instance. Maybe you don’t need this declared instance”</p>",
        "id": 563533223,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765562325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563532525\">said</a>:</p>\n<blockquote>\n<p>Like I think rw and rewrite should be able to tell when the mismatch occurs in a typeclass instance and say “look you have two instances … and .. for this typeclass, maybe that is an error”</p>\n</blockquote>\n<p>They do have this, it's the \"failed to assign instance [...] synthesized value [...] is not definitionally equal to [...]\" error.</p>",
        "id": 563533331,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562366
    },
    {
        "content": "<p>It probably could be better, but the mechanism is there.</p>\n<p>Fundamentally Lean is assuming you don't have overlapping instances, even though <code>DecidableEq</code> and <code>Fintype</code> often violate this.</p>",
        "id": 563533512,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562437
    },
    {
        "content": "<p>It’s not a helpful error message for newcomers. Maybe I am splitting hairs about presentation, but in rust you always get some suggestion about possible fixes. I know lean can’t give deterministically correct suggestions here, but a heuristic would still help.</p>",
        "id": 563533598,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765562473
    },
    {
        "content": "<p>Oh right, there's the other side to rewriting failing. Somewhere I have a PR for <code>rw</code> that tries to identify when typeclass arguments are the cause for the mismatch.</p>",
        "id": 563533703,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562516
    },
    {
        "content": "<p>(You're replying with objections faster than I can finish my messages. This message was meant to be a quick followup to the \"synthesized value not defeq\" message)</p>",
        "id": 563533786,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1765562546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/563532829\">said</a>:</p>\n<blockquote>\n<p>Shreyas, if coercions and subtypes aren't DTT hell, then not much is left. This seems like splitting hairs for something that's not a technical definition anyway.</p>\n</blockquote>\n<p>I'm not sure what we define as DTT hell, but for me, coercions and subtypes are mostly just annoying boilerplate. For me DTT hell, is when e.g. <code>cases</code> or <code>match</code> fail because of some dependant types.</p>",
        "id": 563571538,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765578840
    },
    {
        "content": "<p>One small request: let’s please move the messages starting from mine about DTT hell to a different thread in, say general, since it’s about error messages and common debugging issues. Let’s keep this thread for Marcin’s questions about his code, and our responses.</p>",
        "id": 563574681,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1765581028
    },
    {
        "content": "<p>Hi All, </p>\n<p>thanks again a lot for your comments.</p>\n<p>I went back to the roots, made almost all exercises in <a href=\"https://perfect-math-class.leni.sh/\">this course</a>, and went back to work from scratch. This time I was able to easily navigate around the previous problems, <a href=\"https://github.com/malcin541/chi_boundedness/blob/master/ChiBoundedness/Degeneracy.lean\">this is the result</a>. I feel quite confident now slowly producing working Lean proofs ;-)</p>\n<p>One of the next steps would be to learn to write better Lean code by trying to golf / clean up the code to make it mathlib-ready. Does it make sense? (I know it is probably a long way ;) - I was not thinking about it so far while coding).</p>",
        "id": 575270955,
        "sender_full_name": "Marcin Pilipczuk",
        "timestamp": 1771843599
    },
    {
        "content": "<p>Yes, golfing your own proofs is a very good exercise. Some ideas: get rid of by exact everywhere. Everywhere you use <code>suffices h : ... by exact foo h</code> you can replace that with <code>refine foo ?_</code> You acn also compress things a little more when you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>to <code>refine \\&lt;v, hv, ?_\\&gt;</code> then your <code>...</code></p>",
        "id": 575287576,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1771849860
    },
    {
        "content": "<p>Also here's a lemma of yours I rewrote to be shorter and stated slightly more canonically</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">empty_zero_degenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emptyGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">ne_bot_iff_nonempty_verts</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">degree_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">degree</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 575287732,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1771849922
    },
    {
        "content": "<p>Normally one should try to avoid looking under definitions, e.g. by rewriting with <a href=\"http://SimpleGraph.degree\">SimpleGraph.degree</a> above, but the use of <code>Fintype</code> is causing some issues here I needed to work around.</p>",
        "id": 575287983,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1771850024
    },
    {
        "content": "<p>Another idea: you are constantly essentially doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">ne_bot_iff_nonempty_verts</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n</code></pre></div>\n<p>maybe this should just be an iff lemma instead of invoking it everytime?</p>",
        "id": 575289102,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1771850455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/113489-new-members/topic/Hello.20.26.20graph.20coloring.20exercises/near/575287732\">said</a>:</p>\n<blockquote>\n<p>Also here's a lemma of yours I rewrote to be shorter and started slightly more canonically</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">empty_zero_degenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsDegenerate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emptyGraph</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">ne_bot_iff_nonempty_verts</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hne</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"n\">grw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subgraph</span><span class=\"bp\">.</span><span class=\"n\">degree_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">egree</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Also, it's a good idea to get used to the mathlib naming convention: for example, this should be called <code>isDegenerate_emptyGraph</code></p>",
        "id": 575294936,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1771852308
    }
]