[
    {
        "content": "<p>I have been trying to get a better understanding of inductive types. I was messing around with <code>Eq</code> and its recursor and discovered that the type displayed by <code>#check @Eq.rec</code> is not accepted by lean 4 (or at least it has a red underline in vs code). Is this a bug or intentional? What would its actual type be?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">I added new lines after each \"→\" to make it more readable</span>\n\n<span class=\"cm\">@Eq.rec :</span>\n<span class=\"cm\">    {α : Sort u_2} → {a : α} →</span>\n<span class=\"cm\">    {motive : (a_1 : α) → a = a_1 → Sort u_1} →</span>\n<span class=\"cm\">    motive a (_ : a = a) →</span>\n<span class=\"cm\">    {a_1 : α} →</span>\n<span class=\"cm\">    (t : a = a_1) →</span>\n<span class=\"cm\">    motive a_1 t</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">my_eq_rec</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    don't know how to synthesize placeholder</span>\n<span class=\"cm\">    context:</span>\n<span class=\"cm\">    α : Sort u_2</span>\n<span class=\"cm\">    a : α</span>\n<span class=\"cm\">    motive : (a_1 : α) → a = a_1 → Sort u_1</span>\n<span class=\"cm\">    ⊢ a = a</span>\n<span class=\"cm\">    when the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span>  <span class=\"c1\">-- &lt;- error is here at the underscore</span>\n    <span class=\"o\">{</span><span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">motive</span> <span class=\"n\">a_1</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span>\n</code></pre></div>",
        "id": 363387354,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1685829772
    },
    {
        "content": "<p>The pretty printer doesn't show all proofs by default, and it replaces them with <code>_</code>. I think it's <code>set_option pp.proofs true</code> to get them to pretty print.</p>",
        "id": 363388395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685830365
    },
    {
        "content": "<p>A hint: you should expect the constructor <code>Eq.refl</code> to show up somewhere in the recursor</p>",
        "id": 363388822,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685830587
    },
    {
        "content": "<p>If you want pretty printer output that's most likely to typecheck when you paste it back into your code (though it can be verbose), there's <code>set_option pp.all true</code></p>",
        "id": 363389197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685830780
    },
    {
        "content": "<p>Setting <code>set_option pp.proofs true</code> worked and the displayed type worked when copied into lean.</p>\n<p>Just to make sure I understand whats actually going on with inductive types. When I declare an inductive type like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Qe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>behind the scenes lean creates the following functions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Qe</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- exists by definition of inductive types</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Qe.refl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- exists by definition of inductive types</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Qe.rec_not_parameterized</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Qe.refl</span> <span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"o\">({</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- exists by definition of inductive types</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">an effictively equivalent but syntactically simplified version of `Qe.rec_not_parameterized`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Qe.rec</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"c1\">-- a can be extracted since it would be a parameter to everything below</span>\n    <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Qe.refl</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"c1\">-- b can be extracted since it would be a parameter to everything below</span>\n    <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Qe</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>  <span class=\"c1\">-- derived from Qe.rec_not_parameterized</span>\n</code></pre></div>\n<p>And the recursor function is then used behind the scenes when using <code>match [varname] with ...</code>.</p>\n<p>Is that correct?</p>",
        "id": 363403593,
        "sender_full_name": "Petur Vetle",
        "timestamp": 1685840888
    },
    {
        "content": "<p>I've never seen <code>rec_not_parameterized</code> before, to be completely honest. My understanding is that in your example, <code>Qe</code>, <code>Qe.refl</code>, and <code>Qe.rec</code> are the true basic definitions associated to an inductive type. <code>Qe.rec</code> is corresponding to the type with one parameter and one index. The <code>Qe.rec_not_parameterized</code> looks like what the recursor would be if you had two indices, which is sometimes more convenient and sometimes less. For this type, I believe you can derive one from the other.</p>\n<p>There are also other things Lean generates on top of these, like <code>Qe.no_confusion</code>. There's some system in Lean 4 where it will lazily generate these supporting functions as you need them, and I'm not sure what the full suite of such functions are.</p>",
        "id": 363419162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1685852798
    }
]