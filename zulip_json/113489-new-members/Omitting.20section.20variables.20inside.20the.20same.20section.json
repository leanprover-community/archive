[
    {
        "content": "<p>I wish the following code type checks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"c1\">-- this does not typecheck</span>\n<span class=\"w\">  </span><span class=\"c1\">-- def m: M A := a -- this typechecks</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>where the definition <code>M</code> inside the section uses a section variable <code>A</code>, and when this definition is used \"inside\" the same section, I don't have to provide <code>A</code> again.<br>\nWould it be already possible to do this in Lean? I relied a lot on and loved this feature when I was using Coq, which not just reduced few keystrokes but also made the code shorter and more elegant.<br>\nThis is especially useful when you later add a new parameter to a series of functions (that can call each other) without devastatingly modifying the code.</p>",
        "id": 491459470,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735695804
    },
    {
        "content": "<p>One way to add a parameter to a large collection of functions at once is to move them all within a <code>Reader</code> monad, and then you can have a structure with all the configuration that you can add fields to in just one place.</p>",
        "id": 491462318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735698763
    },
    {
        "content": "<p>That won't help much with parametrized types though!</p>",
        "id": 491462319,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735698764
    },
    {
        "content": "<p>The feature you're asking for existed in Lean 3 as <code>parameter</code> instead of <code>variable</code>, but it was not inherited by Lean 4: presumably due to a combination of lack of interest and surprising behavior</p>",
        "id": 491462361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735698839
    },
    {
        "content": "<p>What I did in a similar situation was to declare a structure (or a class) that holds inputs as fields, and define stuff like <code>M</code> as a function that takes structure. <br>\n<a href=\"https://zenn.dev/pandaman64/articles/lean-proof-data-en\">https://zenn.dev/pandaman64/articles/lean-proof-data-en</a></p>",
        "id": 491471392,
        "sender_full_name": "pandaman",
        "timestamp": 1735708379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"395416\">@pandaman</span> Thank you for the suggestions! I agree that these workarounds could be useful, but that does not cover my cases.</p>",
        "id": 491645817,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735840932
    },
    {
        "content": "<p>As a person who really loves this feature, it is interesting that this feature existed before and got dropped. It would be great if one can at least reimplement \"parameter\" as a user library in Lean4.</p>",
        "id": 491646184,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735841104
    },
    {
        "content": "<p>In what way does it not cover your use case? The \"module\" class approach should be strictly more powerful and convenient, crucially it also allows for reopening the section and accessing declarations instantiated for a given set of parameters</p>",
        "id": 491646638,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1735841344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Can you elaborate on the \"module class approach\"?</p>",
        "id": 491647827,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735841990
    },
    {
        "content": "<p>I think <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> is describing the one that <span class=\"user-mention silent\" data-user-id=\"395416\">pandaman</span> blogged about above</p>",
        "id": 491648775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735842527
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Am I correct that we are discussing something like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Params</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">  </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span>\n\n<span class=\"kn\">section</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Params</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">useA</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Params</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"c1\">-- \"a\" does not typecheck - why?</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">useB</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Params</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">useAB</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Params</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Params</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">useA</span>\n</code></pre></div>\n<p>I have been using this pattern when the set of parameters form a clear semantic unit and they always go together. But in most other cases, I ended up using <code>variable (a: A) (b: B)</code>. In my recollection, the reasons are as follows:<br>\n(1) There is an additional obligation to define such a class (<code>Params</code>).<br>\n(2) I would want <code>useA</code> to rely on parameter <code>A</code> but not <code>B</code>. In this simple case, it should be possible to split these into different sections, but I have cases where I quantify over multiple variables and then define and prove multiple auxiliary derived definitions on top of them in the same section. I want each of these auxiliary definitions and theorems around them to quantify over just the needed ones, automatically (without me needing to figure those out).<br>\n(3) I don't want my final definitions to have typeclass quantification (too much typeclass caused tricky unexpected performance issues). It should be possible to achieve this but I am afraid it will be tedious.</p>\n<p>This is a question: I think <code>a</code> and <code>b</code> (instead of <code>Params.a</code> and <code>Params.b</code>) should work in the above code snippet, but it doesn't. Apparently I made some stupid mistake - do you have any idea?</p>",
        "id": 491665809,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735851779
    },
    {
        "content": "<p>I'm not quite satisfied with my approach either and I hope there is a better guide than mine. For me, there are some usability issues like</p>\n<ul>\n<li>the interaction with case analysis is manual, and I needed to introduce separate classes for each branch by hand</li>\n<li>the fields of the \"module\" class are definitionally equal to variables in my theorem statements, but not equal-that-rw-and-simp-recognize so manipulations of the terms were less than ideal</li>\n<li>Classes don't work well with nested dot notations: <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Nested.20dot.20notation.20fails.20with.20type.20classes\">#general &gt; Nested dot notation fails with type classes</a> </li>\n</ul>\n<p>Still, it at least allows some proof reuse that is crucial for my project.</p>",
        "id": 491704674,
        "sender_full_name": "pandaman",
        "timestamp": 1735880316
    },
    {
        "content": "<p>I also found that, in my mental model, the behavior of <code>parameter</code> is more natural and gives me less cognitive compared to <code>variable</code>. In my mental model, <code>parameter</code> and <code>def</code> in the top-level command roughly corresponds to function arguments and let binding in the kernel term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">parameter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"n\">chunk_of_code</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">===&gt;</span>\n<span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">chunk_of_code</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here, the behavior of <code>parameter</code> is congruent the behavior of the function arguments (e.g., <code>#check (fun (A: Type) (a: A) =&gt; let M := A; let m: M := a; (M, m))</code> typechecks), and it is easy for me to understand. If you want to access <code>chunk_of_code</code> outside the section, you need to provide the section parameters just as the user of the function provides arguments - this behavior is also congruent.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">body</span>\n<span class=\"n\">chunk_of_code</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">===&gt;</span>\n<span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">chunk_of_code</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Also, <code>chunk_of_code</code> typechecks the same way regardless of whether <code>A</code> is <code>parameter</code> or <code>def</code>, just like <code>chunk_of_code</code> typechecks the same way regardless of whether <code>A</code> is a function argument or let-bound. I think this is a desirable property and definitely lessens my cognitive overhead.</p>",
        "id": 492357679,
        "sender_full_name": "Youngju Song",
        "timestamp": 1736272194
    }
]