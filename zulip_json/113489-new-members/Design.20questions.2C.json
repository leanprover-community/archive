[
    {
        "content": "<p>I've been working on learning Lean the past week and I started by developing some graph objects and operations on graphs.  I've learned a lot and I think that I'm finally getting used to using Lean.  However, after ironing out a lot of the details and finishing all of the proofs about correctness I decided it was time to take a step back and think about the proper way to do things.</p>\n<p>While developing the notion of a graph, I first started out with a structure that had a list of vertices and a list of edges.  But then I realized that I needed more structure than that.  The list of vertices needed to have no duplicates <code>no_dups</code> and be non empty <code>nonempty</code>, while the list of edges needed to have their endpoints in the list of vertices <code>closure</code>.  So, I decided to package those properties up in the definition of a graph, but later moved those properties into the definition of a<code> Vertex_List</code> and an <code>Edge_List</code>.  See below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">@[ext]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vertex_List</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">no_dups</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span><span class=\"o\">),</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">u.name</span> <span class=\"bp\">=</span> <span class=\"n\">v.name</span> <span class=\"bp\">→</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Edge_List</span> <span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Vertex_List</span><span class=\"o\">):=</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices.l</span> <span class=\"bp\">∧</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices.l</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Vertex_List</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">Edge_List</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n</code></pre></div>\n<p>One of the problems (maybe it's not a problem?) is that every time that I write a program to operate on a Graph (like <code>add_edge</code>, <code>add_vertex</code>, etc.), I have to prove that the result is a graph inside the program.  Hence, every program I create has to include the proofs  <code>nonempty</code>, <code>no_dups</code>,  and <code>closure</code>.  It quickly became laborious.  </p>\n<p>So after researching other people's implementation of Graphs, I began noticing that other definitions of graphs are missing proofs.  E.g. </p>\n<p><a href=\"https://github.com/PeterKementzey/graph-library-for-lean4/blob/master/Graph/Graph.lean\">Graph Theory Library I found</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">weight</span> <span class=\"o\">:</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">payload</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">adjacencyList</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Edge</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">Vertex</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"o\">{</span> <span class=\"n\">payload</span> <span class=\"o\">:=</span> <span class=\"n\">default</span> <span class=\"o\">}</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Graph.Vertex</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n</code></pre></div>\n<p>This person used an adjacency list but I can't find any proofs about the list being <code>nonempty</code> or <code>no_dups</code>.   Using an adjacency list seems to eliminate the need for <code>closure</code>.   </p>\n<p>When I look at the notion of a simple graph in Mathlib, it's nice how some of the proofs were packaged into <code>symmetric</code> and <code>irreflexive</code>, but I still don't see a proof that there are no parallel edges.  </p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/9b33e5f30c5f161e1d1b16b6b9b922bf49943377/src/combinatorics/simple_graph/basic.lean#L90\">Mathlib Simple Graph</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It feels like I'm doing something fundamentally wrong and it's difficult for me to see at this time how these definitions on graphs capture all of the properties that they need to have.  Can someone help me see a better way to write?  I'm mainly worried that when I get to defining something like the augmenting path algorithm that I'm going to have 300+ lines of code that are just proofs.  How can we mitigate the excessive amounts of coding proofs?</p>",
        "id": 359952830,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684613446
    },
    {
        "content": "<p>Here is a bit of empty philosophical remarks, that hopefully help answer some of your questions.</p>\n<p>When formalizing mathematics, it tends to be simplest to avoid putting in conditions (proofs), for as long as you can.  You started with graphs, though I think that most people come across this with division by zero.  What happens there is that you simply define division between <em>any</em> two real numbers, with the convention that when the denominator is <code>0</code>, the result is <code>0</code>.</p>\n<p>Of course, not all theorems about divisions of real numbers are true for this \"extended division\", but it turns out that a surprising amount still are.  The gain is that a lot of the theorems about division do not have the hypothesis that the denominator is non-zero.  In turn, this means that when you apply these results, you do not need to prove that your denominator is non-zero!  Of course, when you want to use that a number times its inverse equals 1, this specific theorem will have the non-zero assumption.  But most of the time, you can work with division without worrying about this.</p>",
        "id": 359954310,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684614357
    },
    {
        "content": "<p>In the specific case of <code>simple_graph</code>, the parallel edges are excluded by design choice: the \"edges\" <em>are</em> the relation <code>adj</code>: if the relation holds between a pair, then there is an edge, if it doesn't, then there isn't.  There is no further possibility!</p>\n<p>This is another way on which design choices affect how easy or hard it is to proceed: finding a good implementation of a mathematical concept is <strong>hard</strong>.  Making a good choice means that you will be able to formalize results more easily.</p>",
        "id": 359954642,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684614569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"472585\">@Jonathan Whitehead</span> writing definitions is <em>really hard</em> and is not really a good first project for a beginner. What exactly is wrong with just using mathlib's definition of a simple graph? What do you mean by parallel edges? <code>adj</code> is prop-valued, so <code>adj v w</code> is either true (there's an edge) or false (there's no edge). Does that answer your question?</p>",
        "id": 359954739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684614626
    },
    {
        "content": "<p>When I am teaching undergraduates to use the software I first get them to write a gazillion proofs, with no definitions at all.</p>",
        "id": 359954775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684614652
    },
    {
        "content": "<p>The more you formalize, the more you will appreciate the difference between the platonic idea of what the mathematical concept is and what is the best way of implementing it.</p>",
        "id": 359954786,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684614659
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359954739\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> writing definitions is <em>really hard</em> and is not really a good first project for a beginner. What exactly is wrong with just using mathlib's definition of a simple graph? What do you mean by parallel edges? <code>adj</code> is prop-valued, so <code>adj v w</code> is either true (there's an edge) or false (there's no edge). Does that answer your question?</p>\n</blockquote>\n<p>Before I started trying to create my own definitions, I couldn't even read the Mathlib definitions.  For me, it's not a good learning experience to start with the fully developed ideas in the Mathlib library.  In fact, that's why a lot of tutorials for theorem provers start out by building their own version of the natural numbers and arithmetic operations.  After working through some tutorials on theorem provers, they all teach you how to handle objects that are defined inductively, which seems to be easier.  But when you come to a more advanced library, most of the objects aren't defined inductively, and learning how to work with these other kinds of objects just isn't explained very well in the tutorials I've used.   There's a lot of reasons why I wouldn't make it very far in my first project if I started with the Mathlib library.</p>",
        "id": 359956367,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684615625
    },
    {
        "content": "<p>In addition, I also don't understand why the library starts with a simple graph.  A lot of the exercises that I want to prove/formalize aren't even about simple graphs.  So I need a definition of a Graph.</p>",
        "id": 359957377,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684616197
    },
    {
        "content": "<p>A quick remark: your <code>no_dups</code> condition is equivalent to true (i.e. it doesn't add any constraints)</p>",
        "id": 359958340,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684616797
    },
    {
        "content": "<p>Also, what I meant by parallel edges was that the adjacency list tells me that if v ~ u, then there exists an edge between v and u.  But it doesn't tell me that there exists precisely one edge between v and u.</p>",
        "id": 359958359,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684616816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359958340\">said</a>:</p>\n<blockquote>\n<p>A quick remark: your <code>no_dups</code> condition is equivalent to true (i.e. it doesn't add any constraints)</p>\n</blockquote>\n<p>This is a good example of something that I would encounter in the Mathlib definitions.   I would not know what this meant or how to show/prove it.  I still can't say that I know what you mean.  Are you saying that the field <code>no_dups : &lt;proof statement&gt;</code> is equivalent to <code>no_dups : true</code>?</p>",
        "id": 359958672,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684616996
    },
    {
        "content": "<p>Yes. But perhaps to be more clear, I'm saying that your definition considers <code>[v, v ]</code> to have no duplicates</p>",
        "id": 359958938,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684617178
    },
    {
        "content": "<p>Jonathan, you probably want to quantify over elements of <code>l</code> not of <code>Vertex</code>.</p>",
        "id": 359958978,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617212
    },
    {
        "content": "<p>That's not the issue Damiano</p>",
        "id": 359959005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684617236
    },
    {
        "content": "<p>The problem is that <code>u.name = v.name</code> already implies <code>u = v</code> for every possible u and b.</p>",
        "id": 359959073,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684617269
    },
    {
        "content": "<p>Sorry, I meant the indices of elements of <code>l</code>!</p>",
        "id": 359959108,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359954642\">said</a>:</p>\n<blockquote>\n<p>In the specific case of <code>simple_graph</code>, the parallel edges are excluded by design choice: the \"edges\" <em>are</em> the relation <code>adj</code>: if the relation holds between a pair, then there is an edge, if it doesn't, then there isn't.  There is no further possibility!</p>\n<p>This is another way on which design choices affect how easy or hard it is to proceed: finding a good implementation of a mathematical concept is <strong>hard</strong>.  Making a good choice means that you will be able to formalize results more easily.</p>\n</blockquote>\n<p>I think I see what you're saying here.  With division by zero, I imagine there are a lot of statements with proofs that don't depend on the denominator being non-zero.  But in graph theory, a lot of statements about simple graphs need the requirement that only one edge exists between the vertices.  So, what happens when you want to prove these statements?  Do you have to create a <code>structure Simple_Graph_Extended</code> with the additional field that there are no parallel edges?</p>",
        "id": 359959141,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684617311
    },
    {
        "content": "<p>Let me try to say this better: different índices of <code>l</code> correspond to different elements of <code>Vertex</code>.</p>",
        "id": 359959250,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359959250\">said</a>:</p>\n<blockquote>\n<p>Let me try to say this better: different índices of <code>l</code> correspond to different elements of <code>Vertex</code>.</p>\n</blockquote>\n<p>Are you saying that <code>l</code> should be a <code>List String</code> instead of <code>List Vertex</code>?</p>",
        "id": 359959520,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684617568
    },
    {
        "content": "<p>Then I could remove <code>Vertex</code></p>",
        "id": 359959540,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684617589
    },
    {
        "content": "<p><code>simple_graph</code> already models a graph with no parallel edges.  You seem to be interpreting <code>adj</code> as saying \"is there at least one edge between these two vertices\", whereas it is \"is there one or no edge between them\".</p>",
        "id": 359959621,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617634
    },
    {
        "content": "<p>The issue that Eric pointed out is that two elements of <code>Vertex</code> with the same <code>name</code> are equal, whether you ask for it or not.  This is the extensionality question that you asked earlier.</p>",
        "id": 359959714,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359958340\">said</a>:</p>\n<blockquote>\n<p>A quick remark: your <code>no_dups</code> condition is equivalent to true (i.e. it doesn't add any constraints)</p>\n</blockquote>\n<p>Okay, I think I see what you're saying now.  So <code>no_dups : Vertex.mk.injEq </code> instead of the statement I have.  At the time I didn't know <code>Vertex.mk.injEq</code>  existed</p>",
        "id": 359959799,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684617767
    },
    {
        "content": "<p>What you probably meant is that your list of vertices should contain no duplicates.</p>",
        "id": 359959833,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359959833\">said</a>:</p>\n<blockquote>\n<p>What you probably meant is that your list of vertices should contain no duplicates.</p>\n</blockquote>\n<p>Yeah</p>",
        "id": 359959847,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684617830
    },
    {
        "content": "<p>What you told lean is that if you take two vertices that are in your list and have the same name, then they are the same.  Eric was saying: two vertices with the same name are the same, regardless of whether they are in your list or not.</p>",
        "id": 359959969,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617915
    },
    {
        "content": "<p>So, your <code>no_dups</code> condition is vacuous and not what you meant it to be.</p>",
        "id": 359960066,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684617976
    },
    {
        "content": "<p>And what Damiano is saying is that the correct condition is \"if two nodes are equal then they are at the same index in <code>l</code>\"</p>",
        "id": 359961125,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684618749
    },
    {
        "content": "<p>But mathlib already has this; it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nodup\">docs#list.nodup</a></p>",
        "id": 359961139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684618764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359957377\">said</a>:</p>\n<blockquote>\n<p>In addition, I also don't understand why the library starts with a simple graph.  A lot of the exercises that I want to prove/formalize aren't even about simple graphs.  So I need a definition of a Graph.</p>\n</blockquote>\n<p>I can answer that. Simple graphs were fairly clear how to define (though even so there were some initial difficulties coming up with it), and there are a number of ways one can define a multigraph, so we decided to start with simple graphs and see how the library developed before trying to have some theoretical depth in too many combinatorial objects at the same time.</p>\n<p>Another reason is that math textbooks about graph theory tend to be about simple graphs, so may as well start there.</p>\n<p>Something that might not be initially obvious is that the <code>adj</code> relation is equivalent to <code>set (V × V)</code>. The way this goes is <code>set (V × V) = (V × V -&gt; Prop) ≈ (V -&gt; V -&gt; Prop)</code>, where the equivalence is from currying, and the equality is the definition of <code>set</code>. This explains why there are no multiple edges: it's a <em>set</em> of pairs, two per edge (individual elements of this set are called \"darts\", and they're given by <code>simple_graph.dart</code>).</p>",
        "id": 359962558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684619790
    },
    {
        "content": "<p>The <code>symmetric</code> axiom let you pretend that this is a set of <em>unordered</em> pairs. The mathlib name for unordered pairs is <code>sym2</code> (for \"symmetric square\"), and there's some material for going back and forth between this sort of set and a <code>set (sym2 V)</code>.</p>",
        "id": 359962716,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684619907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359954739\">said</a>:</p>\n<blockquote>\n<p>What exactly is wrong with just using mathlib's definition of a simple graph?</p>\n</blockquote>\n<p>The mathlib definition of a simple graph isn't really set up for computation per se, though if you are good with decidable instances and writing fintypes then you can use it for that. There's not really much you can <code>#eval</code> when all you know is that you have <code>Prop</code>-valued things...</p>\n<p>Though mathlib's simple graphs can be used as an interface for proving things about concrete objects that can be converted to <code>simple_graph</code>. There are a number of ways to represent a graph structure in programs (<code>bool</code> matrices, adjacency lists, among others), and <code>simple_graph</code> doesn't try to be any one of these.</p>",
        "id": 359963090,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684620148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359962558\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359957377\">said</a>:</p>\n<blockquote>\n<p>In addition, I also don't understand why the library starts with a simple graph.  A lot of the exercises that I want to prove/formalize aren't even about simple graphs.  So I need a definition of a Graph.</p>\n</blockquote>\n<p>I can answer that. Simple graphs were fairly clear how to define (though even so there were some initial difficulties coming up with it), and there are a number of ways one can define a multigraph, so we decided to start with simple graphs and see how the library developed before trying to have some theoretical depth in too many combinatorial objects at the same time.</p>\n<p>Another reason is that math textbooks about graph theory tend to be about simple graphs, so may as well start there.</p>\n<p>Something that might not be initially obvious is that the <code>adj</code> relation is equivalent to <code>set (V × V)</code>. The way this goes is <code>set (V × V) = (V × V -&gt; Prop) ≈ (V -&gt; V -&gt; Prop)</code>, where the equivalence is from currying, and the equality is the definition of <code>set</code>. This explains why there are no multiple edges: it's a <em>set</em> of pairs, two per edge (individual elements of this set are called \"darts\", and they're given by <code>simple_graph.dart</code>).</p>\n</blockquote>\n<p>This is a lot of good information and I'm still unpacking it, but I went ahead and loaded the Mathlib4 implementation of a <code>SimpleGraph</code> into my editor and I wanted to show/ask a few questions.  The answers to which may be in your reply but I'm still trying to digest it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Basic</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">SimpleGraph.Adj</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">example_graph</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">Adj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">[</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>First of all, when I type check SimpleGraph.Adj it returns </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⊢</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>which is why I couldn't start with the Mathlib implementation.  When I see this, I think of SimpleGraph being a function, where Lean will infer V, but it tells me to \"plug in\" a SimpleGraph V, along with two other V's and it will  give me a Prop.   For someone who's just starting out, this is hard to interpret and plus, I don't think that I want a Prop?  I thought that the structure should return an actual graph.  I feel like <code>SimpleGraph</code> should be a graph where I can do things like<code> G + v</code> or <code>G - e</code>, or maybe at some point <code>G/e</code>.  </p>\n<p>The example graph that I defined doesn't work because the <code>aesop_graph</code> tactic fails to prove that the adjacency relation is symmetric and irreflexive.  I think this is telling me that there's a particular way to define <code>adj</code>, which I think is theoretically answered in your reply when you talk about the relation being a set.  But as a beginner, I can't figure out what a simple concrete implementation of a SimpleGraph looks like.  Assuming <code> vertices = [a, b, c]</code> and <code>edges = [(a,b), (b,c), (a,c)]</code>. </p>\n<p>I feel like the simple answer is that the implementation of SimpleGraph isn't made to do what I'm wanting.   Which brings me back to my original post where I'm asking for ways to implement my ideas without them becoming overburdened with proof objects.  I think that Damiano Testa really helped in his first reply when he said that some properties can be left out (depending on what I want to do), and avoiding conditions for as long as possible.</p>",
        "id": 359968297,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684623952
    },
    {
        "content": "<p><code>SimpleGraph.Adj</code> is the accessor function (the \"projection\") for the adjacency relation. You can write <code>SimpleGraph.Adj example_graph</code> or <code>example_graph.Adj</code>.</p>",
        "id": 359968612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624167
    },
    {
        "content": "<p><code>Prop</code> \"is\" <code>Bool</code>, except for the fact that you can't decide whether the value is <code>True</code> or <code>False</code> in general (though <code>Decidable</code> instances can be registered to give the answer). But the fact is it's either <code>True</code> or <code>False</code>.</p>",
        "id": 359968708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624226
    },
    {
        "content": "<p>It's easier to prove general facts about <code>SimpleGraph</code>s rather than things about particular <code>SimpleGraph</code>s at the moment.</p>",
        "id": 359968859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624380
    },
    {
        "content": "<p>I think I shared it in another thread, but here's a concrete graph with some proofs about it: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/54_konigsberg.lean\">https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/54_konigsberg.lean</a> (That's Lean 3, but it shouldn't be hard to translate it.)</p>",
        "id": 359968970,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Design.20questions.2C/near/359968970\">said</a>:</p>\n<blockquote>\n<p>I think I shared it in another thread, but here's a concrete graph with some proofs about it: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/54_konigsberg.lean\">https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/54_konigsberg.lean</a> (That's Lean 3, but it shouldn't be hard to translate it.)</p>\n</blockquote>\n<p>I think I saw you post the Konigsberg problem in another of my posts but at the time I couldn't read it.  I've learned enough now to be able to see what's going on.  This looks like a good example.  I'm going to go through it.  Thanks!</p>",
        "id": 359969150,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684624603
    },
    {
        "content": "<p>I'm not too familiar yet with what we can expect <code>aesop_graph</code> to be able to prove. In mathlib 3, this was the <code>tidy</code> tactic, and while many times it could prove the two axioms, many times you still had to fill in a proof (see that link). If <code>aesop_graph</code> can't prove the axioms, I would not draw the conclusion that you defined <code>Adj</code> wrong.</p>",
        "id": 359969159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624611
    },
    {
        "content": "<p>In the Konigsberg file, half of it (edit: it seemed bigger in my memory, but it's just 6 lines) is precomputing some data (namely the degrees of all the vertices) so that the proof is a trivial application of another theorem.</p>",
        "id": 359969297,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684624701
    },
    {
        "content": "<p>So, when someone formalizes a definition of a general graph, will the SimpleGraph definition become obsolete and the new SimpleGraph definition will just be an extension of the general graph definition?  Is that typically how people do things?  I'm just thinking of how to define a general graph, then a simple graph and proving that the extension of the graph to a simple graph matches the same implementation as SimpleGraph.</p>",
        "id": 359969430,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684624818
    },
    {
        "content": "<p>By extension, I mean literally using the <code>extension</code> keyword</p>",
        "id": 359969456,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684624849
    },
    {
        "content": "<p>I don't think so, or at least I haven't been anticipating that. There will at least be functions to convert a <code>SimpleGraph</code> to a multigraph along with lemmas that we'll prove to say how structure is preserved.</p>",
        "id": 359970358,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684625621
    },
    {
        "content": "<p>Here's it ported to Lean 4, with some small improvements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2022 Kyle Miller. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Kyle Miller</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Trails</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DeriveFintype</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The Königsberg bridges problem</span>\n\n<span class=\"cm\">We show that a graph that represents the islands and mainlands of Königsberg and seven bridges</span>\n<span class=\"cm\">between them has no Eulerian trail.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">konigsberg</span>\n\n<span class=\"sd\">/-- The vertices for the Königsberg graph; four vertices for the bodies of land and seven</span>\n<span class=\"sd\">vertices for the bridges. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Verts</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">V1</span> <span class=\"bp\">|</span> <span class=\"n\">V2</span> <span class=\"bp\">|</span> <span class=\"n\">V3</span> <span class=\"bp\">|</span> <span class=\"n\">V4</span> <span class=\"c1\">-- The islands and mainlands</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B1</span> <span class=\"bp\">|</span> <span class=\"n\">B2</span> <span class=\"bp\">|</span> <span class=\"n\">B3</span> <span class=\"bp\">|</span> <span class=\"n\">B4</span> <span class=\"bp\">|</span> <span class=\"n\">B5</span> <span class=\"bp\">|</span> <span class=\"n\">B6</span> <span class=\"bp\">|</span> <span class=\"n\">B7</span> <span class=\"c1\">-- The bridges</span>\n<span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Fintype</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Verts</span>\n\n<span class=\"sd\">/-- Each of the connections between the islands/mainlands and the bridges.</span>\n<span class=\"sd\">These are ordered pairs, but the data becomes symmetric in `konigsberg.Adj`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Verts</span> <span class=\"bp\">×</span> <span class=\"n\">Verts</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span> <span class=\"o\">(</span><span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">B1</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">B2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">B3</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">B4</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">B5</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">B1</span><span class=\"o\">,</span> <span class=\"n\">V2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B2</span><span class=\"o\">,</span> <span class=\"n\">V2</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B3</span><span class=\"o\">,</span> <span class=\"n\">V4</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B4</span><span class=\"o\">,</span> <span class=\"n\">V3</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B5</span><span class=\"o\">,</span> <span class=\"n\">V3</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">V2</span><span class=\"o\">,</span> <span class=\"n\">B6</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B6</span><span class=\"o\">,</span> <span class=\"n\">V4</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">V3</span><span class=\"o\">,</span> <span class=\"n\">B7</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">B7</span><span class=\"o\">,</span> <span class=\"n\">V4</span><span class=\"o\">)</span> <span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The adjacency relation for the Königsberg graph. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">adj</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span> <span class=\"bp\">||</span> <span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span>\n\n<span class=\"sd\">/-- The Königsberg graph structure. While the Königsberg bridge problem</span>\n<span class=\"sd\">is usually described using a multigraph, the we use a \"mediant\" construction</span>\n<span class=\"sd\">to transform it into a simple graph -- every edge in the multigraph is subdivided</span>\n<span class=\"sd\">into a path of two edges. This construction preserves whether a graph is Eulerian.</span>\n\n<span class=\"sd\">(TODO: once mathlib has multigraphs, either prove the mediant construction preserves the</span>\n<span class=\"sd\">Eulerian property or switch this file to use multigraphs. -/</span>\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">graph</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">Verts</span> <span class=\"n\">where</span>\n  <span class=\"n\">Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Symmetric</span><span class=\"o\">,</span> <span class=\"n\">adj</span><span class=\"o\">]</span>\n    <span class=\"n\">decide</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Irreflexive</span><span class=\"o\">,</span> <span class=\"n\">adj</span><span class=\"o\">]</span>\n    <span class=\"n\">decide</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableRel</span> <span class=\"n\">graph.Adj</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">inferInstanceAs</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- To speed up the proof, this is a cache of all the degrees of each vertex,</span>\n<span class=\"sd\">proved in `konigsberg.degree_eq_degree`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">degree</span> <span class=\"o\">:</span> <span class=\"n\">Verts</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">V1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">|</span> <span class=\"n\">V2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">3</span> <span class=\"bp\">|</span> <span class=\"n\">V3</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">3</span> <span class=\"bp\">|</span> <span class=\"n\">V4</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">3</span>\n  <span class=\"bp\">|</span> <span class=\"n\">B1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B3</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B4</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B5</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B6</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">|</span> <span class=\"n\">B7</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">degree_eq_degree</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">graph.degree</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">degree</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">v</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">not_even_degree_iff</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Verts</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">degree</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">V1</span> <span class=\"bp\">∨</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">V2</span> <span class=\"bp\">∨</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">V3</span> <span class=\"bp\">∨</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">V4</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">w</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">setOf_odd_degree_eq</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">Odd</span> <span class=\"o\">(</span><span class=\"n\">graph.degree</span> <span class=\"n\">v</span><span class=\"o\">)}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">Verts.V1</span><span class=\"o\">,</span> <span class=\"n\">Verts.V2</span><span class=\"o\">,</span> <span class=\"n\">Verts.V3</span><span class=\"o\">,</span> <span class=\"n\">Verts.V4</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">w</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_even_degree_iff</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The Königsberg graph is not Eulerian. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_is_eulerian</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Verts</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">graph.Walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.IsEulerian</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.card_odd_degree</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"n\">setOf_odd_degree_eq</span>\n  <span class=\"n\">apply_fun</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">at</span> <span class=\"n\">h'</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">konigsberg</span>\n</code></pre></div>",
        "id": 359972711,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684627809
    }
]