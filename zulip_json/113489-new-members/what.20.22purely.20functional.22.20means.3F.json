[
    {
        "content": "<p>I’m a beginner, and I might be making a silly mistake, so I’d like to confirm what the term “purely functional language” really means.</p>\n<p>Consider the division function <code>Nat.div</code>, which is defined with the type <code>Nat → Nat → Nat</code>.<br>\nWould it be correct to explain it as follows?<br>\n“Since the function is defined with the type <code>Nat → Nat → Nat</code>, and Lean is a purely functional language, it is only allowed to return a term of type <code>Nat</code>. Therefore, returning a division-by-zero error is not permitted.”</p>\n<p>I suspect that this explanation might be incorrect.<br>\nI think that “a function that terminates and returns a value for every argument in its domain” is a matter of <em>totality</em>, which is a different concept from <em>purity</em>.<br>\nHowever, I’m not very confident about this.</p>\n<p>I’d appreciate it if you could clarify this for me.</p>",
        "id": 548163170,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761918989
    },
    {
        "content": "<p>The term means if you call a function <code>f</code> with a value <code>x</code> twice the result of both calls is always the same.</p>",
        "id": 548165158,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1761919531
    },
    {
        "content": "<p>What I understand as \"purely functional\" is that it's more like lambda calculus than a Turing machine.</p>\n<p>In languages like C and Rust, you have direct stateful control of the machine's memory. But in Lean and Haskell, the notion of state is built with abstractions on top of fundamentally stateless blocks.</p>",
        "id": 548165819,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1761919723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548165158\">said</a>:</p>\n<blockquote>\n<p>The term means if you call a function <code>f</code> with a value <code>x</code> twice the result of both calls is always the same.</p>\n</blockquote>\n<p>Isn't this a bit tricky for e.g. functions in <code>StateM</code>?</p>",
        "id": 548166378,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1761919866
    },
    {
        "content": "<p>the results are still the same, but the results in turn is a function of the state</p>",
        "id": 548167411,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761920137
    },
    {
        "content": "<p>you're describing how monads are possible</p>",
        "id": 548167467,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761920149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548166378\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548165158\">said</a>:</p>\n<blockquote>\n<p>The term means if you call a function <code>f</code> with a value <code>x</code> twice the result of both calls is always the same.</p>\n</blockquote>\n<p>Isn't this a bit tricky for e.g. functions in <code>StateM</code>?</p>\n</blockquote>\n<p>No, <code>f : StateM s Unit</code> is an alias for <code>f : s -&gt; (s x Unit)</code> so you are passing in a state parameter. Same thing for <code>IO</code> where you are passing in the real world parameter.</p>",
        "id": 548167821,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1761920231
    },
    {
        "content": "<p>Makes sense! Though this is what I meant by \"a bit tricky\". One needs to understand how the notion of state is realized in a monadic context</p>",
        "id": 548168713,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1761920452
    },
    {
        "content": "<p>this seems like an unnecessary distraction for a \"beginner\"</p>",
        "id": 548169030,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761920526
    },
    {
        "content": "<p>Hmm, questionable. This is precisely what confused me when I was a beginner because when I looked at slightly more involved Lean code it often used stateful monads.</p>",
        "id": 548169749,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1761920694
    },
    {
        "content": "<p>which part of the library were you looking at?</p>",
        "id": 548170040,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761920757
    },
    {
        "content": "<blockquote>\n<p>“Since the function is defined with the type <code>Nat → Nat → Nat</code>, and Lean is a purely functional language, it is only allowed to return a term of type <code>Nat</code>. Therefore, returning a division-by-zero error is not permitted.”</p>\n</blockquote>\n<p>So, is this explanation wrong? Or is it correct? I still don’t know.</p>",
        "id": 548170580,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761920884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548170040\">said</a>:</p>\n<blockquote>\n<p>which part of the library were you looking at?</p>\n</blockquote>\n<p>The metaprogramming API.</p>\n<p><span class=\"user-mention\" data-user-id=\"626349\">@Asei Inoue</span> it can't return anything else besides <code>Nat</code> because it wouldn't typecheck otherwise.</p>\n<p>Take Python, for example. You can have a division function that takes two numbers and has the result based on some global variable, which dictates the behavior of the function when the divisor is zero. Even if this function is type-consistent, it's still not purely functional.</p>",
        "id": 548171941,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1761921142
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451983\">Arthur Paulino</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548171941\">said</a>:</p>\n<blockquote>\n<p>The metaprogramming API.</p>\n</blockquote>\n<p>right, ofc if you want to go into metaprogramming then you would have to learn about monads, but 99% of the mathlib users are there to do maths</p>",
        "id": 548172547,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921236
    },
    {
        "content": "<p>I think that sentence you quoted is alluding to a certain model of error handling, a model you see in many imperative languages. In Java, you could have a <code>int f(int x, int y)</code>, which \"should\" always return an integer. But there's also a massive global state, which any function can modify. Part of that global state is, you could say, a big stack of callers. So the function is free to, <em>instead</em> of returning normally, throw an exception - which then searches up the stack for the appropriate error handler to jump to instead.</p>\n<p>That's a very not-pure kind of action, to look at and act upon global state like that. A purely functional setting wouldn't allow such error-handling jumps.</p>",
        "id": 548172650,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761921258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548163170\">said</a>:</p>\n<blockquote>\n<p>I think that “a function that terminates and returns a value for every argument in its domain” is a matter of <em>totality</em>, which is a different concept from <em>purity</em>.</p>\n</blockquote>\n<p>termination is an entirely different concept, in Lean functions are allowed to not terminate, but they still <em>typecheck</em></p>",
        "id": 548173054,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921348
    },
    {
        "content": "<p>now if you actually write a non-terminating function, Lean will detect that and force you to put <code>noncomputable</code> before the definition</p>",
        "id": 548173163,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921369
    },
    {
        "content": "<p>^^ but remember that, if you're coming from an imperative background, <em>totality</em> is also entirely unrelated to <em>termination</em> - so treating those two as equivalent could be very confusing!</p>",
        "id": 548173371,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761921404
    },
    {
        "content": "<p>let's say that without assuming termination, a function _ -&gt; Nat has to <em>theoretically</em> return a natural number, even after infinitely many steps</p>",
        "id": 548173937,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761921527
    },
    {
        "content": "<p>Isn't \"purely functional\" related to the fact that the only thing Lean does when executing a program is evaluating functions? For example there is no \"for cycle\" (we can simulate it of course, but <code>i++</code> is meaningless).</p>",
        "id": 548175404,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1761921863
    },
    {
        "content": "<p>to me \"purely functional\" mean that everything is immutable (in theory)</p>",
        "id": 548189595,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761925081
    },
    {
        "content": "<p>A consequence of this is that, if you run the same function twice with the same inputs, since nothing has mutated between the function calls, it should give the same result</p>",
        "id": 548189804,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761925136
    },
    {
        "content": "<p>giving the same result is one aspect (not 'reading' from a global state), but also it shouldn't 'write' to any kind of global state. <code>x = f 37; y = f 37; return y</code> should be equivalent code to <code>return f 37</code></p>",
        "id": 548216464,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761933381
    },
    {
        "content": "<p>As long as the global state is write only it shouldn't matter should it^^</p>",
        "id": 548218139,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1761933950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20.22purely.20functional.22.20means.3F/near/548170580\">said</a>:<br>\nSo, is this explanation wrong? Or is it correct? I still don’t know.**</p>",
        "id": 548233045,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1761939391
    },
    {
        "content": "<p>The explanation is wrong. A pure function can return an error as long as any change of the evironment don't change the resulting error and that itself don't change the environment.<br>\nTo take your example, a function that does division can return an Option (or an Except)  that is none (or error) when dividing by zero and it's still a pure function.<br>\nLike <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  said, a pure function is a function that always return the same result given the same input.<br>\nWhy lean returns 0 for a division by 0 and not terminate the program is more to have a total function for mathematical properties.<br>\nBut this also makes it a pure function.</p>",
        "id": 548233297,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1761939480
    },
    {
        "content": "<p>Somewhat related I wrote a blog post about \"pure functions\" in JS - <a href=\"https://rkirov.github.io/posts/pure/\">https://rkirov.github.io/posts/pure/</a></p>",
        "id": 555268562,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763010919
    }
]