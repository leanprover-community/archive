[
    {
        "content": "<p>I've got a function that takes as input a map containing <code>Set k</code>s as keys and outputs a separate map which breaks out every <code>k</code> as its own key, with the original <code>Set k</code> as the value.</p>\n<p>How can I prove the relationship between these two maps, that any value in the output map is guaranteed to exist as a key in the input map?</p>\n<p>This is what I've got so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">RBTree</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">hash</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span>\n<span class=\"w\">  </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldl</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">keySet</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">relationShipOuterToInnerMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Forall</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ?</span>\n</code></pre></div>\n<p>I don't know how to prove the theorem, or even whether I've formulated the theorem in the best way</p>",
        "id": 497282344,
        "sender_full_name": "aron",
        "timestamp": 1738523373
    },
    {
        "content": "<p>You don't appear to use RBMaps at all, but instead use HashMaps. Foldl for HashMaps is a bit tricky to prove as there are currently no lemmas yet in Std.<br>\nWhat is supposed to happen if a value of <code>k</code> appears in multiple HashSets that are used as keys?</p>",
        "id": 497351613,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738568685
    },
    {
        "content": "<p>Oops yeah you're right I meant to write <code>HashMaps</code>.</p>\n<blockquote>\n<p>What is supposed to happen if a value of k appears in multiple HashSets that are used as keys?</p>\n</blockquote>\n<p>I'm intending to use this to store disjoint sets, so any given <code>k</code> should only ever appear in one set; although yeah I should probably create a refinement type to carry the proof of that fact along with the map.</p>",
        "id": 497491865,
        "sender_full_name": "aron",
        "timestamp": 1738602816
    },
    {
        "content": "<p>I think proving this is rather difficult, because the way the hashMaps are designed. You might need to go down to the AssocList model that is below all the HashMap proofs, which gets tedious.</p>",
        "id": 497606596,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738657751
    },
    {
        "content": "<p>If you want to use disjoint sets perhaps a different datastructure would be simpler, namely the <a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">union-find or disjoint-set datastructure</a>.  There is a description of how to proving the correctness here (in Coq): <a href=\"https://usr.lmf.cnrs.fr/%7Ejcf/ftp/publis/puf-wml07.pdf\">https://usr.lmf.cnrs.fr/%7Ejcf/ftp/publis/puf-wml07.pdf</a> . Maybe that is simpler depending on your use case</p>",
        "id": 497607039,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738657892
    },
    {
        "content": "<p>In fact, there is a verified Union Find available in Batteries as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Batteries.UnionFind#doc\">docs#Batteries.UnionFind</a></p>",
        "id": 497607213,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738657943
    },
    {
        "content": "<p>Even better <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>  Forgot to check there</p>",
        "id": 497608043,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738658242
    },
    {
        "content": "<p>Unfortunately there is no theory for <code>toList</code> and <code>fold</code> on <code>Std.HashMap</code> at the moment, so proving anything about them will be very difficult. This is on the Lean FRO's TODO list for this year, but it will take a while until we get to it. If anyone is interested in contributing results in this direction to the Lean standard libray, feel free to contact me and I'll help you get started.</p>",
        "id": 497608218,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738658298
    },
    {
        "content": "<p>The result would be <code>m.fold f init = m.toList.foldr/foldl f init</code> (don't know which direction works) or is there anything more related to fold? I could try that in the next days</p>",
        "id": 497608709,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738658466
    },
    {
        "content": "<p>Though I guess the proof above would still be hard</p>",
        "id": 497608732,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738658478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"619540\">Johannes Tantow</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20relationship.20between.20two.20HashMaps.3F/near/497608709\">said</a>:</p>\n<blockquote>\n<p>The result would be <code>m.fold f init = m.toList.foldr/foldl f init</code> (don't know which direction works) or is there anything more related to fold? I could try that in the next days</p>\n</blockquote>\n<p>Yes, but this is only useful if you also have lemmas about <code>toList</code>, which are also missing</p>",
        "id": 497609040,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738658594
    },
    {
        "content": "<p><code>toList</code> would require similar lemmas/proofs to <code>keys</code> I guess.  I see also that my proposed result does not type check as the input the function is curried in fold and uncurried in the foldl.</p>",
        "id": 497609690,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738658813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20relationship.20between.20two.20HashMaps.3F/near/497607213\">said</a>:</p>\n<blockquote>\n<p>In fact, there is a verified Union Find available in Batteries as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Batteries.UnionFind#doc\">docs#Batteries.UnionFind</a></p>\n</blockquote>\n<p>Oh yeah – but... I don't quite understand that type. It has no type parameters for what sets of things it stores? and besides, it doesn't look like it allows for using its sets as keys to point to values?</p>",
        "id": 497613780,
        "sender_full_name": "aron",
        "timestamp": 1738660127
    },
    {
        "content": "<p>Yes, you would have to map the elements of type <code>k</code> you care about to (small) natural numbers in order to use this.</p>",
        "id": 497614842,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1738660462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"619540\">Johannes Tantow</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20relationship.20between.20two.20HashMaps.3F/near/497607039\">said</a>:</p>\n<blockquote>\n<p>If you want to use disjoint sets perhaps a different datastructure would be simpler, namely the <a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">union-find or disjoint-set datastructure</a>.</p>\n</blockquote>\n<p>This is effectively what I'm trying to do; here's what my data structure looks like so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DisjointSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- This maps from sets of `k`s to `v`s -/</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">valType</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- This is a projection of the inner map, into a map of keys to sets of keys -/</span>\n<span class=\"w\">  </span><span class=\"n\">outerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"n\">innerMap</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- The merge function allows for conditionally not adding an item into the list, by returning a `None` -/</span>\n<span class=\"w\">  </span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">valType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">valType</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysNew</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">valType</span>\n</code></pre></div>",
        "id": 497614989,
        "sender_full_name": "aron",
        "timestamp": 1738660515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20relationship.20between.20two.20HashMaps.3F/near/497614842\">said</a>:</p>\n<blockquote>\n<p>Yes, you would have to map the elements of type <code>k</code> you care about to (small) natural numbers in order to use this.</p>\n</blockquote>\n<p>Hmm I don't love that <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 497615056,
        "sender_full_name": "aron",
        "timestamp": 1738660538
    },
    {
        "content": "<p>also because it still won't let me associate values with the sets, so I'd have to store the values separately and check whether they need to be merged every time I do a union operation; so I may as well make my own data structure to store the sets anyway</p>",
        "id": 497615440,
        "sender_full_name": "aron",
        "timestamp": 1738660661
    },
    {
        "content": "<p>I would think that you don't have to use hash maps of sets in order to implement union find, which would simplify the proofs. Also <code>:=</code> is only a default value, best to leave it out of the structure</p>",
        "id": 497615880,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1738660807
    },
    {
        "content": "<p>I wanted to use hashmaps because I figured it'll be simpler to implement than a traditional union-find, I don't really care about performance atm.</p>\n<blockquote>\n<p>Also <code>:=</code> is only a default value, best to leave it out of the structure</p>\n</blockquote>\n<p>Ah I didn't know that, I thought it was syntax for a computed field. Does Lean have a computed field feature for records types?</p>\n<p>Actually I suppose if I name the function <code>DisjointSet.outerMap</code> it will automatically let me do <code>d.outerMap</code> on any <code>DisjointSet</code> <code>d</code> so I don't need it to be part of the structure definition!</p>",
        "id": 497616837,
        "sender_full_name": "aron",
        "timestamp": 1738661120
    },
    {
        "content": "<p>I just came up with a pretty simple solution to my problem. I can just include the <code>innerMap</code>'s keys' values in the <code>outerMap</code> along with each key set. That way I can always retrieve the value in a single hop directly from the outer map without needing to use a proof that a value in <code>outerMap</code> exists as a key of <code>innerMap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span>\n<span class=\"w\">  </span><span class=\"bp\">|&gt;.</span><span class=\"n\">fold</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">keySet</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n</code></pre></div>",
        "id": 497622143,
        "sender_full_name": "aron",
        "timestamp": 1738662764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20relationship.20between.20two.20HashMaps.3F/near/497616837\">said</a>:</p>\n<blockquote>\n<p>Ah I didn't know that, I thought it was syntax for a computed field. Does Lean have a computed field feature for records types?<br>\n</p>\n</blockquote>\n<p>I think I saw a computed field once in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a></p>",
        "id": 497648219,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738670551
    }
]