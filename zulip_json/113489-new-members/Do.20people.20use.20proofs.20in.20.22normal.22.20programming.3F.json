[
    {
        "content": "<p>Since Lean is a runnable language, I'm wondering if anyone is using (or experimenting with using) it in a following fashion: writing \"normal\" (not like super academic) runnable programs but with some properties being passed around as proofs. </p>\n<p>I know obviously people use Lean for proving mathematical theorems, or proving some statements about some systems (maybe some algorithms we want to model). And I know you can also write runtime code in Lean. So what I'm curious about is more like, do these get interleaved. Like would you write a web server with some proofs being passed around right in the midst of it. Or some other general purpose software that has no (obvious) connection with mathematics or formal systems.</p>",
        "id": 531724689,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753836991
    },
    {
        "content": "<p>I do it to avoid bounds checks</p>",
        "id": 531724740,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753837022
    },
    {
        "content": "<p>yea in regular programs too if it's not too much hassle</p>",
        "id": 531724792,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753837048
    },
    {
        "content": "<p>That seems like the most obvious use case, Claude suggested this to me too. Which feels like the most \"practical\" and \"boring\" application at the same time, but maybe also easiest to appreciate coming from TS etc. I wonder if that evolves into something bigger or whether that's too much effort. Or how does it influence how you think about other aspects of the program.</p>",
        "id": 531724871,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753837086
    },
    {
        "content": "<p>Like I guess I'd maybe reach for proving some properties about things where I'd previously reach for tests? For critical pieces. And then maybe more relaxed in other places but using properties here and there. Or having them be a part of the design of how different parts \"fit in\", like maybe security things like proving user input was escaped.</p>",
        "id": 531724971,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753837151
    },
    {
        "content": "<p>Just today I was passing around an term with type <code>{ n : Nat // xs.length = n }</code> and this turned my quadratic time algorithm into linear time without having to make the matching more complicated since the cases where the list is empty and the number is positive and the one where the list is nonempty and the number is zero were eliminated automatically</p>",
        "id": 531725148,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753837235
    },
    {
        "content": "<p>Ah yea I love this, so safe more aggressive optimizations.</p>",
        "id": 531725206,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753837274
    },
    {
        "content": "<p>I've used structures that contain the invariants that the fields are supposed to satisfy, which helped me think about the algorithms I was writing. I actually proved some of them, but other parts I left as <code>sorry</code> when I was confident it was ok (maybe more accurately: when it would have been a lot of work to fill in a formal proof!)</p>\n<p>It's interesting, when writing programs passing proofs around is sort of like strong typing++, where you use the more sophisticated types to make sure things are glued together in a way that prevents data model errors, but when writing algorithms where the goal is to prove correctness, it seems like it's often better to <em>not</em> pass proofs around, but instead write the algorithm and then leave the proofs for the theorems about the definition.</p>\n<p>The example of array bounds checking is a good one. When writing programs, yeah, it's helpful to know that you've got the basic correctness of not indexing out of bounds. But if you're writing theorems, you may as well write everything with <code>arr[i]!</code> since once you prove the program meets its spec you basically know the array indexing must have been in bounds. Using <code>arr[i]!</code> also avoids the dependent types in <code>arr[i]'h</code> (<code>h</code> depends on both <code>arr</code> and <code>i</code>), so it's easier to rewrite <code>arr</code> and <code>i</code>. I say \"may as well\", but to be clear that's not a recommendation, you also may as well prove indexing is in bounds inline if it's easy enough to do :-)</p>",
        "id": 531733021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753842313
    },
    {
        "content": "<blockquote>\n<p>Just today I was passing around an term with type { n : Nat // xs.length = n } and this turned my quadratic time algorithm into linear time</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> is this in a github repo that we can see? How did you know the compiler is making proper use of the extra type info?</p>",
        "id": 531745226,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753849816
    },
    {
        "content": "<p>Array bound is a good example for TS devs, because JS runtime doesn't crash on out-of-bound access but just returns <code>undefined</code>. Because TS type system is not expressive enough to carry array size information and number range information statically, TS basically has to pick between two bad choices <code>a[i]</code> on <code>a: T[]</code> should always return either <code>T</code> or <code>T|undefined</code> (can't express that this choice is dependent on <code>i</code> which it truly is.  They recently made this configurable through <code>noUncheckedIndexedAccess</code> but it is not on by default in the recommended <code>strict</code> flags, because of how unergonomic it is to deal with <code>| undefined</code> even for a simple for loop.</p>",
        "id": 531746277,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1753850361
    },
    {
        "content": "<p>In the self-balancing binary search tree implementation in the standard library, we use proofs of balancing properties to <a href=\"https://github.com/leanprover/lean4/blob/30ceb3260d7d7536092fedff969b4b2e8de7f942/src/Std/Data/DTreeMap/Internal/Balancing.lean#L102\">show that certain situations cannot occur during rebalancing</a>. This allows the compiler to remove the corresponding branch entirely, unlike in e.g., Haskell, where you would need to check and then panic in this situation. The speedup from this is quite noticeable in our microbenchmarks.</p>",
        "id": 531748644,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753851726
    },
    {
        "content": "<p>I tend to avoid writing proofs in programs unless necessary. For example, I'd happily add a bounds check for ordinary functions, while I pass an in-bounds proofs to the hot loop.</p>\n<p>The issue is that the proofs obscure the implementation, especially in a recursive function when you need to prove the properties for the new arguments. I once wrote a function where the proof in it was twice as long as the actual data manipulation <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 531808869,
        "sender_full_name": "pandaman",
        "timestamp": 1753872236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/stream/113489-new-members/topic/Do.20people.20use.20proofs.20in.20.22normal.22.20programming.3F/near/531745226\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Just today I was passing around an term with type { n : Nat // xs.length = n } and this turned my quadratic time algorithm into linear time</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> is this in a github repo that we can see? How did you know the compiler is making proper use of the extra type info?</p>\n</blockquote>\n<p>I don't think the compiler is doing anything with it, since subtypes are represented the same as types in the runtime. It saved me two match branches, and it saved me recomputing the length of the array at every recursive call since I'm passing it down now. Eventually I optimized it out.</p>",
        "id": 531817685,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753875020
    },
    {
        "content": "<p>We're writing code for <a href=\"https://arxiv.org/abs/2505.09095\">scientific computing</a> applications in Lean, and have been integrating proofs with programs in a way that makes sense to us. We're not passing proofs around with functions, nor do the proofs really impact speed or performance - the proofs are there to verify properties of the functions we're executing.</p>",
        "id": 531865217,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1753887617
    },
    {
        "content": "<p>You might be interested in <a href=\"https://github.com/argumentcomputer/Blake3.lean/blob/0e60b1d263d5a1c08f95b5470e4e160fc5754eee/Blake3.lean#L124\">this implementation of <code>squeeze</code></a>, for which I was able to provide a proof for the size of the output.</p>\n<p>Btw, I think <a href=\"https://github.com/argumentcomputer/Blake3.lean/blob/0e60b1d263d5a1c08f95b5470e4e160fc5754eee/Blake3.lean#L3\"><code>ByteArray.size_of_extract</code></a> would be very useful in Batteries.</p>",
        "id": 531870890,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1753889127
    },
    {
        "content": "<p>As already mentioned in this thread, it's common (and often good) practice to add runtime assertions for bounds of arrays/vectors/slices of data. If you can lift those runtime bound checks to compile-time proofs, your application is not only safer but also faster.</p>",
        "id": 531871964,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1753889428
    },
    {
        "content": "<p>I use the interleaving style extensively in my attempts to get AIs to write code with correctness proofs. See <a href=\"https://github.com/GasStationManager/ArtificialAlgorithms\">here</a> for some examples.  It is often the only way I could get Claude to make progress on the proof. In my opinion it is the most intuitive approach if the goal is to produce code with a correctness proof: you can think of the code as already the proof sketch. Why would you want to then unfold the function from outside in order to fill in the rest of the proof. Granted, the end result might not be the most readable, but readability was not the goal.</p>",
        "id": 532136932,
        "sender_full_name": "GasStationManager",
        "timestamp": 1753984802
    },
    {
        "content": "<p>Because I want to prove five theorems about a definition, but I don't want to interleave it with five proofs with different induction hypothesis! Readability matters to me.</p>",
        "id": 532173954,
        "sender_full_name": "pandaman",
        "timestamp": 1753998626
    },
    {
        "content": "<p>I have some in <a href=\"http://github.com/alok/lean-inf\">github.com/alok/lean-inf</a> (currently broken though). I found them invaluable as glue for AI models too since even with everything sorried they still act like legos for snapping types together.</p>",
        "id": 532433816,
        "sender_full_name": "Alok Singh",
        "timestamp": 1754125059
    }
]