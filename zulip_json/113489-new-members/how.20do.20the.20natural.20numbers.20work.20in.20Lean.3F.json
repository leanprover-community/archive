[
    {
        "content": "<p>I'm familiar with how the natural numbers work in dependent type theory (as an inductive type generated by <code>0</code> and <code>succ</code>).  I understand how to use the elimination rule to define addition and multiplication and so on and prove the two redundant Peano axioms (that 0 is not a successor and that the successor function is injective). </p>\n<p>What I don't understand is why I can prove so many things about natural numbers using <code>rfl</code>. Examples include:</p>\n<p><code>rfl : 5 * (3 + 4) = (4 + 3) * 5</code> <br>\n<code>fun _ =&gt; rfl : ∀ n : Nat,  succ n = n + 1</code><br>\n<code>fun _ =&gt; rfl : ∀ n : Nat, n + 0 = n</code><br>\n<code>fun _ _ =&gt; rfl : ∀ m n : Nat,  m + succ n = succ (m + n)</code></p>\n<p>The last two of these I'd expect from the definition of addition using induction in the second variable, and I suppose this explains the second equality as well. The equalities like the first involving explicit numerals are the most mysterious to me. </p>\n<p>Can someone explain when an equality of natural numbers is provable using <code>rfl</code>? I think the answer may have something to do with normal forms (but I don't really understand what these are).</p>",
        "id": 545777602,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1760815667
    },
    {
        "content": "<p>what about</p>\n<ul>\n<li><code>rfl : 0 = Nat.zero</code></li>\n<li><code>rfl : 1 = Nat.succ 0</code></li>\n<li><code>rfl : 2 = Nat.succ 1</code></li>\n</ul>\n<p>etc.</p>\n<p>Is this understandable to you?</p>",
        "id": 545777727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760815829
    },
    {
        "content": "<blockquote>\n<p>What I don't understand is why I can prove so many things about natural numbers using <code>rfl</code></p>\n</blockquote>\n<p>Not an expert at all, but my understanding is that at the core there is a lambda calculus evaluator, that does reduction by default (weak head normal form more specifically, which I forget exactly what it means). So when you have explicit numerals, it can run the reducer (which it can't do when it has variables like x). What happens is that both <code> 5 * (3 + 4) </code> and <code>(4 + 3) * 5</code> turn into 35 first (internally this is 35 succ  in a row, but actually likely represented more efficiently), and then <code>rfl</code> closes with 35 = 35.</p>",
        "id": 545779020,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1760817489
    },
    {
        "content": "<p>The second example also works like that because 1 is alias for <code>succ zero</code>, and the definition of + can be reduced when it has something with <code>succ _</code> in the second argument. But note that <code>succ n = 1 + n</code> doesn't reduce on the RHS hence <code>rfl</code> can't solve it, one needs to use some theorems to rewrite it.</p>",
        "id": 545779304,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1760817821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/how.20do.20the.20natural.20numbers.20work.20in.20Lean.3F/near/545777727\">said</a>:</p>\n<blockquote>\n<p>what about</p>\n<ul>\n<li><code>rfl : 0 = Nat.zero</code></li>\n<li><code>rfl : 1 = Nat.succ 0</code></li>\n<li><code>rfl : 2 = Nat.succ 1</code></li>\n</ul>\n<p>etc.</p>\n<p>Is this understandable to you?</p>\n</blockquote>\n<p>My guess is that this is how 0, 1, and 2 are defined.</p>\n<p>So I guess your point is that 3 + 4 is defined to be </p>\n<p><code>0.succ.succ.succ + 0.succ.succ.succ.succ</code></p>\n<p>which is definitionally equal to </p>\n<p><code>(3 + 0).succ.succ.succ.succ</code></p>\n<p>which is definitionally equal to </p>\n<p><code>0.succ.succ.succ.succ.succ.succ.succ</code></p>\n<p>and I can do a similar reduction of <code>4 + 3</code>. Because both reduce to the same numeral they are equal by <code>rfl</code>?</p>",
        "id": 545779337,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1760817855
    },
    {
        "content": "<p>Is there an upper bound for how high the explicit numerals in Lean go?</p>",
        "id": 545779429,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1760817943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/channel/113489-new-members/topic/how.20do.20the.20natural.20numbers.20work.20in.20Lean.3F/near/545779429\">said</a>:</p>\n<blockquote>\n<p>Is there an upper bound for how high the explicit numerals in Lean go?</p>\n</blockquote>\n<p>Well eventually it's gonna run out of memory I guess</p>",
        "id": 545779478,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760818007
    },
    {
        "content": "<p>Lean actually has special support for reducing common operations on numeric literals</p>",
        "id": 545779501,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760818040
    },
    {
        "content": "<p>your reasoning justifies this reduction in theory so in practice since we know it's gonna reduce anyways why don't we just replace it with a more efficient implementation</p>",
        "id": 545779538,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760818079
    },
    {
        "content": "<p>so you can see the implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.reduceNat%3F#doc\">docs#Lean.Meta.reduceNat?</a> has a list of special-cased operations</p>",
        "id": 545779610,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1760818171
    },
    {
        "content": "<blockquote>\n<p>Is there an upper bound for how high the explicit numerals in Lean go?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Nat\">https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Nat</a> has a comment about this</p>\n<p>GMP would mean there is no limit (other than your computer memory), similarly to say Python, or BigInt in JS.</p>",
        "id": 545779719,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1760818318
    },
    {
        "content": "<p>Custom Nats like if you write <code>inductive MyNat ...</code>  likely don't have that optimization and will quickly make Lean grind to a halt.</p>",
        "id": 545779771,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1760818378
    },
    {
        "content": "<p>Thanks. This is helpful.</p>",
        "id": 545783569,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1760822705
    },
    {
        "content": "<p>In NNG3 this behaviour confused users; I would get bug reports saying \"the goal was <code>n+0=n</code> and I know I'm supposed to <code>rw add_zero,</code> next but I put <code>rfl</code> and it worked\". So in NNG4 I define addition as an undefined function and define <code>add_zero</code> and <code>add_succ</code> as axioms.</p>",
        "id": 545786077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1760826284
    }
]