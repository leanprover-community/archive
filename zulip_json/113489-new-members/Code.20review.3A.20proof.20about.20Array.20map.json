[
    {
        "content": "<p>I made a simple implementation of <code>map</code> for <code>FloatArray</code> that needs to be as fast as it can be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span>\n<span class=\"w\">                      </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">sz_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"n\">sz_eq</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now I want to prove that <code>map</code> does not change the size of the array:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I suspect things like this are proven by some kind of induction tactic, but I am not very familiar with tactics.  So I gave the following proof:</p>\n<p>First, understand how <code>push</code> affects size:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">arr_inc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">size_push</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Next, prove a recursive theorem about <code>mapAux</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size_aux</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span>\n<span class=\"w\">      </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">k_lt_s</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"n\">k_eq</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">sk_le_s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">k_lt_s</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">next_k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">float_array_map_size_aux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">sk_le_s</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">arr_inc</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">next_k</span>\n<span class=\"w\">         </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span>\n<span class=\"w\">         </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Finally apply the recursive theorem to prove what we want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size_aux</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span>\n</code></pre></div>\n<p>I think there is a much simpler, more streamlined way of proving such things but I could not find it in the docs.  Can someone with experience try to simplify the above procedure and suggest tactics/methods for such recursively defined functions?</p>",
        "id": 454612575,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722172804
    },
    {
        "content": "<p>Not really what you're asking for, but here are some small golfs.</p>\n<p>for <code>arr_inc</code>:</p>\n<ul>\n<li>you generally replace <code>: ∀ x:T , fun x ↦</code> with just <code>(x:T) :</code> (giving the theorem itself a parameter)</li>\n<li>the unfolding isn't necessary. (that wasn't obvious to me, but i deleted it and the proof still worked)</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">arr_inc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">size_push</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>for <code>float_arry_map_size</code>:</p>\n<ul>\n<li>same thing about the parameters</li>\n<li>you can replace some of the explicit parameters with _</li>\n<li><code>apply aux_eq</code> to solve the goal works but <code>exact aux_eq</code> is a little more explicit</li>\n<li>then <code>rw [...] at foo; exact foo</code> can be replaced with <code>rwa [...]</code></li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size_aux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span>\n</code></pre></div>",
        "id": 454640270,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722186914
    },
    {
        "content": "<p>Thank you!   I kept the unfolding because Lean complained in tactic mode, but I should have realized I could just turn to term mode.  I also did not know about <code>rwa</code>.</p>\n<p>I'd still like to know if there is any way to bypass this pattern completely and give a simple \"induction\" style proof rather than the explicit recursive call.</p>",
        "id": 454642970,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722187691
    },
    {
        "content": "<p>for <code>float_array_map_size_aux</code>, you can pull out the duplicated <code>unfold</code> and <code>split</code> and put them before the <code>if</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_array_map_size_aux</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k_eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">k_lt_s</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">k_le_s</span><span class=\"w\"> </span><span class=\"n\">k_eq</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">sk_le_s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_le_of_lt</span><span class=\"w\"> </span><span class=\"n\">k_lt_s</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">next_k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">float_array_map_size_aux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">sk_le_s</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">arr_inc</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">next_k</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I think you're right about an inductive proof, but I'm not confident that I can produce one. I may give it a shot later. :)</p>",
        "id": 454643118,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722187780
    },
    {
        "content": "<p>So... You could do induction on the <code>List</code> inside the <code>Array</code>, or you could find some natural number that's decreasing and do induction on that.</p>\n<p>Your list is growing at each recursive step instead of shrinking, so it's kind of hard to write it as an induction. I think if you rewrote the algorithm to be more amenable to induction, you'd just wind up with <code>map</code>. </p>\n<p>On the other hand, you also don't have any explicit numbers that are decreasing... but there is an implicit one: the difference between the length of C and the length of A.</p>\n<p>So I rewrote your algorithm slightly. It still has the same logic, but instead of a <code>k</code> that is equal to <code>C.size</code> at each step (and thus growing), I used a <code>d</code> that is equal to <code>A.size - C.size</code>.</p>\n<p>Now we can do induction on <code>d</code>. Since <code>mapAux</code> is recursive, the trick is to unfold it a second time and then the induction hypothesis (<code>ih</code>) does the rest of the work. </p>\n<p>Here's the complete proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">specialize</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">Float</span><span class=\"bp\">→</span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">:</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"bp\">+</span><span class=\"n\">d</span><span class=\"bp\">=</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">])</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">size_push</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">      </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"n\">Float</span><span class=\"bp\">→</span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">size_mapAux</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">→</span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"o\">:</span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"bp\">+</span><span class=\"n\">d</span><span class=\"bp\">=</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">mapAux</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">mapAux</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">d'</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">mapAux</span>\n<span class=\"w\">      </span><span class=\"n\">simp_all</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">size_map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">→</span><span class=\"n\">Float</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">aux_eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">size_mapAux</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">aux_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 454670399,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722203704
    },
    {
        "content": "<p>Out of curiosity, is this actually faster than the native <code>map</code>? and if so, why?</p>",
        "id": 454670610,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722203934
    },
    {
        "content": "<p><code>FloatArray</code> does not have a <code>map</code> instance; it has <code>ForIn</code>, but it is very hard for me to prove things monadically.</p>",
        "id": 454823700,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722257185
    },
    {
        "content": "<p>Very nice refactoring, by the way; thanks!</p>",
        "id": 454824283,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722257331
    },
    {
        "content": "<p>No problem.... But it might be worth benchmarking against this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">-&gt;</span><span class=\"n\">Float</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FloatArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨#</span><span class=\"o\">[</span><span class=\"mf\">0.5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mf\">0.324</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mf\">0.65345345</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 454904063,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722275303
    },
    {
        "content": "<p>Both of these implementations are inherently suboptimal because they allocate even when RC=1. For an optimal implementation you would want to basically do what <code>Array.map</code> is doing.</p>",
        "id": 454904387,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722275395
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> huh. I don't know what this means yet, but is there any way to just automatically derive <code>WhateverArray. map</code> (and presumably other Array functions)?</p>",
        "id": 454905833,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722275694
    },
    {
        "content": "<p>You have to look deeper</p>",
        "id": 454905892,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722275708
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Init/Data/Array/Basic.lean#L280-L309\">https://github.com/leanprover/lean4/blob/702c31b8071269f0052fd1e0fb3891a079a655bd/src/Init/Data/Array/Basic.lean#L280-L309</a></p>",
        "id": 454905990,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722275730
    },
    {
        "content": "<p>the <code>mapMUnsafe</code> is the optimal implementation as it is able to modify the array directly in place</p>",
        "id": 454906145,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722275760
    },
    {
        "content": "<p>And no there is not such a way. Note that <code>FloatArray.data</code> allocates. <code>FloatArray</code> is actually a real unboxed float array (similar to how <code>ByteArray</code> is a unboxed byte array), unlike <code>Array</code> which is an array of pointers for ABI reasons. That's why both calling <code>data</code> or doing the <code>push</code> implementation is suboptimal, both will allocate even if unnecessary.</p>",
        "id": 454906535,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722275847
    },
    {
        "content": "<p>Ah! In looking into this yesterday, I noticed that plain <code>Array</code> is written as a wrapper  for <code>List</code> but also annotated with <code>@[extern]</code> something-or-other. Is the idea that the list-based implementation sort of a semantic definition for proofs, and then at compile time, that implementation gets replaced with a completely different implementation in C that the dev team is asserting has the same semantics?</p>",
        "id": 454907414,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722276030
    },
    {
        "content": "<p>Yes</p>",
        "id": 454907531,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722276054
    },
    {
        "content": "<p>Similar for FloatArray and ByteArray</p>",
        "id": 454907556,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722276061
    },
    {
        "content": "<p>Interesting.. and in <code>FloatArray</code> and <code>ByteArray</code> I see: <code>-- TODO: avoid code duplication in the future after we improve the compiler.</code> Does this TODO predate the macro system, or is there something planned for the compiler that we're still waiting on?</p>",
        "id": 454910387,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722276714
    },
    {
        "content": "<p>Well, ideally <code>Array</code>'s ABI would be smart enough to not use an array of pointers to <code>uint8_t</code> when it can just be an array of <code>uint8_t</code> directly wouldn't it? That's what this comment is waiting for to happen.</p>",
        "id": 454910686,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722276774
    },
    {
        "content": "<p>Oh I see. So if <code>Array X</code> were more powerful, <code>XArray</code> probably wouldn't need to exist at all, provided <code>X</code> had some way of mapping directly to a chunk of raw memory. Then <code>Array</code> could use an array of some primitive C type under the hood if possible, and fall back to pointers if not.</p>\n<p>I would be willing to implement this if someone could help get me oriented and tell me exactly what needs to be done.</p>\n<p>(I have fairly extensive experience with this sort of thing. I work professionally with the J and K array languages, and have done a lot of work binding them to other native languages (rust, pascal, godot game engine)... I'm also pretty familiar with compilers)</p>",
        "id": 454913371,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722277416
    },
    {
        "content": "<p>Thanks for the offer Michal, but this is probably not a good first-Lean-internals project. For projects touching essential internals like this the FRO would either plan to do it internally, or in conjunction with a contributor with an already established track record of collaboration. There are lots of small <code>Array</code> adjacent things that could be better places to start. There is <code>Array</code> adjacent work happening at <a href=\"https://github.com/leanprover-community/batteries/pulls?q=sort%3Aupdated-desc+is%3Apr+is%3Aopen\">Batteries</a>, and PRs adding doc-strings to <code>Array</code> functions in Lean would be great. Good benchmarks demonstrating the problems with the current implementation would also be helpful.</p>",
        "id": 454976522,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1722297266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> fair enough. I will take a look at the issues list after I wrap up my current project.</p>",
        "id": 454977117,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722297552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> out of interest: I've been doing a lot of work with some Array stuff recently and I would be interested in contributing to Batteries-level proofs or adding docstrings and the like. Is there a good place where these efforts are being coordinated or tracked?</p>",
        "id": 455142921,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1722350954
    },
    {
        "content": "<p>there is the <a class=\"stream\" data-stream-id=\"348111\" href=\"/#narrow/stream/348111-batteries\">#batteries</a>  channel.</p>",
        "id": 455144497,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722351400
    },
    {
        "content": "<p>At present little is being merged to Batteries, but I agree that channel is still a good place to discuss.</p>",
        "id": 455241392,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1722382751
    },
    {
        "content": "<p>I'm soon going to start work on <code>Array</code> in Lean core, and am happy to have pointers to basic material that is conspicuously missing (whether present in Batteries or other libraries).</p>",
        "id": 455241589,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1722382811
    },
    {
        "content": "<p>Will the maintainer bottleneck in batteries be resolved soon?</p>",
        "id": 455367396,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722429958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20review.3A.20proof.20about.20Array.20map/near/454904387\">said</a>:</p>\n<blockquote>\n<p>Both of these implementations are inherently suboptimal because they allocate even when RC=1. For an optimal implementation you would want to basically do what <code>Array.map</code> is doing.</p>\n</blockquote>\n<p>But the main loop in <code>Array.map</code> is about <code>NonScalar</code>; how would I adapt it to <code>FloatArray</code>?</p>",
        "id": 455387840,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722436070
    },
    {
        "content": "<p>The main point of the implementation of <code>Array.map</code> is not the non scalar trick, that's just an additional implementation detail because you have ref counted elements. The main point is that it uses <code>set</code> instead of <code>push</code> (or accessing the data, which is even worse). This means that when you have an <code>Array</code> with <code>RC = 1</code> it will not get copied but instead modified in place. All implementations provided for <code>FloatArray.map</code> in this thread so far will forcibly allocate a new <code>FloatArray</code> which is not necessary.</p>",
        "id": 455388208,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722436183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20review.3A.20proof.20about.20Array.20map/near/455388208\">said</a>:</p>\n<blockquote>\n<p>The main point of the implementation of <code>Array.map</code> is not the non scalar trick, that's just an additional implementation detail because you have ref counted elements. The main point is that it uses <code>set</code> instead of <code>push</code> (or accessing the data, which is even worse). This means that when you have an <code>Array</code> with <code>RC = 1</code> it will not get copied but instead modified in place. All implementations provided for <code>FloatArray.map</code> in this thread so far will forcibly allocate a new <code>FloatArray</code> which is not necessary.</p>\n</blockquote>\n<p>Last time I tried using <code>set</code> instead of <code>push</code> in my code, I got tremendous slowdowns.  I will try again.  Also, is this relevant? <a href=\"https://github.com/leanprover/lean4/issues/4699\">https://github.com/leanprover/lean4/issues/4699</a></p>",
        "id": 455388649,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722436309
    },
    {
        "content": "<p>Right, I cannot get <code>uget</code> and <code>uset</code> to perform in the same vicinity as consecutive pushes; I just get tremendous slowdowns.  I'll try to dig deeper and see if I am making mistakes or give a benchmark.</p>",
        "id": 455390377,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722436741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/Code.20review.3A.20proof.20about.20Array.20map/near/454910686\">said</a>:</p>\n<blockquote>\n<p>Well, ideally <code>Array</code>'s ABI would be smart enough to not use an array of pointers to <code>uint8_t</code> when it can just be an array of <code>uint8_t</code> directly wouldn't it? That's what this comment is waiting for to happen.</p>\n</blockquote>\n<p>i am curious: i have been running into a lot of stuff that is implemented on <code>Array UInt8</code>, but not <code>ByteArray</code>. should i bother with making PRs to lean/batteries, or is <code>ByteArray</code> expected to be replaced with an optimized <code>Array UInt8</code> in the near future?</p>",
        "id": 466112784,
        "sender_full_name": "JJ",
        "timestamp": 1724965630
    },
    {
        "content": "<p>We don't even have a <code>Byte</code> type in Lean core so I don't know where you would've seen that.</p>",
        "id": 466114592,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1724966535
    },
    {
        "content": "<p>sorry, my bad, i meant <code>Array UInt8</code>. i was working on some code with an <code>abbrev Byte := UInt8</code> in it earlier today.</p>",
        "id": 466114702,
        "sender_full_name": "JJ",
        "timestamp": 1724966590
    },
    {
        "content": "<p>I can't comment on batteries. If you do know about code like this in core and can show that it makes a performance difference it might be interesting, otherwise probably just leave it alone.</p>",
        "id": 466114783,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1724966634
    },
    {
        "content": "<p>but yeah looking it up in core there is literally no API that uses it apart from ByteArray itself</p>",
        "id": 466114924,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1724966705
    },
    {
        "content": "<p>oh, i mean, would it be desired to implement <code>Array</code> functionality for <code>ByteArray</code>? i would think that if <code>ByteArray</code> is sticking around it might be helpful, but if the goal is to remove it (soonish) in favour of an optimized <code>Array UInt8</code> then it probably wouldn't be worth the bother</p>",
        "id": 466115726,
        "sender_full_name": "JJ",
        "timestamp": 1724967040
    },
    {
        "content": "<p>given the lack of internal usage sounds like the answer is probably the latter</p>",
        "id": 466115750,
        "sender_full_name": "JJ",
        "timestamp": 1724967053
    },
    {
        "content": "<p>I don't think so. We're still figuring out the API for Array itself anyways</p>",
        "id": 466115824,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1724967079
    }
]