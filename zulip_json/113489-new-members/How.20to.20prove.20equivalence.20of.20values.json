[
    {
        "content": "<p>What is the approach of proving equivalence of values of inductive types? The Eq type only has propIntro which doesn't help here. What sort of tactics could I use?</p>\n<p>In the example below, I assume the helper neg_neg function needs to be used but not sure how to use it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">neg_neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">other</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">value_eq_neg_neg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 462963599,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723889906
    },
    {
        "content": "<p>I can’t see why your theorem is true. It looks like what you are stating is equivalent to saying that <code>succ (succ 0) = 0</code>.</p>",
        "id": 462965113,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723890840
    },
    {
        "content": "<p>Yeah, it's not true</p>",
        "id": 462965187,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723890902
    },
    {
        "content": "<p><code>Value.neg_neg</code> confused me, but it's just a function. It doesn't change anything about the equality</p>",
        "id": 462965289,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723890994
    },
    {
        "content": "<p>Distinct constructors of an inductive type create distinct values by definition</p>",
        "id": 462965341,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723891071
    },
    {
        "content": "<p>I think Jonathan wants to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">value_eq_neg_neg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">neg_neg</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">neg_neg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 462965660,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723891331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20prove.20equivalence.20of.20values/near/462965113\">said</a>:</p>\n<blockquote>\n<p>I can’t see why your theorem is true. It looks like what you are stating is equivalent to saying that <code>succ (succ 0) = 0</code>.</p>\n</blockquote>\n<p>I'm trying to say that <code>neg (neg n) = n</code> or <code>-(-n) = n</code>. I guess since this is a new inductive type, what I am really asking is how do I introduce this equivalence? And maybe then I can prove it is true?</p>\n<p>I am really new to this theorem proving stuff so I don't even know if that makes sense. But I would assume this can be done somehow since in the standard library there is <code>Int.neg_neg</code> which can prove the same thing for actual integers.</p>",
        "id": 462965987,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723891719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20prove.20equivalence.20of.20values/near/462965341\">said</a>:</p>\n<blockquote>\n<p>Distinct constructors of an inductive type create distinct values by definition</p>\n</blockquote>\n<p>The inductive type of <code>Int</code> defined in Lean looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">negSucc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n</code></pre></div>\n<p>Here it doesn't seem like there is really any information about what is \"negative\". But somehow they introduce this concept and are able to prove similar propositions. I guess what I am asking is how is this done?</p>",
        "id": 462966221,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723891919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20prove.20equivalence.20of.20values/near/462965660\">said</a>:</p>\n<blockquote>\n<p>I think Jonathan wants to prove</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"bp\">.</span><span class=\"n\">value_eq_neg_neg</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">neg_neg</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">neg_neg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think that would work too. But if I am able to prove that, I should also be able to prove the one I mentioned above right?</p>",
        "id": 462966500,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723892061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"743962\">Jonathan Lacombe</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20prove.20equivalence.20of.20values/near/462966221\">said</a>:</p>\n<blockquote>\n<p>Here it doesn't seem like there is really any information about what is \"negative\". But somehow they introduce this concept and are able to prove similar propositions. I guess what I am asking is how is this done?</p>\n</blockquote>\n<p>In Mathlib, the way it is done is by defining <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.neg#doc\">docs#Int.neg</a>. This is a function which sends an integer to what you would expect to be its negative version. You should do something similar in your case: define a function <code>Value.neg' (v : Value) := unit =&gt; neg unit | neg v =&gt; v</code>, and then prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">neg'_neg'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">neg'</span><span class=\"bp\">.</span><span class=\"n\">neg'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 462967756,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723892841
    },
    {
        "content": "<p>This seems to be what I am looking for. Thanks for this, I will try this out.</p>",
        "id": 462968198,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723893117
    },
    {
        "content": "<p>In fact the theorem I wrote down is not true: <code>unit.neg.neg.neg'.neg' = unit</code> whereas it should be equal to <code>unit.neg.neg</code>.</p>",
        "id": 462970289,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723894558
    },
    {
        "content": "<p>In fact the type you defined is really the same as <code>Nat</code>. And the function I defined is the one sending <code>0</code> to <code>1</code> and any other integer to its predecessor, so it's not an involution. Maybe the structure of your type is not the one you are looking for?</p>",
        "id": 462970853,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723894947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20prove.20equivalence.20of.20values/near/462970853\">said</a>:</p>\n<blockquote>\n<p>In fact the type you defined is really the same as <code>Nat</code>. And the function I defined is the one sending <code>0</code> to <code>1</code> and any other integer to its predecessor, so it's not an involution. Maybe the structure of your type is not the one you are looking for?</p>\n</blockquote>\n<p>Yeah, I think you're right. And this is probably what <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> was saying earlier. I was trying to prove equivalence of two structures that are different. I really am beginning to understand a lot from this. The reason double negation \"works\" for the <code>Int</code> type is because <code>neg</code> just sends <code>ofNat(n)</code> to <code>negSucc</code> and vice-versa.</p>\n<p>The way I am describing \"negation\" would make sense with a structure like below (which checks out):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">F</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"bp\">.</span><span class=\"n\">not_not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>However, I can't just change the structure because what I really am trying to do is create a type that defines \"operations\" that can be done on another type. I wanted to represent computational operations (ex: C math functions <code>sin</code>, <code>floor</code>, <code>pow</code>, etc) and then find \"similar\" operations that I can replace with another. Also, I wanted to do this without defining the type that is being operated on.</p>\n<p>I don't have a background in mathematics or proofs and I know this might sound unusual or even unsound, especially considering that these operations are not really replaceable since resulting values may actually turn out to be different. But this doesn't need to have a rigorous proof, it's just an experiment to see if I can find some small optimizations. Like finding a <code>sin(pi)</code> and replacing with <code>0</code>.</p>\n<p>Anyway, thanks for your help. I am starting to know what direction I should take.</p>\n<p>And in case you're wondering, considering the context above, I will look into proving statements like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">identity</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"bp\">.</span><span class=\"n\">not_not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BooleanOp</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 462991508,
        "sender_full_name": "Jonathan Lacombe",
        "timestamp": 1723906060
    },
    {
        "content": "<p>Right, in this context you can work with a kind of equivalence relation, but not equality, because the equality is equality of terms, not \"values\"</p>",
        "id": 462994470,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723907157
    },
    {
        "content": "<p>Once you have that relation, you can create a quotient type - but perhaps try playing with the relation first</p>",
        "id": 462994922,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723907389
    },
    {
        "content": "<p>That looks interesting, have fun! And don’t hesitate to open a new topic if you have other questions</p>",
        "id": 462995926,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723907831
    }
]