[
    {
        "content": "<p>What is large elimination? What is subsingleton elimination? Why do we care about these? What do they have to do with proof irrelevance? What's so good about proof irrelevance anyway?</p>",
        "id": 196007956,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588366024
    },
    {
        "content": "<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>",
        "id": 196012582,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368819
    },
    {
        "content": "<p>This is basically because they would be a subsingleton anyway, even if they were types. They only have one constructor, and all arguments are either props or are mentioned in the type of the output. There is a more precise rule for this somewhere.</p>",
        "id": 196012775,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368920
    },
    {
        "content": "<p>I think other people can answer what is so good about proof irrelevance better than me, but one example is that <code>subtype.ext</code> would not hold without it.</p>",
        "id": 196012885,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368978
    },
    {
        "content": "<p><a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\" title=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a> might be helpful</p>",
        "id": 196013729,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588369493
    },
    {
        "content": "<p>Thanks Chris. I will have a read</p>",
        "id": 196015004,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588370392
    },
    {
        "content": "<p>Only the Prop type is proof irrelevant (all terms are definitionally equal) because it has to be in order to support classical reasoning - that was my understanding from the HoTT book. I asked a related question a little while ago, where I learned there are type theories that support continuation passing (e.g. exception handlers) model classical logic in a proof relevant way  (I think). As far as I know there are no proof assistants that utilize this approach for reasons unknown to me.</p>",
        "id": 196015631,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588370799
    },
    {
        "content": "<p>Is this the thing about callcc with type <code>(((A -&gt; B) -&gt; A) -&gt; A</code> that has some computational interpretation. I never understood that.</p>",
        "id": 196015836,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588370972
    },
    {
        "content": "<p>Yes. I don't understand it either. But it seems like an exciting approach since to me proof relevance and computational interpretation seem desirable. But I'm sure there's some drawback that makes it not practical or something</p>",
        "id": 196016521,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588371546
    },
    {
        "content": "<p>I think it's an interesting observation that proof irrelevance and ignoring computation, the approach used in mathlib in general, has meant that the library has grown very quickly and seems to be well on the way to covering a pure mathematics degree</p>",
        "id": 196017228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588372181
    },
    {
        "content": "<p>Well I certainly wouldn't want to adopt a system that provides proof relevance at the expense of being able to do ordinary mathematics efficiently. But from my feeble understanding of the exception handling/continuation-passing style is that this wouldn't be the case. I don't see how on the surface any of what we do in Lean would be different and would slow anything down, it would just add proof relevance so that we could do interesting things with proof objects themselves.</p>",
        "id": 196017788,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372731
    },
    {
        "content": "<p>There are all these different interesting ways to write a proof of the same proposition that I as a human outside the system can appreciate, but the type theory itself cannot because all the proofs are equal. It would be neat if the type theory itself could represent all the proofs and therefore have functions from one proof to another etc. You could prove things about the space of proofs for a proposition or something.</p>",
        "id": 196018062,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372956
    },
    {
        "content": "<p>You not really forced to use proof irrelevance in Lean even though it's available, you can always use <code>Type</code> if you want.</p>",
        "id": 196018176,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588373085
    },
    {
        "content": "<p>Yes but my understanding is you're restricted to constructive logic outside of Prop</p>",
        "id": 196018344,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373245
    },
    {
        "content": "<p>I think the continuation passing style would look something like this under-the-hood (mixing C++-style code with Lean)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">try</span> <span class=\"o\">{</span>\n   <span class=\"c1\">-- derive contradiction, raising an exception</span>\n<span class=\"o\">}</span> <span class=\"n\">catch</span> <span class=\"n\">Exception</span> <span class=\"n\">e</span> <span class=\"o\">{</span>\n    <span class=\"c1\">-- something something</span>\n    <span class=\"n\">return</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 196018881,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373801
    }
]