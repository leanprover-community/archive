[
    {
        "content": "<p>What is large elimination? What is subsingleton elimination? Why do we care about these? What do they have to do with proof irrelevance? What's so good about proof irrelevance anyway?</p>",
        "id": 196007956,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588366024
    },
    {
        "content": "<p>Some inductive propsition have a recursor that can make elements of a Type e.g. <code>eq</code>, <code>true</code>, <code>false</code>, <code>and</code>, <code>acc</code>. Others can only make a Prop, e.g. <code>exists</code> and <code>or</code>. eliminating into Type is call large elemination. If large elimination was allowed on <code>or</code> then the iota reduction rule would be inconsistent because of proof irrelevance, your function could return different values for <code>or.inl x</code> and <code>or.inr y</code>, even though <code>or.inl x.= or.inr y</code>. The Props with large elimination don't have this problem.</p>",
        "id": 196012582,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368819
    },
    {
        "content": "<p>This is basically because they would be a subsingleton anyway, even if they were types. They only have one constructor, and all arguments are either props or are mentioned in the type of the output. There is a more precise rule for this somewhere.</p>",
        "id": 196012775,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368920
    },
    {
        "content": "<p>I think other people can answer what is so good about proof irrelevance better than me, but one example is that <code>subtype.ext</code> would not hold without it.</p>",
        "id": 196012885,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588368978
    },
    {
        "content": "<p><a href=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\" title=\"https://lean-forward.github.io/logical-verification/2018/41_notes.html\">https://lean-forward.github.io/logical-verification/2018/41_notes.html</a> might be helpful</p>",
        "id": 196013729,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588369493
    },
    {
        "content": "<p>Thanks Chris. I will have a read</p>",
        "id": 196015004,
        "sender_full_name": "Ken Lee",
        "timestamp": 1588370392
    },
    {
        "content": "<p>Only the Prop type is proof irrelevant (all terms are definitionally equal) because it has to be in order to support classical reasoning - that was my understanding from the HoTT book. I asked a related question a little while ago, where I learned there are type theories that support continuation passing (e.g. exception handlers) model classical logic in a proof relevant way  (I think). As far as I know there are no proof assistants that utilize this approach for reasons unknown to me.</p>",
        "id": 196015631,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588370799
    },
    {
        "content": "<p>Is this the thing about callcc with type <code>(((A -&gt; B) -&gt; A) -&gt; A</code> that has some computational interpretation. I never understood that.</p>",
        "id": 196015836,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588370972
    },
    {
        "content": "<p>Yes. I don't understand it either. But it seems like an exciting approach since to me proof relevance and computational interpretation seem desirable. But I'm sure there's some drawback that makes it not practical or something</p>",
        "id": 196016521,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588371546
    },
    {
        "content": "<p>I think it's an interesting observation that proof irrelevance and ignoring computation, the approach used in mathlib in general, has meant that the library has grown very quickly and seems to be well on the way to covering a pure mathematics degree</p>",
        "id": 196017228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588372181
    },
    {
        "content": "<p>Well I certainly wouldn't want to adopt a system that provides proof relevance at the expense of being able to do ordinary mathematics efficiently. But from my feeble understanding of the exception handling/continuation-passing style is that this wouldn't be the case. I don't see how on the surface any of what we do in Lean would be different and would slow anything down, it would just add proof relevance so that we could do interesting things with proof objects themselves.</p>",
        "id": 196017788,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372731
    },
    {
        "content": "<p>There are all these different interesting ways to write a proof of the same proposition that I as a human outside the system can appreciate, but the type theory itself cannot because all the proofs are equal. It would be neat if the type theory itself could represent all the proofs and therefore have functions from one proof to another etc. You could prove things about the space of proofs for a proposition or something.</p>",
        "id": 196018062,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588372956
    },
    {
        "content": "<p>You not really forced to use proof irrelevance in Lean even though it's available, you can always use <code>Type</code> if you want.</p>",
        "id": 196018176,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1588373085
    },
    {
        "content": "<p>Yes but my understanding is you're restricted to constructive logic outside of Prop</p>",
        "id": 196018344,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373245
    },
    {
        "content": "<p>I think the continuation passing style would look something like this under-the-hood (mixing C++-style code with Lean)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">dne</span> <span class=\"o\">:</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"n\">try</span> <span class=\"o\">{</span>\n   <span class=\"c1\">-- derive contradiction, raising an exception</span>\n<span class=\"o\">}</span> <span class=\"n\">catch</span> <span class=\"n\">Exception</span> <span class=\"n\">e</span> <span class=\"o\">{</span>\n    <span class=\"c1\">-- something something</span>\n    <span class=\"n\">return</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 196018881,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588373801
    },
    {
        "content": "<p>We already have a syntax for LEM, namely <code>if/then/else</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">dne</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">not</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"k\">then</span> <span class=\"n\">hp</span> <span class=\"k\">else</span> <span class=\"n\">false</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>I think you are proposing a kind of \"computational\" semantics for <code>if/then/else</code> where <code>if hp : p then x[hp] else y[hp]</code> is implemented as \"capture the current continuation and pass it to <code>y</code> as a claimed proof of <code>not p</code>; if <code>y</code> ever tries to invoke this proof then reset to the branch point and instead pass <code>x</code> the proof of <code>p</code> you got from <code>y</code>\".</p>",
        "id": 196020106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588374904
    },
    {
        "content": "<p>As I understand it, this is somehow logically sound in that a valid proof using classical logic is transformed into a program which terminates (in some sense).</p>",
        "id": 196020172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588374965
    },
    {
        "content": "<p>Yes yes. Now do you know why this doesn't seem to be implemented in any proof assistant? Looks like continuation passing idea dates back to at least the early 90s</p>",
        "id": 196020244,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375042
    },
    {
        "content": "<p>However, another property you would probably like for your language is that <code>if hp : p then x[hp] else y[hp]</code> evaluates to <code>x[hp]</code> if <code>p</code> is true and <code>y[hp]</code> if <code>p</code> is false, and this property would be lost. For example if <code>y</code> does not actually use <code>hp</code> then the result will always be <code>y</code>.</p>",
        "id": 196020248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375049
    },
    {
        "content": "<p>So, the semantics is logically sound (you will get out some value) but not sound in the sense of producing the <em>correct</em> value.</p>",
        "id": 196020318,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375084
    },
    {
        "content": "<p>So, for programming it's rather useless.</p>",
        "id": 196020330,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375090
    },
    {
        "content": "<p>In particular using LEM you can define a function <code>value : Prop -&gt; bool</code> with <code>value true = tt</code> and <code>value false = ff</code> according to the logic, but if you actually run <code>value p</code> you will always get the answer <code>ff</code> (or maybe <code>tt</code>, depending on how you defined it).</p>",
        "id": 196020486,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375243
    },
    {
        "content": "<p>I'm not sure I follow but that's my fault not yours. I thought all we care about when proving something is to create a valid term of a type, doesn't matter what term it is</p>",
        "id": 196020827,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375534
    },
    {
        "content": "<p>I agree that a function that always raises an exception and doesn't give you what you expect isn't a useful function, but exception handling as a construct is useful in that it allows you to do something else before the function returns. You might try calling the function again with a different value for example.</p>",
        "id": 196020913,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375600
    },
    {
        "content": "<p>Well that's what I care about, and that's why proof <em>ir</em>relevance is a natural and good property to look for in your system.</p>",
        "id": 196020914,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375602
    },
    {
        "content": "<p>Well there are two levels. On the one hand, in order to prove something under the propositions-as-types paradigm, I only need to construct a term of that type, any term. So in some sense, no matter what all terms are \"equally good\" since they prove the type. But in another sense, I might care that a particular term uses lemma1 versus another term that uses lemma2, and this could be an interesting area of study in its own right. That is only possible with proof relevance. So I don't see how proof relevance gets rid of anything good that is in a proof irrelevant system; you only get more options.</p>",
        "id": 196021065,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588375783
    },
    {
        "content": "<p>No, it is possible for example by examining the proof metatheoretically.</p>",
        "id": 196021127,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375806
    },
    {
        "content": "<p>I don't think it has any internal meaning.</p>",
        "id": 196021133,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375817
    },
    {
        "content": "<p>We have this in Lean in the sense that the olean file will be different depending on which proof you wrote.</p>",
        "id": 196021171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375861
    },
    {
        "content": "<p>To turn your argument around, being able to prove that <code>proof1 = proof2</code> for any two proofs of the same statement is something only possible with proof irrelevance, and it can only be good to have this additional option.</p>",
        "id": 196021264,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588375932
    },
    {
        "content": "<p>If two terms are syntactically identical but with different names, you could prove proof1 = proof2 using reflexivity right?</p>",
        "id": 196021462,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376113
    },
    {
        "content": "<p>Sure, but the interesting case is when the proofs are not syntactically identical</p>",
        "id": 196021546,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376193
    },
    {
        "content": "<p>for a more recent version of the link that chris posted, see <a href=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\" title=\"https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf\">https://github.com/blanchette/logical_verification_2020/raw/master/hitchhikers_guide.pdf</a>.<br>\nthey talk about benefits of proof irrelevance in 11.2 and 11.4.</p>",
        "id": 196021575,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1588376224
    },
    {
        "content": "<p>I think the usual abuse of \"proof\" to mean inhabitant of a proposition causes some confusion here</p>",
        "id": 196021784,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376464
    },
    {
        "content": "<p>But in Lean right now, if I restrict myself to non-Prop types and therefore do not use classical axioms, then I can construct two (non-syntactically identical) terms for a theorem about some property of lists, for example. Then I could perhaps write a function that computes a distance between two terms and then I could have a sort of metric space of proof terms. Many other interesting things I could do with the proof terms.</p>",
        "id": 196021857,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376563
    },
    {
        "content": "<p>And with continuation-passing, I think this could be extended into proofs using classical logic</p>",
        "id": 196021917,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588376631
    },
    {
        "content": "<p>You seem to be confusing a proof <strong>term</strong> (a syntactic thing) with its value internally</p>",
        "id": 196021982,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376674
    },
    {
        "content": "<p>If I give you <code>x y : forall (a b : nat), a + b = b + a</code>, there is no function you can define inside Lean that has any way to distinguish between <code>x</code> and <code>y</code></p>",
        "id": 196022017,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376736
    },
    {
        "content": "<p>In fact, in this case, I'm pretty sure that even if you do not use Prop at all, you can still prove that <code>x = y</code></p>",
        "id": 196022090,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376833
    },
    {
        "content": "<p>well, at least if you allow <code>funext</code></p>",
        "id": 196022101,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588376848
    },
    {
        "content": "<p>You can distinguish proofs of <code>p -&gt; p or p</code> based on whether they produce <code>or.inl</code> or <code>or.inr</code>, but this is not at all the same kind of thing as \"distance between two terms\".</p>",
        "id": 196022272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588377013
    },
    {
        "content": "<p>Ah I see now. You could only do stuff like that metatheoretically as you said earlier. Like in homoiconic programming languages like Lisp or Julia you could take the syntactic term code and use it as data. Not sure if such languages could be made to correspond to a consistent logic.</p>",
        "id": 196022625,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588377401
    },
    {
        "content": "<p>Here is a concrete advantage of (definitional) proof irrelevance. Suppose I need to prove</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"c1\">-- example shamelessly stolen from Kevin</span>\n</code></pre></div>\n\n\n<p>as part of a larger development. Proving this by hand would be a not very enjoyable exercise. Fortunately we have the <code>ring</code> tactic so I can just write <code>by ring</code> and move on. Later I use lemma <code>A</code> in order to prove some amazing theorem.</p>\n<p>Now the next day somebody finds that the <code>ring</code> tactic has an annoying bug where sometimes you have to write <code>ring, ring</code>, and this gets fixed. As a side effect, maybe <code>ring</code> no longer produces the exact same proof term for lemma <code>A</code> as it did before. But that is fine, since I have a guarantee that changing the proof of <code>A</code> will not break the proof of my amazing theorem--that's provided by definitional proof irrelevance.</p>",
        "id": 196022656,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588377471
    },
    {
        "content": "<p>But even if it changes the proof term I don't see how it should affect anything downstream. It just needs to type check right?</p>",
        "id": 196023025,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588377879
    }
]