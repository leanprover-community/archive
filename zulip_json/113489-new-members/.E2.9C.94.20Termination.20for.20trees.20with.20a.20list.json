[
    {
        "content": "<p>Hello,</p>\n<p>I am trying to model datalog and prove results about that in lean and am currently interested in the proof-theoretic semantics. For this I defined trees using the list, as there is no bound on the number of atoms in the body, in the following way</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">tree</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span><span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">tree</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">→</span>  <span class=\"n\">tree</span> <span class=\"n\">A</span>\n</code></pre></div>\n<p>I want to define a function that identifies valid trees and looks at a large scale like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">root</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">Tree.node</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">localCriteria1</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">:</span><span class=\"n\">List</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">localCriteria2</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValid</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Tree.node</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">localCriteria1</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">root</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">List.All₂</span> <span class=\"n\">isValid</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∧</span> <span class=\"n\">localCriteria2</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>For this I need to prove termination and am a bit lost. Without List.All I have no problems. I have read some posts here and the parts of functional programming in lean, but I don't find a way to prove termination. I have seen the unfolding by adding a local definition for the list-function but that didn't work for me and seems inpractical to always redefine the functions.</p>\n<p>Intuitively, it should terminate because I only call it on the children, so that sizeOf should decrease, but this is hidden inside List.All. Ideally I would want to prove that for every t in l, sizeOf t &lt; sizeOf (node a l), but don't know how to get this goal. Just using sizeOf, gets me an unhelpful proof state. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isValid</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Tree.node</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">localCriteria1</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">root</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">List.All₂</span> <span class=\"n\">isValid</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∧</span> <span class=\"n\">localCriteria2</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">termination_by</span> <span class=\"n\">isValid</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n  <span class=\"n\">decreasing_by</span>\n    <span class=\"n\">simp_wf</span>\n\n<span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">t</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">A</span>\n<span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Tree</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"n\">Tree.node</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n<span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span> <span class=\"bp\">&lt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span><span class=\"bp\">✝</span>\n</code></pre></div>\n<p>What do I have to change ?</p>",
        "id": 400133569,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1699018004
    },
    {
        "content": "<p>Try replacing <code>List.All₂ isValid l</code> with <code>l.attach.All₂ (fun \\&lt;x, _h\\&gt; =&gt; isValid x)</code>. This way, the assumption <code>x \\elem l</code> will be in scope for the termination checker.</p>",
        "id": 400151423,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1699023923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"619540\">Johannes Tantow</span> has marked this topic as resolved.</p>",
        "id": 400178643,
        "sender_full_name": "Notification Bot",
        "timestamp": 1699032795
    },
    {
        "content": "<p>Thank you, this works</p>",
        "id": 400178670,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1699032810
    }
]