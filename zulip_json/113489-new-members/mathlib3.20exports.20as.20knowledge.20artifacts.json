[
    {
        "content": "<p>Howdy folks, I have been looking at mathlib as a library of constructive entities, from the knowledge management (KM) point of view.  (I recognize that mathlib is an ongoing project, incomplete and imperfect, and that is just fine!)</p>\n<p>I would like to look at the <code>export.json</code> file that is built as an intermediate step in the doc-gen process for mathlib.  <br>\nIt is output by the lean code in <a href=\"https://github.com/leanprover-community/doc-gen/blob/master/src/export_json.lean\">https://github.com/leanprover-community/doc-gen/blob/master/src/export_json.lean</a>.<br>\n(This file is not the same as <code>export_db.json.gz</code>, which is a less-structured output from the next stage of the doc-gen process).<br>\nAFAIK I would need to install Lean and build mathlib before I could see <code>export.json</code>.    <br>\nI have not yet tried to do a full Lean install.<br>\nI will enjoy doing so when I can, but if anyone can help me skip ahead to see <code>export.json</code> sooner, that would be swell.<br>\nI presume it appears somewhere in this neighborhood during a build of the mathlib docs:<br>\n<code>/home/runner/work/doc-gen/doc-gen/mathlib/</code></p>\n<p>Additional background on where I am coming from, including discussion of the \"Mathematics Subject Classification\" (MSC) taxonomy and recent work on math knowledge mgmt., in the mathlib channel of the Xena Discord:<br>\nMay 23:  <a href=\"https://discord.com/channels/679792285910827018/717708103059112007/846158094466547743\">https://discord.com/channels/679792285910827018/717708103059112007/846158094466547743</a><br>\nMay 29:  <a href=\"https://discord.com/channels/679792285910827018/717708103059112007/848263391458230353\">https://discord.com/channels/679792285910827018/717708103059112007/848263391458230353</a></p>",
        "id": 240716246,
        "sender_full_name": "Stu B22",
        "timestamp": 1622314815
    },
    {
        "content": "<p>I'm running <code>doc-gen</code> locally now and I can upload <code>export.json</code> later today when I'm back at the computer.</p>",
        "id": 240719945,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622320718
    },
    {
        "content": "<p>That's splendid Bryan, thank you very much!</p>",
        "id": 240720106,
        "sender_full_name": "Stu B22",
        "timestamp": 1622320987
    },
    {
        "content": "<p>Learned that \"low level format\"  (aka <code>export_format</code> ex: <code>lean --export=export.out --recursive</code>) is a more faithful form of export for a given loadable fully-elaborated theory.  <br>\nDiscussion at <a href=\"#narrow/stream/113488-general/topic/Lean.20type.20checkers.20overview/near/240698222\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Lean.20type.20checkers.20overview/near/240698222</a>  <br>\nleads us to  <a href=\"https://github.com/leanprover/lean/blob/master/doc/export_format.md\">https://github.com/leanprover/lean/blob/master/doc/export_format.md</a> <br>\n\"Lean can export .lean files in a low-level format that is easy to parse and process. The exported file contains only fully elaborated terms. The file describes hierarchical names, universe levels and expressions. These objects are used to declare inductive datatypes, definitions and axioms.\"<br>\nThis lean low-level-format is suitable for external checking of the proofs by a typechecker like <code>Trepplein</code> <br>\n<a href=\"https://github.com/gebner/trepplein/blob/master/src/main/scala/trepplein/typechecker.scala\">https://github.com/gebner/trepplein/blob/master/src/main/scala/trepplein/typechecker.scala</a><br>\n\"Lean is an interactive theorem prover based on dependent type theory. For additional trust, Lean can export the generated proofs so that they can be independently verified. Trepplein is a tool that can check these exported proofs. Trepplein is written in Scala\".</p>",
        "id": 240723976,
        "sender_full_name": "Stu B22",
        "timestamp": 1622325876
    },
    {
        "content": "<p>Here it is: <a href=\"/user_uploads/3121/IfFjlfh3pKOPn3xlTu6OEZFP/export.json.zip\">export.json.zip</a> (13 MB file, uncompresses to about 93 MB)</p>\n<p>Note that it only takes about 10-15 minutes to generate, but I've been out and about until now.</p>",
        "id": 240727843,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622331724
    },
    {
        "content": "<p>Got it!  I appreciate your time spent.  This file should help me jump ahead in my learning.</p>",
        "id": 240735970,
        "sender_full_name": "Stu B22",
        "timestamp": 1622346155
    },
    {
        "content": "<p>I now have desktop lean3 tutorials working on MS-Win 10 with VSCode, so now I have better frame of reference.<br>\nI also did some initial analysis on the export.json.zip which Bryan kindly provided.<br>\nGood news :  ~90MB unpacked export.json for mathlib parses and loads promptly into objects using an ordinary java setup.<br>\nWe see 5 kinds of top level entities:  <code>decls, instances, mod_docs, notes, tactic_docs</code><br>\nWe find 79,515 decls, each of which contains these fields (in no particular order): <br>\n<code>structure_fields, name , line, equations, constructors, attributes, filename, args, doc_string, kind, type, is_meta</code><br>\nExample: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"s2\">\"args\"</span><span class=\"o\">:</span>  <span class=\"n\">OMITTED</span>\n<span class=\"s2\">\"attributes\"</span> <span class=\"o\">:</span> <span class=\"o\">[</span> <span class=\"o\">],</span>\n  <span class=\"s2\">\"constructors\"</span> <span class=\"o\">:</span> <span class=\"o\">[</span> <span class=\"o\">],</span>\n  <span class=\"s2\">\"doc_string\"</span> <span class=\"o\">:</span> <span class=\"s2\">\"\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"equations\"</span> <span class=\"o\">:</span> <span class=\"o\">[</span> <span class=\"o\">],</span>\n  <span class=\"s2\">\"filename\"</span> <span class=\"o\">:</span> <span class=\"s2\">\"/Users/chb/Documents/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"is_meta\"</span> <span class=\"o\">:</span> <span class=\"n\">false</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"kind\"</span> <span class=\"o\">:</span> <span class=\"s2\">\"theorem\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"line\"</span> <span class=\"o\">:</span> <span class=\"mi\">1856</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"name\"</span> <span class=\"o\">:</span> <span class=\"s2\">\"has_deriv_within_at.liminf_right_slope_le\"</span><span class=\"o\">,</span>\n  <span class=\"s2\">\"structure_fields\"</span> <span class=\"o\">:</span> <span class=\"o\">[</span> <span class=\"o\">],</span>\n  <span class=\"s2\">\"type\"</span> <span class=\"o\">:</span>  <span class=\"n\">OMITTED</span>\n</code></pre></div>\n<p>I omitted <code>args</code> and <code>type</code> because they contain the meat: long text/structure including much spicy unicode.</p>\n<p>A practical sticking point arises from the breadth of unicode in these exported decls.   Different text environments (browser/editor/IDE, font) can give visually different results,  and may show missing-char codes.  (I hope that font-codepage is the ONLY challenge I hit here).  </p>\n<p>I noticed that even VSCode may fail to display all of the text from the export, so I wanted to be sure I had a real Lean3  desktop setup to compare with.  That was Friday's accomplishment, and now I am excited to probe further.</p>",
        "id": 241655940,
        "sender_full_name": "Stu B22",
        "timestamp": 1622926641
    },
    {
        "content": "<p>It SEEMS that the <code>efmt</code> strings written by <code>export_json.lean</code> contain some unicode chars that do not commonly appear in .lean source files.<br>\nIn the source code here <br>\n<a href=\"https://github.com/leanprover-community/doc-gen/blob/master/src/export_json.lean\">https://github.com/leanprover-community/doc-gen/blob/master/src/export_json.lean</a><br>\nwe see that the output format is summarized by this typescript:</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"kd\">interface</span> <span class=\"nx\">DeclInfo</span> <span class=\"p\">{</span>\n  <span class=\"nx\">name</span>: <span class=\"kt\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">args</span>: <span class=\"kt\">efmt</span><span class=\"p\">[];</span>\n  <span class=\"kd\">type</span><span class=\"o\">:</span> <span class=\"nx\">efmt</span><span class=\"p\">;</span>\n  <span class=\"nx\">doc_string</span>: <span class=\"kt\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">filename</span>: <span class=\"kt\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">line</span>: <span class=\"kt\">int</span><span class=\"p\">;</span>\n  <span class=\"nx\">attributes</span>: <span class=\"kt\">string</span><span class=\"p\">[];</span>\n  <span class=\"nx\">equations</span>: <span class=\"kt\">efmt</span><span class=\"p\">[];</span>\n  <span class=\"nx\">kind</span>: <span class=\"kt\">string</span><span class=\"p\">;</span>\n  <span class=\"nx\">structure_fields</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">efmt</span><span class=\"p\">][];</span>\n  <span class=\"nx\">constructors</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">efmt</span><span class=\"p\">][];</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Where efmt is defined as follows ('c' is a concatenation, 'n' is nesting) - again as typescript:</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"kd\">type</span> <span class=\"nx\">efmt</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"nx\">efmt</span><span class=\"p\">,</span> <span class=\"nx\">efmt</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"p\">[</span><span class=\"s1\">'n'</span><span class=\"p\">,</span> <span class=\"nx\">efmt</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kt\">string</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>...and we see the decls are actually marshalled by this lean function</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">decl_info.to_json</span> <span class=\"o\">:</span> <span class=\"n\">decl_info</span> <span class=\"bp\">→</span> <span class=\"n\">json</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">is_meta</span><span class=\"o\">,</span> <span class=\"n\">args</span><span class=\"o\">,</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">doc_string</span><span class=\"o\">,</span> <span class=\"n\">filename</span><span class=\"o\">,</span> <span class=\"n\">line</span><span class=\"o\">,</span> <span class=\"n\">attributes</span><span class=\"o\">,</span> <span class=\"n\">equations</span><span class=\"o\">,</span> <span class=\"n\">kind</span><span class=\"o\">,</span> <span class=\"n\">structure_fields</span><span class=\"o\">,</span> <span class=\"n\">constructors</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"n\">json.object</span> <span class=\"o\">[</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"name\"</span><span class=\"o\">,</span> <span class=\"n\">to_string</span> <span class=\"n\">name</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"is_meta\"</span><span class=\"o\">,</span> <span class=\"n\">is_meta</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"args\"</span><span class=\"o\">,</span> <span class=\"n\">json.array</span> <span class=\"bp\">$</span> <span class=\"n\">args.map</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">⟩,</span> <span class=\"n\">json.object</span> <span class=\"o\">[(</span><span class=\"s2\">\"arg\"</span><span class=\"o\">,</span> <span class=\"n\">s.to_json</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"s2\">\"implicit\"</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)]),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"type\"</span><span class=\"o\">,</span> <span class=\"n\">type.to_json</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"doc_string\"</span><span class=\"o\">,</span> <span class=\"n\">doc_string.get_or_else</span> <span class=\"s2\">\"\"</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"filename\"</span><span class=\"o\">,</span> <span class=\"n\">filename</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"line\"</span><span class=\"o\">,</span> <span class=\"n\">line</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"attributes\"</span><span class=\"o\">,</span> <span class=\"n\">json.of_string_list</span> <span class=\"n\">attributes</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"equations\"</span><span class=\"o\">,</span> <span class=\"n\">equations.map</span> <span class=\"n\">efmt.to_json</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"kind\"</span><span class=\"o\">,</span> <span class=\"n\">kind</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"structure_fields\"</span><span class=\"o\">,</span> <span class=\"n\">json.array</span> <span class=\"bp\">$</span>\n    <span class=\"n\">structure_fields.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩,</span> <span class=\"n\">json.array</span> <span class=\"o\">[</span><span class=\"n\">to_string</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t.to_json</span><span class=\"o\">])),</span>\n  <span class=\"o\">(</span><span class=\"s2\">\"constructors\"</span><span class=\"o\">,</span> <span class=\"n\">json.array</span> <span class=\"bp\">$</span>\n    <span class=\"n\">constructors.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩,</span> <span class=\"n\">json.array</span> <span class=\"o\">[</span><span class=\"n\">to_string</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">t.to_json</span><span class=\"o\">]))]</span>\n</code></pre></div>",
        "id": 241664036,
        "sender_full_name": "Stu B22",
        "timestamp": 1622940669
    },
    {
        "content": "<p>It appears that the output text contains a lot of 3-byte unicode characters beginning with hex EE.<br>\nThe hex sequence   <code>EE 80 80</code>  occurs a lot, similarly <code>EE 80 81</code> and <code>EE 80 82</code>.<br>\nIt seems these chars are from the Private Use Area range of unicode.   <a href=\"https://en.wikipedia.org/wiki/Private_Use_Areas\">https://en.wikipedia.org/wiki/Private_Use_Areas</a></p>",
        "id": 241664776,
        "sender_full_name": "Stu B22",
        "timestamp": 1622941980
    },
    {
        "content": "<p>I get the impression that these special chars are being used by the doc-gen <code>export_json.lean</code> to mark-up the <code>efmt</code> text output, in a way that is useful to the downstream doc-gen python scripts.</p>",
        "id": 241664985,
        "sender_full_name": "Stu B22",
        "timestamp": 1622942329
    },
    {
        "content": "<p>It looks like most of these occurrences are delimiting the occurrences of (linkable?) symbols.</p>",
        "id": 241665368,
        "sender_full_name": "Stu B22",
        "timestamp": 1622943075
    },
    {
        "content": "<p>Does this help? <a href=\"https://github.com/leanprover-community/doc-gen/blob/7e76fe3e93fa96aa6332d3e6cbcfacd168f59d4b/print_docs.py#L354\">https://github.com/leanprover-community/doc-gen/blob/7e76fe3e93fa96aa6332d3e6cbcfacd168f59d4b/print_docs.py#L354</a></p>",
        "id": 241677225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622962771
    },
    {
        "content": "<p>There is no such thing as a \"3 byte unicode character\"; what you're describing is a unicode codepoint <em>whose UTF-8 encoding</em> has 3 bytes.</p>",
        "id": 241677318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622962856
    },
    {
        "content": "<p>Yes, that link helps, thanks, and good point about the unicode definitions.</p>",
        "id": 241706823,
        "sender_full_name": "Stu B22",
        "timestamp": 1623007503
    }
]