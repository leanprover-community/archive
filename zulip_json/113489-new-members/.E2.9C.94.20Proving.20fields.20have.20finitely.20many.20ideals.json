[
    {
        "content": "<p>I'm trying to prove that given a commutative ring R, if R is a field then Ideal R is finite.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">LocalRing</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isField_Finite_Ideals</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsField</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">toField</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">finIdeal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">instFinite</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">finIdeal</span>\n</code></pre></div>\n<p>It runs fine until the last line where I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">finIdeal</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">DivisionSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">CommSemiring</span><span class=\"bp\">.</span><span class=\"n\">toSemiring</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I'm still getting used to typeclass instances so this seems like a good place to learn, how should I fix this?</p>",
        "id": 508087957,
        "sender_full_name": "Brian Nugent",
        "timestamp": 1742924153
    },
    {
        "content": "<p>Please add the imports so that it's a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 508088885,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1742924385
    },
    {
        "content": "<p>Ok, I added them</p>",
        "id": 508089515,
        "sender_full_name": "Brian Nugent",
        "timestamp": 1742924566
    },
    {
        "content": "<p>Make you <code>have q</code> into a <code>let q</code>. That should fix it.</p>",
        "id": 508089523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742924570
    },
    {
        "content": "<p>Why does changing the <code>have</code> into a <code>let</code> fix the issue?</p>",
        "id": 508089761,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1742924641
    },
    {
        "content": "<p>That did fix it, thank you! Could you explain why so I can figure these out by myself in the future?</p>",
        "id": 508089802,
        "sender_full_name": "Brian Nugent",
        "timestamp": 1742924643
    },
    {
        "content": "<p>Otherwise Lean forgets the data of the field structure, and doesn't see that it agrees with the ring structure you started</p>",
        "id": 508089820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742924647
    },
    {
        "content": "<p>Let me take a stab at describing the problem to see if I understand it correctly. When we use <code>have</code> here lean forgets the data attached to <code>R</code> so the <code>Field</code> instance on <code>R</code> is just <em>some</em> ring structure. When we use <code>let</code> it makes sure that we get <em>the</em> ring structure in the statement of the theorem.</p>",
        "id": 508091003,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1742925000
    },
    {
        "content": "<p>So when I use let, if there is an instance that takes Field R down to CommRing R, it knows the identify that with the instance of CommRing R that we already have? </p>\n<p>Also, it seems that when we have an instance of Field R, to go down to SemiRing R there are multiple \"paths\", one going through DivisionSemiring and another going through CommSemiring (this is what caused the initial error it seems). Is there something in Lean that says these are the same? If I write my own instances, should I prove compatibilities like this?</p>",
        "id": 508092313,
        "sender_full_name": "Brian Nugent",
        "timestamp": 1742925432
    },
    {
        "content": "<p>Those compatibilities are not enforced by Lean, but indeed they are very important for a usable library</p>",
        "id": 508099815,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742927583
    },
    {
        "content": "<p>So we try hard to make sure that Mathlib doesn't have such \"diamonds\"</p>",
        "id": 508099911,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742927617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"891789\">Brian Nugent</span> has marked this topic as resolved.</p>",
        "id": 508112360,
        "sender_full_name": "Notification Bot",
        "timestamp": 1742931529
    }
]