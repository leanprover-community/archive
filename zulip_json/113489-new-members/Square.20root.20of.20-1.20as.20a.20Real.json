[
    {
        "content": "<p>So I was reading a <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2024/Part_A/section02reals/reals.html#garbage-in-garbage-out\">section on Reals</a> from Kevin's course notes and this stood out to me:</p>\n<blockquote>\n<p>So what happens if you feed in <code>-1</code> or some other negative number? Lean doesn’t give you an error! It just spits out some arbitrary answer – for all I know, <code>Real.sqrt (-1) = 37</code>. I have no idea what <code>Real.sqrt (-1)</code> actually is, and it doesn’t even matter, because I am a mathematician, so I only run <code>Real.sqrt</code> on non-negative real numbers. If I want to take the square root of a negative number, I use <code>Complex.sqrt</code>. Perhaps you are worried that such a cavalier attitude towards square roots of negative numbers leads to contradictions in the system – but it does not. The simplest way to explain why is the following. Let me define a function <code>f</code> on the real numbers, by <code>f(x) = sqrt(x)</code> for <code>x ≥ 0</code>, and <code>f(x) = 37</code> if <code>x&lt;0</code>. Does <em>defining such a function</em> lead to a contradiction in mathematics? Of course it does not! That’s what <code>Real.sqrt</code> looks like (although they might have chosen <code>0</code> or <code>sqrt(-x)</code> for the output when <code>x</code> was negative – who knows, and who cares). The trick is that it is in the <em>theorems</em> about <code>Real.sqrt</code> where the hypotheses of nonnegativity appear. For example, it is probably not true that <code>Real.sqrt (a * b) = Real.sqrt (a) * Real.sqrt (b)</code> in general, because <code>a</code> or <code>b</code> might be negative. However it <em>is</em> true that <code>Real.sqrt (a * b) = Real.sqrt (a) * Real.sqrt (b)</code> if <code>a ≥ 0</code> and <code>b ≥ 0</code>, and this is the theorem in the library. So you <em>do</em> have to check that you’re not taking the square roots of negative numbers – just not where you might expect.</p>\n</blockquote>\n<p>This freaked me out a bit so I'm trying to reconstruct my mental model after this devastating blow. I want to understand this from the first principles. Why <em>is</em> it that the hypothesis is not \"needed\" at <code>Real.sqrt</code> stage? And if it only shows up later when I use the theorems, what (in Mathlib? in Lean?) ensures that no one \"forgot\" to enforce this constraint in all the relevant theorems about square roots? Does the need for nonnegativity emerge from the structure of how roots are defined but is also somehow naturally delayed until some fact about it is retrieved? I guess this is similar to how I can define <code>0 / 0</code> but then wouldn't be able to \"work\" with it?</p>\n<p>I feel like this almost makes sense but I'm struggling to convince myself that something underneath is holding all of this to be sound.</p>",
        "id": 505119208,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741782870
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Sqrt.html#Real.sqrt\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Sqrt.html#Real.sqrt</a><br>\nMaybe I missed something, but the doc says it returns 0 for negative numbers?</p>",
        "id": 505119885,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1741783033
    },
    {
        "content": "<p>So I think it's really two different questions:</p>\n<ul>\n<li>\n<p>\"How\": What mechanism ensures that at some point nonnegativity would <em>have</em> to be checked? Presumably, if it's ensured by the system, it's also encoded somewhere in the structure of the \"square root\" itself, even if we don't have to \"fill it in\" during a call. So where is it?</p>\n</li>\n<li>\n<p>\"Why\": Is there a <em>need</em> and/or a <em>benefit</em> to this kind of delayed justification? <em>Could</em> we define <code>Real.sqrt</code> as accepting the nonnegativity and \"carrying\" it? I guess this would force the return value to be a different structure from normal <code>\\R</code> which would be inconvenient? Is there some reason why it just <em>can't</em> be \"filled in\" early?</p>\n</li>\n</ul>",
        "id": 505120293,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741783141
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Sqrt.html#Real.sqrt\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Sqrt.html#Real.sqrt</a><br>\nMaybe I missed something, but the doc says it returns 0 for negative numbers?</p>\n</blockquote>\n<p>Right, my question is more philosophical — I'm asking why it's designed this way.</p>",
        "id": 505120424,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741783175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Square.20root.20of.20-1.20as.20a.20Real/near/505120293\">said</a>:</p>\n<blockquote>\n<ul>\n<li>\"How\": What mechanism ensures that at some point nonnegativity would <em>have</em> to be checked? Presumably, if it's ensured by the system, it's also encoded somewhere in the structure of the \"square root\" itself, even if we don't have to \"fill it in\" during a call. So where is it?</li>\n</ul>\n</blockquote>\n<p><code>Real.sqrt</code> is defined something like <code>fun x =&gt; if h : 0 ≤ x then (NNReal.sqrt ⟨x, h⟩).toReal else 0</code>. When you prove stuff about <code>Real.sqrt</code>, you have to do a case split on this if-then-else block, and sometimes you need the assumption that <code>0 ≤ x</code> to discard the <code>else</code> branch.</p>",
        "id": 505122194,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741783572
    },
    {
        "content": "<p>Kevin should quote his own <a href=\"https://xenaproject.wordpress.com/2020/07/05/division-by-zero-in-type-theory-a-faq/\">blog</a> here!</p>",
        "id": 505122391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741783628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Square.20root.20of.20-1.20as.20a.20Real/near/505120293\">said</a>:</p>\n<blockquote>\n<ul>\n<li>\"Why\": Is there a <em>need</em> and/or a <em>benefit</em> to this kind of delayed justification? <em>Could</em> we define <code>Real.sqrt</code> as accepting the nonnegativity and \"carrying\" it? I guess this would force the return value to be a different structure from normal <code>\\R</code> which would be inconvenient? Is there some reason why it just <em>can't</em> be \"filled in\" early?</li>\n</ul>\n</blockquote>\n<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NNReal.sqrt#doc\">docs#NNReal.sqrt</a>, which also exists, and you can use it. But you can't plug in real numbers, you have to use <code>NNReal</code>.</p>",
        "id": 505122900,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741783749
    },
    {
        "content": "<p>OK so reading Kevin's post about defining square root is helpful and helps me refine my question. If I <em>were</em> setting up my own <code>sqrt</code> from scratch, and if I did <em>not</em> follow Kevin's original approach (i.e. if I did similar to Mathlib and allowed any <code>\\R</code> inputs), would anything in Lean <em>force</em> me to make sure my theorems about <code>sqrt</code> took the nonnegativity hypothesis? Or would I be able to define it unsoundly and still have the proofs type check? (I don't mean it as \"Lean core has some opinions about square roots\" but more like, if math needs this constraint to be sound, surely this soundness has to creep up on me somewhere, as long as I'm not just defining new axioms?)</p>\n<p>Not sure if this makes sense. I'm mostly trying to understand whether anything \"forces\" the existing Mathlib theorems about square root to have the nonnegativity constraint, or whether it relies on the maintainers being careful. (There's also a question whether a structure like <code>NNReal</code> is essential to developing theorems about a square root — and that's what provides this enforcement — or whether it would be possible to develop the same user-facing theorems without a structure like this internally.)</p>",
        "id": 505125304,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741784317
    },
    {
        "content": "<p>Any theorem mentioning <code>Real.sqrt</code> might indeed not mean what you expect it to mean, and you do have to be a little careful when reading such a theorem. Two points though - (1) the theorems are still <em>true</em>, and (2) you can still use <code>Real.sqrt</code> to prove theorems that don't mention <code>Real.sqrt</code> at all. At no point does using this definition introduce soundness issues.</p>\n<p>Indeed the nonnegativity constraint is not generally enforced in mathlib: consider <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Sqrt.html#Real.sqrt_inv\">Real.sqrt_inv</a></p>",
        "id": 505128935,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1741785178
    },
    {
        "content": "<p>Let's imagine that your definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NNReal</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NNReal</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"bp\">⟨-</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">...⟩</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span>\n</code></pre></div>\n<p>so in practice <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mrow><mo>−</mo><mn>4</mn></mrow></msqrt><mo>=</mo><msqrt><mrow><mi mathvariant=\"normal\">∣</mi><mn>4</mn><mi mathvariant=\"normal\">∣</mi></mrow></msqrt><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\sqrt{-4}= \\sqrt{|4|}=2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1744em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8656em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">−</span><span class=\"mord\">4</span></span></span><span style=\"top:-2.8256em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1744em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.24em;vertical-align:-0.305em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.935em;\"><span class=\"svg-align\" style=\"top:-3.2em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"mord\">∣4∣</span></span></span><span style=\"top:-2.895em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.28em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.28em\" viewBox=\"0 0 400000 1296\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M263,681c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl0 -0\nc4.7,-7.3,11,-11,19,-11\nH40000v40H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM1001 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.305em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>. In this case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mrow><mi>x</mi><mi>y</mi></mrow></msqrt><mo>=</mo><msqrt><mi>x</mi></msqrt><msqrt><mi>y</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{xy}= \\sqrt{x}\\sqrt{y}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.3369em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7031em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span><span style=\"top:-2.6631em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3369em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1372em;vertical-align:-0.3369em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7031em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span><span style=\"top:-2.6631em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3369em;\"><span></span></span></span></span></span></span></span></span> is true without any assumption, and the idiomatic way of stating this in mathlib is in full generality.</p>",
        "id": 505128970,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785187
    },
    {
        "content": "<p>The idea is that if you want to <em>mathematically</em> use the theorem you do it in the case both <code>x</code> and <code>y</code> are positive, and it says what you want. The fact that it doesn't ask for those assumptions may be surprising, but it doesn't say something false.</p>",
        "id": 505129220,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785251
    },
    {
        "content": "<p>Note that if you really want you can prove in this way statement that are mathematically false, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo mathvariant=\"normal\">≠</mo><mn>4</mn><mo separator=\"true\">,</mo><mtext>  </mtext><msqrt><mi>x</mi></msqrt><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\exists x \\neq 4, \\; \\sqrt{x} = 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">x</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>.</p>",
        "id": 505129402,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785303
    },
    {
        "content": "<p>but this is a more philosophical question: checking that a Lean statement means what you have in mind cannot be done by a computer, that does not know what you have in mind. (In practice asserting the existence of something is probably the only way of doing this.)</p>",
        "id": 505129727,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785391
    },
    {
        "content": "<p>It's not about soundness, it's about translating what a human being has in mind to Lean. This is checked by other human beings, and in general it is a nontrivial task (are you sure Lean real numbers are what you think they are? You can check the definition of course, but at some point you just trust that nobody cheated in defining, say, the addition of natural numbers)</p>",
        "id": 505130990,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785741
    },
    {
        "content": "<p>You can have a look at <a href=\"https://leanprover-community.github.io/blog/posts/lte-examples/\">post</a> where we explain why we claimed to have formalized a theorem in some paper (the actual statement doesn't matter, the point is \"we have a proof of <em>something</em>, is this <em>something</em> the theorem we wanted?\")</p>",
        "id": 505131419,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741785863
    },
    {
        "content": "<p>You can google \"checking formalized mathematics\" or something similar to understand this is not a trivial job. <a href=\"https://www.brics.dk/RS/97/18/BRICS-RS-97-18.pdf\">Here</a> an interesting article.</p>",
        "id": 505134554,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741786594
    },
    {
        "content": "<p>In direct analogy with division by zero, a theorem that <em>must</em> assume <code>0 ≤ x</code> is the equality <code>x.sqrt ^ 2 = x</code>.</p>\n<p>With Riccardo's \"extension\", the analogous theorem would be <code>x.sqrt ^ 2 = x.abs</code> which works for all <code>x</code>.</p>\n<p>With mathlib's convention, the analogous theorem would be <code>x.sqrt ^ 2 = max x 0</code> which works for all <code>x</code>.</p>\n<p>Notice that over the \"interesting\" domain, the two conventions give you the same result.  You are simply able to prove other theorems, depending on which definition you use.</p>",
        "id": 505137515,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741787254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> One reason, in my opinion, to not include the condition <code>hx : 0 &lt;= x</code> or <code>hx : x \\ne 0</code> in things like <code>sqrt x</code> or <code>1 / x</code>, is because now we can have nice notation. Our usual notation does not have a slot where we can add the extra argument that proves the side condition.</p>\n<p>And notation is worth a lot...</p>",
        "id": 505154063,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1741790605
    },
    {
        "content": "<p>There is a more technical / pragmatic reason to not want to have <code>sqrt</code> be a function with the type <code>sqrt (x : ℝ) (hx : x ≥ 0) : ℝ</code>, which is that this makes <code>sqrt</code> have a dependent type (the type of <code>hx</code> depends on <code>x</code>), and that can cause very annoying rewrite blockage. For example, suppose you have a goal that has <code>sqrt (x + y) (...)</code> in it, where <code>...</code> is a proof that <code>x + y ≥ 0</code>. The usage of the dependent type here means that you are forced to prove that <code>x + y ≥ 0</code> upfront, which is what we signed up for, so everything is looking as expected so far.</p>\n<p>But now suppose you want to rewrite the <code>x + y</code> to <code>y + x</code>. If you use <code>rw [add_comm]</code> you will get a <code>motive is not type correct</code> error, and this is an extraordinarily frustrating experience because all of the workarounds are very verbose. What is happening is that <code>rw</code> tries to rewrite the goal to <code>sqrt (y + x) (...)</code>, where the <code>...</code> is the same as before, and in particular it still has type <code>x + y ≥ 0</code>, which is a problem since it's now supposed to be a proof of <code>y + x ≥ 0</code>. This is of course also true but the proof of <code>y + x ≥ 0</code> is different from the proof of <code>x + y ≥ 0</code>, and <code>rw</code> tried to rewrite only one piece of it. To do this rewrite properly you have to replace both terms at the same time, and <code>rw</code> isn't equipped to do that because rewriting the proof is much more than a find and replace job.</p>\n<p>By making the function simply typed, even if it's just a wrapper around the dependently typed function like <a href=\"#narrow/channel/113489-new-members/topic/Square.20root.20of.20-1.20as.20a.20Real/near/505122194\">this</a>, this issue disappears and you can perform rewrites under the <code>sqrt</code> freely.</p>",
        "id": 505513202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741895523
    },
    {
        "content": "<p>A mathematician would probably say that the \"right\" solution is to consider a function <code>ℝ≥0 → ℝ≥0</code>, that has not this problem (of curse it has the problem that now we cannot apply it to <code>π</code>).</p>",
        "id": 505618678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741942713
    },
    {
        "content": "<p>If I was informally discussing the square root with someone I would defer being precise about the details until they mattered.</p>\n<p>E.g., I might say \"well <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mrow><mi>t</mi><mi>r</mi><mo stretchy=\"false\">(</mo><msup><mi>A</mi><mi>t</mi></msup><mi>A</mi><mo stretchy=\"false\">)</mo></mrow></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{tr(A^tA)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.24em;vertical-align:-0.305em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.935em;\"><span class=\"svg-align\" style=\"top:-3.2em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7196em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.895em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.28em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.28em\" viewBox=\"0 0 400000 1296\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M263,681c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl0 -0\nc4.7,-7.3,11,-11,19,-11\nH40000v40H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM1001 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.305em;\"><span></span></span></span></span></span></span></span></span> is an integer and so ...\" and only later when I wanted to justify some claim would I confront issues like the trace being non-negative.</p>\n<p>This is exactly the sort of freedom the junk-value pattern gives us here.</p>",
        "id": 505621290,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1741943471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Square.20root.20of.20-1.20as.20a.20Real/near/505513202\">said</a>:</p>\n<blockquote>\n<p>But now suppose you want to rewrite the <code>x + y</code> to <code>y + x</code>. If you use <code>rw [add_comm]</code> you will get a <code>motive is not type correct</code> error, and this is an extraordinarily frustrating experience because all of the workarounds are very verbose. [...] To do this rewrite properly you have to replace both terms at the same time, and <code>rw</code> isn't equipped to do that because rewriting the proof is much more than a find and replace job.</p>\n</blockquote>\n<p>This example feels weak to me; <code>simp_rw</code> can handle such a rewrite IIRC, and I think there's a thread about a version of <code>rw</code> that can handle such dependent goals (by inserting casts into the proofs)</p>",
        "id": 505629321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741945869
    },
    {
        "content": "<p>That's why I called it a pragmatic issue, not a theoretical one. Sure you can have tactics that work around this issue, and there are proof assistants that do this systematically and partial functions are all the rage there. Lean is not such a system, and you will frequently run into rough edges when working with dependent types.</p>",
        "id": 505652288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1741952424
    }
]