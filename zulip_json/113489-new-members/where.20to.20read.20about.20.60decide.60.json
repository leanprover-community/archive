[
    {
        "content": "<p>I can't seem to find any online intro / guide to <code>decide</code>.</p>\n<p>I'd welcome pointers.</p>\n<p>(or if it is truly simple to understand, perhaps a paragraph here might suffice?)</p>",
        "id": 502762826,
        "sender_full_name": "rzeta0",
        "timestamp": 1740846408
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#decidable-propositions\">https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#decidable-propositions</a></p>",
        "id": 502765089,
        "sender_full_name": "Niels Voss",
        "timestamp": 1740847901
    },
    {
        "content": "<p>Here's the basic level:</p>\n<p>Thanks to Gödel, we know that there is no algorithm that can, in general, decide whether or not any given proposition is true (in the sense of finding a proof). However, this does not mean that every proposition is undecidable. For example, <code>1 &lt; 100</code> is decidable, since there is an algorithm that can evaluate natural number inequalities.</p>\n<p>Lean has a system to create a patchwork of decision algorithms, using the <code>Decidable</code> typeclass. People can define <code>Decidable</code> \"instances\" that extend the bounds of what is decidable.</p>\n<p>The <code>decide</code> tactic makes use of these instances to try to resolve goals. Given the goal, it tries to create a decision algorithm using the available instances. This might immediately fail with a \"failed to synthesize <code>Decidable</code> ...\" error, meaning there is no algorithm known to Lean. Then it evaluates the procedure, and there are three options: succeeds with true, fails with false, or indeterminate. In the success case, the goal is closed, in the failure case the tactic tells you the goal is actually false, and in the indeterminate case, the procedure was too complicated for Lean to evaluate (or it's fundamentally non-computable; this can happen if <code>decide</code> is used inside the <code>classical</code> tactic).</p>",
        "id": 502767886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740849804
    },
    {
        "content": "<p>There is no clear definition for when <code>decide</code> succeeds or fails.</p>\n<p>I think, basically, if you think it might work, it doesn't hurt trying it. If it doesn't work and you think it should, then (1) maybe the instance you need is in some un-imported module, (2) maybe the instance you need hasn't been written yet, or (3) maybe the goal is too complex to ever expect <code>decide</code> to be able to handle it.</p>",
        "id": 502768230,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740850037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  thanks - this is helpful.</p>\n<p>Is <code>exhaust</code> a simpler form of <code>decide</code> which only applies to propositions with no variables?</p>",
        "id": 502776005,
        "sender_full_name": "rzeta0",
        "timestamp": 1740855410
    },
    {
        "content": "<p>You remind me of one last point about <code>decide</code> that I didn't mention:</p>\n<p>The <code>decide</code> prefers not having any variables in the goal (though variables defined with <code>let</code> are OK). It will give you an error if there are any. (The rough reason why is that there are two things <code>decide</code> could try to do: symbolically evaluate the algorithm, or universally quantify the variable. Not only are there two options, but both can be unexpectedly expensive, so <code>decide</code> decides 'no'.)</p>\n<p>If you <em>do</em> want to work with goals that have variables, the <code>decide +revert</code> option causes the variables to become universally quantified. It's like it does <code>revert</code> with all the variables that currently appear in the goal.</p>",
        "id": 502777634,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740856597
    },
    {
        "content": "<blockquote>\n<p>Is <code>exhaust</code> a simpler form of <code>decide</code> which only applies to propositions with no variables?</p>\n</blockquote>\n<p>A number of tactics tend to be custom decision algorithms for some sub-area of mathematics or logic. For example, <code>tauto</code> can decide anything that is purely propositional logic.</p>\n<p>The <code>decide</code> tactic is actually a very simple tactic (so long as you are comfortable with Lean's typeclass system). It makes no promises to be able to decide anything in particular, just whatever is \"plugged-in\" via the <code>Decidable</code> instances. (Just to re-emphasize a point: <code>decide</code> is user-extensible by anyone who is comfortable writing instances.)</p>\n<p><code>exhaust</code> is significantly more complicated tactic than <code>decide</code>. It makes use of <a href=\"https://github.com/leanprover-community/duper\">duper</a> to resolve goals involving equalities and propositions. (That's my understanding; I've never used <code>exhaust</code>, which is a MoP tactic, and unfortunately I haven't used duper yet.) Note that it does allow variables, just no quantifiers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exhaust</span>\n</code></pre></div>\n<p>It's a \"saturation-based automated theorem prover\", and it's not comparable to <code>decide</code>. I'm sure there are things each can do that the other cannot.</p>",
        "id": 502778898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740857407
    },
    {
        "content": "<p><strong>Example:</strong> It's possible to configure <code>decide</code> to prove tautologies by evaluating the entire truth table.</p>\n<p>The goal is to get this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">revert</span>\n</code></pre></div>\n<p>The effect of <code>+revert</code> is that the goal <code>decide</code> will try to prove is <code>∀ (p q r : Prop), (p → q) ∧ (q → r) → (p → r)</code>.</p>\n<p>The only thing we need to do is \"teach\" <code>decide</code> how to prove statements that are universally quantified over propositions.</p>\n<p>Strategy: To prove above forall, if we can evaluate the truth of both <code>∀ (q r : Prop), (True → q) ∧ (q → r) → (True → r)</code> and <code>∀ (q r : Prop), (False → q) ∧ (q → r) → (False → r)</code>, then we can evaluate the truth of <code>∀ (p q r : Prop), (p → q) ∧ (q → r) → (p → r)</code>. (And we do this recursively to with <code>q</code> and <code>r</code>.)</p>\n<p>To do this, we can define a Decidable instance that does the job. I won't walk you through the details. The point is that it is possible to do.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">      </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">eq_true</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">eq_false</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_and_or</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">push_neg</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">True</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">False</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>With this block of code placed before the <code>example</code>, you can observe that <code>decide +revert</code> does indeed prove the tautology.</p>",
        "id": 502780061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740858113
    },
    {
        "content": "<p>thanks again - I will need to re-read this last comment a few time for it to sink in.</p>",
        "id": 502780541,
        "sender_full_name": "rzeta0",
        "timestamp": 1740858411
    },
    {
        "content": "<p>I am also getting my head around this, and I feel the confusion comes from the word \"decidable\" conflating two distinctly different things - 1) abstractly something in logic (or computability theory) 2) something more specific in Lean that has to do with the Decidable typeclass.</p>\n<blockquote>\n<p>For example, <code>1 &lt; 100</code> is decidable</p>\n</blockquote>\n<p>This is a clear statement of abstract logic. But in Lean we can prove it by <code>norm_num</code>, <code>linarith</code>, <code>simp</code> and <code>decide</code>. AFAIKT, <code>decide</code> is the most generic tactic that uses type classes to \"plug in\" specific implementations. <code>simp</code> is also pluggable but through a different mechanism <code>[@simp]</code> which is confusing and norm_num and linarith are not.</p>\n<p>What I am missing is why aren't all statements that are known to be decidable (in theory) proved  in Lean by using <code>decide</code> tactic - is it for performance or style?</p>",
        "id": 502783468,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740860275
    },
    {
        "content": "<p>Performance can definitely be an issue, yeah</p>",
        "id": 502783688,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740860408
    },
    {
        "content": "<p>Maybe <code>reflect</code> could be a better name for the tactic. What it does is it takes a <code>Prop</code> and uses the <code>Decidable</code> to turn it into (essentially) a <code>Bool</code> (a process known as \"reflection\"). It then reduces that boolean, and, if it gets <code>true</code>, it's able to extract a proof of the original proposition.</p>\n<p>This depends on</p>\n<ul>\n<li>Can typeclass inference match the Props involved to create a Decidable instance?</li>\n<li>Can these Decidable instances be robust enough that propositions will be reliably matched?</li>\n<li>Is the algorithm it synthesizes good enough to be evaluated using term reduction?</li>\n</ul>\n<p>Tactics in particular domains can often come up with much better algorithms. They can run native code to calculate some details about a situation and then choose an efficient proof after the fact too.</p>\n<p>A tactic like <code>ring</code> can be implemented using <code>decide</code>-like reflection (it's not currently), but implementing it using the typeclass system is probably too much to expect, and, if it's even possible, likely to be very fragile.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/where.20to.20read.20about.20.60decide.60/near/502783468\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>For example, <code>1 &lt; 100</code> is decidable</p>\n</blockquote>\n<p>This is a clear statement of abstract logic</p>\n</blockquote>\n<p>In particular I mean that it's decidable in the sense that for all concrete naturals <code>n</code> and <code>m</code>, we can calculate <code>n &lt; m</code> by reducing <code>Nat.blt n m</code> to (hopefully) <code>true</code>, and using this result to justify that <code>n &lt; m</code>. (Another way it could be implemented is to calculate <code>100 - 1</code> and see that it is not <code>0</code>.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/where.20to.20read.20about.20.60decide.60/near/502783468\">said</a>:</p>\n<blockquote>\n<p><code>simp</code> is also pluggable but through a different mechanism <code>[@simp]</code> which is confusing and norm_num and linarith are not.</p>\n</blockquote>\n<p>What are you finding confusing about <code>@[simp]</code>? The tactic uses a giant database of rewrite rules, and when you annotate a lemma with <code>@[simp]</code> it adds the rule to that database.</p>\n<p>Note that you can write <code>norm_num</code> plugins to get <code>norm_num</code> to be able to evaluate new functions. These are programs that generate a value and a proof that the original expression evaluates to this value.</p>",
        "id": 502785034,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740861329
    },
    {
        "content": "<blockquote>\n<p>What are you finding confusing about <code>@[simp]</code>? The tactic uses a giant database of rewrite rules, and when you annotate a lemma with <code>@[simp]</code> it adds the rule to that database.</p>\n</blockquote>\n<p>I am confused why there are two \"extensibility mechanisms\" for making powerful tactics - type classes and annotations and what are the tradeoffs. Two powerful tactics - <code>decide</code> and <code>simp</code> use each. And I mean confusing for newcomers like me, likely it will become clear as I learn more.</p>",
        "id": 502785622,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740861702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> It's all annotations (\"attributes\") in the end. Instances are definitions with the <code>@[instance]</code> attribute.</p>\n<p>The <code>decide</code> tactic is pretty much the only tactic that use instances in such a direct way. It's a very imperfect tactic too. It's nice that it can reuse the typeclass system, but it also means it's limited by the way the typeclass system works. Maybe a future <code>decide</code> won't use instances so directly, letting people plug in more powerful decision procedures.</p>",
        "id": 502786261,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740862194
    },
    {
        "content": "<p>I see, thanks for elaborating. Lean's type system is basically the fanciest type system I have seen, so surprising to see that it is still limiting in some ways, but the more I think of it it makes sense, at some point you don't want to go through the type class dispatch and just take 1 &lt; 100 and run a custom procedure.</p>",
        "id": 502787072,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740862727
    },
    {
        "content": "<p><code>Decidable</code> also has the limitation that it's not appropriate for problems that are semidecidable. For example, <code>ring</code> can prove ring equalities, but it can't disprove them (maybe the ring has additional relations; ring can't use them, it can only prove what's universally true, in a polynomial ring).</p>",
        "id": 502787713,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740863188
    },
    {
        "content": "<p>Are there tactics that try to find concrete instances of existentials? Like if I give it <code>exists p \\in Prime, 2^p -1 is composite</code> it grinds some small primes for a bit and outputs <code>11</code> (or gives up)? It can use type classes to match the type with a generator something like <a href=\"https://en.wikipedia.org/wiki/QuickCheck\">https://en.wikipedia.org/wiki/QuickCheck</a> but done at type-checking not test run time.</p>",
        "id": 502788559,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740863618
    },
    {
        "content": "<p>Yes, Lean's QuickCheck is known as Plausible</p>",
        "id": 502788632,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740863649
    }
]