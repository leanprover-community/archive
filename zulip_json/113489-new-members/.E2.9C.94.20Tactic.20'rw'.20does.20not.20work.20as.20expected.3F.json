[
    {
        "content": "<p>Hello community! In <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/title_page.html\">TPIL</a>, chapter <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#tactics\">Tactics</a> , section <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#rewriting\">Rewriting</a>, I am told that if the left-hand side of an identity can match more than one subterm in the pattern, in which case the <code>rw</code> tactic chooses the first match it finds when traversing the term.  So I make the following trial</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">   </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Nat.add_zero (n : Nat) : n + 0 = n</span>\n</code></pre></div>\n<p>I guess that the first term that matches <code>n + 0</code> is <code>0 + 0</code>, so the tactic <code>rw [Nat.add_zero]</code> will change all <code>0 + 0</code> to <code>0</code> and thus the goal will be converted to <code>0 + (x + 0) + 0 + (x + 0) = 2 * x</code>. However, the output is actually <code>0 + 0 + (x + 0) + (x + 0) = 2 * x</code> and I don't know what is happening. Can someone help me? Any help is highly appreciated!</p>",
        "id": 453633381,
        "sender_full_name": "Tiffany",
        "timestamp": 1721810608
    },
    {
        "content": "<p>Can you please provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 453635091,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721810884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"707242\">Ralf Stephan</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453635091\">said</a>:</p>\n<blockquote>\n<p>Can you please provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<p>I think this is already an mew since it's actually what I typed into my VS code, with no <code>import</code>s, <code>open</code>s, <code>universe</code>s, or <code>variable</code>s.</p>",
        "id": 453637253,
        "sender_full_name": "Tiffany",
        "timestamp": 1721811369
    },
    {
        "content": "<p>surprisingly, the first term that matches is <code>(0 + 0 + (x + 0)) + (0 + 0)</code>! This is possible because <code>0 + 0</code> is defeq to <code>0</code>.</p>",
        "id": 453637336,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721811394
    },
    {
        "content": "<p>i do agree that this is not at all obvious. if you want to force it to match <code>0  + 0</code> instead, simply pass <code>0</code> as a parameter.</p>",
        "id": 453637685,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721811469
    },
    {
        "content": "<p>to be more precise about it, you may recall reading in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> that the inductive definition for <code>+</code> on <code>Nat</code> uses <code>a + 0 = a</code> by definition.</p>",
        "id": 453638367,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721811611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"727530\">Tiffany</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453637253\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"707242\">Ralf Stephan</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453635091\">said</a>:</p>\n<blockquote>\n<p>Can you please provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<p>I think this is already an mew since it's actually what I typed into my VS code, with no <code>import</code>s, <code>open</code>s, <code>universe</code>s, or <code>variable</code>s.</p>\n</blockquote>\n<p>I usually add this on top of any posted code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<p>It makes sure people can click on the small icon top right and it works, without having to type anything.</p>",
        "id": 453638369,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721811611
    },
    {
        "content": "<p>it already does though?</p>",
        "id": 453638558,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721811658
    },
    {
        "content": "<p>this example doesn't use mathlib?</p>",
        "id": 453638605,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721811674
    },
    {
        "content": "<p>Ah ok, <code>Nat.add_zero</code> is <code>Init.Core</code>. Apologies.</p>",
        "id": 453638933,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721811786
    },
    {
        "content": "<p>That's really to my surprise. In fact, I also make the following trial</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>at this time the tactic <code>rw [add_zero</code> works as I expected. The remaining goal is <code>0 + (x + 0) + 0 + (x + 0) = 2 * x</code></p>",
        "id": 453638987,
        "sender_full_name": "Tiffany",
        "timestamp": 1721811806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453638605\">said</a>:</p>\n<blockquote>\n<p>this example doesn't use mathlib?</p>\n</blockquote>\n<p>Yes.</p>",
        "id": 453639257,
        "sender_full_name": "Tiffany",
        "timestamp": 1721811884
    },
    {
        "content": "<p>But by writing <code>add_zero</code> instead of <code>Nat.add_zero</code> you actually use <code>Mathlib.Algebra.Group.Defs.add_zero</code>. You can see this by hovering over it.</p>",
        "id": 453639738,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1721812058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453638367\">said</a>:</p>\n<blockquote>\n<p>to be more precise about it, you may recall reading in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> that the inductive definition for <code>+</code> on <code>Nat</code> uses <code>a + 0 = a</code> by definition.</p>\n</blockquote>\n<p>I think I get what you said: in lean (n + 0) is definitionally equal to n, so the term <code>(0 + 0) + (x + 0) + (0 + 0) + (x + 0)</code>is indeed <code>0 + x + 0 + x</code>, no wonder that the first matching term is (0 + x) + 0</p>",
        "id": 453640234,
        "sender_full_name": "Tiffany",
        "timestamp": 1721812233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"707242\">Ralf Stephan</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20'rw'.20does.20not.20work.20as.20expected.3F/near/453639738\">said</a>:</p>\n<blockquote>\n<p>But by writing <code>add_zero</code> instead of <code>Nat.add_zero</code> you actually use <code>Mathlib.Algebra.Group.Defs.add_zero</code>. You can see this by hovering over it.</p>\n</blockquote>\n<p>Yeah, I see it, thanks for your reply!</p>",
        "id": 453640413,
        "sender_full_name": "Tiffany",
        "timestamp": 1721812298
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"727530\">Tiffany</span> has marked this topic as resolved.</p>",
        "id": 453640740,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721812413
    },
    {
        "content": "<p>Yeah, but rw shouldn't work like that</p>",
        "id": 453640938,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1721812485
    },
    {
        "content": "<p>If you use <code>show_term</code> on <code>rw</code>, if you know what you're looking for, you can see that it indeed decided to use <code>0 + 0 + (x + 0)</code> for <code>n</code> in <code>Nat.add_zero</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Equivalently parenthesized:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ (0 + 0 + (x + 0)) + (0 + 0) + (x + 0) = 2 * x</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- (0 + 0 + (x + 0)) + 0 matches (0 + 0 + (x + 0)) + (0 + 0)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- replaces it with (0 + 0 + (x + 0))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- New goal:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ (0 + 0 + (x + 0)) + (x + 0) = 2 * x</span>\n</code></pre></div>\n<p>I think this is explainable because the algorithm rw uses, \"kabstract\", uses something called key matching rather than discrimination tree matching. It looks for subexpressions whose head expression has the same \"key\" as the head of the rw pattern (it would be addition in this case, from <code>n + 0</code>, which is <code>HAdd.hAdd n 0</code> in full), and then once it finds a possible match, it uses unification to see if it's an actual match. That allows <code>0 + 0</code> and <code>0</code> to be the same.</p>",
        "id": 453746665,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721839337
    }
]