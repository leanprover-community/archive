[
    {
        "content": "<p>I am trying to express a theorem statement that 'if a belongs to Nat, then a+1 belongs to Nat'. </p>\n<p>I tried <code>theorem succ_is_nat (a:Nat):((a+1):Nat):=sorry</code> and  <code>theorem succ_is_nat (a:Nat):((a+1)∈Nat):=sorry</code>, but neither seems to work. What should be the proper syntax?</p>",
        "id": 490785791,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735138749
    },
    {
        "content": "<p>You can't express this idea naively because + is <em>defined</em> to be a function which takes two naturals and returns a natural.</p>",
        "id": 490786317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735139203
    },
    {
        "content": "<p>In type theory you can't state a theorem saying \"this term has this type\", just like you can't express in set theory the concept \"this set is a set\"</p>",
        "id": 490786373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735139281
    },
    {
        "content": "<p>Lean does not use set theory, it uses type theory instead. Hence, there is no such statement 'a belongs to Nat'.</p>",
        "id": 490786498,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735139373
    },
    {
        "content": "<p>Well, you <em>can</em> do something like this, if this is what you mean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 490786831,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735139645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and <span class=\"user-mention\" data-user-id=\"757121\">@hilbert</span> Umm, I am not well versed in type theory, so please bear with me. Is Lean not expressive enough to deal with set theoretic statements? Or is there some way to deal with sets in Lean?</p>",
        "id": 490787310,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735140106
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  It represents that if <code>a</code> belongs to the range of the casting function, then <code>a+1</code> does too, right? But why do we need to write it in such a roundabout fashion? Why can't we just write <code>a belongs to the set of all things of type Nat</code>?</p>",
        "id": 490787410,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735140201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Like why doesn't <code>a ∈ (Set Nat)</code> work?</p>",
        "id": 490787764,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735140536
    },
    {
        "content": "<p>As mentioned above, Lean's foundations are type-theoretic, not set-theoretic. While they have the same expressivity (modulo details), the way in which it is most natural to express various statements varies slightly. </p>\n<p>If you have <code>a : ℝ</code>, you simply can't say <code>a : ℕ</code>, because things can only have one type (up to definitonal equality). Unlike in set theory, <code>ℕ</code> is <em>not</em> a subset of <code>ℝ</code>, as these are just two types. However, there is a natural map, which in Lean is a coercion, <code>(↑) : ℕ → ℝ</code>. This map is the \"obvious\" one that takes a natural number to the corresponding real number (i.e., <code>0 : ℕ ↦ 0 : ℝ</code>, <code>1 : ℕ ↦ 1 : ℝ</code>, etc.). So, you can say \"<code>a : ℝ</code> is a natural number\" by: <code>a ∈ Set.range ((↑) : ℕ → ℝ)</code>.</p>",
        "id": 490788936,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735141589
    },
    {
        "content": "<p><code>a ∈ (Set Nat)</code> doesn't parse because <code>Set Nat</code> is <em>also</em> a type (the type of subsets of <code>ℕ</code>), not a set.</p>",
        "id": 490788975,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735141639
    },
    {
        "content": "<p>You can only write <code>a ∈ s</code> when <code>s : Set X</code> for some type <code>X</code>. Here <code>s</code> should be thought of as a \"subset\" of <code>X</code>. However, you can't write <code>s ⊆ X</code> in this case. That would instead be expressed as <code>s ⊆ Set.univ</code>, where the latter is the set consisting of all elements in the type <code>X</code>.</p>",
        "id": 490789093,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735141744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> So <code>Set Nat</code> is the <em>type</em> of all subsets of <code>Nat</code>, but for <code>s</code> to be a subset of <code>Nat</code>, <code>s</code> has to have type <code>Set Nat</code>. Only if <code>s</code> is a subset of <code>Nat</code>, then we can have <code>a ∈ s</code>, right?</p>",
        "id": 490790193,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735142819
    },
    {
        "content": "<p>That's correct.</p>",
        "id": 490790220,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735142846
    },
    {
        "content": "<p>And <code>Set.univ Nat</code> does have type <code>Set Nat</code>?</p>",
        "id": 490790240,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735142876
    },
    {
        "content": "<p>Yes, except <code>Set.univ</code> doesn't have an explciit argument, so you would need to write <code>@Set.univ Nat</code>, or just let Lean infer the type with <code>Set.univ</code>.</p>",
        "id": 490790318,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1735142939
    },
    {
        "content": "<p>I need to read up on explicit and implicit arguments, but then we have <code>a ∈ (@Set.univ Nat)</code> signifying that <code>a</code> belongs to the set of all <code>Nat</code>s?</p>",
        "id": 490790409,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735143048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815044\">Soham Saha</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20write.20a.20proposition.20that.20'a'.20belongs.20to.20'Nat'.3F/near/490787310\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>  and <span class=\"user-mention silent\" data-user-id=\"757121\">hilbert</span> Umm, I am not well versed in type theory, so please bear with me. Is Lean not expressive enough to deal with set theoretic statements? Or is there some way to deal with sets in Lean?</p>\n</blockquote>\n<p>In Lean, a set is a collection of some objects of certain type. For example, <code>Set Nat</code> is a collection of some natural numbers.</p>\n<p>Given <code>s : Set Nat</code> (i.e. <code>s</code> is a set of natural numbers) and <code>a : Nat</code> (i.e. <code>a</code> is a natural number), we can write <code>a ∈ s</code>.</p>\n<p>But given <code>b : Int</code>, <code>b ∈ s</code> is illegal in Lean.</p>\n<p>This is constraint from type theory. But at  the other hand, this is benefit from type theory. It prevents us from writing nonsense statment.</p>",
        "id": 490790927,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735143580
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>  Then for my original question, it doesn't make sense to ask if <code>a+1</code> is a <code>Nat</code> if <code>a</code> is one, because <code>+</code> is defined so (as <strong>Kevin Buzzard</strong> said), right?</p>\n<p>But if I want to know if <code>a</code> being an even integer implies that <code>a/2</code> is an integer, then first I'd have to take <code>a</code> belonging to the range of a function that casts even integers to the reals (because division is not defined over integers), and then show that <code>a/2</code> belongs to the range of a function that casts integers to reals</p>\n<p>Am I going on the right track here?</p>",
        "id": 490791022,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735143664
    },
    {
        "content": "<p>@hilbert Understood. Thanks :)</p>",
        "id": 490791048,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735143713
    },
    {
        "content": "<p>Ah, but in lean, division is defined over the integers (by rounding the result)</p>",
        "id": 490794252,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735146716
    },
    {
        "content": "<p>If you feed division two integers, it will spit out an integer; division is a very \"computer science\" thing to do with integers. For example if 5,2,1,0 denote integers then 5/2 and 1/0 are also necessarily integers. If you want to use the concept of division which you're used to then you should use rationals (or reals, but why not rationals?), and your question about \"being an integer\" just needs to be slightly rephrased as \"being in the image of the obvious map from the integers to the rationals\".</p>",
        "id": 490795742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735148144
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks, got it now :)</p>",
        "id": 490795969,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735148363
    },
    {
        "content": "<p>I must say, the Lean Zulip community is really wonderful.</p>",
        "id": 490796050,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735148431
    },
    {
        "content": "<p>Thanks to all who’ve helped.</p>",
        "id": 490796056,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735148444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815044\">Soham Saha</span> has marked this topic as resolved.</p>",
        "id": 490796060,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735148455
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"c1\">-- evenness</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">Init</span><span class=\"w\"> </span><span class=\"c1\">-- rationals</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That should be provable :-) (and should mean what you mathematically think it means). Division of two integers is pathological as far as mathematicians are concerned.</p>",
        "id": 490796093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735148504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> So we can change the type of a variable if we are casting to a ‘higher’ type? Like from Nat to Real or Rat?</p>",
        "id": 490796809,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735149258
    },
    {
        "content": "<p>Yeah if you look at the actual goal you'll see up-arrows, which indicate \"the obvious map\" between various types.</p>",
        "id": 490796907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735149367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, it does show that.</p>\n<p>Could you suggest some material where I can get better understanding about the syntax and this type-theoretic backbone of Lean? Currently, I am trying to learn from <a href=\"https://lean-lang.org/theorem_proving_in_lean4/\">here</a></p>",
        "id": 490797027,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735149522
    },
    {
        "content": "<p>If you're interested in mathematics then <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> and <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2024/\">my course notes</a> might be other options</p>",
        "id": 490797315,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1735149762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for the links, I will check them out. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 490797423,
        "sender_full_name": "Soham Saha",
        "timestamp": 1735149874
    }
]