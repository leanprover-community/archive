[
    {
        "content": "<p>import Mathlib.GroupTheory.OrderOfElement</p>\n<p>import Mathlib.Algebra.Group.Subgroup.Basic</p>\n<p>import Mathlib.Data.Fintype.Basic</p>\n<p>import Mathlib.Data.Fintype.Card</p>\n<p>import Mathlib.Data.Set.Finite.Basic</p>\n<p>open Function</p>\n<p>theorem power_in_kernel_of_finite_image</p>\n<p>{G H : Type*} [Group G] [Group H]</p>\n<p>(f : G →* H) (hf : (Set.range f).Finite) :</p>\n<p>∀ x : G, ∃ n : ℕ, x ^ n ∈ f.ker := by</p>\n<p>intro x</p>\n<p>let K := Subgroup.closure (Set.range f)</p>\n<p>-- 给出 Fintype 实例</p>\n<p>have hK : Set.Finite (K : Set H) := Subgroup.closure_closure_coe_preimage</p>\n<p>letI : Fintype K := Fintype.ofFinite _</p>\n<p>-- 构造 f x 属于 K 中的元素</p>\n<p>have hx : f x ∈ K := Subgroup.subset_closure (Set.mem_range_self x)</p>\n<p>let y : K := ⟨f x, hx⟩</p>\n<p>-- 得到 f x 在 K 中阶整除阶数</p>\n<p>have hpow : y ^ Fintype.card K = 1 := pow_card_eq_one y</p>\n<p>-- 拆掉 coercion 包装</p>\n<p>simp only [Subgroup.coe_pow, Subgroup.coe_one, Subgroup.coe_mk] at hpow</p>\n<p>-- 最终结论</p>\n<p>use Fintype.card K</p>\n<p>rw [MonoidHom.mem_ker, map_pow]</p>\n<p>exact hpow请问这个怎么解决啊，ll Messages (4)</p>\n<p>EX05.lean:17:38</p>\n<p>type mismatch<br>\n  Subgroup.closure_closure_coe_preimage<br>\nhas type<br>\n  Subgroup.closure (Subtype.val ⁻¹' ?m.759) = ⊤ : Prop<br>\nbut is expected to have type<br>\n  (↑K).Finite : Prop</p>\n<p>EX05.lean:18:22</p>\n<p>failed to synthesize<br>\n  Finite ↥K</p>\n<p>Additional diagnostic information may be available using the <code>set_option diagnostics true</code> command.</p>\n<p>EX05.lean:25:40</p>\n<p>function expected at<br>\n  pow_card_eq_one<br>\nterm has type<br>\n  ?m.1895 ^ Fintype.card ?m.1892 = 1</p>\n<p>EX05.lean:33:2</p>\n<p>type mismatch<br>\n  hpow<br>\nhas type<br>\n  y ^ Fintype.card ↥K = 1 : Prop<br>\nbut is expected to have type<br>\n  f x ^ Fintype.card ↥K = 1 : Prop</p>\n<p>Restart File，</p>",
        "id": 523042763,
        "sender_full_name": "Shara Hunt",
        "timestamp": 1749456335
    },
    {
        "content": "<p>You'll need to use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> to make that readable</p>",
        "id": 523061446,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1749463796
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/native.20support.20of.20coinductive.20types.20.2F.20codata\">#lean4 &gt; native support of coinductive types / codata</a> by <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>.</p>",
        "id": 523170436,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749504789
    },
    {
        "content": "<p>3 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/native.20support.20of.20coinductive.20types.20.2F.20codata/with/522716056\">#new members &gt; native support of coinductive types / codata</a> by <span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span>.</p>",
        "id": 523180182,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749509227
    }
]