[
    {
        "content": "<p>I am experimenting with a more adapative and hierarchical partitioning structure. I want, for all the layers, to know which one has been refined by (is an injective map of) which one.</p>\n<p>The <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AdaptivePartitioningStructure</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lattice</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SimpleGraph</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">layers</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finpartition</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">refinement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">layers</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">is_refinement_of</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">layers</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">adaptive_epsilon</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n<span class=\"w\">  </span><span class=\"n\">part_count_bounds</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">l_i</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">layers</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">parts</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">layers</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">parts</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">SzemerediRegularity</span><span class=\"bp\">.</span><span class=\"n\">bound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">adaptive_epsilon</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l_i</span>\n</code></pre></div>\n<p>I guess I don't need <code>[Lattice α]</code> in the definition. I also got this from the diagnostics tool:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">reduction</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">unfolded</span><span class=\"w\"> </span><span class=\"n\">reducible</span><span class=\"w\"> </span><span class=\"n\">declarations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">44</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">44</span>\n\n<span class=\"o\">[</span><span class=\"n\">kernel</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">unfolded</span><span class=\"w\"> </span><span class=\"n\">declarations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">50</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">▼</span>\n\n<span class=\"w\">  </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">optParam</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"mi\">50</span>\n</code></pre></div>\n<p>I have two questions:</p>\n<ol>\n<li>I'm getting <code>failed to synthesize Lattice (Type u)</code>.  How I can solve this?</li>\n<li>I don't yet have the <code>is_refinement_of function</code>. I checked out <code>Finpartition</code>'s docs and found <code>parts_map</code>.  How could that work?</li>\n</ol>",
        "id": 481809908,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1731359524
    },
    {
        "content": "<p>To 1.: Look at the definition of Finpartition <br>\n<code>structure Finpartition {α : Type u_1}[Lattice α] [OrderBot α] (a : α) </code><br>\nThe values in the round brackets you pass directly. Your α is the a in this definition. Lean then infers  that <code>Type u </code> must be the α in the definition. Hence it requires the lattice operation on <code>Type u </code></p>",
        "id": 481812419,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1731360645
    },
    {
        "content": "<p>Got it. Thank was very helpful, Johannes. Thank you.</p>",
        "id": 481936784,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1731414855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> has marked this topic as resolved.</p>",
        "id": 481936807,
        "sender_full_name": "Notification Bot",
        "timestamp": 1731414862
    }
]