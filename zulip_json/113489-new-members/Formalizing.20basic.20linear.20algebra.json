[
    {
        "content": "<p>Hello Lean-Prover Community,</p>\n<p>I'm very new to Lean. I've completed Kevin Buzzard's Natural Number Game, and the tutorial project exercise files. I'm in the process of reading Theorem Proving in Lean.</p>\n<p>As a hands-on learning exercise, I'd like to try formalizing some theorems from a textbook I have; it covers basic real analysis and linear algebra. I want to work at the same level of generality as the book, taking from mathlib anything that the book assumes.</p>\n<p>I quickly run up against a roadblock. How does one import/construct a definition for R^n from mathlib?</p>\n<p>(side note, are there any beginner resources doing similar formalizations that I might learn from?)</p>",
        "id": 308907343,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1668045999
    },
    {
        "content": "<p>The standard approach is to use <code>fin n \\-&gt; \\R</code> (sorry for the lack of unicode... I'm writing this on mobile). With the right imports (some sufficiently deep file from <code>linear_algebra</code> would suffice), this would obtain a structure of a vector space over the reals</p>",
        "id": 308908424,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668046975
    },
    {
        "content": "<p>Following along b/c I have a similar goal -- would like to do linear algebra done right, and import only the minimum from <code>mathlib</code> -- if there's material for how get the minimums from <code>mathlib</code> without all the proofs that one wants to reconstruct.</p>",
        "id": 308908466,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668047028
    },
    {
        "content": "<p>Another useful thing to look at is mathlib's matrix notation, found here <a href=\"https://tqft.net/mathlib/data/matrix/notation\">file#data/matrix/notation</a></p>",
        "id": 308908477,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668047037
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> for the response!</p>\n<p>My understanding of <code>fin n /to \\R</code> is a function type from <code>fin n</code> to <code>\\R</code>, but I have not seen <code>fin</code>. Is it some kind of index type? Where can I learn more?</p>",
        "id": 308909430,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1668047765
    },
    {
        "content": "<p><code>fin n</code> is a type with <code>n</code> elements. So functions from <code>fin n</code> to <code>R</code> can be thought of as n-tuples of real numbers.</p>",
        "id": 308909559,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668047894
    },
    {
        "content": "<p>I think <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a> covers this?</p>",
        "id": 308909615,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668047941
    },
    {
        "content": "<p>Maybe not.</p>",
        "id": 308909662,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668047971
    },
    {
        "content": "<p>I found <a href=\"https://leanprover-community.github.io/mathlib_docs/data/fin/vec_notation.html\">https://leanprover-community.github.io/mathlib_docs/data/fin/vec_notation.html</a> (sorry, no idea what magic embeds doc links)</p>",
        "id": 308910454,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668048550
    },
    {
        "content": "<p>That notation works for concrete numerals like elements of <code>fin 4 -&gt; \\R</code>.</p>",
        "id": 308935694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668067043
    },
    {
        "content": "<p>Mathematicians would write the type <code>fin n -&gt; \\R</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(\\{0,1,\\ldots,n-1\\},\\R).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Hom</span></span><span class=\"mopen\">({</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 308935907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668067168
    },
    {
        "content": "<p>That's our \"model\" in mathlib for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\R^n.</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 308936032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668067224
    },
    {
        "content": "<p>As an observation, there's a trend where one tries to do undergraduate math using <code>mathlib</code> but one ends up doing category theory</p>",
        "id": 309012437,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668093962
    },
    {
        "content": "<p>The arrow is not the category theory arrow, it's the function arrow. So it's not category theory yet.</p>",
        "id": 309026997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668097890
    },
    {
        "content": "<p>This has nothing to do with category theory! This is the usual definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>. People often lie to themselves and pretend <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\R^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is an iterated product of individual copies of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> but they don't mean it. An element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\R^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span> doesn't look like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">((x, y), z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mclose\">)</span></span></span></span>, it looks like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(x_0, x_1,  x_2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> which is exactly description of a map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, 1, 2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span>, aka <code>fin 3</code>, to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>.</p>",
        "id": 309029122,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1668098571
    },
    {
        "content": "<p>I only wrote the Hom thing to explain another way of thinking about the function type.</p>",
        "id": 309031776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668099351
    },
    {
        "content": "<p>I was jokingly referring to the homomorphism.</p>\n<p>But it's true, though. The documentation for linear algebra \"basic\" states that \"This file defines the basics of linear algebra. It sets up the \"categorical/lattice structure\" of modules over a ring, submodules, and linear maps\" and the underlying definition of a vector space is in terms of <code>module</code> where the documentation is \"A module is a generalization of vector spaces to a scalar semiring. It consists of a scalar semiring R and an additive monoid of \"vectors\" M, connected by a \"scalar multiplication\" operation r • x : M (where r : R and x : M) with some natural associativity and distributivity axioms similar to those on a ring.\"</p>\n<p>This isn't quite at the \"a monad is a monoid in the category of endofunctors\" level, but it's close.</p>\n<p>A reasonably rigorous undergraduate linear algebra text like Axler starts with an \"ordered list of length n\" (which does conform to <code>fin n</code>) and the basic axioms of a vector space.</p>",
        "id": 309037018,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668100892
    },
    {
        "content": "<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>",
        "id": 309038000,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668101148
    },
    {
        "content": "<p>Linear algebra is not linear algebra without linear maps. I suppose that's what the word \"category\" is referring to in the quote you mentioned.</p>",
        "id": 309040737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668101930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000\">said</a>:</p>\n<blockquote>\n<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>\n</blockquote>\n<p>I predict this will be an immense pain.</p>",
        "id": 309043564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1668102732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309043564\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000\">said</a>:</p>\n<blockquote>\n<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>\n</blockquote>\n<p>I predict this will be an immense pain.</p>\n</blockquote>\n<p>Probably. I guess I'm asking (from those who have taught or learned theorem proving in undergraduate math) what the the best way to use <code>mathlab</code> without pulling too much in, where the point is to re-derive and prove the same things that <code>mathlib</code> has already proved.</p>",
        "id": 309045879,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668103339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/113489-new-members/topic/get.20R.5En.20from.20mathlib/near/309038000\">said</a>:</p>\n<blockquote>\n<p>I wonder whether it's better to discard all that and start with <code>set</code> and define closed addition and scalar multiplication?</p>\n</blockquote>\n<p>Perhaps you already know this, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> does exactly that</p>",
        "id": 309065363,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668109449
    },
    {
        "content": "<p>But sets aren't the building blocks of Lean, <code>Type</code>s are; so you rarely start with sets, instead starting with <code>Type</code>s and later specializing to <code>set</code>s.</p>",
        "id": 309065493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1668109513
    },
    {
        "content": "<p>No, I didn't know that <code>submodule</code> automatizes linear spaces... Mm, so I could start with <a class=\"stream-topic\" data-stream-id=\"288720\" href=\"/#narrow/stream/288720-mathlib-documentation/topic/submodule\">#mathlib documentation &gt; submodule</a>  and then do my own proofs from there &amp; pick up more of <code>mathlib</code> as I've already covered it?</p>\n<p>I love <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s work on NNG (and I've now redone Complex NG in standard Lean3), and want to recreate that for reasonably undergraduately values of abstract linear algebra.</p>",
        "id": 309068699,
        "sender_full_name": "Arien Malec",
        "timestamp": 1668110567
    },
    {
        "content": "<p>Reviving this topic ...</p>\n<p>I have come across a hurdle in my quest to formalize some undergraduate math.</p>\n<p>I am trying to define the standard basis vectors for R^n. Minimally, I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">decidable.em</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">=</span><span class=\"n\">j</span><span class=\"o\">),</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">heq</span> <span class=\"n\">hneq</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It's this final <code>cases</code> that gives an error: \"induction tactic failed, recursor 'or.dcases_on' can only eliminate into Prop\". As I understand it, the issue lies in fact of trying to construct a non-Prop value from a Prod inductive type (or). I believe the relevant text is found in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#axiomatic-details\">7.8 Axiomatic Details (TPL)</a>, where it states \"Generally speaking, for an inductive type in Prop, the motive of the elimination rule is required to be in Prop.\" Please correct me if I'm mistaken.</p>\n<p>I guess my question is, what's my alternative? How can I define the standard basis vectors as I've set up above?</p>",
        "id": 312766706,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1669697400
    },
    {
        "content": "<p>In general it might not be a good idea to construct data in tactic mode.<br>\nIn this case you can do <code>refine if (h : i = j) then _ else _</code>.</p>",
        "id": 312766906,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669697525
    },
    {
        "content": "<p>I see, thanks Andrew. Is your suggestion of  <code>refine if (h : i = j) then _ else _</code> for tactic mode or term mode?</p>",
        "id": 312767486,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1669698080
    },
    {
        "content": "<p>That is in tactic mode.  <code>refine</code> is a tactic.</p>",
        "id": 312768180,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669698598
    },
    {
        "content": "<p>To elaborate further, tactic modes are generally designed for proofs, so the terms they produce might not be easy to manipulate. The most basic tactics (<code>intro</code>, <code>refine</code>, <code>apply</code>, <code>exact</code>) might be fine, some might be okay if you know what you are doing (<code>dsimp</code>, <code>change</code>, <code>cases</code>, ...), but other tactics will probably give unreadable and unusable terms.</p>",
        "id": 312768298,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669698651
    },
    {
        "content": "<p>Thanks for the elaboration! Do you mind showing me how you would write this in term mode? Here is my try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">or.rec_on</span> <span class=\"o\">(</span><span class=\"n\">decidable.em</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">=</span><span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>I get a new error \"\"eliminator\" elaborator failed to compute the motive\", but I suspect it's the same issue.</p>\n<p>Can you explain for me how we are getting around this issue of recursing on \"or\" (inductively defined Prop) and producing data (a real number) ?</p>",
        "id": 312768583,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1669698868
    },
    {
        "content": "<p>Btw, I am trying not to use classical until I need to</p>",
        "id": 312768656,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1669698907
    },
    {
        "content": "<p><code>if i = j then 1 else 0</code>. I believe this doesn't use classical but I might be wrong.</p>",
        "id": 312768833,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669698981
    },
    {
        "content": "<p>Aha! I found <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html?highlight=else#decidable-propositions\">10.4 Decidable Propositions (TPL)</a> which talks exactly about this if-then-else requiring decidable props. Wonderful!</p>",
        "id": 312769074,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1669699153
    },
    {
        "content": "<p>You might also want <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.single\">docs#pi.single</a></p>",
        "id": 312786459,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1669709272
    },
    {
        "content": "<p>Try <code>by_cases i = j,</code> as an alternative to <code>have H: i = j ∨ ¬i = j, from decidable.em (i=j)</code>.</p>",
        "id": 312837442,
        "sender_full_name": "King Crawford",
        "timestamp": 1669727005
    },
    {
        "content": "<p>Thanks all for your answers.</p>\n<p>How do you perform induction on a term which is not part of the context? I am trying to prove this lemma, which says \"finite sums of vectors can be done coordinate-by-coodinate\" . I'm trying to employ induction on the size of  the fintype α. This is my best try so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">data.real.sqrt</span> <span class=\"n\">data.nat.basic</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span>\n\n<span class=\"c1\">-- I've show (add_comm_monoid (R n))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_by_coordinate</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sizeof</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I used <code>let n := sizeof α</code> when <code>induction (sizeof  α)</code> failed to work on its own. But now I don't know how to work with the resulting target term:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sizeof</span> <span class=\"n\">α</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>What's the standard way forward here? Btw, I am trying to prove this first without <code>finset.sum_induction</code>,  just as an exercise.</p>",
        "id": 313877679,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1670207250
    },
    {
        "content": "<p>You should use <code>finset.sum_induction</code> and then specialise to <code>finset.univ</code> to get your result.</p>",
        "id": 313903541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670225747
    },
    {
        "content": "<p>I'm pretty sure you want <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card\">docs#fintype.card</a> not <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sizeof\">docs#sizeof</a></p>",
        "id": 313911885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670229351
    },
    {
        "content": "<p><code>induction h : fintype.card α</code> might be what you're asking for</p>",
        "id": 313912275,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670229445
    },
    {
        "content": "<p>I'm not sure that encouraging the use of induction on the type is a good idea here. It's much easier to prove the more general statement about a finset because then you don't need to move the underlying type.</p>",
        "id": 313923829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670233658
    },
    {
        "content": "<p>Just to give a mathlib example of how to do induction on the cardinality of a type (which is like what Eric brought up), there's this part of the proof of Hall's marriage theorem: <a href=\"https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229\">https://github.com/leanprover-community/mathlib/blob/f1a2caaf51ef593799107fe9a8d5e411599f3996/src/combinatorics/hall/finite.lean#L229</a></p>\n<p>There's a Lean technicality where you have to use <code>unfreezingI</code> since the <code>fintype</code> instance is \"frozen\".</p>",
        "id": 313930603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1670235928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Formalizing.20basic.20linear.20algebra/near/313923829\">said</a>:</p>\n<blockquote>\n<p>I'm not sure that encouraging the use of induction on the type is a good idea here.</p>\n</blockquote>\n<p>Indeed; but it does directly answer the \"How do you perform induction on a term which is not part of the context?\". It just happens that in this particular case that's not actually a helpful thing to do!</p>",
        "id": 313937607,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670238128
    },
    {
        "content": "<p>Hello all,</p>\n<p>Thank you again for your helpful answers.</p>\n<p>I am still stuck on proving the below lemma. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> thank you for your suggestion to use <code>finset.sum_induction</code>. Upon further study of that theorem, I am struggling to apply it to my case (though I do not doubt it may apply). Specifically, I am struggling to formulate a predicate <code>p: R n -&gt; Prop</code> to use in my case. I believe I want to show a property of summing in <code>R n</code>.</p>\n<p>Having temporarily hit a wall with the recommended approach, I have decided to continue playing with the ill-advised induction on <code>fintype.card α</code>, in hopes to learn why it breaks down. It did break down, but in an unexpected way. Here is my current state (using the induction pointed out by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- In my file, I have shown</span>\n<span class=\"kd\">instance</span> <span class=\"n\">vec_add_comm_monoid</span><span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- the lemma in question</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"k\">with</span> <span class=\"n\">n'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"c1\">-- constructing this instance as I don't know how to help Lean find/infer it</span>\n    <span class=\"k\">have</span> <span class=\"n\">α_is_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card_eq_zero_iff.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- error on this line</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">fintype.sum_empty</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">vec_add_comm_monoid</span> <span class=\"n\">α_is_empty</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Giving the following state/error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n<span class=\"n\">α_is_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_empty</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>I am quite stumped, as I expect Lean to find the pattern in the target as <code>∑ (a : α), f a</code>. I believe this pattern is <code>finset.univ.sum f</code>. Does it perhaps have to do with Type universes?</p>\n<p>Any help on either of these fronts would be greatly appreciated.</p>",
        "id": 314382089,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1670392408
    },
    {
        "content": "<p>I <em>think</em> what's being suggested here is to begin with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">A</span> <span class=\"n\">using</span> <span class=\"n\">finset.cons_induction</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">A</span> <span class=\"n\">hb</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>and only then proceed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_sum_pointwise'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">vec_sum_pointwise</span> <span class=\"n\">finset.univ</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 314422552,
        "sender_full_name": "Alistair Tucker",
        "timestamp": 1670408809
    },
    {
        "content": "<p>FWIW, this more general lemma exists already as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_apply\">docs#finset.sum_apply</a></p>",
        "id": 314443573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670416089
    },
    {
        "content": "<p>Thanks to those who have helped me thus far.</p>\n<p>This time I'm not stuck, I just want to know the most idiomatic way of doing something. I have the following lemmas</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">vec_smul_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Later on, I want to show that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⟪</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span>\n</code></pre></div>\n<p>However, I find that I cannot <code>rw</code> or <code>apply</code> dot_prod_right_distrib directly. The problem is that the lemma does not know that <code>α</code> and <code>β</code> can be taken to be 1.  Thus, my proof of the latter statements starts like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n      <span class=\"c1\">-- insert \"1 •\" on every vector</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">vec_smul_one</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">vec_smul_one</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- apply the lemma with α = β = 1</span>\n      <span class=\"n\">rw</span> <span class=\"n\">dot_prod_distrib</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n      <span class=\"c1\">-- remove the \"1 •\"</span>\n      <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">vec_smul_one</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>My question is, is there a better way to do this? I suspect many theorems/lemmas will appear in these generalized forms. Can I tell LEAN how to guess <code>α = β = 1</code> automatically? Alternatively, I could just write multiple versions of the same lemma, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib''</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"n\">β</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dot_prod_right_distrib'''</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">=</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">+</span> <span class=\"bp\">⟪</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but this seems rather tedious.</p>\n<p>Thanks for the help!</p>",
        "id": 318027898,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672108941
    },
    {
        "content": "<p><code>1 bub x</code> is neither syntactically nor definitely equal to <code>x</code>. The problem is not that lean isn't guessing alpha = 1, it's that even if you set alpha = 1 the lemma doesn't match. It might be what you see in the textbooks but the lemma isn't a good one for rewriting because it's doing too many jobs at once, and <code>rw</code> works up to syntactic equality. Why not prove additivity and linearity as two separate lemmas? <code>(x+y,z) and </code>(c \\bub x,z), and also have lemmas for (x,y+z) etc.</p>",
        "id": 318039481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672120707
    },
    {
        "content": "<p>You don't want the more complex lemmas, you should tell the simplifier about the basic lemmas and then it will prove the more complex ones by itself.</p>",
        "id": 318039671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672120888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for the insight. I see what you mean about this lemma being overloaded. I'll prove the two lemmas separately and show the textbook's lemma as an example.</p>",
        "id": 318040060,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672121249
    },
    {
        "content": "<p>The proof of the textbook lemma should be <code>simp</code></p>",
        "id": 318060279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1672133880
    },
    {
        "content": "<p>Isn't your <code>vec_smul_one</code> just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/one_smul\">docs#one_smul</a>?</p>",
        "id": 318121303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672157061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>. Thanks for the pointer. I had not seen this theorem. I have since removed my <code>vec_smul_one</code> lemma as I don't need it.</p>\n<p>What I'm trying to do is formalize a basic linalg book, replicating any definitions/theorems from the book, while using mathlib as much as possible to help with any definitions/theorems that the book assumes or uses without proof.</p>",
        "id": 318517174,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672366488
    },
    {
        "content": "<p>I had a followup question about the simplifier.</p>\n<p>I am working on a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">vec_norm_sum</span> <span class=\"o\">:</span>  <span class=\"bp\">∥</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"bp\">∥</span><span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">dot_prod_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">dot_prod_comm</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">ring</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>After the first <code>simp</code>,  the tactic state becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1</span> <span class=\"n\">goal</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">xy</span><span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>However, I have a theorem <code>dot_prod_comm</code> marked with <code>@[simp]</code> with the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- #check dot_prod_comm</span>\n<span class=\"n\">dot_prod_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">?</span><span class=\"n\">M_1</span><span class=\"o\">),</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>My question is, why doesn't the simplifier use this lemma to further simplify the state? As shown above, I can manually rewrite <code>dot_prod_comm</code> twice with another <code>simp</code> and <code>ring</code> to complete the proof.</p>",
        "id": 318517595,
        "sender_full_name": "Mitchell  Douglass",
        "timestamp": 1672366799
    },
    {
        "content": "<p><code>simp</code> detects commutativity (such as your <code>dot_prod_comm</code> and only uses them if the rewrite results in smaller variable indices when taken lexicographically, or something along those lines. The details don't matter, but the point is that you don't want to rewrite <code>a + b</code> into <code>b + a</code> into <code>a + b</code> into... so <code>simp</code> has some secret preferred ordering of the variables, and in your case it just happens that the variables are in its preferred order.</p>",
        "id": 318532329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672383230
    },
    {
        "content": "<p>Here I would suggest adding <code>dot_prod_comm x</code> (or <code>dot_prod_comm x, dot_prod_comm y</code>) to your <code>simp</code> call because it suddenly isn't a commutativity lemma either (it won't rewrite back).</p>",
        "id": 318532433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1672383307
    },
    {
        "content": "<p>In this case I think a better approach would be: you seem to have a simp lemma that says that <code>inner</code> is linear in the first argument, but not one for the second argument; you should add it.</p>",
        "id": 318539509,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672388423
    },
    {
        "content": "<p>That's more sensible than relying on <code>dot_prod_comm</code> in this proof (which isn't \"simplification\" at all, it just happens to <em>allow</em> further simplification).</p>",
        "id": 318539679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1672388542
    },
    {
        "content": "<p>Are you aware of the lemmas <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_add_right\">docs#inner_add_right</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_add_left\">docs#inner_add_left</a>?</p>",
        "id": 318541169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1672389425
    }
]