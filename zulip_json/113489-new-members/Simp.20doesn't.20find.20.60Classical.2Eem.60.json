[
    {
        "content": "<p>Hi all!</p>\n<p>While trying to prove an easy lemma about indexed unions, I tried simplify a subexpression like <code>p a ∨ ¬ p a</code> but it didn't get rid of it (by rewriting it to <code>True</code>). What could be wrong? Here's my exact code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iUnion_split</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iUnion</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_union</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mem_compl_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">exists_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">or_and_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ (∃ i, x ∈ f i) ↔ ∃ x_1, (x_1 ∈ part ∨ x_1 ∉ part) ∧ x ∈ f x_1</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- simp -- doesn't work</span>\n<span class=\"w\">  </span><span class=\"c1\">-- simp_all -- doesn't work</span>\n<span class=\"w\">  </span><span class=\"c1\">-- tauto -- doesn't work</span>\n<span class=\"w\">  </span><span class=\"c1\">-- aesop -- doesn't work</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">em</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>It seems like the simplifier doesn't have a lemma for situations like the above <code>x_1 ∈ part ∨ x_1 ∉ part</code>. Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.em#doc\">docs#Classical.em</a> be marked as <code>@[simp]</code>?</p>\n<p>PS. Did not find a lemma from mathlib for generalizing the above lemma.</p>",
        "id": 520094263,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1748019322
    },
    {
        "content": "<p>I'm not sure why you would expect that to be a <code>simp</code> lemma, that is arguably <a href=\"https://leanprover-community.github.io/extras/simp.html\">not what simp is for</a></p>",
        "id": 520094651,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1748019457
    },
    {
        "content": "<p>Oh, maybe I have misunderstood what simp is for...</p>\n<p>But even on the website you linked, there is a simp lemma <code>eq_self</code> which does <code>b = b ==&gt; True</code>, which is not too different what I'm looking for, which is <code>A ∨ ¬ A ==&gt; True</code>. Is there a clear distinction between the two which I'm not seeing?</p>\n<p>I tried adding it to the simplifier like follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">em_iff_true</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">iff_true_intro</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">em</span><span class=\"w\"> </span><span class=\"n\">A</span>\n</code></pre></div>\n<p>and then <code>simp</code> found it immediately in my <code>iUnion_split</code> example! So the simplifier does appear to work better for my example, but of course it might have other unforeseen consequences.</p>\n<p>I wonder if I should just make a PR for this...</p>",
        "id": 520097923,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1748020722
    },
    {
        "content": "<p>Note that you could have also proven your goal like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">iUnion_split</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">biUnion_union</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp?</span><span class=\"w\"> </span><span class=\"c1\">-- see what the simp lemmas look like</span>\n</code></pre></div>",
        "id": 520098830,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1748021107
    },
    {
        "content": "<p>Cool, I didn't see that.</p>\n<p>Is the point here that <code>simp</code> must always be constructive? I tried with some De Morgan's laws and couldn't get simp to solve those, so I guess that's the case then. Never knew that before... I wonder if this is documented anywhere?</p>",
        "id": 520099856,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1748021513
    },
    {
        "content": "<p><code>simp</code> has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.not_not#doc\">docs#Classical.not_not</a>, so it's not constructive</p>",
        "id": 520100278,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748021657
    },
    {
        "content": "<p>Oh good point!</p>\n<p>But now I'm <strong>very confused</strong> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> what is the reason for not having <code>em</code> or similar to simplify my goal in my initial example? Is it not what the simplifier is for, as suggested <span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> ?</p>",
        "id": 520103177,
        "sender_full_name": "Niklas Halonen",
        "timestamp": 1748022803
    },
    {
        "content": "<p>What's the difference between <code>em</code> and any other true statement?</p>",
        "id": 520107090,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748024325
    },
    {
        "content": "<p>I mean, following the same logic any theorem should be tagged by <code>simp</code>.</p>",
        "id": 520107144,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748024354
    },
    {
        "content": "<p>But <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sup_compl_eq_top#doc\">docs#sup_compl_eq_top</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.or_not_self#doc\">docs#Bool.or_not_self</a> are both <code>@[simp]</code></p>",
        "id": 520107603,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748024548
    },
    {
        "content": "<p>theorems <em>with asumptions</em> typically don't get tagged simp</p>",
        "id": 520107639,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1748024566
    },
    {
        "content": "<p>the only exceptions i can think of are <code>implies_true</code> and maybe <code>False.elim</code></p>",
        "id": 520107755,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1748024627
    },
    {
        "content": "<p>Oh aren't there many exceptions to that rule? Simp can quite happily use theorems with assumptions if my understanding is correct</p>",
        "id": 520121833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748030677
    }
]