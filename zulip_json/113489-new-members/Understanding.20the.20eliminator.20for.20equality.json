[
    {
        "content": "<p>I recently started learning inductive types from TPIL, and I'm starting to get a hang of the \"constructors\" part. The \"eliminators\" part is a bit harder to grasp for me, but I have understood it for Nat and Lists. The eliminator for equality is proving to be a hassle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n                  <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">a</span> <span class=\"n\">rfl</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This hasn't been elaborated in TPIL. Can someone explain to me how this works, and how it is supposed to build a function with domain a = b?</p>",
        "id": 407718321,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1702471484
    },
    {
        "content": "<p>To answer your immediate question: Notice that the last parameter to <code>Eq.rec</code> is of type <code>(h : a = b) → …</code>, so if you use <code>@Eq.rec α a motive p b</code>, then this has type <code>a = b → …</code>, so it is a function with domain <code>a = b</code>.</p>",
        "id": 407720193,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1702472100
    },
    {
        "content": "<p>But even then the eliminator for equality is still a hassle :-). It may help to walk through using it for a concrete function, maybe <code>a = b → b = a</code>. In that case, what is your <code>motive</code>? And what role does the forth argument to <code>Eq.rec</code>, the type of <code>motive a rfl</code>, then play.</p>",
        "id": 407720531,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1702472200
    },
    {
        "content": "<p>It is probably the most difficult eliminator to understand. I usually try to explain it as follows: instead of saying <code>a = b</code> I will say \"<code>a</code> and <code>b</code> are friends\" (since <code>=</code> is so deeply rooted in our brain that it is difficult to have a good intuition).</p>\n<p>Start with a type <code>α</code> and a term <code>(a : α)</code>. Suppose you want to do \"something\" for all <code>b</code> (of type <code>α</code>) that are friends with <code>a</code>. This \"something\" can be proving a proposition (so proving that all friends of <code>a</code> have some property) or construct a natural number or whatever, depending on the friend. Then it is enough to do this something for <code>a</code>.</p>\n<p>Note two things:</p>\n<ul>\n<li>often (but not always!) this \"something\" is defined for all <code>(b : α)</code>, but it is enough that is is well defined for the friends of <code>a</code>.</li>\n<li>On the other hand, it <em>has to be defined</em>. Contrary to other eliminators, this is usually the tricky part, you have to specify what you want to do in general before saying \"it is enough to do it for <code>a</code>.</li>\n</ul>",
        "id": 407721805,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702472572
    },
    {
        "content": "<p>I wrote a blog post <a href=\"https://xenaproject.wordpress.com/2021/04/18/induction-on-equality/\">here</a> about the recursor for equality -- all Lean 3 but probably this doesn't matter for your question.</p>",
        "id": 407721834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702472581
    },
    {
        "content": "<p>Concerning my last point, a very good exercise is to understand why \"the uniqueness of <code>refl</code>\" is a serious problem in type theory. The question is the following: suppose that <code>(a b : α)</code> and that <code>(h₁ : a = b)</code> and <code>(h₂ : a = b)</code>. Does it follow that <code>h₁ = h₂</code>?</p>\n<p>Of course in Lean the answer is yes (because of proof irrelevance, <code>h₁</code> and <code>h₂</code> are proofs of the same proposition so they're definitionally equal), but it is interesting to try to prove it <em>without</em> using proof irrelevance. <code>Eq.rec</code> allows you to reduce the problem to prove that if <code>(h : a = a)</code> then <code>h = Eq.refl a</code>, but then you're stuck, and the problem is exactly that you don't find a good motive to use again <code>Eq.rec</code>.</p>",
        "id": 407723330,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702473056
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> , <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> . I think I understood what Eq.rec says.<br>\nCorrect me if I'm wrong, but it says \"Suppose you have a type <code>\\a</code> and an element <code>a : \\a</code>, suppose you have a function that can map all <code>b : \\a</code> that are equal to <code>\\a</code> to something (say, of Type k), and suppose you can map <code>a</code> to  something (same/different thing) of Type k. Then you can construct a function that can take a proposition of some element in <code>\\a</code> being equal to <code>a</code>,  and map it to something of Type k. (For clarity, Sort v has been reduced to k)\"<br>\nNoe that I have written it down, I realise that it is almost the same thing that <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> has said, and <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has written in his blog post.</p>\n<p>However, what I still struggle to understand, is how this sort of a statement guarantees that <code>refl</code> is the only element in <code>Eq a a</code>. I know that this follows from a statement in <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> 's blog post:<br>\n\"“Let’s say that for every element x of X we have a set C(x), and let’s say we have an element of C(p). Then we have a method of constructing an element of C(x) for all x \\in X.” This looks like a rather long-winded way of saying that p is the only element of X. \"<br>\nBut I cannot grasp how the 2nd sentence here follows from the first one either.</p>",
        "id": 407893511,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1702537137
    },
    {
        "content": "<blockquote>\n<p>However, what I still struggle to understand, is how this sort of a statement guarantees that refl is the only element in Eq a a</p>\n</blockquote>\n<p>It isn't the case, in many other type theories, that this eliminator implies the uniqueness of identity proof (the fact that all proofs of <code>Eq a a</code> are equal to <code>refl</code>). In univalent type theories such as CubicalTT, it is in fact explicitly not the case. In Lean, this property is true because <code>Eq</code> lives in the <code>Prop</code> universe, which is proof-irrelevant (read, any two proofs of a given proposition are equal).</p>",
        "id": 407896967,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1702538360
    },
    {
        "content": "<p>I see, thanks a lot. Regardless, how do the eliminators for other types imply that the only elements residing in that type are the constructors?</p>",
        "id": 407897520,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1702538570
    },
    {
        "content": "<p>The elimination rule says \"if it's true for all terms made using constructors then it's true for all terms\" and you can prove that all terms of the type are made from one of the constructors very easily from this.</p>",
        "id": 407897882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702538705
    },
    {
        "content": "<p>You may learn this by example. Take the type of booleans <code>Bool</code>, made of two constructors. It's eliminator, <code>Bool.rec</code>, has type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Bool.rec.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">false</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>if we take <code>fun _ =&gt; Prop</code> as a motive, we may use the recursor to map <code>true</code> to the <code>True</code> type, and <code>false</code> to <code>False</code>. In order to prove that <code>true != false</code>, you now only need to prove that <code>True != False</code>. Furthermore, if <code>True = False</code>, then you can inhabit <code>False</code> by transporting <code>True.intro</code> through your equality. That's how you generally prove that two constructors are different.</p>",
        "id": 407901638,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1702540022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Understanding.20the.20eliminator.20for.20equality/near/407897882\">said</a>:</p>\n<blockquote>\n<p>The elimination rule says \"if it's true for all terms made using constructors then it's true for all terms\" and you can prove that all terms of the type are made from one of the constructors very easily from this.</p>\n</blockquote>\n<p>Is the proof basically to take the special case of the \"true thing\" being \"this term can be made using constructors\"? Sorry if this is a very trivial doubt, I haven't learnt anything like type theory before and my experience with Lean is relatively short, around 5 months.</p>",
        "id": 407908776,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1702542929
    },
    {
        "content": "<p>Yes, basically</p>",
        "id": 407909084,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702543052
    },
    {
        "content": "<p>As an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nat_from_constructors</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">m</span>\n</code></pre></div>",
        "id": 407909412,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1702543188
    },
    {
        "content": "<p>Can you please open a new thread and write a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 407933652,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702551096
    },
    {
        "content": "<p>Concerning again the equality I have somewhere an exercice sheet with several examples. <span class=\"user-mention\" data-user-id=\"627751\">@Vivek Rajesh Joshi</span> if you want I can share it.</p>",
        "id": 407934043,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702551219
    },
    {
        "content": "<p>Sure, you can share it to me. Thanks a lot!</p>",
        "id": 407934234,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1702551277
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ex</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">section</span> <span class=\"n\">equality</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Eq</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ≃ \"</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">Eq</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">eliminator</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">A</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">ha</span> <span class=\"n\">b</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">eliminator</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">equivalence</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">reflexivity</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">refl</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">symmetry</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">a</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">reflexivity</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">transitivity</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≃</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">equivalence</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">substitution</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">reflexivity</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrefl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrefl</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.rec</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n    <span class=\"n\">refine</span> <span class=\"n\">transitivity</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">this</span>\n    <span class=\"n\">apply</span> <span class=\"n\">substitution</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.rec</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Eq.refl</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">d</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">≃</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">≃</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">this</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">succ</span> <span class=\"n\">d</span> <span class=\"bp\">≃</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">≃</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">≃</span> <span class=\"n\">h'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e'</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">e</span> <span class=\"bp\">≃</span> <span class=\"n\">e'</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">e'</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">equality</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ex</span>\n</code></pre></div>\n<p>I redefine equality and I prove basic properties (that is an equivalence relation + substitution).</p>\n<p>Something interesting you can do is to modify the definition as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>so it takes values in <code>Type</code> rather than in <code>Prop</code>. Nothing breaks util the uniqueness of <code>refl</code>. Of course the proof in line 79 does not work anymore, but the example in line 82 still works. The difference is that before it was easy to finish the proof, and now it's not.</p>",
        "id": 407935032,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702551545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Understanding.20the.20eliminator.20for.20equality/near/407933652\">said</a>:</p>\n<blockquote>\n<p>Can you please open a new thread and write a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<p>Sorry, I may have posted here by accident. This was my first message. I'm not sure how to ask a new question.</p>",
        "id": 407935507,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1702551692
    }
]