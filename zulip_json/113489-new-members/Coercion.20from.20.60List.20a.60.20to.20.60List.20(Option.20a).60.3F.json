[
    {
        "content": "<p>Not really a new member, but I have a very basic question. The following code confuses me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- works, displays the following:</span>\n<span class=\"c1\">-- do</span>\n<span class=\"c1\">--   let a ← l</span>\n<span class=\"c1\">--   pure (some a) : List (Option α)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- failed to synthesize</span>\n</code></pre></div>\n<p>Somehow Lean is able to interpret <code>l</code> as a <code>List (Option α)</code>, even though it can't find a <code>Coe</code> instance (I wouldn't have expected there to be one either). Even weirder, it displays it using do-notation.</p>",
        "id": 567806830,
        "sender_full_name": "Justus Springer",
        "timestamp": 1768321159
    },
    {
        "content": "<p>Is this a MWE? In Lean 4 Web I get an error...</p>",
        "id": 567808462,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768321563
    },
    {
        "content": "<p>It works after <code>import Mathlib</code></p>",
        "id": 567808584,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768321592
    },
    {
        "content": "<p>You're right, it only works with Mathlib. <code>#min_imports</code> is giving nothing though.</p>",
        "id": 567809017,
        "sender_full_name": "Justus Springer",
        "timestamp": 1768321704
    },
    {
        "content": "<p>Edited the example to include Mathlib</p>",
        "id": 567809341,
        "sender_full_name": "Justus Springer",
        "timestamp": 1768321789
    },
    {
        "content": "<p>I think this is using MonadLift not Coe</p>",
        "id": 567809592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768321831
    },
    {
        "content": "<p>Yeah <code>Monad List</code> instance is in Mathlib but not in Core or Batteries</p>",
        "id": 567809940,
        "sender_full_name": "David Ledvinka",
        "timestamp": 1768321922
    },
    {
        "content": "<p>I don't know how MonadLift works. I naively assumed that whenever you do <code>variable (x : A)</code> and then <code>#check (x : B)</code> works, there must be a coercion from A to B, which is why I got confused. In the docs about MonadLift, it says \"Computations in the monad <code>m</code> can be run in the monad <code>n</code>. These translations are inserted automatically by the compiler.\" So I guess that automatic insertion is what's causing this, correct?</p>",
        "id": 567811161,
        "sender_full_name": "Justus Springer",
        "timestamp": 1768322214
    },
    {
        "content": "<p>Yeah, it is - monads are used for do notation, that's also why it's printing like that</p>",
        "id": 567811819,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768322389
    },
    {
        "content": "<p>I suppose you could argue that automated <code>MonadLift</code> insertion should not happen outside of <code>do</code> notation</p>",
        "id": 567812167,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768322499
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It's used frequently when passing monadic values to various combinators. I suppose Lean could require <code>do</code> to signal intent to coerce, but that'd be a disruptive change.</p>",
        "id": 567812855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768322663
    },
    {
        "content": "<p>Is it easy for you to find an example that doesn't use <code>do</code>?</p>",
        "id": 567813170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768322740
    },
    {
        "content": "<p>You could also argue that <code>Monad List</code> shouldn't be an instance, to prevent this coercion insertion. It's a bit uneasy to have <code>List</code> represent both data and a computational context. (<code>Option</code> is in a similar situation, but so far it's too useful to require using a monad-specific <code>OptionM</code>.)</p>",
        "id": 567813280,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768322770
    },
    {
        "content": "<p>I guess another option (which I think I started exploring in a PR) is to have the <code>MonadLift</code> instance be <code>some &lt;$&gt; l</code> instead of the <code>bind</code> that is currently inserted</p>",
        "id": 567813421,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768322813
    },
    {
        "content": "<p>Should core <code>Monad</code> be called <code>MonadForComputation</code> instead?</p>",
        "id": 567813808,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1768322924
    },
    {
        "content": "<p>Or a <code>[EnableDoNotation m]</code> that is orthogonal to <code>Monad</code>, which is required by <code>do</code> and <code>MonadLift</code> auto-insertion</p>",
        "id": 567814069,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768323001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I don't have any immediately accessible examples, but monad lifting occurs frequently enough between all the metaprogramming monads that I'm sure removing monad lifting from the term coercion system would break many things.</p>",
        "id": 567814191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1768323038
    },
    {
        "content": "<p>I suppose the easiest way to find the examples (which is not particularly easy) is to make the change and see what breaks</p>",
        "id": 567814398,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768323096
    }
]