[
    {
        "content": "<p>In the documentation for the class <code>Seq</code>, it is written:</p>\n<blockquote>\n<p><code>seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β</code></p>\n<p>If <code>mf : F (α → β)</code> and <code>mx : F α</code>, then <code>mf &lt;*&gt; mx : F β</code>. In a monad this is the same as <code>do let f ← mf; x ← mx; pure (f x)</code>: it evaluates first the function, then the argument, and applies one to the other.</p>\n<p>To avoid surprising evaluation semantics, <code>mx</code> is taken \"lazily\", using a <code>Unit→ f α</code> function.</p>\n</blockquote>\n<p>My question is on the last sentence: What is an example of a \"surprising evaluation semantic\" that one would like to avoid?</p>",
        "id": 477238161,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1729090874
    },
    {
        "content": "<p>I also found myself wondering about this comment. The docstring seems to go back to at least <a href=\"https://github.com/leanprover/lean4/pull/1445\">PR#1445</a>.</p>\n<p>Does the putative counterexample of surprising behavior have to do with <a href=\"https://lean-lang.org/functional_programming_in_lean/hello-world/conveniences.html?highlight=nested%20actions#nested-actions\">nested actions</a> in <code>do</code>-notation, perhaps? I can imagine how forcing the user to write a thunk might disallow the nested action, thereby disallowing the unexpected effect order.</p>",
        "id": 516894669,
        "sender_full_name": "Jason Reed",
        "timestamp": 1746710554
    },
    {
        "content": "<p>For one thing, I think that line is there for consistency with all the other monad combinators like <code>*&gt;</code>, <code>&lt;*</code>, <code>&lt;|&gt;</code> which do the same thing. But an example which would be affected by evaluation order of <code>&lt;*&gt;</code> would be in parser combinators, where e.g. you have </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Internal</span><span class=\"w\"> </span><span class=\"n\">Parsec</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">parseExpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">pchar</span><span class=\"w\"> </span><span class=\"bp\">'+'</span><span class=\"w\"> </span><span class=\"bp\">*&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">parseExpr</span><span class=\"w\"> </span><span class=\"bp\">&lt;*&gt;</span><span class=\"w\"> </span><span class=\"n\">parseExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">digits</span>\n</code></pre></div>\n<p>you would like the occurrences of <code>parseExpr</code> not to be evaluated immediately in the body of <code>parseExpr</code> because then it would immediately infinitely recurse before parsing anything.</p>",
        "id": 516900327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746712065
    },
    {
        "content": "<p>Thanks, that example is helpful</p>",
        "id": 516903459,
        "sender_full_name": "Jason Reed",
        "timestamp": 1746712867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">Jason Reed</span> <a href=\"#narrow/channel/113489-new-members/topic/Question.20on.20Seq/near/516894669\">said</a>:</p>\n<blockquote>\n<p>I can imagine how forcing the user to write a thunk might disallow the nested action, thereby disallowing the unexpected effect order.</p>\n</blockquote>\n<p>Note that this doesn't happen - nested actions are permitted in that context, because the check for surrounding fun binders runs before macro expansion</p>",
        "id": 516909908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1746714491
    },
    {
        "content": "<p>Hmm. My comment reflected the error message<br>\n<code>cannot lift `(&lt;- ...)` over a binder, this error usually happens when you are trying to lift a method nested in a `fun`, `let`, or `match`-alternative, and it can often be fixed by adding a missing `do`Lean 4</code><br>\narising from, for example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- this is fine:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">)])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">]))</span>\n\n<span class=\"c1\">-- this is an error:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>but maybe you have something in mind that circumvents that in a different way. I'm still getting used to the edge cases of the scoping rules for <code>(← ... )</code> but it seems like a great convenience feature.</p>",
        "id": 516928862,
        "sender_full_name": "Jason Reed",
        "timestamp": 1746719456
    },
    {
        "content": "<p>And in any case, I think I take your point that this is a tangential issue unrelated to why monad/applicative combinators take thunks. Just trying to clarify what I speculatively had in mind in the first place :)</p>",
        "id": 516929162,
        "sender_full_name": "Jason Reed",
        "timestamp": 1746719531
    },
    {
        "content": "<p>(and if I cured this error by doing, e.g., </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">     </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">]))</span>\n<span class=\"w\">  </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">res</span>\n</code></pre></div>\n<p>then I would think any evaluation-order consequences of this would be made fully explicit by the extra <code>do</code> and therefore not confusing)</p>",
        "id": 516930381,
        "sender_full_name": "Jason Reed",
        "timestamp": 1746719867
    },
    {
        "content": "<p>Yes, this error message appears when you <em>literally</em> write a function binder and use <code>&lt;- e</code> under it. If you have <code>macro \"myfun\" e =&gt; `(fun _ =&gt; e)</code> then <code>myfun (&lt;- e)</code> will not trigger the error but <code>fun _ =&gt; (&lt;- e)</code> will</p>",
        "id": 517492365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747044802
    },
    {
        "content": "<p>This error message is mostly just a warning, trying to avoid the surprising order of evaluation that arises. It has both false positives and false negatives</p>",
        "id": 517492880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747044934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">Jason Reed</span> <a href=\"#narrow/channel/113489-new-members/topic/Question.20on.20Seq/near/516930381\">said</a>:</p>\n<blockquote>\n<p>(and if I cured this error by doing, e.g., </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">     </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">]))</span>\n<span class=\"w\">  </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">res</span>\n</code></pre></div>\n<p>then I would think any evaluation-order consequences of this would be made fully explicit by the extra <code>do</code> and therefore not confusing)</p>\n</blockquote>\n<p>That's not the equivalent code to what the errored code would do if it were not for the error message. What it actually desugars to is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 517493535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747045090
    },
    {
        "content": "<p>The fact that it <em>doesn't</em> evaluate the monadic action every time in the function is exactly the counterintuitive behavior which the error message is trying to warn you about</p>",
        "id": 517493753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747045144
    }
]