[
    {
        "content": "<p>In the documentation for the class <code>Seq</code>, it is written:</p>\n<blockquote>\n<p><code>seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β</code></p>\n<p>If <code>mf : F (α → β)</code> and <code>mx : F α</code>, then <code>mf &lt;*&gt; mx : F β</code>. In a monad this is the same as <code>do let f ← mf; x ← mx; pure (f x)</code>: it evaluates first the function, then the argument, and applies one to the other.</p>\n<p>To avoid surprising evaluation semantics, <code>mx</code> is taken \"lazily\", using a <code>Unit→ f α</code> function.</p>\n</blockquote>\n<p>My question is on the last sentence: What is an example of a \"surprising evaluation semantic\" that one would like to avoid?</p>",
        "id": 477238161,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1729090874
    }
]