[
    {
        "content": "<p>Hi. Is there an easy way to define Mul/Semigroup/Monoid hierarchy for a structure with 2 fields? I can pretty easily define <code>MyStruct ≃ Nat × Nat</code> which probably can be used somehow?</p>",
        "id": 468581953,
        "sender_full_name": "Evgeny Kurnevsky",
        "timestamp": 1725807056
    },
    {
        "content": "<p>Prod requires some proofs: <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Algebra/Group/Prod.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Algebra/Group/Prod.lean</a> so defining it by hand would also require me to write those proofs..</p>",
        "id": 468582462,
        "sender_full_name": "Evgeny Kurnevsky",
        "timestamp": 1725807306
    },
    {
        "content": "<p>I'm aware of one approach.</p>\n<p>Use mathlibs <code>proxy_equiv%</code> which for a creates an equivalence between the structure with a type build out of <code>Sigma</code>, <code>Sum</code> and <code>Unit</code>.</p>\n<p>Then define function <code>&lt;strcture&gt;.ofEquvi</code> which transfers the algebraic structure along and equivalence. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">ofEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then you can provide the instance for your structure <code>S</code> like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddComGroup</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">ofEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Short mwe for addition</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y2</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"bp\">.</span><span class=\"n\">ofEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"bp\">.</span><span class=\"n\">ofEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"mi\">1000</span>\n</code></pre></div>",
        "id": 468606818,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725818186
    },
    {
        "content": "<p>Here I have <a href=\"https://github.com/lecopivo/SciLean/blob/790248d8ea9d71c1bc4aa7b6e7cfa9e691bdc06d/SciLean/Data/Instances/Sigma.lean\">a file</a> setting it up to get <code>NormedSpace</code> but all the proofs use sorry right now.</p>",
        "id": 468607220,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725818382
    },
    {
        "content": "<p>I would really like to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">NormedAddCommGroup</span><span class=\"o\">,</span>\n<span class=\"w\">          </span><span class=\"o\">{</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>",
        "id": 468607700,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725818571
    },
    {
        "content": "<p>I'm curious if anyone thought about automatically generating these instances a bit more. I'm have been thinking about it for quite some time and still don't know what would be the best approach.</p>\n<p>For the above structure <code>Vec3 R</code> the <code>deriving [AddCommGroup R] -&gt; AddCommGroup</code> would ideally trigger a sequence of instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddSemigroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSemigroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMagma</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommMagma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Vec3</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>I can of course hardcode this particular sequence of instances but ideally it would be automatically generated.</p>\n<p>I think there are effectively two questions:</p>\n<ol>\n<li>Figure out the sequence of typeclasses for which to derive an instance.</li>\n<li>For each typeclass figure out the necessary constraints on the structure parameters</li>\n</ol>\n<p>Partial answers:</p>\n<ol>\n<li>\n<p>This is probably easy as you can just walk the class hierarchy. For example, <code>AddCommGroup</code> extends <code>AddGroup</code> <code>AddCommMonoid</code>. So you try to derive instances for those first. I'm not sure how to prevent diamonds though as a naive application of the approach above would mean calling <code>AddGroup.ofEquiv</code> and <code>AddCommMonoid.ofEquiv</code> which would create two instances of <code>Add</code> on <code>Vec3</code> and that is bad.</p>\n</li>\n<li>\n<p>The task is to figure out the \"minimal/sufficient/obvious\" conditions under which you can provide an instance <code>AddCommGroup (Vec3 R)</code>. It would be great to be able to run some kind of analysis on failed typeclass synthesis and figure out the minimal set of instances to make the synthesis to succeed. Such analysis would be also great for improving typeclass synthesis error messages.</p>\n</li>\n</ol>",
        "id": 468986718,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725945088
    },
    {
        "content": "<p>Relatedly, something I got a bit stuck on with <a href=\"https://github.com/leanprover-community/mathlib4/pull/3251\">#3251</a> (deriving LinearOrders) was what API should be automatically generated to support the derived LinearOrder. It seems that most derived typeclasses don't need any supporting theory, but for this you do want to know how the order is related to the actual inductive type. Similarly, for these algebraic structures, you want to know how the operations are related to the inductive type.</p>",
        "id": 468990190,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725946670
    }
]