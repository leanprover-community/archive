[
    {
        "content": "<p>This is a follow up to the question 'How to define \"Decidable\" and \"DecidablePred\"?'<br>\nThe solution there was to use \"abbrev\" instead of \"def\".</p>\n<p>Now I want to add some lemmas and again run into the problem: \"failed to synthesize DecidablePred (isCoveringCode Code)\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">InformationTheory</span><span class=\"bp\">.</span><span class=\"n\">Hamming</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hammingDist</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode_decidablePred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- For a non-empty finite set Code of functions, Code serves as a covering code</span>\n<span class=\"c1\">-- for the cardinality of the finite type ι.</span>\n<span class=\"c1\">-- Note that the non-emptyness of Code is mandatory, as an empty Code</span>\n<span class=\"c1\">-- is not a covering code.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">le_card_fintype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnonempty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Since the set Code is finite and non-empty, we can choose an arbitrary codeword c ∈ Code</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hnonempty</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">frequently_principal</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"c1\">-- By the definition of h, we have hammingDist x c ≤ Fintype.card ι</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Finally, we need to show that c ∈ C and hammingDist x c ≤ Fintype.card ι</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hammingDist_le_card_fintype</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- The covering radius of a code is the smallest radius such that every element in the space</span>\n<span class=\"c1\">-- can be covered by a codeword within this radius.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">coveringRadius</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_card_fintype</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">hnonempty</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Monotonicity lemma for isCoveringCode</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hrs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">hrs</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- Proof that coveringRadius gives the smallest radius that satisfies isCoveringCode</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">coveringRadius_is_smallest</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">coveringRadius</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">hnonempty</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_min'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isCoveringCode_mono</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">le_card_fintype</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">hnonempty</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>In the definition of \"coveringRadius\" as well as in the proof that the covering radius is minimal the \"DeciablePrep\" is needed even when using \"abbrev\" instead of \"def\" in the definition of \"isCoveringCode\".</p>\n<p>What is the way forward? Do I need to adapt the definition of \"coveringRadius\" and the proof or is it easier to define the \"DecidablePred\"? If so: how can this be done?</p>",
        "id": 456517511,
        "sender_full_name": "florath",
        "timestamp": 1722857277
    },
    {
        "content": "<p>in order to get lean there, you need these two assumptions : <code>[DecidableEq ι] [∀ i, Fintype (β i)]</code></p>",
        "id": 456524199,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722858765
    },
    {
        "content": "<p>from there, lean should be able to infer the instance you need.</p>",
        "id": 456524272,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722858789
    },
    {
        "content": "<p>the second assumption is an obvious requirement; in order to see that the radius indeed does cover, you need <code>∀ i, β i</code> to be a fintype which isn't the case when <code>β i</code> is infinite.</p>",
        "id": 456524646,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722858903
    },
    {
        "content": "<p>Again: thanks a lot. This works.</p>\n<p>Also <code>[DecidableEq ι]</code> is obvious - for indices (of <code>type ι</code>) the equality must be decidable.<br>\nNever thought that this kind of requirement would solve the \"DecidablePred\" problem.</p>",
        "id": 456584304,
        "sender_full_name": "florath",
        "timestamp": 1722868049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"706789\">florath</span> has marked this topic as resolved.</p>",
        "id": 456584317,
        "sender_full_name": "Notification Bot",
        "timestamp": 1722868054
    }
]