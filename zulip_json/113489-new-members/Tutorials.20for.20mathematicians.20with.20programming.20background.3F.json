[
    {
        "content": "<p>Are there any tutorials out there that assume the reader already knows how to write proofs and understands basic logic, doesn't care about the details of Lean's implementation, and just wants to know the bare minimum syntax to formalize, check, or generate proofs?</p>\n<p>E.g. which keywords, which punctuation, in which order, etc.</p>\n<p>For example, trying to look at examples from tutorials, I thought that it should be straightforward to check that 2+2=4 and that 2+2 does not equal 5. But the output <code>#0</code> from Lean does not seem to mean anything (it returns the same for both the true statement and the false statement, and doesn't say anything unambiguous like \"this evaluates to true\" or \"this evaluates to false\").</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">4</span>\n<span class=\"k\">#eval</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">4</span>  <span class=\"c1\">-- neither returns something clear like \"True\" as output</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span>\n<span class=\"k\">#eval</span> <span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">=</span><span class=\"mi\">5</span> <span class=\"c1\">-- neither returns something clear like \"False\" as output</span>\n</code></pre></div>\n<p>Is it a typing issue and I have to specifically declare 2, 4, and 5 as natural numbers before I can check the validity of these statements? If so, fine, but then what is a minimum working example that shows or validates or checks that 2+2=4 is true for natural numbers, and 2+2=5 is false for natural numbers? </p>\n<p>Do users really need to know  all about dependent type theory and tactics and a million other things to understand the code syntax of the very fist, simplest examples of verifying that 2+2=4 and that 2+2 does not equal 5? </p>\n<p>Like sure syntax can sometimes have different or more general meanings in different contexts, but I'd like to be able to learn by copying-pasting-modifying simple examples I understand either until they break or they do things that are more complicated and interesting to me.</p>\n<p>Maybe as a more non-trivial example of what kinds of tutorials I'm looking for, I'm not able to check the validity of basic predicate logic statements, and the tutorials I've been able to find have a lot of information extraneous to my goal: get an unambiguous report of \"True\" or \"False\".  </p>\n<p>As one example: <a href=\"https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html\">https://leanprover.github.io/logic_and_proof/first_order_logic_in_lean.html</a> &lt;- Is the letter <code>h</code> somehow a keyword in Lean? It seems to be used like one in those examples, but if so its syntactical role is never explained or mentioned. The tutorial is partially helpful, but not enough to get me all the way to my end goal.</p>\n<p>Here is a simple example of the kind of basic statements I'd like to write in predicate logic, and whose validity that I would like to check.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"c1\">-- undefined, primitive sort</span>\n<span class=\"kd\">constant</span> <span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- undefined, primitive predicate</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">test</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">):</span>  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">test</span><span class=\"o\">,</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- how do I show that this is true given test?</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">):=</span>\n<span class=\"k\">assume</span> <span class=\"n\">test</span><span class=\"o\">,</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- how do I show that this is false given test?</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"c1\">-- neither of these</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"c1\">-- seem to work</span>\n</code></pre></div>\n<p>I get that in constructive logic, without excluded middle, we don't necessarily have that the universal and existential quantifiers can be defined in terms of each other. And I get that Lean supports constructive logic by default, with classical logic as a special case. But beginning the code with <code>open classical</code> doesn't seem to be enough. Instead running Lean on the code gives me an error about <code>has_repr type</code>, and says nothing about whether the statements are True or False. This is confusing to me both as someone trained as a mathematician using classical logic, and as a programmer who uses languages that have Boolean types with unambiguous <code>True</code> or <code>False</code> values.</p>\n<p>(Also even in constructive logic the second example should still be False I think, even if the first example need not be True nor False.)</p>\n<p>Anyway all I'm asking for is for dumbed-down, basic tutorials that explain the programming language syntax for showing that certain statements are True and False, and how to read/understand the output from Lean for whether it is telling you that something is True or False.</p>",
        "id": 367453334,
        "sender_full_name": "William",
        "timestamp": 1687118427
    },
    {
        "content": "<p>Does <code>#eval (2+2 = 4 : bool)</code> give something better?</p>",
        "id": 367457111,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1687120756
    },
    {
        "content": "<p>Does <code>#eval (2+2 = 4 : bool)</code> give something better?</p>",
        "id": 367457131,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1687120778
    },
    {
        "content": "<p>(I'm on mobile, hence the duplicate message <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span>)</p>",
        "id": 367457217,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1687120815
    },
    {
        "content": "<p>Anyway, the short summary is that writing <code>#eval 2+2=4</code> basically gets lean to the stage where it realizes that it has a proposition, namely the assertion that 2+2 equals 4, but does not find a truth value for it, since in general, there is no decision procedure for a proposition.  With the explicit type ascription (to <code>bool</code>eans, rather than <code>Prop</code>ositions), you tell Lean to try harder and then it realizes that there is a decidable instance somewhere that allows is to actually compute the truth value of this specific proposition, and then it should report <code>tt</code>: the proposition is true.</p>",
        "id": 367457771,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1687121073
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> That's how Lean 4 <code>#eval</code> works, but in Lean 3 you get <code>#0</code> for a proposition since this command is a front-end for the VM compiler and evaluator, propositions are computationally irrelevant thus erased, and as an implementation quirk the result of computing nothing is this <code>#0</code> thing.</p>",
        "id": 367462393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687123724
    },
    {
        "content": "<p>In Lean 4, there's a check that turns <code>#eval p</code> into <code>#eval decide p</code> if <code>p</code> is a proposition.</p>",
        "id": 367462597,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687123847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"625947\">@William</span> Lean is meant to be a system where you interactively construct proofs of propositions rather than one that automatically decides whether a proposition is true or false. The <code>#check</code> command is simply meant to give you the type of an expression (after checking it is well-typed) and <code>#eval</code> is meant to evaluate Lean-as-a-programming-language, and it strips out all propositions since these are considered to have no computational content.</p>",
        "id": 367463129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1687124278
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"c1\">-- undefined, primitive sort</span>\n<span class=\"kd\">constant</span> <span class=\"n\">P</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- undefined, primitive predicate</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">test</span><span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">test'</span> <span class=\"o\">:</span>  <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">not_test</span><span class=\"o\">,</span>\n<span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">test</span> <span class=\"k\">in</span>\n<span class=\"n\">not_test</span> <span class=\"n\">y</span> <span class=\"n\">hy</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"c1\">-- fails because there is no decidability instance for this proposition</span>\n<span class=\"k\">#check</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"c1\">-- it's a prop</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">test'</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"c1\">-- it's a true prop, because test' is a proof of it</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">assume</span> <span class=\"n\">test</span><span class=\"o\">,</span>\n<span class=\"gr\">sorry</span>  <span class=\"c1\">-- we can't prove it, so there isn't much hope here</span>\n\n\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"c1\">-- it's a prop</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"c1\">-- but we still can't evaluate it like this</span>\n\n<span class=\"c1\">-- Since we proved it is false, we can inform lean of it using this instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">is_false</span> <span class=\"n\">test'</span>\n\n<span class=\"c1\">-- and now these work:</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"c1\">-- tt</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">P</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"c1\">-- ff</span>\n</code></pre></div>",
        "id": 367498857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1687147656
    },
    {
        "content": "<p>Note that unlike in logic the keyword <code>assume</code> has nothing to do with the keyword <code>axiom</code>, so saying something like <code>assume test</code> is probably not what you want to do. If you want to prove <code>P → Q</code> (which of course means \"if <code>P</code> then <code>Q</code>\") then writing <code>assume h</code> creates a new variable called <code>h</code> which records the fact that <code>P</code> is true, and then switches to you trying to prove <code>Q</code>. <code>assume</code> actually has very little to do with assuming things.</p>\n<p>One very important thing about Lean is that it uses the <a href=\"https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence\">propositions-as-types paradigm</a>. What this means is that if <code>P</code> is a proposition, then <code>P</code> can also be seen as the type of proofs of <code>P</code> (this is a confusing statement and it takes time to get used to). So <code>P → Q</code> can also be seen as the type of functions which take proofs of <code>P</code> as input and output proofs of <code>Q</code>. In this sense, the keyword <code>assume</code> is almost exactly the same as python's keyword <code>lambda</code>.</p>\n<p>Also, you're probably aware of this, but the primary role of Lean is to verify that your proofs are correct, rather than to prove complex statements on its own. So there's no command to check whether or not a given statement is true. If you do want to have Lean attempt to generate a proof of a statement, you can use something called tactics (in particular, writing <code>by tauto</code> will have Lean try to generate proofs of first order logic statements), but note that these usually can't prove anything super complex.</p>",
        "id": 367502510,
        "sender_full_name": "Niels Voss",
        "timestamp": 1687150015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"625947\">William</span> <a href=\"#narrow/stream/113489-new-members/topic/Tutorials.20for.20mathematicians.20with.20programming.20background.3F/near/367453334\">said</a>:</p>\n<blockquote>\n<p>Are there any tutorials out there that assume the reader already knows how to write proofs and understands basic logic, doesn't care about the details of Lean's implementation, and just wants to know the bare minimum syntax to formalize, check, or generate proofs?</p>\n<p>E.g. which keywords, which punctuation, in which order, etc.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"625947\">@William</span> The canonical answer for someone asking for a \"tutorial for mathematicians\" is <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a>.  Have you already looked at this?</p>\n<blockquote>\n<p>Do users really need to know  all about dependent type theory and tactics and a million other things to understand the code syntax of the very fist, simplest examples of verifying that 2+2=4 and that 2+2 does not equal 5? </p>\n</blockquote>\n<p>It's true that in Mathematics in Lean, the proof that <code>2 + 2 = 4</code> will go via a tactic (possibly <code>rfl</code> or <code>decide</code>, but these are still tactics) rather than in term mode.  That's because mathematician users of Lean tend to rely heavily on tactics rather than writing term proofs for everything, so the book gets started early with explaining tactics.  Perhaps your use case is different, feel free to explain.</p>\n<p>On the other hand, for the impatient, I have found that simply mousing through the infoview in a proof of a theorem you know well can be a good way to get started.  It should be a fairly advanced/abstract theorem, otherwise you will have the problem that the mathlib implementation has been transformed or splintered beyond recognition from the version you know.  If you want to tell us your field, people can probably suggest an interesting file to look at first.</p>\n<p>Definitely you don't need to know anything about dependent type theory for your first month.</p>",
        "id": 367779268,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1687224790
    },
    {
        "content": "<p>Sorry for the slow response everyone, I thought people would be too busy to read / see this anytime soon and so wasn't expecting responses so soon. Everyone's enthusiasm and helpfulness is amazing! I really appreciate it.</p>\n<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> Thank you so much for this! <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html#getting-started\">https://leanprover-community.github.io/mathematics_in_lean/C01_Introduction.html#getting-started</a></p>\n<p>I actually didn't know that this existed at all, the first page even has the 2+2=4 example, haha.</p>\n<p>This is perfect. I will definitely have to spend a lot of time working through that from now on.</p>\n<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> The explanation of <code>assume</code> is very helpful, I was definitely completely misunderstanding it. Also the explanation of where these <code>h</code> variables in the tutorials come from also really helped.</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thank you so much for the line-by-line explanation of that example! I was getting really frustrated because the behavior wasn't what I naively expected at all, but this is much clearer now. I still have to think through it more though, but I really appreciate the time you spent to help me.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I was also really misunderstanding the points you mentioned too. In particular the difference in purposes between tactics and type checking in Lean. The explanation of Lean vs Lean 4 is also really helpful -- it looks like there'll be a lot to look forward to in the new release!</p>\n<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Thank you for the explanation of this! I didn't understand the purpose of the eval keyword at all, nor when to use propositions vs when to use booleans (or even whether Lean had booleans). This is all much more clear to me now.</p>\n<p>@ everyone<br>\nI'll have to spend a lot more time getting used to Lean and working through examples to become productive with it at all, but you've all given me the confidence that this is not a hopeless task and that it really is worth trying after all! I had been getting really frustrated failing with such simple examples, so all of these explanations really mean a lot to me, and again I really appreciate all of the help from everyone! Thank you all so much again!</p>",
        "id": 369302991,
        "sender_full_name": "William",
        "timestamp": 1687665532
    }
]