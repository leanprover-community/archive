[
    {
        "content": "<p>This doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"c1\">-- typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"c1\">--  Singleton ℕ ?m.57</span>\n</code></pre></div>\n<p>OK, fair enough, we don't know if I meant a natural, an integer, or something else.</p>\n<p>What about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"c1\">-- unsupported structure instance field abbreviation, expecting identifier</span>\n</code></pre></div>\n<p>Ugh, right, that's invalid syntax, we have to wrap it up.</p>\n<p>Let's try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)}</span>\n<span class=\"c1\">-- typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"c1\">--  Singleton ℕ ?m.57</span>\n</code></pre></div>\n<p>Nope! But at this point, haven't I given it enough information? I clearly want a singleton of a natural; why is this not enough for a conservative estimate that I want a set of naturals?</p>\n<p>I'd like to both understand the technical reason why it can't do that <em>and</em> the design reason (<em>shouldn't</em> it be able to infer this?)</p>\n<p>For the record, these <em>do</em> work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">--works</span>\n</code></pre></div>\n<p>But for more complex types, it requires repeating the type fully.</p>\n<p>For a slightly more realistic example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{{</span><span class=\"n\">a</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">foo</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>Why can't I just write </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">foo</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>here? Why is it hard or bad to infer that I just want a Set of the thing I'm passing?</p>\n<p>Thanks!</p>",
        "id": 530234773,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753224229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> firstly in <code>def</code> it's always better to specify the type. Please don't ever write <code>:=</code> without the <code>:</code>.</p>\n<p>secondly, if you do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Singleton</span>\n</code></pre></div>\n<p>then you'll see that singleton can be from any type to any type.</p>\n<p>More importantly, you actually need to change types, because both <code>Set X</code> and <code>Finset X</code> use the singleton notation, so just from <code>{(1:Nat)}</code> there is no way for Lean to know if you meant the set, or the finset.</p>",
        "id": 530235309,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753224441
    },
    {
        "content": "<p>Ah right, so we have many Set-like containers so it has to be explicit. Makes sense.</p>",
        "id": 530235581,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753224622
    },
    {
        "content": "<p>and I guess for my last example, this would've worked</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{{</span><span class=\"n\">a</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pair</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"n\">foo</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so then at least I don't have to repeat the type.</p>\n<p>(I hear you re: <code>def</code>, I just used that for the demo, iirc the actual problems I was running into were deeper in proofs)</p>",
        "id": 530235677,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753224684
    },
    {
        "content": "<p>The other problem here is that <code>{}</code> is also notation for structure constructors like <code>{ fst := _, snd := _ }</code></p>",
        "id": 530237067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753225495
    }
]