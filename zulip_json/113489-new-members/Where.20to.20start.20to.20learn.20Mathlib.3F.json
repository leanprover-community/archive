[
    {
        "content": "<p>I've been programming and proving in Lean for a while and have a decent amount of experience with the tactics, typeclasses, conventions in the standard library, metaprogramming.</p>\n<p>However, I'm having a hard time understanding the algebraic hierarchy as well as the encoding of a couple theorems. For example from following mathematics in Lean, I'm trying to prove the first isomorphism theorem from a paper proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> our two groups G and H -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">???</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Looking at <code>QuotientGroup.quotientKerEquivRange</code> which is the theorem I'm trying to prove that already exists, which I'm guessing isn't encoded as an \"is isomorphic\" relation, but instead just provides the isomorphism.</p>\n<p>This would be okay but I'm trying to navigate how this is all defined in the algebraic hierachy. When I press Ctrl-space inside the structure there are a couple fields. The <code>toFun</code> part is a function from <code>G ⧸ φ.ker → φ.range</code> where <code>G ⧸ φ.ker : Type</code> and <code>φ.range : Type</code>. But I don't know how to actually construct the canonical isomorphism (the one that takes <code>gK ↦ φ(g)</code>), since these are opaque types which I can't extract the representative of the coset in the domain. I'm assuming most of this is hidden behind typeclasses.</p>\n<p>Above is sort of my thought process, but my question is that since Mathlib is such a large library (it's software afterall) and that a lot of technical choices are made when encoding definitions in such a way that they're nice to use, <strong>where could you begin to comprehend it all?</strong></p>\n<p>I am an undergraduate at mathematics but self study ahead, if that matters. I was also thinking about trying to reverse engineer some of the definitions, and recreate my own subset of Mathlib (thinking from a software engineer perspective). How about it?</p>",
        "id": 567892760,
        "sender_full_name": "l1mey",
        "timestamp": 1768357582
    },
    {
        "content": "<p>I am not good at providing general guides, so just commenting on small pieces...</p>\n<blockquote>\n<p>since these are opaque types which I can't extract the representative of the coset in the domain</p>\n</blockquote>\n<p>Groups and quotient groups are not so opaque and you can unfold a lot of things to see how it works under the hood. It is not a recommended code style for serious contribution, but for helping your own understanding it is fine to do. For example, the quotient group, if you unfold the definition a few times, is eventually the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a> type, from which you <em>can</em> get a representative by calling <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.out#doc\">docs#Quotient.out</a>, which can lead to valid proof and construction. Though, constructions using Quotient.out is very cumbersome, so what one usually does is to use various recursion/induction helper to effectively get a representative elegantly. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.quotientKerEquivRange#doc\">docs#QuotientGroup.quotientKerEquivRange</a> uses (again after unfolding definitions a few times) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.lift#doc\">docs#QuotientGroup.lift</a>, which is ultimately is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.liftOn#doc\">docs#Quotient.liftOn</a>. By reading its signature, it basically says you give it a function that accepts representatives, and it will return you a lifted function that accepts quotient elements.</p>",
        "id": 567894438,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1768358887
    },
    {
        "content": "<p>To answer some of your other questions:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> has some pretty good guides and exercises on particular topics in Mathlib. It is much less foundational than <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> and is more applied.</li>\n<li>You can use loogle or a semantic search engine (e.g. leansearch, lean explore, lean dex) to search through theorems quickly. This will indirectly teach you the algebraic hierarchy as you can see what typeclasses are needed for certain theorems.</li>\n<li>There's this library note: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/HierarchyDesign.html#The-algebraic-hierarchy\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/HierarchyDesign.html#The-algebraic-hierarchy</a>, but it is more of a guide on how to extend the hierarchy than how to navigate it.</li>\n</ul>\n<p>I think most mathlib contributors learned the hierarchy as a result of working with mathlib, rather than because there was explicit documentation on the algebraic hierarchy.</p>",
        "id": 567895813,
        "sender_full_name": "Niels Voss",
        "timestamp": 1768360058
    },
    {
        "content": "<p>A quotient group isn't cosets, it's an opaque type satisfying the universal property of quotients. To define a function from a quotient you use a function called <code>lift</code>, feeding it a function from the big type and supplying the universal property (that it's constant on equivalence classes).</p>",
        "id": 567916890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1768375795
    },
    {
        "content": "<p>Let's do it step by step and let's concentrate on the <code>toFun</code> field, that is the bare function (then it remains to prove that it respects multiplication and to provide the inverse, or to prove injectivity and surjectivity), so let's define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am going to write several times the same line, adding missing pieces at each time. Usually it's not a good idea to write definition in tactic mode, but at the beginning you can do it to have a working infoview, and go back to term mode at the end. So here we are</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Of course we want to take <code>(x : G ⧸ φ.ker)</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now you see that the goal is <code>⊢ ↥φ.range</code>: we need to specify the image of <code>x</code>. The point is that <code>φ.range</code> is of type <code>φ.range : Subgroup H</code>: it is a subgroup of <code>H</code>, so it's term are pairs given by a term of <code>H</code> and a proof that this term belongs to <code>φ.range</code>. We can see this as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the first <code>sorry</code> the goal is <code>H</code>: we need to specify the image of <code>x</code>. Mathematically the point is that we descend <code>φ</code> to the quotient, since obviously it respects the equivalence relation. In Lean we always say \"lift\" instead of \"descend\", and for example one can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.liftOn%27#doc\">docs#Quotient.liftOn'</a> (it gives a better version of <code>h</code> than <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.liftOn#doc\">docs#Quotient.liftOn</a>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">liftOn</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now the <code>sorry</code> is the fact that <code>φ</code> respects the equivalence relation, and this is not very difficult.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">liftOn'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">leftRel_apply</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"bp\">.</span><span class=\"n\">inv_mem</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_inv_rev</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inv_inv</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"bp\">.</span><span class=\"n\">mem_comm</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">MonoidHom</span><span class=\"bp\">.</span><span class=\"n\">div_mem_ker_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">div_eq_mul_inv</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Can you see how to finish? Of course I am doing things very much by hand, and mathlib approach is <em>much</em> more granular, so you don't see any of this, but the idea is more or less the same.</p>",
        "id": 567935183,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1768382562
    },
    {
        "content": "<p>I appreciate the responses, over today I finished a proof based on some of the ideas that have been said. I know Mathlib does it differently (especially using <code>by</code> to construct data, which I've never done before but it made it easy to follow), but I've tried to follow my paper proof as much as possible. Below is an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">style</span><span class=\"bp\">.</span><span class=\"n\">emptyLine</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> our two groups G and H -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> we know φ is a homomorphism -/</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eq_iff_mem_ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> φ g₁ = φ g₂ -/</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inv_mul_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_inv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_mul</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidHom</span><span class=\"bp\">.</span><span class=\"n\">mem_ker</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Canonical Homomorphism π : G ⧸ ker φ → φ(G). -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> g₁ ≈ g₂ → φ g₁ = φ g₂ -/</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> we have g₁K = g₂K if and only if g₁⁻¹ g₂ ∈ K -/</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hrel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">leftRel_apply</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_iff_mem_ker</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_mk</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonoidHom</span><span class=\"bp\">.</span><span class=\"n\">mem_range</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">π_hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">π</span>\n<span class=\"w\">  </span><span class=\"n\">map_one'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">π</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">mk_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_mk</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> φ 1 = 1     (φ is a homomorphism) -/</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MonoidHom</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n\n<span class=\"w\">  </span><span class=\"n\">map_mul'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> π (g₁ * g₂) = π g₁ * π g₂ -/</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">π</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MulMemClass</span><span class=\"bp\">.</span><span class=\"n\">mk_mul_mk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">mk_mul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_mk</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> φ (g₁ * g₂) = φ g₁ * φ g₂     (φ is a homomorphism) -/</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MonoidHom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"n\">g₂</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">π_bijective</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> π (g₁ * g₂) = π g₁ * π g₂ -/</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">g₁</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">g₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">π</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_mk</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">injEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_iff_mem_ker</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span><span class=\"cm\"> we know that y ∈ φ.range, hence ∃g, φ g = y -/</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">π</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">exists_mk</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">g</span>\n\n<span class=\"w\">    </span><span class=\"n\">ext</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FIT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"w\"> </span><span class=\"n\">π_hom</span><span class=\"w\"> </span><span class=\"n\">π_bijective</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: 'FIT' depends on axioms: [propext, Classical.choice, Quot.sound]</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">FIT</span>\n</code></pre></div>\n<p>I know the proof is quite ugly, but I hope it's workable enough to be read. I have a couple questions:</p>\n<ol>\n<li>\n<p>What is the difference between <code>Quotient.mk</code> and <code>QuotientGroup.mk</code> ? Sometimes I see either <code>⟦g₁⟧ : Quotient (QuotientGroup.leftRel φ.ker)</code> or <code>↑g : G ⧸ φ.ker</code> (mentioned in the same order) used in the argument of a <code>Quotient.lift</code> where a <code>G ⧸ φ.ker</code> would be expected.</p>\n</li>\n<li>\n<p>When constructing the homomorphism <code>G ⧸ φ.ker →* φ.range</code>, you provide the function and a proof that the function preserves the one and multiplication. Is there a reason for the proof of <code>map_one</code> ? I thought you could prove <code>map_one</code> straight from the <code>map_mul</code> (the defn. of a homomorphism) hypothesis?</p>\n</li>\n<li>\n<p>What is the best way to avoid <code>induction x using Quotient.inductionOn</code> to extract out a representative <code>g : G</code> from an element <code>x : G ⧸ φ.ker</code> ?</p>\n</li>\n</ol>\n<p>A lot of my time was spent searching around for definitions and theorems, and guessing their names. Could anyone also be able to provide some advice as well? I appreciate it.</p>",
        "id": 568133625,
        "sender_full_name": "l1mey",
        "timestamp": 1768459001
    },
    {
        "content": "<p>In (1) it might be a definitional equality? I think I remember seeing a couple notes in the documentation about some things being definitional equalities. If someone could let me know in the QuotientGroup API what parts are designed around a definitional equality that would be good.</p>",
        "id": 568133886,
        "sender_full_name": "l1mey",
        "timestamp": 1768459209
    }
]