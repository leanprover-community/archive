[
    {
        "content": "<p>Hi all,<br>\ni defined this Option like Inductive <strong>I</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ns</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\">   </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">None</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\">      </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"hello\"</span>\n</code></pre></div>\n<p>It holds a value of <strong>α</strong> if the second type parameter <strong>n</strong> is included in the set <strong>ns</strong>.<br>\nobviously there is an equivalence of  types <strong>I ns n</strong> and <strong>I ns' n</strong> where <strong>ns</strong> and <strong>ns'</strong> are equal.<br>\nthe function <strong>castI</strong> transforms from one to another.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">castI</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ns'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">None</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">   </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">None</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">castI</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"c1\">-- shoud be casted / coerced automatically</span>\n</code></pre></div>\n<p>Is there an elegant way to hide this casting step? I thought of a coe instance but failed to define it.<br>\nthanks in advance :)</p>",
        "id": 455904464,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1722596380
    },
    {
        "content": "<p>Note that you don't need a separate lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"hello\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">v1</span>\n</code></pre></div>",
        "id": 455934393,
        "sender_full_name": "Number Eighteen",
        "timestamp": 1722605821
    },
    {
        "content": "<p>Generally no, and indeed much of the difficulty of programming with dependent types is due to the poor behavior of casting and <code>HEq</code> at a mathemtical-foundational level. We tend to avoid dealing with type equality in general as a result, instead preferring just such explicit type-specific casting functions.</p>",
        "id": 456049991,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722635831
    },
    {
        "content": "<p>Playing around with the code in the Lean playground, I'm guessing the problem you're running into with <code>Coe</code> instances is errors of the form <code>cannot find synthesization order for instance ...</code>? That means that there's no reasonable way for the compiler to infer one of the variables in the instance from the context; in this case, there's no good way to guess what <code>ns</code> should be given only that the output is <code>I ns' n α</code>, since the set of things that are propositionally equal to <code>ns</code> could be huge.</p>",
        "id": 456050377,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722635963
    },
    {
        "content": "<p>In certain cases, the compiler can make use of <em>definitional</em> equality to make this go through for you, but that requires that <code>ns</code> be <em>definitionally</em> equal to <code>ns'</code> -- usually meaning that it's syntactically the same after unfolding reducible definitions -- and not merely that there exists a proof that they're equal (which is propositional equality and a much broader class).</p>",
        "id": 456050709,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722636114
    },
    {
        "content": "<p>thanks for your answers, explicit casting seems reasonable</p>\n<p>i was already wondering why lean is able to make sense of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">Some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"hello\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">v3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v1</span>\n</code></pre></div>\n<p>but it seems like lean unfolds the union directly.<br>\ni tried to define coe like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ns'</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">ns'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">castI</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n</code></pre></div>\n<p>with a \"instance does not provide concrete values for (semi-)out-params\" error that i dont quite understand.</p>",
        "id": 456454533,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1722839807
    }
]