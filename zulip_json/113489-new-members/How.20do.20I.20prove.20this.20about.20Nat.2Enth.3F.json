[
    {
        "content": "<p>The following proposition is intuitively obvious.  But how do I prove it?  I haven't been able to get any ideas from the existing results about Nat.nth in mathlib.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 522697605,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749179905
    },
    {
        "content": "<p>First, you shouldn't use range (the Set) as Nat -&gt; Prop, that is piercing through a defeq that isn't meant to be used that way.</p>",
        "id": 522707257,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1749188153
    },
    {
        "content": "<p>Looks like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.nth_eq_sInf#doc\">docs#Nat.nth_eq_sInf</a> could help</p>",
        "id": 522707479,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1749188349
    },
    {
        "content": "<p>Thanks for the pointer!  Nat.nth has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>What do you suggest I use instead of <code>range φ</code> for its first argument?</p>",
        "id": 522816072,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749229133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522816072\">said</a>:</p>\n<blockquote>\n<p>Thanks for the pointer!  Nat.nth has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>What do you suggest I use instead of <code>range φ</code> for its first argument?</p>\n</blockquote>\n<p><code>fun x =&gt; x ∈ range φ</code></p>",
        "id": 522817523,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749229643
    },
    {
        "content": "<p>Isn’t that just ugly?</p>",
        "id": 522817806,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749229768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522817806\">said</a>:</p>\n<blockquote>\n<p>Isn’t that just ugly?</p>\n</blockquote>\n<p>you can also use <code>(· ∈ range φ)</code></p>",
        "id": 522818648,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749230139
    },
    {
        "content": "<p>I think it has been a mistake for Lean to distinguish between sets and predicates. It’s a distinction without substance and just introduces unnecessary work and complexity.</p>",
        "id": 522822111,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749231501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522822111\">said</a>:</p>\n<blockquote>\n<p>just introduces unnecessary work and complexity.</p>\n</blockquote>\n<p>i'm not so sure about that... i think that since most mathematicians think about sets and not predicates, having something which represents that seems like the logical thing to do. Once you have sets, it also makes sense to try to consistently distinguish between predicates and sets because a lot of notation which makes sense for one does not at all make sense for the other. I would hate to see something like <code>x ∈ (fun y =&gt; Even y)</code> in lean, nobody writes math like that.</p>",
        "id": 522823560,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749232187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522822111\">said</a>:</p>\n<blockquote>\n<p>I think it has been a mistake for Lean to distinguish between sets and predicates. It’s a distinction without substance and just introduces unnecessary work and complexity.</p>\n</blockquote>\n<p>No, if anything we should make the distinction <em>stronger</em> (e.g., by making <code>Set</code> irreducible or a one-field structure) in order to prevent defeq abuse. The only way to make the distinction any weaker would be to make <code>Set</code> an <code>abbrev</code>, which would be a mess (e.g., all instances would be visible to both).</p>",
        "id": 522826528,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1749233436
    },
    {
        "content": "<p>If you make no distinction between sets and predicates, then what happens is that the correct thing for Lean to do would be to always simplify <code>x ∈ s</code> to <code>s x</code>, or else always pretty print <code>p x</code> as <code>x ∈ p</code>. Having the separate types ensures that one can stick with the language of sets.</p>",
        "id": 522829206,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749234729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20prove.20this.20about.20Nat.2Enth.3F/near/522822111\">said</a>:</p>\n<blockquote>\n<p>I think it has been a mistake for Lean to distinguish between sets and predicates. It’s a distinction without substance and just introduces unnecessary work and complexity.</p>\n</blockquote>\n<p>when was the last time you took the union of two predicates?</p>",
        "id": 522829731,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749234933
    },
    {
        "content": "<p>I've taken the sup of predicates before. It's not that odd of a thing to do.</p>",
        "id": 522830029,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749235074
    },
    {
        "content": "<p>Here's a proof of the original statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth_comp_of_strictMono</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n<span class=\"w\">  </span><span class=\"n\">exfalso</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">infinite_range_of_injective</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 522830808,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749235440
    },
    {
        "content": "<p>and here's the proof golfed to oblivion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_range</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth_comp_of_strictMono</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">infinite_range_of_injective</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">exists_apply_eq_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth_true</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StrictMono</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">nth_comp_of_strictMono</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">infinite_range_of_injective</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 522832000,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749236002
    },
    {
        "content": "<p>Thanks for providing me with solutions!  It saves me a lot of time on trial and error.</p>\n<p>But on the subject of sets vs predicates, I beg to differ.  In my ideal world, Lean should have just predicates and no sets.  Set operations like ∪, ∩, ᶜ , ⊂, etc can be defined directly on predicates and there is no need for ∈ .  Nor is there any need for the set comprehension notation, though the notation for enumerated finite sets would still be useful.  Perhaps this is unfamiliar to most mathematicians.  But the notion that propositions can be regarded as types and proofs as terms is also unfamiliar to most mathematicians.  When one learns to formalize math in a formal system, one has to learn to adapt one's conceptual framework.</p>\n<p>Also observe that \"sets\" in Lean are actually quite different from sets in informal mathematics.  For example, I believe most mathematicians intuitively think that ℕ is literally a subset of ℤ, which is literally a subset of ℚ, which is literally a subset of ℝ, and so on.  But that is definitely not the case in Lean.  Similarly, <code>Fin n</code> is not a subset of <code>Fin (n + 1)</code> or ℕ, which I suspect many mathematicians will also find peculiar.</p>",
        "id": 522848837,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749245342
    },
    {
        "content": "<p>But <code>s : Set X</code> can be converted to subtype implicitly. I think it will cause a big chaos if <code>P : X -&gt; Prop</code> could be also converted to the subtype <code>{ x : X // P x }</code> implicitly.</p>",
        "id": 522874767,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749274901
    },
    {
        "content": "<p>True.  But if there had never been <code>Set</code> in Lean, I'm sure such implicit conversion would never have existed.</p>\n<p>Fundamentally, the formal system implemented by Lean is a type theory, not a set theory.  It seems to me better to accept and live with that fact than try to \"simulate\" set theory in a type theory.  But, of course, it is too late to change anything now.</p>",
        "id": 522877659,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749278773
    },
    {
        "content": "<p>We want to be more friendly to mathematicians, not less friendly. In particular we want to hide type theory as much as possible and let mathematicians think they're dealing with sets, as they are used to. One of the reasons mathlib has been so successful is that it has not prioritised stressing its type-theoretic foundations and has instead been very good at accommodating mathematicians with no training in the foundations of their subject (aka \"most mathematicians\").</p>",
        "id": 522880602,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749283026
    },
    {
        "content": "<p>I'm not a mathematician, so I don't really know what mathematicians prefer.  But it seems to me that once anyone digs just a little deeper into Lean, one quickly realizes that Lean's formal system not only is not a set theory but does not even support real subtypes.  (If Lean has real subtypes, <code>x : ℚ</code> should imply <code>x : ℝ</code> and <code>k : Fin n</code> should imply <code>k : Fin (n + 1)</code> and <code>k : ℕ</code>.)</p>",
        "id": 522885098,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1749289263
    },
    {
        "content": "<p>Otoh, in almost every setup of mathematics in set theory, the inclusions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">Z</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">Q</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">R</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\N \\subseteq \\Z \\subseteq \\mathbb{Q} \\subseteq \\R \\subseteq \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> are also white lies.</p>",
        "id": 522885352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749289584
    },
    {
        "content": "<p>They are lies that, to quote Kevin above, \"most mathematicians\" (by my estimation, the vast majority of them)  don't consider to be lies - most would probably consider the \"lies\" assertion to be, at best, splitting hairs, and at worst, utter nonsense.</p>\n<p>Formalization is difficult enough without having to re-learn everything from scratch - at least for those of us who are way past their initial training years. If Lean and Mathlib lie to us just so that we can understand the theorem statements when we need them, and let us write new theorems almost as we would write them on paper, then the lie is, IMHO, a good one, even though it will occasionally come back and make trouble for us.</p>",
        "id": 522886890,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749291770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"726077\">@Philippe Duchon</span> I completely agree! And even though Lean doesn't support real subtypes, I think the coercion system gets you pretty far in terms of \"write new theorems almost as we would write them on paper\"...</p>",
        "id": 522898978,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1749306506
    }
]