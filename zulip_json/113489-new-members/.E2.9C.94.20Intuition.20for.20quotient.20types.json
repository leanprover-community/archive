[
    {
        "content": "<p>I might be asking for too much with too little prerequisite work here but I'm curious.</p>\n<p>Is there any TLDR on quotient types that doesn't presuppose much mathematical knowledge? I did read through <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2022/Part_B/threekindsoftypes.html#quotient-types\">this explainer</a> but it seems a bit too high-level and lacking. I've also worked through <a href=\"https://github.com/b-mehta/formalising-mathematics-notes/blob/main/FormalisingMathematics2025/Section07subgroupsAndHomomorphisms/Sheet3.lean\">these examples on quotient groups</a>. I don't fully grasp the idea yet (more below) but I suspect this is \"downstream\" from the Lean concept of quotient types and doesn't directly help me grasp them (and if I believe Kevin's notes, it seems like quotient types are kind of an implementation detail anyway and maybe I shouldn't care?)</p>\n<p>Now let me summarize my understanding:</p>\n<ul>\n<li>\n<p><strong>Quotient groups:</strong> This is a mathematical concept, not a Lean concept. Quotient groups are kind of like \"dividing\" a group by a subgroup. It doesn't always work. When it <em>does</em> work, it's kind of like mapping many elements in the input to one element in the output. Kind of like mod operation for integers. So we're kind of \"erasing\" the distinction encapsulated by the thing we're dividing by. I realize my intuition is a bit flaky there.</p>\n</li>\n<li>\n<p><strong>Quotient groups in Lean vs Math:</strong> In normal math, quotient groups are defined as groups whose elements themselves are subsets of the group being divided, chosen in a particular way (take the subgroup we're diving by — that'll be the first element of the quotient — then get each next element of the quotient — each of them is also a set — by multiplying the original set by each element of the big group one by one). However, if I understand correctly, this is just <em>one possible way</em> to define quotient groups, and Lean chooses some different way which is intuitively more like \"redefining\" equality to be \"less picky\" so that it considers precisely the same elements equal as the ones that would fall into the sets explained in the previous definitions.</p>\n</li>\n<li>\n<p><strong>Quotient types in Lean:</strong> This is the more fundamental mechanism in Lean. It's being used for this \"redefining equality\" business and somehow makes it more convenient. It isn't needed in some fundamental way (presumably just inductive types would do) but somehow it's nicer as a built-in (maybe it makes equality work more powerfully and implicitly without doing things manually somehow)? The <code>lift</code> thing is a part of this mechanism somehow. From what I gather, <code>lift</code> is a built-in thing that lets us turn a function that operates on the whole into a function that operates on a part. Somehow this maybe also allows nice <code>rfl</code> proofs for things that wouldn't obviously \"match up\" just by reading.</p>\n</li>\n</ul>\n<p>My question is basically how far off am I about these things, and if there's anything in particular I'm misstating (or stating correctly).</p>\n<p>Thanks!</p>",
        "id": 508330671,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1743007303
    },
    {
        "content": "<p>Quotient groups in math and in Lean are a special case of the quotient construction in sets (aka types in type theory parlance)</p>",
        "id": 508331050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007408
    },
    {
        "content": "<p>In math class they teach you how to construct quotient types via equivalence relations, and the setting is not too far off from what lean does, but the implementation is slightly different</p>",
        "id": 508331249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007463
    },
    {
        "content": "<p>you can construct so-called \"set-quotients\" in lean as well, i.e. using the set of all equivalence classes as the definition of a quotient type, but doing this in lean requires set extensionality, which turns out to use quotient types in the end</p>",
        "id": 508331662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007574
    },
    {
        "content": "<p>but you could do things with a slightly different axiomatic basis and avoid axiomatizing quotient types</p>",
        "id": 508331773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007609
    },
    {
        "content": "<p>I would very handwavily say that quotient types are defining an <code>__eq__</code> override, in Python speak. If I have a class of ColorCube which is really (Size, Color), then I can make a quotient of ColorCube that ignores color and only compares Size.</p>",
        "id": 508331807,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743007620
    },
    {
        "content": "<p>I prefer to avoid this \"redefining equality\" explanation though because quotient types in mathematics are quite different from the unquotiented version of the type and equality isn't a thing you can redefine in the traditional set-theory-like conception of types as sets</p>",
        "id": 508332159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007723
    },
    {
        "content": "<p>from the perspective of the computational model it does look a lot like redefining equality though</p>",
        "id": 508332333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007784
    },
    {
        "content": "<p>Fair, I guess \"redefining equality\" is a way to _implement_ quotients.</p>",
        "id": 508332352,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743007791
    },
    {
        "content": "<blockquote>\n<p>It isn't needed in some fundamental way (presumably just inductive types would do)</p>\n</blockquote>\n<p>Actually, no, surprisingly enough. There is a generalization of inductive types called \"higher inductive types\" or \"quotient inductive types\" which allow you to add constructors to an inductive type that are equalities between previous constructors, but lean doesn't support this. You could say that lean supports exactly one HIT which is the axiomatic <code>Quot</code> type</p>",
        "id": 508332701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743007882
    },
    {
        "content": "<p>Just to finish my (partially misleading) explanation:<br>\nBefore for ColorCube, I had (5, Blue) = (5, Blue), but (5, Blue) != (5, Green) and (5, Blue) != (4, Blue).</p>\n<p>But then I define Cube := ColorCube-but-eq-iff-size-eq. And I'll notate the quotient term using <code>[]</code> brackets. Then [(5, Blue)] = [(5, Green)], and we still have that [(5, Blue)] != [(4, Blue)]</p>\n<p>You're not actually allowed to peer inside the square brackets though. So for all intents and purposes <code>[(5, Blue)] = [(5, Green)] = [5]</code>.</p>",
        "id": 508332935,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743007942
    },
    {
        "content": "<p>this explanation is similar but it comes with code which might make it more helpful: <a href=\"https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#quotients\">https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#quotients</a></p>",
        "id": 508333046,
        "sender_full_name": "llllvvuu",
        "timestamp": 1743007971
    },
    {
        "content": "<p>There's a some kind of tldr for people who like arrows: <a href=\"https://ncatlab.org/nlab/show/quotient+object\">https://ncatlab.org/nlab/show/quotient+object</a></p>",
        "id": 508333227,
        "sender_full_name": "suhr",
        "timestamp": 1743008021
    },
    {
        "content": "<blockquote>\n<p><code>lift</code> is a built-in thing that lets us turn a function that operates on the whole into a function that operates on a part</p>\n</blockquote>\n<p>Yes, with the contract that when you call <code>lift</code>, you have to promise that when you operate on the part you care about, ignoring the rest of the whole is done consistently.</p>",
        "id": 508333491,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1743008086
    },
    {
        "content": "<p>The Xena blog also has a post about quotients that might be helpful: <a href=\"https://xenaproject.wordpress.com/2025/02/09/what-is-a-quotient/\">https://xenaproject.wordpress.com/2025/02/09/what-is-a-quotient/</a></p>",
        "id": 508333834,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1743008179
    },
    {
        "content": "<p>Damn. I've read this before but only understood the part down to the quotients heading. Now I understand it all the way down to the Lean part. I'll give the Lean part a few more reads tomorrow but this link was massively helpful. Thanks!</p>",
        "id": 508341641,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1743010434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 508341718,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743010450
    },
    {
        "content": "<p>One thing that somehow confuses me regarding quotients is that the Xena blog post mentions equivalence relations (and this seems consistent with my intuition), but (and this is something I've read, though I'm not sure where; possibly Theorem Proving in Lean?) <code>Quot.mk</code> doesn't seem to care about the \"equivalence\" part, it will take any binary relation.</p>\n<p>I suppose there are good reasons for this, but it's somehow confusing.</p>",
        "id": 508492185,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1743075643
    },
    {
        "content": "<p>you can look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient#doc\">docs#Quotient</a> , which <em>does</em> require an equivalence relation (i.e. take one as a parameter)...</p>",
        "id": 508493766,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743076091
    },
    {
        "content": "<p>here's how i reconcile it:<br>\na quotient by some relation <code>r</code> (not necessarily equivalence) is made by saying \"any two elements which are related are now equal, but if this doesn't cause two elements to become equal, they aren't\". Then, if we have <code>r a b</code> and <code>r b c</code>, then under the quotient we have <code>a = b mod r</code> and <code>b = c mod r</code>. since equality is transitive, we <em>still</em> get that <code>a = c mod r</code>, even if <code>r</code> isn't transitive itself... similarly, since equality is reflexive, we always get <code>a = a mod r</code>, even when <code>r</code> isn't reflexive, and similar for symmetry. In other words, taking the quotient by some relation (which isn't necessarily an equivalence) is the same as taking the quotient by the equivalence relation that it \"generates\". Rephrasing again, it's the quotient by the \"smallest\" equivalence relation that <em>is implied by</em> or <em>contains</em> <code>r</code></p>",
        "id": 508495550,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743076591
    },
    {
        "content": "<p>this notion of \"generating\" an equivalence relation can be made concrete, with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Relation.EqvGen#doc\">docs#Relation.EqvGen</a></p>",
        "id": 508496018,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743076721
    },
    {
        "content": "<p>That would \"just\" be the transitive and reflexive closure of the original relation, right?</p>\n<p>Actually, my interrogation is more from the design point of view. When designing the library, why isn't the definition given only in the case where <code>r</code> is guaranteed to be an equivalence relation? (In informal mathematics, this would clearly be more natural)</p>",
        "id": 508507946,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1743080039
    },
    {
        "content": "<p>no, it's the transitive, reflexive <em>and symmetric</em> closure (i.e., if <code>r a b</code>, then <code>[a] = [b]</code> so <code>[b] = [a]</code>, even though it's possible that <code>¬ r b a</code>). As a simple example take <code>r : ℕ → ℕ → Prop</code> to be the inductively defined relation with the single constructor <code>(n : ℕ) → r n (n + 1)</code> (i.e., each natural is related only to its successor, not it's predecessor). Then <code>Quot r</code> consists of a single element (i.e., everything gets sent to the same thing, which means everything is equivalent under the generated equivalence relation), but the transitive and reflexive closure of <code>r</code> is <code>≤</code>.</p>",
        "id": 508509650,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1743080476
    },
    {
        "content": "<p>(edit: <span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> pointed this out, but i wrote it already) it's the transitive reflexive <em>symmetric</em> closure of the original relation.</p>\n<p>The reason why it's not requiring <code>r</code> to be an equivalence relation is (i'm guessing) twofold:</p>\n<ul>\n<li>it's not necessary: the <em>construction</em> also works when <code>r</code> <em>isn't</em> an equivalence, you just don't get that equality in the quotient implies that the \"unquotiented\" elements are related</li>\n<li>it's impractical: the definition of <code>Quot</code> lies deep in the bootstrapping/initializing files of lean, and defining the notion of equivalence relation at that point is an unnecessary load on the process of initializing.</li>\n</ul>",
        "id": 508509745,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743080505
    },
    {
        "content": "<p>some more about that second point: the definition of quotients is so ingrained in Lean that <code>Quot</code> doesn't even get directly created in the <code>Init.Prelude</code> file; all that's there is the <code>init_quot</code>-command and some code to add docstrings to the related definitions.</p>",
        "id": 508513780,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743080867
    },
    {
        "content": "<p>compare that to the definitions of <code>False</code>, <code>Empty</code> and <code>Eq</code>, which <em>do</em> happen explicitly in <code>prelude</code></p>",
        "id": 508514106,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1743080955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intuition.20for.20quotient.20types/near/508513780\">said</a>:</p>\n<blockquote>\n<p>some more about that second point: the definition of quotients is so ingrained in Lean that <code>Quot</code> doesn't even get directly created in the <code>Init.Prelude</code> file; all that's there is the <code>init_quot</code>-command and some code to add docstrings to the related definitions.</p>\n</blockquote>\n<p>Yes, the actual code that produces the types of the quotient axioms is meticulously hand-crafted inside the kernel, which makes every single application very painful because it's like writing <code>pp.all</code> code manually (it's actually slightly worse than that because the expressions are deeply embedded with <code>mk_app</code> things instead of getting such nice syntax as adjacency)</p>",
        "id": 508623943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1743111978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intuition.20for.20quotient.20types/near/508509745\">said</a>:</p>\n<blockquote>\n<p>The reason why it's not requiring <code>r</code> to be an equivalence relation is (i'm guessing) twofold:</p>\n<ul>\n<li>it's not necessary: the <em>construction</em> also works when <code>r</code> <em>isn't</em> an equivalence, you just don't get that equality in the quotient implies that the \"unquotiented\" elements are related</li>\n<li>it's impractical: the definition of <code>Quot</code> lies deep in the bootstrapping/initializing files of lean, and defining the notion of equivalence relation at that point is an unnecessary load on the process of initializing.</li>\n</ul>\n</blockquote>\n<p>Thanks, that makes  a lot of sense.</p>\n<p>(And yes, I forgot symmetry, thanks for pointing that out)</p>",
        "id": 508791135,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1743177700
    }
]