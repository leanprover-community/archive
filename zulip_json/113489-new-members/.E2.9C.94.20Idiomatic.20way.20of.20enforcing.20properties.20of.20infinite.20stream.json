[
    {
        "content": "<p>I'm trying to come up with a representation for an infinite stream of states, where neighboring states have some properties that must be maintained. Because this is infinite, list might not be a good fit. Currently I can come up with the following, where <code>R</code> is the property that neighboring states must meet, but this would require me writing my own theorems/functions such as taking \"n\" elements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">StreamGen</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">StreamGen</span> <span class=\"n\">s'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">StreamGen</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>I know that we have <code>Stream'</code> in <code>Mathlib.Data.Stream.Defs</code> with various useful theorems, is there an idiomatic way I could use <code>Stream'</code> instead of defining my own inductive type? <code>Stream'</code> is just a function that maps index to the actual element: <code>def Stream' (α : Type u) := ℕ → α</code></p>",
        "id": 400654780,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699327584
    },
    {
        "content": "<p>How about the subtype of things zipped with its own tail?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Stream'</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">s.zip</span> <span class=\"n\">s.tail</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">All</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 400657208,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699328843
    },
    {
        "content": "<p>thanks for the suggestion, i will give it a shot!</p>",
        "id": 400673299,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699338937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"649880\">Z. Wu</span> has marked this topic as resolved.</p>",
        "id": 400673307,
        "sender_full_name": "Notification Bot",
        "timestamp": 1699338943
    },
    {
        "content": "<p>I think it works well, and i think subtype is easy to work with compared to the inductive for some reasons</p>",
        "id": 400726283,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699358826
    }
]