[
    {
        "content": "<p>Hi, everyone.  When proving the existence of a simple R-module for nontrivial R, I found that <code>letI</code> correctly infers the R-module structure of R/I, but <code>haveI</code> does not. Why the difference?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Exists_SimpleModule</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hI</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">exists_maximal</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"n\">I</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isSimpleModule_iff_isCoatom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"c1\">-- If 'haveI' is used before, it fails .</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">isMaximal_def</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hI</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Error message: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">rewrite'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">expression</span>\n<span class=\"w\">  </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n\n<span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"n\">hI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">IsMaximal</span>\n<span class=\"n\">this</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">IsSimpleModule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 505425411,
        "sender_full_name": "Han Han",
        "timestamp": 1741873473
    },
    {
        "content": "<p><code>have</code>/<code>haveI</code> is for propositions, <code>let</code>/<code>letI</code> for all the rest. In your example <code>Module R ...</code> contains data, you you should use <code>let</code>.</p>",
        "id": 505425983,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741873606
    },
    {
        "content": "<p>The difference is that <code>have : n = 0</code> just remembers that <code>n</code> is a natural number, not which natural numbers (and it indeed it shouldn't be used in the case)</p>",
        "id": 505426201,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741873669
    },
    {
        "content": "<p>Thanks, now I understand the difference. Very clear explanation!</p>",
        "id": 505427902,
        "sender_full_name": "Han Han",
        "timestamp": 1741874076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"887009\">Han Han</span> has marked this topic as resolved.</p>",
        "id": 505428053,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741874122
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20.60letI.60.20vs.2E.20.60haveI.60/near/505426201\">said</a>:</p>\n<blockquote>\n<p>The difference is that <code>have : n = 0</code> just remembers that <code>n</code> is a natural number, not which natural numbers (and it indeed it shouldn't be used in the case)</p>\n</blockquote>\n<p>Did you mean <code>have n := 0</code>? Otherwise I'm confused :)</p>",
        "id": 505446169,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741877976
    },
    {
        "content": "<p>ops yes</p>",
        "id": 505446240,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741877994
    },
    {
        "content": "<p>Inside of proofs, there's no need for <code>letI</code> and <code>haveI</code>, <code>let</code> and <code>have</code> should be sufficient (the purpose of the <code>I</code> variants is <em>inlining</em>, meaning the substitute the values for the variables at the end; this is useful for adding instances in theorem types). We had a completely different <code>letI</code>/<code>haveI</code> in Lean 3, which were for <em>instances</em>, but they are different tactics now.</p>\n<p><strong>However:</strong> I do see that <code>let</code> doesn't let you write <code>let := val</code>. I've put it on my list of things to look into fixing. Currently you would have to write <code>let _inst : Module R (R ⧸ I) := Submodule.Quotient.module I</code>, with a name that goes unused.</p>",
        "id": 505483484,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741886896
    },
    {
        "content": "<p>Looking forward to that changing :)</p>",
        "id": 505494592,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741889840
    },
    {
        "content": "<p>Oh maybe I don't understand the new way to use <code>letI</code>. Here's something from the FLT repo:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">rightAlgebra</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- Let `S` be an `R`-algebra and `ψ` a ring homomorphism from an `R`-algebra `A` to an</span>\n<span class=\"sd\">`S`-algebra `B` compatible with the algebra map `R → S`. If, in addition, `B` is</span>\n<span class=\"sd\">an `R`-algebra and the scalar action of `R` on `B` factors through `S`, then</span>\n<span class=\"sd\">`baseChangeRightOfAlgebraMap ψ` is the induced `A`-algebra map `S ⊗[R] A → B`.-/</span>\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SemialgHom</span><span class=\"bp\">.</span><span class=\"n\">baseChangeRightOfAlgebraMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₛₐ</span><span class=\"o\">[</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span>\n<span class=\"w\">  </span><span class=\"n\">AlgHom</span><span class=\"bp\">.</span><span class=\"n\">changeScalars</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">baseChange_of_algebraMap</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RingHom</span><span class=\"bp\">.</span><span class=\"n\">algebraMap_toAlgebra</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SemialgHom</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap_eq_coe</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>It's exhibiting the tension we see where people want to talk about linear or semilinear ring maps and then suddenly want to take tensor products along them despite the <code>Algebra</code> instances not being present. Should one of these <code>letI</code>s be a <code>let</code>?</p>",
        "id": 505648356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741951203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> has marked this topic as unresolved.</p>",
        "id": 505648508,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741951259
    },
    {
        "content": "<p>Since this is a definition so I would say <code>letI</code> is right here.</p>",
        "id": 505648573,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1741951278
    },
    {
        "content": "<p>If you want a rule: after the colon, you should use <code>letI</code> when introducing instances. The rationale is that you don't want to see a <code>let</code> in the type of your definition.</p>\n<p>I've been though wondering whether <code>let</code> after the colon should be zeta reduced in general. That would let us not need to know about <code>letI</code> in most cases. Are there any use cases where we actually want to preserve the <code>let</code> expression?</p>\n<p>I think Eric has a proposal for <code>let</code> binders. Maybe in the future you'll be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SemialgHom</span><span class=\"bp\">.</span><span class=\"n\">baseChangeRightOfAlgebraMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">CommSemiring</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsScalarTower</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₛₐ</span><span class=\"o\">[</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>(Next quarter it's likely that the FRO will have <code>let</code> improvements as one of its foci, so I'm trying to collect issues people have with <code>let</code>/<code>have</code> and friends.)</p>",
        "id": 505660663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741954905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/.60letI.60.20vs.2E.20.60haveI.60/near/505660663\">said</a>:</p>\n<blockquote>\n<p>Are there any use cases where we actually want to preserve the <code>let</code> expression?</p>\n</blockquote>\n<p>Yes, if I have a <code>let</code> after the colon then likely I want to be able to <code>intro</code> it in the proof</p>",
        "id": 505667767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741956962
    },
    {
        "content": "<p>So IMO the letI distinction is worth keeping</p>",
        "id": 505667902,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741956997
    },
    {
        "content": "<p>Can you substantiate that? Do you commonly put <code>let</code> after the colon to be able to <code>intro</code> it? Why do you want to preserve the <code>let</code>?</p>",
        "id": 505669998,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741957560
    },
    {
        "content": "<p>Usually if I found a <code>let</code> convenient for writing the statement, I'm going to find it convenient to use the same <code>let</code> in the proof</p>",
        "id": 505671927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958130
    },
    {
        "content": "<p>Of course you could argue that I should just make an auxiliary definition instead</p>",
        "id": 505672090,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958167
    },
    {
        "content": "<p>I'm going to actually argue, \"can you dig up any examples of this?\"</p>",
        "id": 505672155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958191
    },
    {
        "content": "<p>Of the former implying the latter, or of even the former?</p>",
        "id": 505672239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958222
    },
    {
        "content": "<p>I'm trying to imagine why you'd want a <code>let</code> to appear in the actual theorem statement and what purpose that could serve.</p>",
        "id": 505672293,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958240
    },
    {
        "content": "<p>In my own experience, <code>let</code>s only clutter up the types of theorems and definitions.</p>",
        "id": 505672366,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958262
    },
    {
        "content": "<p>Using <code>let</code> in the statement is a fairly common approach when building \"all fits in a single statement\" datasets for ML use</p>",
        "id": 505672389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958268
    },
    {
        "content": "<p>Indeed for any library of theorems it's undesirable, but for a leaf result it can be handy</p>",
        "id": 505672518,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958294
    },
    {
        "content": "<p>If we had <code>let</code> binders, that would be solved, right?</p>",
        "id": 505672519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958295
    },
    {
        "content": "<p>At least for <code>let</code>s immediately after the <code>:</code></p>",
        "id": 505672630,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958318
    },
    {
        "content": "<p>Assuming the let binders enter the context in the proof, then yes I agree</p>",
        "id": 505672785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741958362
    },
    {
        "content": "<p>Another option in the design space is to have the <code>let</code>s be zeta reduced in just the type when the declaration is added to the environment, not in the type that's seen by the declaration's body. That way, you get to <code>intro</code> your <code>let</code>s, but the <code>let</code>s don't clutter anything up.</p>",
        "id": 505673287,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958494
    },
    {
        "content": "<p><code>let</code> binders would be really nice for definitions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.completeDistribLatticeMinimalAxioms#doc\">docs#Function.Injective.completeDistribLatticeMinimalAxioms</a>, that's painful.</p>",
        "id": 505674652,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958820
    },
    {
        "content": "<p>The doc formatting is particularly painful</p>",
        "id": 505714605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741968879
    }
]