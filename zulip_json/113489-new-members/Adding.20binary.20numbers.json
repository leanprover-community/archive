[
    {
        "content": "<p>Hi all,<br>\nI don't think I'm smart enough to prove this in Lean. Kindly help. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ^^ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xor</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">carry</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"o\">(</span><span class=\"n\">Nat.testBit</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">Nat.testBit</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">||</span> <span class=\"o\">((</span><span class=\"n\">Nat.testBit</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">^^</span> <span class=\"n\">Nat.testBit</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">carry</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pls_halp</span>  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">testBit</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">x.testBit</span> <span class=\"n\">i</span> <span class=\"bp\">^^</span> <span class=\"n\">y.testBit</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">^^</span> <span class=\"n\">carry</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 346653135,
        "sender_full_name": "Ben Nale",
        "timestamp": 1680547740
    },
    {
        "content": "<p><del>Can you re-ask your question (just edit the post above) as a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (click on the link for more info)? Right now I have errors when I post your code into Lean.</del> (thanks!)</p>",
        "id": 346653501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1680547850
    },
    {
        "content": "<p>fixed :). This is using Lean 4</p>",
        "id": 346655199,
        "sender_full_name": "Ben Nale",
        "timestamp": 1680548381
    },
    {
        "content": "<p>I believe the usual math problem solving techniques apply here</p>",
        "id": 346885130,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680620676
    },
    {
        "content": "<p>These being<br>\na) try solving smaller problems first<br>\nb) if in doubt about a theorem on naturals, use induction</p>",
        "id": 346885246,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680620697
    },
    {
        "content": "<p>This was a really nice but really hard exercise. Took about 7 hours total. Seems like we're missing a lot of API for bitwise operations. You're welcome to improve on my code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import Mathlib.Data.Int.Bitwise</p>\n<p>infix:30 \" ^^ \" =&gt; xor</p>\n<p>namespace Bool</p>\n<p>@[simp] lemma not_xor : ∀ x y : Bool, (!(x ^^ y)) = (x == y) := by decide<br>\n@[simp] lemma xor_not_left' : ∀ x y : Bool, (!x ^^ y) = (x == y) := by decide<br>\n@[simp] lemma xor_not_right' : ∀ x y : Bool, (x ^^ !y) = (x == y) := by decide</p>\n<p>@[simp] lemma xor_eq_left : ∀ x y : Bool, ((x ^^ y) == x) = !y := by decide<br>\n@[simp] lemma xor_eq_right : ∀ x y : Bool, ((x ^^ y) == y) = !x := by decide</p>\n<p>@[simp] lemma xor_left_inj : ∀ x y z : Bool, (x ^^ y) = (x ^^ z) ↔ y = z := by decide<br>\n@[simp] lemma xor_right_inj : ∀ x y z : Bool, (x ^^ z) = (y ^^ z) ↔ x = y := by decide</p>\n<p>/-- Whether <code>x + y + z</code> produces a carry. Is true iff at least two of <code>x</code>, <code>y</code>, <code>z</code> are. -/<br>\ndef carry (x y z : Bool) := x &amp;&amp; y || (x ^^ y) &amp;&amp; z</p>\n<p>@[simp] lemma carry_self_self : ∀ x y, carry x x y = x := by decide</p>\n<p>@[simp] lemma carry_false₁ : ∀ y z, carry false y z = (y &amp;&amp; z) := by decide<br>\n@[simp] lemma carry_false₂ : ∀ x z, carry x false z = (x &amp;&amp; z) := by decide<br>\n@[simp] lemma carry_false₃ : ∀ x y, carry x y false = (x &amp;&amp; y) := by decide</p>\n<p>@[simp] lemma carry_true₁ : ∀ y z, carry true y z = (y || z) := by decide<br>\n@[simp] lemma carry_true₂ : ∀ x z, carry x true z = (x || z) := by decide<br>\n@[simp] lemma carry_true₃ : ∀ x y, carry x y true = (x || y) := by decide</p>\n<p>lemma carry_comm : ∀ x y z, carry x y z = carry y x z := by decide</p>\n<p>end Bool</p>\n<p>namespace Nat</p>\n<p>variable (x y i : Nat)</p>\n<p>lemma shiftr_one : x.shiftr 1 = div2 x := rfl</p>\n<p>lemma shiftr_succ : x.shiftr i.succ = div2 (x.shiftr i) := rfl</p>\n<p>lemma shiftr_succ' : x.shiftr i.succ = (div2 x).shiftr i := by<br>\n  rw [←shiftr_one, ←shiftr_add, succ_eq_one_add]</p>\n<p>@[simp] lemma shiftr_bit (b : Bool) : shiftr (bit b x) i.succ = shiftr x i := by<br>\n  rw [shiftr_succ', div2_bit]</p>\n<p>-- why are Nat.zero_shiftr and Nat.shiftr_zero the same and neither is this one?<br>\n@[simp] lemma zero_shiftr' : x.shiftr 0 = x := rfl</p>\n<p>@[simp] lemma testBit_zero_left : testBit 0 i = false := by<br>\n  simp [testBit]</p>\n<p>@[simp] lemma testBit_zero_right : x.testBit 0 = x.bodd := by<br>\n  simp [testBit]</p>\n<p>lemma testBit_succ_right : x.testBit i.succ = (div2 x).testBit i := by<br>\n  rw [testBit, succ_eq_one_add, shiftr_add]<br>\n  rfl</p>\n<p>@[simp] lemma testBit_one_succ : testBit 1 i.succ = false := by<br>\n  rw [testBit_succ_right, div2_one, testBit_zero_left]</p>\n<p>@[simp] lemma testBit_one_zero : testBit 1 0 = true := rfl</p>\n<p>@[simp] lemma testBit_bit (b : Bool) : testBit (bit b x) i.succ = testBit x i := by<br>\n  rw [testBit, shiftr_bit]<br>\n  rfl</p>\n<p>-- Should be marked <code>simp</code> in Mathlib.<br>\nattribute [simp] bodd_bit div2_bit bit_zero</p>\n<p>@[simp] lemma succ_bit0 : (bit false x).succ = bit true x := rfl<br>\n@[simp] lemma succ_bit1 : (bit true x).succ = bit false x.succ := by<br>\n  simp [bit, Nat.bit0_succ_eq]<br>\n  rfl</p>\n<p>lemma bit_succ (b : Bool) : bit b x.succ = (bit b x).succ.succ := match b with<br>\n  | false =&gt; Nat.bit0_succ_eq x<br>\n  | true =&gt; Nat.bit1_succ_eq x</p>\n<p>lemma bit1_add' : bit true x + bit true y = bit false (x + y).succ := by<br>\n  change bit false x + 1 + (bit false y + 1) = _\n  rw [add_add_add_comm, ←bit_add, bit_succ]</p>\n<p>/-! ## Carry theorem -/</p>\n<p>def carry (x y i : Nat) : Bool := match i with<br>\n  | 0     =&gt; false<br>\n  | i + 1 =&gt; Bool.carry (Nat.testBit x i) (Nat.testBit y i) (carry x y i)</p>\n<p>@[simp] lemma carry_zero : carry x y 0 = false := rfl</p>\n<p>lemma carry_succ :<br>\n    carry x y i.succ = Bool.carry (Nat.testBit x i) (Nat.testBit y i) (carry x y i) :=<br>\n  rfl</p>\n<p>lemma carry_comm : carry x y i = carry y x i := by<br>\n  induction' i with i IH<br>\n  · rfl<br>\n  · rw [carry_succ, carry_succ, Bool.carry_comm, IH]</p>\n<p>@[simp] lemma carry_zero' : carry 0 y i = false := by<br>\n  induction' i with i IH<br>\n  · rfl<br>\n  · simp [carry_succ, IH]</p>\n<p>@[simp] lemma carry_zero'' : carry x 0 i = false := by<br>\n  rw [carry_comm, carry_zero']</p>\n<p>@[simp] lemma carry_bit0_left (b : Bool) : carry (bit false x) (bit b y) i.succ = carry x y i := by<br>\n  induction' i with i IH<br>\n  · rw [carry_succ]<br>\n    simp<br>\n  · rw [carry_succ]<br>\n    simp [IH]<br>\n    rfl</p>\n<p>@[simp] lemma carry_bit0_right (b : Bool) : carry (bit b x) (bit false y) i.succ = carry x y i := by<br>\n  rw [carry_comm, carry_bit0_left, carry_comm]</p>\n<p>@[simp] lemma carry_bit0_one : carry (bit false x) 1 i = false := by<br>\n  cases i<br>\n  · rfl<br>\n  · change carry _ (bit true 0) _ = _\n    rw [carry_bit0_left, carry_zero'']</p>\n<p>@[simp] lemma carry_bit1_one_succ_succ :<br>\n    carry (bit true x) 1 i.succ.succ = carry x 1 i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ x 1 (succ i)]<br>\n    simp [IH]</p>\n<p>@[simp] lemma carry_bit1_bit0_bit1 :<br>\n    carry (bit true (bit false x)) (bit true y) i.succ.succ =<br>\n    carry (bit true x) y i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ (bit true x)]<br>\n    simp [IH]</p>\n<p>@[simp] lemma carry_bit1_bit1_bit0 :<br>\n    carry (bit true x) (bit true (bit false y)) i.succ.succ =<br>\n    carry x (bit true y) i.succ := by<br>\n  rw [carry_comm, carry_bit1_bit0_bit1, carry_comm]</p>\n<p>@[simp] lemma carry_bit1_bit1_bit1_bit1 :<br>\n    carry (bit true (bit true x)) (bit true (bit true y)) i.succ.succ =<br>\n    carry (bit true x) (bit true y) i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ (bit true x)]<br>\n    simp [IH]</p>\n<p>lemma carry_bit1_bit1 : ∀ x y,<br>\n    carry (bit true x) (bit true y) i.succ.succ =<br>\n    (carry x 1 i.succ ^^ carry (succ x) y i.succ) := by<br>\n  induction' i with i IH<br>\n  · have : ∀ a b : Bool, (a || b) = (a ^^ !a &amp;&amp; b) := by decide<br>\n    simp [carry_succ, this]<br>\n  · intro x y<br>\n    apply x.bitCasesOn<br>\n    apply y.bitCasesOn<br>\n    rintro (_ | _) x (_ | _) y<br>\n    · rw [carry_succ]<br>\n      simp [IH]<br>\n      rfl<br>\n    · simp [IH]<br>\n    · simp<br>\n    · simp [IH]</p>\n<p>lemma carry_bit1_one : carry (bit true x) 1 i.succ.succ = carry x 1 i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ x]<br>\n    simp [IH]</p>\n<p>lemma testBit_succ_one : x.succ.testBit 1 = (x.testBit 1 ^^ bodd x) := by<br>\n  induction' x with x IH<br>\n  · rfl<br>\n  · apply x.bitCasesOn<br>\n    rintro (_ | _) x<br>\n    all_goals simp [IH, testBit, shiftr_one, div2_succ]</p>\n<p>lemma testBit_succ_succ : ∀ x, x.succ.testBit i.succ = (x.testBit i.succ ^^ carry x 1 i.succ) := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n    exact testBit_succ_one<br>\n  · intro x<br>\n    apply x.bitCasesOn<br>\n    rintro (_ | _) x<br>\n    · simp [testBit_succ_right _ i.succ, carry_bit0_one]<br>\n    · simp [testBit_succ_right _ i.succ, IH, carry_bit1_one]</p>\n<p>theorem testBit_add :<br>\n    ∀ x y, (x + y).testBit i = ((x.testBit i ^^ y.testBit i) ^^ carry x y i) := by<br>\n  induction' i with i IH<br>\n  · simp<br>\n  · intro x y<br>\n    apply x.bitCasesOn<br>\n    apply y.bitCasesOn<br>\n    rintro (_ | _) x (_ | _) y<br>\n    · simp [←bit_add, IH]<br>\n    · simp [←bit_add', IH]<br>\n    · simp [←bit_add, IH]<br>\n    · rw [bit1_add', ←add_succ]<br>\n      simp [IH]<br>\n      cases' i with i<br>\n      · simp [carry_succ]<br>\n      · rw [carry_comm (bit true y), carry_bit1_bit1, testBit_succ_succ]<br>\n        simp [carry_comm]</p>\n<p>end Nat</p>\n</div></div>",
        "id": 346976287,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680645238
    },
    {
        "content": "<p>I do apologize for the wall of text, I was hoping Zulip would auto-hide it</p>",
        "id": 346976407,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680645275
    },
    {
        "content": "<p>Here's some general pointers as to how I came up with all of this code:</p>\n<ul>\n<li>Lean rewards you if you take the time to fill in the basic API. No matter how trivial, marking the easy stuff as <code>simp</code> can be really helpful down the line.</li>\n<li>It's really easy to get lost in a wall of Lean symbols. If you find that the easiest route doesn't work, try working through the problem on paper, then translate that into Lean code.</li>\n<li>If faced with a hard problem, it's a good idea to try simpler problems first. They'll often appear as lemmas in the harder one.</li>\n</ul>",
        "id": 346977585,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680645812
    },
    {
        "content": "<p>I hope the goal here was for a Mathlib PR, and that I didn't accidentally just do your homework <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 346977704,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680645858
    },
    {
        "content": "<p>(Note you can collapse large walls of text with <code> ```spoiler title\\n ``` </code> blocks)</p>",
        "id": 346981985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680647646
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 346982450,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1680647817
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Like this</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Markdown\"><pre><span></span><code>````spoiler Proof\n<span class=\"sb\">```lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">oh_no</span>\n<span class=\"sb\">```</span>\n````\n</code></pre></div>\n<p>gives</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">oh_no</span>\n</code></pre></div>\n</div></div>\n</div></div>",
        "id": 346984562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1680648643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459227\">Violeta Hernández</span> <a href=\"#narrow/stream/113489-new-members/topic/Adding.20binary.20numbers/near/346976287\">said</a>:</p>\n<blockquote>\n<p>This was a really nice but really hard exercise. Took about 7 hours total. Seems like we're missing a lot of API for bitwise operations. You're welcome to improve on my code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import Mathlib.Data.Int.Bitwise</p>\n<p>infix:30 \" ^^ \" =&gt; xor</p>\n<p>namespace Bool</p>\n<p>@[simp] lemma not_xor : ∀ x y : Bool, (!(x ^^ y)) = (x == y) := by decide<br>\n@[simp] lemma xor_not_left' : ∀ x y : Bool, (!x ^^ y) = (x == y) := by decide<br>\n@[simp] lemma xor_not_right' : ∀ x y : Bool, (x ^^ !y) = (x == y) := by decide</p>\n<p>@[simp] lemma xor_eq_left : ∀ x y : Bool, ((x ^^ y) == x) = !y := by decide<br>\n@[simp] lemma xor_eq_right : ∀ x y : Bool, ((x ^^ y) == y) = !x := by decide</p>\n<p>@[simp] lemma xor_left_inj : ∀ x y z : Bool, (x ^^ y) = (x ^^ z) ↔ y = z := by decide<br>\n@[simp] lemma xor_right_inj : ∀ x y z : Bool, (x ^^ z) = (y ^^ z) ↔ x = y := by decide</p>\n<p>/-- Whether <code>x + y + z</code> produces a carry. Is true iff at least two of <code>x</code>, <code>y</code>, <code>z</code> are. -/<br>\ndef carry (x y z : Bool) := x &amp;&amp; y || (x ^^ y) &amp;&amp; z</p>\n<p>@[simp] lemma carry_self_self : ∀ x y, carry x x y = x := by decide</p>\n<p>@[simp] lemma carry_false₁ : ∀ y z, carry false y z = (y &amp;&amp; z) := by decide<br>\n@[simp] lemma carry_false₂ : ∀ x z, carry x false z = (x &amp;&amp; z) := by decide<br>\n@[simp] lemma carry_false₃ : ∀ x y, carry x y false = (x &amp;&amp; y) := by decide</p>\n<p>@[simp] lemma carry_true₁ : ∀ y z, carry true y z = (y || z) := by decide<br>\n@[simp] lemma carry_true₂ : ∀ x z, carry x true z = (x || z) := by decide<br>\n@[simp] lemma carry_true₃ : ∀ x y, carry x y true = (x || y) := by decide</p>\n<p>lemma carry_comm : ∀ x y z, carry x y z = carry y x z := by decide</p>\n<p>end Bool</p>\n<p>namespace Nat</p>\n<p>variable (x y i : Nat)</p>\n<p>lemma shiftr_one : x.shiftr 1 = div2 x := rfl</p>\n<p>lemma shiftr_succ : x.shiftr i.succ = div2 (x.shiftr i) := rfl</p>\n<p>lemma shiftr_succ' : x.shiftr i.succ = (div2 x).shiftr i := by<br>\n  rw [←shiftr_one, ←shiftr_add, succ_eq_one_add]</p>\n<p>@[simp] lemma shiftr_bit (b : Bool) : shiftr (bit b x) i.succ = shiftr x i := by<br>\n  rw [shiftr_succ', div2_bit]</p>\n<p>-- why are Nat.zero_shiftr and Nat.shiftr_zero the same and neither is this one?<br>\n@[simp] lemma zero_shiftr' : x.shiftr 0 = x := rfl</p>\n<p>@[simp] lemma testBit_zero_left : testBit 0 i = false := by<br>\n  simp [testBit]</p>\n<p>@[simp] lemma testBit_zero_right : x.testBit 0 = x.bodd := by<br>\n  simp [testBit]</p>\n<p>lemma testBit_succ_right : x.testBit i.succ = (div2 x).testBit i := by<br>\n  rw [testBit, succ_eq_one_add, shiftr_add]<br>\n  rfl</p>\n<p>@[simp] lemma testBit_one_succ : testBit 1 i.succ = false := by<br>\n  rw [testBit_succ_right, div2_one, testBit_zero_left]</p>\n<p>@[simp] lemma testBit_one_zero : testBit 1 0 = true := rfl</p>\n<p>@[simp] lemma testBit_bit (b : Bool) : testBit (bit b x) i.succ = testBit x i := by<br>\n  rw [testBit, shiftr_bit]<br>\n  rfl</p>\n<p>-- Should be marked <code>simp</code> in Mathlib.<br>\nattribute [simp] bodd_bit div2_bit bit_zero</p>\n<p>@[simp] lemma succ_bit0 : (bit false x).succ = bit true x := rfl<br>\n@[simp] lemma succ_bit1 : (bit true x).succ = bit false x.succ := by<br>\n  simp [bit, Nat.bit0_succ_eq]<br>\n  rfl</p>\n<p>lemma bit_succ (b : Bool) : bit b x.succ = (bit b x).succ.succ := match b with<br>\n  | false =&gt; Nat.bit0_succ_eq x<br>\n  | true =&gt; Nat.bit1_succ_eq x</p>\n<p>lemma bit1_add' : bit true x + bit true y = bit false (x + y).succ := by<br>\n  change bit false x + 1 + (bit false y + 1) = _\n  rw [add_add_add_comm, ←bit_add, bit_succ]</p>\n<p>/-! ## Carry theorem -/</p>\n<p>def carry (x y i : Nat) : Bool := match i with<br>\n  | 0     =&gt; false<br>\n  | i + 1 =&gt; Bool.carry (Nat.testBit x i) (Nat.testBit y i) (carry x y i)</p>\n<p>@[simp] lemma carry_zero : carry x y 0 = false := rfl</p>\n<p>lemma carry_succ :<br>\n    carry x y i.succ = Bool.carry (Nat.testBit x i) (Nat.testBit y i) (carry x y i) :=<br>\n  rfl</p>\n<p>lemma carry_comm : carry x y i = carry y x i := by<br>\n  induction' i with i IH<br>\n  · rfl<br>\n  · rw [carry_succ, carry_succ, Bool.carry_comm, IH]</p>\n<p>@[simp] lemma carry_zero' : carry 0 y i = false := by<br>\n  induction' i with i IH<br>\n  · rfl<br>\n  · simp [carry_succ, IH]</p>\n<p>@[simp] lemma carry_zero'' : carry x 0 i = false := by<br>\n  rw [carry_comm, carry_zero']</p>\n<p>@[simp] lemma carry_bit0_left (b : Bool) : carry (bit false x) (bit b y) i.succ = carry x y i := by<br>\n  induction' i with i IH<br>\n  · rw [carry_succ]<br>\n    simp<br>\n  · rw [carry_succ]<br>\n    simp [IH]<br>\n    rfl</p>\n<p>@[simp] lemma carry_bit0_right (b : Bool) : carry (bit b x) (bit false y) i.succ = carry x y i := by<br>\n  rw [carry_comm, carry_bit0_left, carry_comm]</p>\n<p>@[simp] lemma carry_bit0_one : carry (bit false x) 1 i = false := by<br>\n  cases i<br>\n  · rfl<br>\n  · change carry _ (bit true 0) _ = _\n    rw [carry_bit0_left, carry_zero'']</p>\n<p>@[simp] lemma carry_bit1_one_succ_succ :<br>\n    carry (bit true x) 1 i.succ.succ = carry x 1 i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ x 1 (succ i)]<br>\n    simp [IH]</p>\n<p>@[simp] lemma carry_bit1_bit0_bit1 :<br>\n    carry (bit true (bit false x)) (bit true y) i.succ.succ =<br>\n    carry (bit true x) y i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ (bit true x)]<br>\n    simp [IH]</p>\n<p>@[simp] lemma carry_bit1_bit1_bit0 :<br>\n    carry (bit true x) (bit true (bit false y)) i.succ.succ =<br>\n    carry x (bit true y) i.succ := by<br>\n  rw [carry_comm, carry_bit1_bit0_bit1, carry_comm]</p>\n<p>@[simp] lemma carry_bit1_bit1_bit1_bit1 :<br>\n    carry (bit true (bit true x)) (bit true (bit true y)) i.succ.succ =<br>\n    carry (bit true x) (bit true y) i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ (bit true x)]<br>\n    simp [IH]</p>\n<p>lemma carry_bit1_bit1 : ∀ x y,<br>\n    carry (bit true x) (bit true y) i.succ.succ =<br>\n    (carry x 1 i.succ ^^ carry (succ x) y i.succ) := by<br>\n  induction' i with i IH<br>\n  · have : ∀ a b : Bool, (a || b) = (a ^^ !a &amp;&amp; b) := by decide<br>\n    simp [carry_succ, this]<br>\n  · intro x y<br>\n    apply x.bitCasesOn<br>\n    apply y.bitCasesOn<br>\n    rintro (_ | _) x (_ | _) y<br>\n    · rw [carry_succ]<br>\n      simp [IH]<br>\n      rfl<br>\n    · simp [IH]<br>\n    · simp<br>\n    · simp [IH]</p>\n<p>lemma carry_bit1_one : carry (bit true x) 1 i.succ.succ = carry x 1 i.succ := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n  · rw [carry_succ, carry_succ x]<br>\n    simp [IH]</p>\n<p>lemma testBit_succ_one : x.succ.testBit 1 = (x.testBit 1 ^^ bodd x) := by<br>\n  induction' x with x IH<br>\n  · rfl<br>\n  · apply x.bitCasesOn<br>\n    rintro (_ | _) x<br>\n    all_goals simp [IH, testBit, shiftr_one, div2_succ]</p>\n<p>lemma testBit_succ_succ : ∀ x, x.succ.testBit i.succ = (x.testBit i.succ ^^ carry x 1 i.succ) := by<br>\n  induction' i with i IH<br>\n  · simp [carry_succ]<br>\n    exact testBit_succ_one<br>\n  · intro x<br>\n    apply x.bitCasesOn<br>\n    rintro (_ | _) x<br>\n    · simp [testBit_succ_right _ i.succ, carry_bit0_one]<br>\n    · simp [testBit_succ_right _ i.succ, IH, carry_bit1_one]</p>\n<p>theorem testBit_add :<br>\n    ∀ x y, (x + y).testBit i = ((x.testBit i ^^ y.testBit i) ^^ carry x y i) := by<br>\n  induction' i with i IH<br>\n  · simp<br>\n  · intro x y<br>\n    apply x.bitCasesOn<br>\n    apply y.bitCasesOn<br>\n    rintro (_ | _) x (_ | _) y<br>\n    · simp [←bit_add, IH]<br>\n    · simp [←bit_add', IH]<br>\n    · simp [←bit_add, IH]<br>\n    · rw [bit1_add', ←add_succ]<br>\n      simp [IH]<br>\n      cases' i with i<br>\n      · simp [carry_succ]<br>\n      · rw [carry_comm (bit true y), carry_bit1_bit1, testBit_succ_succ]<br>\n        simp [carry_comm]</p>\n<p>end Nat</p>\n<p></div></div><br>\n</p>\n</blockquote>\n<p>omg, thank you so much. This is actually incredible. I appreciate it!!!</p>",
        "id": 346996677,
        "sender_full_name": "Ben Nale",
        "timestamp": 1680654947
    }
]