[
    {
        "content": "<p>What does this error message mean?<br>\n<code>The termination measure's type must not depend on the function's varying parameters, but UnifyTys.unifyTysInner's termination measure does</code></p>\n<p>Surely the only time you can use a parameter as a termination measure is if it varies between calls?</p>\n<p>Unless this is about the <em>type</em> of parameters being different across two different mutually recursive functions?</p>\n<p>Termination proving is already difficult enough as it is, this error makes no sense to me</p>",
        "id": 529891823,
        "sender_full_name": "aron",
        "timestamp": 1753104675
    },
    {
        "content": "<p>I'm not sure, but it seems like the message is complaining that the measure's <strong>type</strong> depends on the varying parameters; since I assume it's expecting something like a well-founded order on that type, it seems reasonable to want it to be a single, non-dependent type.</p>",
        "id": 529894737,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1753105542
    },
    {
        "content": "<p>Let me give an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">error: The termination measure's type must not depend on the function's varying parameters, but testMe's termination measure does:</span>\n<span class=\"sd\">  {n : ℕ} → Fin n → Fin n</span>\n<span class=\"sd\">Try using `sizeOf` explicitly</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">testMe</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">testMe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Reason: It wants to get a <code>WellFoundedRelation</code> for a particular type; but in this case there is not one such type: First it's <code>Fin 10</code> but in the recursive call it's <code>Fin 9</code> etc. so you can't make a relation (in the sense of <code>α → α → Prop</code>) with them.<br>\nIf you specify <code>sizeOf</code>, you get one concrete type and it can get a relation of type <code>Nat → Nat → Prop</code> (the less than relation).</p>",
        "id": 529896507,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753106063
    },
    {
        "content": "<p>Alternatively, you can include <code>n</code> in one way or another, e.g. <code>termination_by (⟨n, x⟩ : (n : Nat) × Fin n)</code> so it can use a relation of type <code>(n : Nat) × Fin n → (n : Nat) × Fin n → Prop</code></p>",
        "id": 529896826,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1753106149
    }
]