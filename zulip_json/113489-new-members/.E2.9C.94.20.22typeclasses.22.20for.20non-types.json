[
    {
        "content": "<p>Makes sense with dependent types, but apparently you can declare typeclasses for non-types? Here I used it to attach a proof to an object, and can now annotate my defs with <code>[Multitree G]</code> to mean \"this theorem applies to multitrees\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Multitree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DAG</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">uniquePath</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Multitree</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DAG</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">Multitree</span><span class=\"bp\">.</span><span class=\"n\">uniquePath</span>\n</code></pre></div>\n<p>Is this usage idiomatic? Is there a better way to do that - an implicit variable or something?</p>",
        "id": 476852551,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1728940338
    },
    {
        "content": "<p>It's called a \"typeclass\" due to history, and it's a more general concept in Lean, so yes, it's not just for types.</p>\n<p>You can do this. It's a way to synthesize proofs using the syntactic form of <code>G</code>. This is probably the only way to create such a <code>Subsingleton</code> instance if you want to work with the <code>DAG</code> directly.</p>\n<p>The downside is that if you rewrite <code>G</code> inside of proofs, then typeclass synthesis will likely fail to find <code>Multitree</code> instances for the new type.</p>",
        "id": 476852999,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728940655
    },
    {
        "content": "<p>Another solution is to define <code>structure Multitree (N : Type _) extends DAG N</code>, assuming <code>DAG</code> is a structure. This \"bundles\" the <code>uniquePath</code> axiom into the value. This has its own tradeoffs, in particular a <code>Multitree</code> is a different type from a <code>DAG</code>, which can sometimes be annoying.</p>",
        "id": 476853238,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728940805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/stream/113489-new-members/topic/.22typeclasses.22.20for.20non-types/near/476852551\">said</a>:</p>\n<blockquote>\n<p>implicit variable or something</p>\n</blockquote>\n<p>That won't work since in an <code>instance</code> you need to be able to solve for all implicit variables using only the class expression and any outParams from any instance arguments there may be. Here, there's no way for Lean to solve for the <code>{_ : Multitree G}</code> under these constraints.</p>",
        "id": 476853604,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1728941062
    },
    {
        "content": "<p>Thanks! Yes, I went with <code>extends</code> approach initially, but any types dependent on <code>G</code> also then need to be duplicated along with relevant defs, and its a mess.</p>",
        "id": 476875172,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1728957125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> has marked this topic as resolved.</p>",
        "id": 476875179,
        "sender_full_name": "Notification Bot",
        "timestamp": 1728957129
    }
]