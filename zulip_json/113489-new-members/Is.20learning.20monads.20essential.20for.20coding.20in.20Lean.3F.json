[
    {
        "content": "<p>I’ve gotten more interested in the “Lean as a programming language” side of things and have scanned through FPIL. I’ve never programmed in a completely pure language before so I’m not familiar with idioms around that. </p>\n<p>I’ve noticed a bulk of FPIL seems dedicated to monads, functors, and monad transformers. I’m familiar with the general idea of pure functional programming (and treating IO as part of return value). I’m also familiar with the idea that monadic interfaces let you create sequential-like syntax a la async/await which makes pure IO feel close in usability to imperative programming languages.</p>\n<p>However, to my non-fully-functional brain, the idea of learning about “monad transformers” and such feels like an immediate turn-off. At least compared to things like Koka where, if I understands it right, typed effects propagate upwards without the explicit machinery associated with monads.</p>\n<p>Do I need to bite the bullet and just learn these concepts? And does Lean consider them SOTA in terms of usability, i.e. does the Lean team consider that everyone who wants to write programs that do IO need to learn what a “monad transformer” is? Or are there ideas on how to avoid that?</p>",
        "id": 534985375,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755534358
    },
    {
        "content": "<p>I don't think about how monad transformers work I just use them</p>",
        "id": 534986178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755534679
    },
    {
        "content": "<p>My way of thinking about monads is that there are essentially 3 orthogonal operations we want to perform more ergonomically in a purely functional language:</p>\n<ol>\n<li>We want to have access to some read-only data. This is similar to passing shared references to functions in Rust</li>\n<li>We want to mutate some state. This is similar to passing (exclusive) mutable references to functions in Rust</li>\n<li>We want to return errors, and have the ability to <em>early</em> return them sometimes. This is similar to using the <code>Result</code> type in Rust and the <code>?</code> operator</li>\n</ol>\n<p>For (1), there's <code>ReaderT</code>. For <code>(2)</code> there's <code>StateT</code> and for (3) there's <code>ExceptT</code>.</p>",
        "id": 534988717,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1755535891
    },
    {
        "content": "<p>When I read <a href=\"https://leanprover.github.io/functional_programming_in_lean/\">#fpil</a> a few years ago, I seem to remember that Chapter 2 basically teaches you how monads work without actually telling you that that's what you're learning. The info in Chapter 2 should be enough to let you write lots of nontrivial programs without actually needing a deeper understanding of what's going on.</p>\n<p>I guess whether you need to learn monads depends on what kinds of programs you plan to write. But I think if you get used to how <code>IO</code> works, you'll find that learning monads isn't actually very hard. I wouldn't worry about monad transformers unless you get to the point where you understand monads well enough that you start wanting to combine different monads.</p>",
        "id": 535035452,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755560861
    },
    {
        "content": "<p>(Also, maybe the linkifier should link to the new website of FPIL rather than the old one)</p>",
        "id": 535036114,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755561332
    },
    {
        "content": "<p>Here's how I think about monad transformers, let's use <code>StateT</code> as an example.</p>\n<ul>\n<li><code>StateM σ</code> is a monad that gives you access to a box containing one mutable value of type <code>σ</code>. A value of type <code>StateM σ α</code> is a computation that produces an <code>α</code> using a box containing a mutable value of <code>σ</code>. You can interact with this box using the <code>get</code>, <code>set</code>, and <code>modifyGet</code> functions that <code>StateM</code> provides. If you have <code>f : StateM σ α</code> and <code>init : σ</code> then <code>f.run init : α × σ</code> will set up a box, put <code>init</code> inside, and then run <code>f</code> using this box. The return value is <code>α × σ</code>, which is the value of <code>α</code> produced, and also the final state of the box.</li>\n<li>If <code>m</code> is a monad, then <code>StateT σ m</code> is a monad that extends <code>m</code> with a box containing one mutable value of type <code>σ</code>. A value of type <code>StateT σ m α</code> is a computation in <code>m</code> that produces an <code>α</code> using a box containing a mutable value of type <code>σ</code>. You can interact with this box using the <code>get</code>, <code>set</code>, and <code>modifyGet</code> functions that <code>StateT</code> provides, and you can also do all the things that are possible in <code>m</code>. If you have <code>f : StateT σ m α</code> and <code>init : σ</code> then <code>f.run init : m (α × σ)</code> will set up a box, put <code>init</code> inside, and then run <code>f</code> using this box. The return value is <code>m (α × σ)</code>, which is the computation in <code>m</code> that will return the value of <code>α</code> produced by <code>f</code>, and also the final state of the box.</li>\n</ul>",
        "id": 535037754,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755562478
    },
    {
        "content": "<p>Slightly off topic and not sure about monad transformers but on monads  Waller’s original paper <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf\">https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf</a> IMHO still remains the best practical introduction to monads. It doesn’t go into the category theory at all, it has a lot of examples of writing mini parser with monads, etc. The myriad of analogy driven blog posts muddled the waters.</p>",
        "id": 535066058,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755586874
    },
    {
        "content": "<p>I remember monads being scary when I first learned functional programming. Nowadays I think of monads as a powerful abstraction over control flow. Other languages have features such as methods, exceptions, or async/await. In a purely functional language all of these features can be built on top of monads and do notation.</p>\n<p>I recommend learning how to use specific monads such as <code>IO</code>, <code>Option</code>, <code>Except</code>, or <code>StateM</code>. You don't need to know what a monad is to use those. In fact, some of these also exist in other languages, they just aren't called monads. Once you have a good understanding of these specific monads you might want to dive deeper and learn how to write your own monads or combine monads using monad transformers.</p>",
        "id": 535088056,
        "sender_full_name": "eyelash",
        "timestamp": 1755595498
    },
    {
        "content": "<p>One other way to think about monads that might be useful to programmers is to think of monads as operator overloading, but instead of overloading the usual operators, you overload control flow. In a language with operator overloading the meaning of <code>a + b</code> depends on the types of <code>a</code> and <code>b</code> and the definition of the overloaded plus operator. Similarly, in a language with monads and do notation, the meaning of <code>do { a; b }</code> depends on the definition of the monad. In Lean, to overload the plus operator, you create an instance of <code>HAdd</code> and to overload the do notation you create an  instance of <code>Monad</code>.</p>",
        "id": 535093392,
        "sender_full_name": "eyelash",
        "timestamp": 1755597319
    },
    {
        "content": "<p>These are good explanations, thanks. To answer this directly:</p>\n<blockquote>\n<p>Other languages have features such as methods, exceptions, or async/await. In a purely functional language all of these features can be built on top of monads and do notation.</p>\n</blockquote>\n<p>What I’m asking about is whether dealing with monads directly <em>actually is</em> state of the art in pure functional language. As I mention in the OP post, I’ve heard of other approaches to this, for example effects in <a href=\"https://koka-lang.github.io/koka/doc/book.html\">Koka</a>:</p>\n<blockquote>\n<p>Effect handlers can be composed freely. This is unlike general monads which need monad transformers to compose in particular ways.</p>\n</blockquote>\n<p>Lean seems to be state of the art in multiple ways so what I’m expressing is some doubt whether this particular approach is also state of the art. I guess I’m asking if we really have nothing “better” by this point. I’m obviously biased towards effects (they “feel” “obvious” to me in a way monadic ceremony isn’t) but maybe there’s something else that’s promising.</p>",
        "id": 535098510,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755599423
    },
    {
        "content": "<p>So more concretely I’m wondering whether</p>\n<ol>\n<li>\n<p>Lean team doesn’t consider algebraic effects to be an improvement over dealing with monad transformers</p>\n</li>\n<li>\n<p>Lean team does consider it to be an improvement but there’s still not enough research into effects to build upon them</p>\n</li>\n<li>\n<p>It’s an improvement but also too much work and can’t possibly be prioritized so will likely have to wait for years</p>\n</li>\n<li>\n<p>It’s an improvement but fundamentally can’t fit into the Lean typesystem so it isn’t considered </p>\n</li>\n</ol>\n<p>I searched this board for discussions about algebraic effects and found surprisingly little. I don’t understand if it’s because the folks here don’t find value in them, or because of insurmountable difficulties, or because they’re somehow not well-known (that would be difficult to believe in the PL crowd though).</p>",
        "id": 535099682,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755599913
    },
    {
        "content": "<p>Did you look at <a href=\"#narrow/channel/270676-lean4/topic/algebraic.20effects.20and.20handlers.3F\">https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/algebraic.20effects.20and.20handlers.3F</a> ?</p>",
        "id": 535102607,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1755601222
    },
    {
        "content": "<p>Yea that seems to be closest to the official word on the matter. I was hoping maybe there's a bit more on how Lean plans to solve similar problems (or maybe Lean just considers them non-problems, which would be helpful to hear explicitly too).</p>",
        "id": 535124991,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755608789
    }
]