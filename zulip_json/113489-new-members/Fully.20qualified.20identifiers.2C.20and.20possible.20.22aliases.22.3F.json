[
    {
        "content": "<p>If I can successfully run <code>#check &lt;name&gt;</code> or <code>#print &lt;name&gt;</code>, does that mean <code>&lt;name&gt;</code> is the unique, fully qualified identifier for that theorem/declaration?</p>\n<p>Consider the examples below (<code>Polynomial.X_pow_sub_C_ne_zero</code> and <code>mul_assoc</code>):</p>\n<p>Once I’ve verified that <code>#check Polynomial.X_pow_sub_C_ne_zero</code> and <code>#print Polynomial.X_pow_sub_C_ne_zero</code> works, can I be sure there are no other aliases or shorter names for that same theorem (unless, of course, the theorem has been duplicated under a different name)?</p>\n<p>Is <code>Polynomial.X_pow_sub_C_ne_zero</code> itself the fully qualified name—independent of its location (<code>Mathlib.Algebra.Polynomial.Degree.Operations</code>)?</p>\n<p>And how does this apply to more \"global\" declarations like <code>mul_assoc</code>? What is the fully qualified name for <code>mul_assoc</code>?</p>\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span>\n<span class=\"c1\">-- import Mathlib.Algebra.Polynomial.Degree.Operations\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span>\n<span class=\"c1\">-- import Mathlib.Algebra.Group.Defs\"</span>\n</code></pre></div>",
        "id": 515561056,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1746125381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515561056\">said</a>:</p>\n<blockquote>\n<p>If I can successfully run <code>#check &lt;name&gt;</code> or <code>#print &lt;name&gt;</code>, does that mean <code>&lt;name&gt;</code> is the unique, fully qualified identifier for that theorem/declaration?</p>\n</blockquote>\n<p>No, that is not the case.</p>\n<ol>\n<li>You might have <code>open</code> commands that make it possible to refer to a declaration by a shorter name.</li>\n<li>There might be aliases, created using the <code>export</code> command.</li>\n</ol>\n<p>Simple counterexample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">toString</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">succ</span>\n</code></pre></div>",
        "id": 515561695,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746125637
    },
    {
        "content": "<p>Both <code>#check &lt;name&gt;</code> and <code>#print &lt;name&gt;</code> will also succeed even if <code>&lt;name&gt;</code> is ambiguous. They print all interpretations.</p>",
        "id": 515561888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746125699
    },
    {
        "content": "<p>I believe both <code>#check</code> and <code>#print</code> will print the fully-qualified names.</p>\n<p>You can always hover over the declaration name to be sure. I think that gives the fully qualified name.</p>",
        "id": 515562378,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746125895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515561056\">said</a>:</p>\n<blockquote>\n<p>What is the fully qualified name for <code>mul_assoc</code>?</p>\n</blockquote>\n<p><code>mul_assoc</code></p>",
        "id": 515562572,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746125978
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>!</p>\n<p>Great point about <code>open</code>—I hadn’t considered that, but it makes perfect sense.</p>\n<p>So generally, to find a declaration’s fully qualified name, can I just take the first identifier in the <code>#check &lt;name&gt;</code> output and ignore the trailing universe annotation (<code>.{u}</code>)?</p>\n<p>In this example, I would treat <code>Polynomial.X_pow_sub_C_ne_zero</code> as the fully qualified name:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">X_pow_sub_C_ne_zero</span>\n<span class=\"c1\">-- Polynomial.X_pow_sub_C_ne_zero.{u} {R : Type u} [Ring R]</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span>\n<span class=\"c1\">-- Polynomial.X_pow_sub_C_ne_zero.{u} {R : Type u} [Ring R]</span>\n</code></pre></div>\n<p>Also, what do the these 32 universe-specific variants mean?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"c1\">-- X_pow_sub_C_ne_zero : 0 &lt; ?m.4 → ∀ (a : ?m.1), X ^ ?m.4 - C a ≠ 0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span>\n<span class=\"c1\">-- X_pow_sub_C_ne_zero : 0 &lt; ?m.1973 → ∀ (a : ?m.1970), X ^ ?m.1973 - C a ≠ 0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">}</span>\n<span class=\"c1\">-- X_pow_sub_C_ne_zero : 0 &lt; ?m.3942 → ∀ (a : ?m.3939), X ^ ?m.3942 - C a ≠ 0</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">X_pow_sub_C_ne_zero</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">32</span><span class=\"o\">}</span>\n<span class=\"c1\">-- X_pow_sub_C_ne_zero : 0 &lt; ?m.5911 → ∀ (a : ?m.5908), X ^ ?m.5911 - C a ≠ 0</span>\n</code></pre></div>\n<p>I naïvely  assumed one of them would simply display the same output as for <code>#check Polynomial.X_pow_sub_C_ne_zero</code>, but they all seem to contain <code>?m.xxx</code> placeholders. What’s happening here?</p>",
        "id": 515565123,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1746126969
    },
    {
        "content": "<blockquote>\n<p>can I just take the first identifier in the <code>#check &lt;name&gt;</code> output</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515562378\">said</a>:</p>\n<blockquote>\n<p>I believe both <code>#check</code> and <code>#print</code> will print the fully-qualified names.</p>\n</blockquote>\n<p>Emphasis here on \"believe\". To be sure, you'll have to dig into the source code yourself.</p>",
        "id": 515565393,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746127077
    },
    {
        "content": "<blockquote>\n<p>Also, what do the these 32 universe-specific variants mean?</p>\n</blockquote>\n<p>I am puzzled by your motivation here. Do you expect the different instantiations of the universe parameters to be fundamentally different from one another?</p>\n<p>In any case, take a look at the source for <code>#check</code>. You'll see why there's different behavior when you give it something that's not an identifier.</p>",
        "id": 515565738,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746127195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515565738\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also, what do the these 32 universe-specific variants mean?</p>\n</blockquote>\n<p>I am puzzled by your motivation here. Do you expect the different instantiations of the universe parameters to be fundamentally different from one another?</p>\n</blockquote>\n<p>Quite the opposite—I assumed they were <em>exactly</em> the same, so I naïvely expected <em>identical</em> output for <code>#check Polynomial.X_pow_sub_C_ne_zero</code> and <code>#check Polynomial.X_pow_sub_C_ne_zero.{n}</code> for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mn>31</mn><mo separator=\"true\">,</mo><mn>32</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">n \\in \\{0, 1, …, 31, 32\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">31</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">32</span><span class=\"mclose\">}</span></span></span></span>. (And if that wasn't the case I expected at least one of them to have exactly the same output as <code>#check Polynomial.X_pow_sub_C_ne_zero</code>: namely the one at the declaration’s original, lowest universe level.)</p>\n<p>(I'm a beginner here, but the expectation above comes from the following: my simple mental mode that each universe embeds into the next—everything in universe 0 also lives in universe 1, everything in universe 1 in universe 2, and so on up to universe 32. As far as I understand, <code>Polynomial.X_pow_sub_C_ne_zero</code> is a <code>Prop</code> and thus has it \"home\" in universe 0 (but can be found in universe 1-32 too!).)</p>",
        "id": 515568081,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1746128123
    },
    {
        "content": "<p>Given your questions about exact implementations of tactics, I strongly recommend you investigate the implementation of <code>#check</code>.</p>",
        "id": 515568294,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746128196
    },
    {
        "content": "<blockquote>\n<p>and so on up to universe 32</p>\n</blockquote>\n<p>There are infinitely many universe levels. Passing 32 simply triggers the \"you probably don't mean this\" error.</p>",
        "id": 515568603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746128311
    },
    {
        "content": "<p>You can pass <code>31 + n</code> to exceed it (for concrete <code>n</code>)</p>",
        "id": 515568763,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746128400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515568081\">said</a>:</p>\n<blockquote>\n<p>As far as I understand, <code>Polynomial.X_pow_sub_C_ne_zero</code> is a <code>Prop</code> and thus has it \"home\" in universe 0 (but can be found in universe 1-32 too!)</p>\n</blockquote>\n<p>I'm not sure that's the right interpretation. Yes, this theorem has a type that is in <code>Prop</code> (a.k.a. <code>Sort 0</code>), but the domains of the foralls are types, and the theorem is parameterized so that those domains can come from various universe levels.</p>\n<p>The <code>Prop</code> universe is \"impredicative\". The effect of impredicativity is that, despite the fact that the domains can lie in larger universes, the type is regardless still in <code>Prop</code>.</p>",
        "id": 515569041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746128499
    },
    {
        "content": "<p>(You give me a <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>, but there's a subtlety that I'm not sure about. I don't know if there are versions of type theory where the way impredicativity works is that the type is \"actually\" in the higher universe, but then there is a corresponding <code>Prop</code> that means \"the type in that higher universe is inhabited.\" At least from within Lean's system it's \"no, <code>Polynomial.X_pow_sub_C_ne_zero</code> is not found in any higher universes, it is only in <code>Prop</code>\".)</p>",
        "id": 515569945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746128801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515569945\">said</a>:</p>\n<blockquote>\n<p>(You give me a <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span>, but there's a subtlety that I'm not sure about. I don't know if there are versions of type theory where the way impredicativity works is that the type is \"actually\" in the higher universe, but then there is a corresponding <code>Prop</code> that means \"the type in that higher universe is inhabited.\" At least from within Lean's system it's \"no, <code>Polynomial.X_pow_sub_C_ne_zero</code> is not found in any higher universes, it is only in <code>Prop</code>\".)</p>\n</blockquote>\n<p>What do you by \"corresponding\"? Is that a function?</p>",
        "id": 515570979,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746129206
    },
    {
        "content": "<p>Thanks, that’s really helpful—TIL!</p>\n<p>I’m left wondering why Lean displays the fully elaborated signature for <code>#check mul_assoc</code>, but shows a <code>?m.1</code> placeholder when I force it to universe 0 by doing <code>#check mul_assoc.{0}</code>. Is that due to what you mentioned about the theorem being parameterized?</p>\n<p>Is it that at level 0 Lean can no longer infer the parameters (<code>G : Type u₁</code>, <code>[Semigroup G]</code>, etc.) when printing?</p>\n<p>More specifically, I’m wondering whether this is merely a practical implementation choice, or if Lean \"doesn’t have\" the required information to print that at universe level 0 (from a theoretical perspective).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span>\n<span class=\"c1\">-- mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) : a * b * c = a * (b * c)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"c1\">-- mul_assoc : ∀ (a b c : ?m.1), a * b * c = a * (b * c)</span>\n</code></pre></div>",
        "id": 515571212,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1746129296
    },
    {
        "content": "<p><code>#check</code> has special support for identifiers vs terms</p>",
        "id": 515571256,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746129318
    },
    {
        "content": "<p>So since <code>mul_assoc</code> is an identifier, it gets the special treatment. You can see what happens when you do <code>#check (mul_assoc)</code> is different.</p>",
        "id": 515571403,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746129366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515568763\">said</a>:</p>\n<blockquote>\n<p>You can pass <code>31 + n</code> to exceed it (for concrete <code>n</code>)</p>\n</blockquote>\n<p>Heh, nice trick <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>! It seems to work for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">n \\le 32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">32</span></span></span></span>, but the process can be repeated to reach arbitrarily high:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">33</span><span class=\"o\">}</span>\n<span class=\"c1\">-- fails: maximum universe level offset threshold (32) has been reached, …</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"o\">}</span>\n<span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"bp\">+</span><span class=\"mi\">32</span><span class=\"o\">}</span>\n<span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 515572447,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1746129751
    },
    {
        "content": "<p>perhaps the following is to your satisfaction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span>\n<span class=\"c1\">-- mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) : a * b * c = a * (b * c)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul_assoc</span><span class=\"o\">)</span>\n<span class=\"c1\">-- mul_assoc : ∀ (a b c : ?m.2), a * b * c = a * (b * c)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mul_assoc</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n<span class=\"c1\">-- mul_assoc : ∀ (a b c : ?m.288), a * b * c = a * (b * c)</span>\n</code></pre></div>",
        "id": 515572624,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746129835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515572447\">said</a>:</p>\n<blockquote>\n<p>Heh, nice trick <span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span>!</p>\n</blockquote>\n<p>Of course you can also <code>set_option maxUniverseOffset 999</code> and get up to 999 offsets.</p>",
        "id": 515572825,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746129909
    },
    {
        "content": "<p>which is to say, there's nothing special about universe levels here, it's just that once you provide specific terms, the <code>#check</code> command needs to employ a different algorithm for displaying the type</p>",
        "id": 515572829,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1746129911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Fully.20qualified.20identifiers.2C.20and.20possible.20.22aliases.22.3F/near/515571212\">said</a>:</p>\n<blockquote>\n<p>I’m left wondering why Lean displays the fully elaborated signature for <code>#check</code></p>\n</blockquote>\n<p>I see you didn't follow up on my strong suggestion. Please read it — if there is anything you don't understand, please ask followup questions.</p>",
        "id": 515586861,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746135694
    },
    {
        "content": "<p>It's all a \"go to definition\" away</p>",
        "id": 515586897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1746135711
    }
]