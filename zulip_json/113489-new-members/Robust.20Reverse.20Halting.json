[
    {
        "content": "<p>Here is a tiny Lean core capturing the dynamic idea I’m working with.</p>\n<p>The setup is:</p>\n<ul>\n<li>\n<p>A temporal trace is <code>Trace := ℕ → Prop</code>.</p>\n</li>\n<li>\n<p><code>Halts T</code> means “there exists a time <code>n</code> with <code>T n</code>”.</p>\n</li>\n<li>\n<p>A <strong>reverse–halting kit</strong> <code>RHKit</code> with the axiom <code>DetectsMonotone</code> induces an operator <code>Rev</code> on traces.</p>\n</li>\n<li>\n<p>The key lemma is that, under <code>DetectsMonotone K</code>, the stabilised predicate <code>Rev0 K</code> is <em>forced</em> to coincide with the plain halting predicate <code>Halts</code> on all traces.</p>\n</li>\n<li>\n<p>A <code>LocalReading</code> maps each <code>(Γ, φ)</code> to a trace; <code>Prov</code> says the trace ever holds, and <code>verdict K</code> is <code>Rev0 K</code> on that trace.</p>\n</li>\n<li>\n<p>So the “verdict” of any admissible <code>K</code> collapses extensionally to provability-as-halting.</p>\n</li>\n</ul>\n<p>Lean code (minimal core):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">LogicDissoc</span>\n\n<span class=\"sd\">/-- A temporal trace: at each time `n`, a proposition may hold. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"sd\">/-- `(up T) n` means “there exists `k ≤ n` with `T k`”. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">up_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hnm</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk_le_n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk_T</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span><span class=\"w\"> </span><span class=\"n\">hk_le_n</span><span class=\"w\"> </span><span class=\"n\">hnm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk_T</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- Direct halting predicate on traces. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Halts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">exists_up_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Halts</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk</span><span class=\"bp\">⟩⟩</span>\n\n<span class=\"sd\">/-- A reverse–halting kit. -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">`DetectsMonotone K` says: on monotone families `X`,</span>\n<span class=\"sd\">`K.Proj X` coincides with `∃ n, X n`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DetectsMonotone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">proj_of_mono</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Revision operator obtained from a reverse–halting kit. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rev</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Concrete alias. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rev0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Rev</span><span class=\"w\"> </span><span class=\"n\">K</span>\n\n<span class=\"sd\">/-- Core lemma: any monotone–detecting kit collapses to plain halting. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Rev0_iff_Halts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DK</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DetectsMonotone</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Trace</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Rev0</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Halts</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Rev0</span><span class=\"w\"> </span><span class=\"n\">Rev</span><span class=\"w\"> </span><span class=\"n\">Halts</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmono</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">up_mono</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">Proj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">DetectsMonotone</span><span class=\"bp\">.</span><span class=\"n\">proj_of_mono</span><span class=\"w\"> </span><span class=\"n\">DK</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hnm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hmono</span><span class=\"w\"> </span><span class=\"n\">hnm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">exists_up_iff</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! Local reading, provability and verdicts. -/</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"w\"> </span><span class=\"n\">v'</span>\n\n<span class=\"sd\">/-- A local reading assigns a trace to each `(Γ, φ)`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">LocalReading</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Sentence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Trace</span>\n\n<span class=\"sd\">/-- Provability as “halting of the local reading”. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Prov</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Sentence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalReading</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"sd\">/-- Stabilised verdict via `Rev0`. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">verdict</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Sentence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalReading</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Rev0</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Verdict = provability for any admissible kit. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">verdict_iff_Prov</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RHKit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DK</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DetectsMonotone</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Sentence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LocalReading</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Sentence</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">verdict</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Prov</span><span class=\"w\"> </span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">verdict</span><span class=\"w\"> </span><span class=\"n\">Prov</span>\n<span class=\"w\">  </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Halts</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Rev0_iff_Halts</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">DK</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LR</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">LogicDissoc</span>\n</code></pre></div>\n<p>If anyone is interested, I also have a full version where this is connected to a standard semantic closure <code>CloE</code> (Galois connection between models/theories) via a “dynamic bridge”:</p>\n<blockquote>\n<p><code>φ ∈ CloE Γ</code> if and only if the local reading trace <code>LR Γ φ</code> halts,</p>\n</blockquote>\n<p>and then the robust <code>Rev</code>–verdict is <em>forced</em> to coincide with semantic consequence.</p>\n<p>Thank you</p>",
        "id": 562990151,
        "sender_full_name": "John Doe",
        "timestamp": 1765382212
    },
    {
        "content": "<p>Link to the repo : <a href=\"https://github.com/JohnDoe-collab-stack/RevHalt\">https://github.com/JohnDoe-collab-stack/RevHalt</a></p>\n<h1>RevHalt</h1>\n<p>A Lean 4 framework proving that computational truth (halting) is:</p>\n<ul>\n<li><strong>Canonical</strong> — independent of how you observe it</li>\n<li><strong>Inaccessible</strong> — no sound formal system fully captures it</li>\n<li><strong>Complementary</strong> — any sound theory can be strictly extended toward it</li>\n</ul>\n<p>Unlike classical presentations of Gödel's theorems, which work <em>inside</em> a specific theory, RevHalt provides the abstract framework and treats theories (PA, ZFC) as instances to be plugged in.</p>\n<hr>\n<h2>Foundational perspective</h2>\n<p>Standard presentations of Gödel's incompleteness theorems work <em>within</em> a base theory (typically PA or ZFC) and derive limitative results about that theory's expressive power.</p>\n<p>This project inverts the perspective:</p>\n<ul>\n<li><strong>RevHalt provides the abstract syntactic framework</strong>, grounded in Turing-style computability (halting, diagonalization, definability).</li>\n<li><strong>Formal theories become semantic instances</strong> of this framework, obtained by supplying concrete interpretations of the abstract interface (provability, truth, arithmetization).</li>\n</ul>\n<p>In this formulation, the \"proof strength\" of any particular theory is not a primitive notion but rather emerges as a local property: it measures how much of the externally-defined computational truth the theory's provability predicate can capture.</p>\n<h3>Original contributions</h3>\n<p>This project establishes three main results, each with distinct novelty:</p>\n<h4>T1 — Canonicity of computational truth</h4>\n<p>Classical result (Turing): <em>The halting problem is undecidable.</em></p>\n<p>T1 proves something different: <strong>computational truth is objective</strong> — independent of the observation mechanism.</p>\n<p>The framework introduces <code>RHKit</code>, an abstract \"observation mechanism\" for traces. T1 proves:</p>\n<ul>\n<li><code>T1_traces</code>: Any valid Kit yields the same verdict as standard halting</li>\n<li><code>T1_uniqueness</code>: Two valid Kits are extensionally equivalent</li>\n<li><code>T1_semantics</code>: Under the DynamicBridge hypothesis, Rev captures model-theoretic consequence</li>\n</ul>\n<p>This is not Turing's theorem. It is a <strong>canonicity result</strong>: all valid observers converge to the same truth.</p>\n<h4>T2 — Abstract Turing-Gödel synthesis</h4>\n<p>Classical results: Turing (algorithmic undecidability) and Gödel I (true unprovable sentences) are typically presented separately.</p>\n<p>T2 extracts their <strong>common abstract core</strong> via <code>TuringGodelContext'</code>:</p>\n<ul>\n<li><code>diagonal_program</code>: the diagonal fixed-point axiom unifying both arguments</li>\n<li>Result: no internal predicate can be simultaneously Total, Correct, and Complete</li>\n</ul>\n<p>This is not a reformulation; it is an <strong>abstraction</strong> that reveals the structural unity of Turing and Gödel.</p>\n<h4>T3 — Complementarity: the central concept</h4>\n<p>Classical incompleteness is <strong>limitative</strong>: it tells you what theories <em>cannot</em> do.</p>\n<p>T3 introduces a <strong>new concept</strong> — <strong>complementarity</strong> — and proves it formally:</p>\n<blockquote>\n<p><strong>Rev is the complement of any sound formal system.</strong></p>\n</blockquote>\n<p>This means:</p>\n<ul>\n<li>Formal systems are not \"failures\" for being incomplete — they are <strong>structurally partial</strong></li>\n<li>Rev is not merely \"bigger\" than PA/ZFC — it is <strong>what they lack</strong></li>\n<li>Truth and provability are not opposed — they are <strong>complementary</strong></li>\n</ul>\n<p>The theorem <code>T3_strong</code> proves that this complementarity is <strong>structured and rich</strong>. The space of true-but-unprovable statements is not an amorphous limiting void, but a <strong>partitioned landscape</strong>.</p>\n<p>We prove the existence of <strong>infinitely many disjoint, compatible directions</strong> of extension. This means that completing a theory is not a single forced step, but a <strong>dynamical choice</strong> — a navigation through the geography of computational truth.<br>\n<strong>This concept has no classical analog.</strong> It transforms incompleteness from a limitative statement into a structural dynamical relationship.</p>\n<hr>\n<h2>Syntax–semantics correspondence</h2>\n<p>The framework establishes a precise correspondence:</p>\n<table>\n<thead>\n<tr>\n<th>RevHalt (syntax)</th>\n<th>Instance L (semantics)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RMHalts e</code> — halting defined by the computability model</td>\n<td><code>L.Truth (HaltEncode e)</code> — truth as seen by the theory</td>\n</tr>\n<tr>\n<td><code>M.PredDef</code> — definability in the abstract model</td>\n<td><code>L.Provable</code> via arithmetization — derivability as seen by the theory</td>\n</tr>\n<tr>\n<td>Diagonalization (<code>diagonal_halting</code>)</td>\n<td>Arithmetization (<code>repr_provable_not</code>)</td>\n</tr>\n</tbody>\n</table>\n<p>The theorems then express structural gaps between syntactic truth and semantic observability:</p>\n<table>\n<thead>\n<tr>\n<th>Theorem</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>T1</strong> : <code>∀ T, Rev0_K K T ↔ Halts T</code></td>\n<td><strong>Canonicity</strong>: computational truth is objective, independent of observation mechanism</td>\n</tr>\n<tr>\n<td><strong>T2</strong> : <code>∃ p, Truth p ∧ ¬Provable p</code></td>\n<td><strong>Synthesis</strong>: no internal predicate captures external truth (Turing-Gödel core)</td>\n</tr>\n<tr>\n<td><strong>T2'</strong> : <code>∃ e, ¬Provable(H e) ∧ ¬Provable(¬H e)</code></td>\n<td><strong>Independence</strong>: some halting facts are invisible to the semantic observer</td>\n</tr>\n<tr>\n<td><strong>T3</strong> : <code>∃ T₁ ⊃ ProvableSet, sound</code></td>\n<td><strong>Complementarity</strong>: Rev provides structured infinite extensions for any sound theory</td>\n</tr>\n</tbody>\n</table>\n<p>This is the reverse of classical incompleteness proofs, which work <em>in</em> a theory <em>about</em> that theory. Here, the proofs work <em>in</em> RevHalt <em>about</em> any conforming semantic instance.</p>\n<hr>\n<h2>Structure</h2>\n<h3>Core modules</h3>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Contents</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>RevHalt.lean</code></td>\n<td>Base layer: <code>Trace</code>, <code>Halts</code>, <code>RHKit</code>, <code>TuringGodelContext'</code>, <code>T2_impossibility</code></td>\n</tr>\n<tr>\n<td><code>RevHalt.Unified.Core</code></td>\n<td>Abstract results: <code>EnrichedContext</code>, <code>ProvableSet</code>, <code>true_but_unprovable_exists</code>, <code>independent_code_exists</code></td>\n</tr>\n<tr>\n<td><code>RevHalt.Unified.RigorousModel</code></td>\n<td>Computability model: <code>RigorousModel</code>, <code>SoundLogicDef</code>, <code>Arithmetization</code></td>\n</tr>\n<tr>\n<td><code>RevHalt.Unified.Bridge</code></td>\n<td>Integration: <code>SoundLogicEncoded</code>, <code>EnrichedContext_from_Encoded</code>, <code>RevHalt_Master_Complete</code></td>\n</tr>\n</tbody>\n</table>\n<h3>Entry point</h3>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">RevHalt.Unified</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">RevHalt_Unified</span>\n</code></pre></div>\n<hr>\n<h2>Interface (M / L / A / E)</h2>\n<p>The framework factors assumptions into four components:</p>\n<h3>M — Computability model (<code>RigorousModel</code>)</h3>\n<ul>\n<li><code>Code</code>, <code>Program : Code → ℕ → Option ℕ</code></li>\n<li><code>PredCode</code>, <code>PredDef : PredCode → Code → Prop</code> (definability, not decidability)</li>\n<li><code>diagonal_halting</code> (fixed-point over definable predicates)</li>\n<li><code>no_complement_halts</code> (non-halting is not definable)</li>\n</ul>\n<h3>L — Logic (<code>SoundLogicDef PropT</code>)</h3>\n<ul>\n<li><code>Provable</code>, <code>Truth : PropT → Prop</code></li>\n<li><code>soundness : Provable p → Truth p</code></li>\n<li><code>Not</code>, <code>FalseP</code>, <code>consistent</code>, <code>absurd</code>, <code>truth_not_iff</code></li>\n</ul>\n<h3>A — Arithmetization (<code>Arithmetization M PropT L</code>)</h3>\n<ul>\n<li><code>repr_provable_not</code> : for any <code>G : Code → PropT</code>, the predicate <code>Provable (Not (G e))</code> is definable in <code>PredCode</code>.</li>\n</ul>\n<h3>E — Encoding (in <code>SoundLogicEncoded</code>)</h3>\n<ul>\n<li><code>HaltEncode : Code → PropT</code></li>\n<li><code>encode_correct : RMHalts e ↔ Truth (HaltEncode e)</code></li>\n</ul>\n<hr>\n<h2>Main theorem</h2>\n<h3><code>RevHalt_Master_Complete</code></h3>\n<p>For any semantic instance <code>(M, K, L)</code> satisfying the interface:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">RealHalts</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Halts</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\">           </span><span class=\"c1\">-- T1: canonicity</span>\n<span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Truth</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Provable</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">                     </span><span class=\"c1\">-- T2: synthesis</span>\n<span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Provable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Provable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">))</span><span class=\"w\">   </span><span class=\"c1\">-- T2': independence</span>\n<span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">T₁</span><span class=\"w\"> </span><span class=\"bp\">⊃</span><span class=\"w\"> </span><span class=\"n\">ProvableSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">T₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Truth</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">         </span><span class=\"c1\">-- T3: complementarity</span>\n</code></pre></div>\n<hr>\n<h2>Demos</h2>\n<ul>\n<li><code>RevHalt_Demo_A</code> : trivial model (empty provability)</li>\n<li><code>RevHalt_Demo_C</code> : non-trivial model (non-empty provability, structured predicates)</li>\n<li><code>RevHalt/Demo/Template.lean</code> : instantiation skeleton</li>\n</ul>\n<hr>\n<h2>Build</h2>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lake<span class=\"w\"> </span>build\nlake<span class=\"w\"> </span>env<span class=\"w\"> </span>lean<span class=\"w\"> </span>RevHalt/Demo/All.lean\n</code></pre></div>\n<hr>\n<h2>Design notes</h2>\n<ul>\n<li><code>PredDef</code> is <code>Prop</code>-valued (definability), avoiding implicit decidability assumptions.</li>\n<li><code>no_complement_halts</code> blocks trivial instantiations where \"not halts\" would be definable.</li>\n<li>Soundness (<code>Provable → Truth</code>) is an explicit hypothesis, not an ambient assumption.</li>\n</ul>",
        "id": 563574649,
        "sender_full_name": "John Doe",
        "timestamp": 1765581005
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Robust.20Reverse.20Halting\">#lean4 &gt; Robust Reverse Halting</a> by <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>.</p>",
        "id": 563575735,
        "sender_full_name": "Notification Bot",
        "timestamp": 1765581954
    },
    {
        "content": "<p>This has nothing to do with development of the core software so I've moved it to a more appropriate channel. Looks like slop to me but was reluctant to unilaterally junk because I don't know the area.</p>",
        "id": 563575817,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765582021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Robust.20Reverse.20Halting/near/563575817\">said</a>:</p>\n<blockquote>\n<p>This has nothing to do with development of the core software so I've moved it to a more appropriate channel. Looks like slop to me but was reluctant to unilaterally junk because I don't know the area.</p>\n</blockquote>\n<p>Thanks for the triage. I understand this isn’t “core software” work, so moving it is fine.</p>\n<p>On “slop”: the README is summarizing Lean-formalized results (not marketing text). The three main theorems are:</p>\n<ul>\n<li>\n<p><strong>T1 (<code>T1_traces</code>)</strong>: canonicity : for any valid <code>RHKit</code>, <code>Rev0_K K T ↔ Halts T</code> (all valid observers agree with standard halting).</p>\n</li>\n<li>\n<p><strong>T2 (<code>T2_impossibility</code>)</strong>: abstract Turing–Gödel core : no internal predicate can be simultaneously total, correct, and complete with respect to <code>RealHalts</code>.</p>\n</li>\n<li>\n<p><strong>T3 (<code>T3_strong</code>)</strong>: complementarity : for any sound theory, there are strict extensions (in structured, disjoint directions) toward computational truth.</p>\n</li>\n</ul>\n<p>Repo: <strong><a href=\"https://github.com/JohnDoe-collab-stack/RevHalt\">&lt;REPO_LINK&gt;</a></strong><br>\nRepro: <code>lake update</code> then <code>lake build</code><br>\nLocations: <code>T1_traces</code> (RevHalt.lean), <code>T2_impossibility</code> (RevHalt.lean), <code>T3_strong</code> (RevHalt.lean).</p>\n<p>thanks</p>",
        "id": 563577355,
        "sender_full_name": "John Doe",
        "timestamp": 1765583469
    },
    {
        "content": "<p>Was an LLM involved with writing the code or the documentation? It would be good to disclose that if so</p>",
        "id": 563579264,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765585070
    },
    {
        "content": "<p>And specifically, can you please elaborate on the degree to which you've used LLMs, and for what purposes? Using LLMs is fine in general, as long as it's clear exactly what they've been used for. :)</p>\n<p>Also, for some context on Kevin's assessment here: we occasionally get people coming to the Lean Zulip out of the blue who post LLM-generated code and text, making fanciful claims. Some text in the messages you've sent (and in the repo) looks very LLMish on first glance; plus, the promise of a new framework without specific reference to existing research makes it look at least superficially similar to those cases. Hopefully you can understand the skeptical reaction given the experiences we've had here!</p>\n<p>I've confirmed that your project does build, though, which is a great sign! :) (In many of the cases I've mentioned, this is not the case.)</p>",
        "id": 563579914,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1765585790
    },
    {
        "content": "<p>I’m anonymous because I want to be able to tell the truth without having to carry the personal weight of it.</p>\n<p>I’ve always had difficulties expressing my ideas in my native language and with mathematical notation. For years I’ve been thinking about these topics in my head using a private internal \"language\". A few years ago, the arrival of LLMs gave me an interlocutor that could sometimes rephrase my ideas into ordinary words — at a time when most people around me just found me “weird”, so I couldn’t really discuss these ideas productively.</p>\n<p>With an LLM, I was able to work by discussion: explore concepts, propose definitions, and iterate on many ideas. The hard part for me was determining whether my conclusions were actually true. That is how I discovered proof assistants.</p>\n<p>Since then, I continued essentially the same way as before (conceptual work first), except that after the “paper”/discussion stage we would attempt formalization. In practice: the Lean code (and most prose) in this repository is LLM-generated; my contribution was specifying the conceptual/definitional constraints, pushing the system to respect them, and iterating by building, reading errors, revising statements/definitions, and repeating until the development compiled. Even after that, I repeatedly rebuilt the development from scratch to improve clarity and to be sure the formalization matched the concepts I had in mind.</p>\n<p>A key part of my method is target selection. For me, the “targets” are structural constraints: constraints that are often implicit in standard notation, and which can look tautological or degenerate when stated explicitly. I focus on the ideas and the links between ideas, and I try to identify which additional constraint to target next in order to understand the overall constraint system. In practice, this is essentially a form of reverse engineering.</p>\n<p>This was roughly six years of work from scratch using dictionaries, Wikipedia, and books, and then with ChatGPT; now I’m at the point where part of those ideas can be expressed and checked formally.</p>\n<p>So the repository should be understood as <strong>LLM-generated Lean code and documentation</strong>, guided by my long-term conceptual and definitional constraints, rather than Lean code authored by me.</p>\n<p>I understand the skeptical reaction given past experiences here and given my method. For me this is first a way to confront my ideas, and also a way to express myself. I’ll add an explicit “LLM disclosure” section to the repo (including which models were used and for what) and keep the README strictly checkable (theorem statements, assumptions, file locations, and build instructions).<br>\n<strong>T1 is a “for each locality / observer” convergence statement.</strong></p>\n<p>Formally: for any kit <code>K</code> satisfying <code>DetectsMonotone K</code>, and for any trace <code>T</code>,</p>\n<p><code>Rev0_K K T ↔ Halts T</code>.</p>\n<p>Conceptually:</p>\n<ul>\n<li>\n<p><code>up</code> is a closure/stabilization of a trace: it turns any trace into a monotone one (once a witness appears, it stays witnessed).</p>\n</li>\n<li>\n<p><code>DetectsMonotone</code> is a structural constraint on observers: on monotone processes, the observer’s projection must coincide with existential truth (<code>∃ n, X n</code>).</p>\n</li>\n<li>\n<p>Therefore, after closing any trace with <code>up</code>, every admissible observer is forced to agree with standard halting. This is exactly why <code>T1_uniqueness</code> follows: any two valid kits are extensionally equivalent on all traces.</p>\n</li>\n</ul>\n<p>Repro: <code>lake build</code> (and see <code>T1_traces</code> / <code>T1_uniqueness</code> in <code>RevHalt.lean</code>).</p>",
        "id": 563585004,
        "sender_full_name": "John Doe",
        "timestamp": 1765591317
    },
    {
        "content": "<p>So with T1, it sounds like you're trying to say something about predicates on infinite binary sequences (which you call Traces). You've got 2 predicates (<code>Rev0_K</code> and <code>Halts</code>) and you've proved that they're equivalent if <code>DetectsMonotone</code> holds. That makes sense, but I'm wondering about the significance here.</p>\n<p>To review:</p>\n<p><code>Rev0_K</code> takes in a trace, converts it to Monotone by setting all indices after the initial 1 (if it exists) to 1, and calls the <code>proj</code> function of an <code>RHKit</code> object on this trace.</p>\n<p><code>Halts</code> is <code>true</code> if there's at least one 1 in the trace.</p>\n<p><code>DetectsMonotone</code> is a predicate that says that an <code>RHKit</code>'s <code>proj</code> function can detect whether or not a trace halts (contains a 1) if the trace is Monotone.</p>\n<p>Your theorem observes that <code>Rev0_K</code> (with some <code>RHKit</code>) and <code>Halts</code> are equivalent when <code>DetectsMonotone</code> is true. But we should expect that: <code>DetectsMonotone</code> means that <code>RHKit</code> can detect ones if the sequence is monotone, and we're monotonizing the sequence before we pass it in! As you observed in your lemma <code>exists_up_iff</code>, monotonizing a sequence preserves 1-existence, so it shouldn't be a surprise that a function which detects a 1 in Monotone sequences can always accomplish this when you pass it a monotonized sequence.</p>\n<p>The thing is that your <code>Monotone T</code> requirement in <code>DetectsMonotone</code> could be replaced by any property which is preserved by an operation and the theorem would still hold. In a general sense, what the theorem is stating is: \"if you have a function which detects a property P of an input when the input meets a  condition C, and if you can transform the input to meet that condition in a P-preserving way, then you can compose your function with the modifier to detect P for all inputs.\" The problem (to me, anyway) is that it isn't clear what this has to do with locality or observers. The terminology feels like it expresses more than the definitions actually capture.</p>\n<p>Just my 2 cents, though.</p>",
        "id": 563587057,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765593990
    },
    {
        "content": "<p>Also not trying to discourage you, btw! It can make sense to try to add rigor to a philosophical system even if the math isn't groundbreaking. What matters is that it helps you (and hopefully others) understand your ideas.</p>\n<blockquote>\n<p>constraints that are often implicit in standard notation, and which can look tautological or degenerate when stated explicitly</p>\n</blockquote>\n<p>could you provide an example of this? not sure what you're referring to here</p>",
        "id": 563587398,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765594574
    },
    {
        "content": "<p>My viewpoint here is dynamic-first: the primary objects are processes <code>T : ℕ → Prop</code> and stabilization/closure operators on them (not static predicates on finished objects).</p>\n<p>I take your point: T1 is immediate once you see <code>up</code> and the assumption <code>DetectsMonotone</code>. That is intentional. T1 is a coherence/interface lemma: it pins down what any admissible observer can return after stabilization. (“Observer” here just means a choice of kit / coding convention for projecting a stabilized trace; I’m not assuming or claiming any finitary, prefix-local, or computability property.)</p>\n<p>More broadly, this is part of an architectural approach: I’m designing a constraint system on dynamics so that the <strong>whole development</strong> is coherent and compositional, not a collection of unrelated lemmas. T1 is the coherence pin that makes later layers inherit observer-independence rather than re-proving it case-by-case.</p>\n<p>The intended effect is a form of dynamic self-consistency: admissibility + stabilization enforce global coherence by construction.</p>\n<p>More precisely: <code>DetectsMonotone</code> is the admissibility condition on kits (it specifies correctness on stabilized/monotone evolutions), and <code>up</code> is the stabilization operation. Then T1 says that for each admissible kit <code>K</code> (equipped with <code>DK : DetectsMonotone K</code>), the composed verdict <code>Rev0_K K := K.Proj ∘ up</code> is uniquely determined and coincides extensionally with <code>Halts</code> on all traces. So the significance is not computational hardness; it’s uniqueness-by-constraints / observer-independence: once you fix the admissibility criterion and the stabilization step, the space of possible observers collapses to a single extensional behavior. This is what makes downstream notions (e.g. bridges from traces to semantic consequence / provability instances) independent of the particular <code>K</code>, rather than artifacts of terminology.</p>\n<p>Re “implicit constraints”: one example is precisely the move from “eventually true” to a stabilized monotone witness predicate. Informally people talk about “detecting eventuality”, but they often implicitly assume the monotonicity convention (equivalently, invariance under <code>up</code>).</p>",
        "id": 563589355,
        "sender_full_name": "John Doe",
        "timestamp": 1765597285
    },
    {
        "content": "<p>In <code>RevHalt.lean</code> you state:</p>\n<blockquote>\n<p><code>T3 shows that Rev, as external truth, can always extend any sound theory</code></p>\n</blockquote>\n<p>but you don't mention <code>Rev</code> at all after <a href=\"https://github.com/JohnDoe-collab-stack/RevHalt/blob/0020241f0f8958256019c2e81317e619461bb268/RevHalt.lean#L162\">this line</a> which is at the start of your statement of T2, so I'm not sure how you proved anything about it</p>",
        "id": 563599116,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765608731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/Robust.20Reverse.20Halting/near/563599116\">said</a>:</p>\n<blockquote>\n<p>In <code>RevHalt.lean</code> you state:</p>\n<blockquote>\n<p><code>T3 shows that Rev, as external truth, can always extend any sound theory</code></p>\n</blockquote>\n<p>but you don't mention <code>Rev</code> at all after <a href=\"https://github.com/JohnDoe-collab-stack/RevHalt/blob/0020241f0f8958256019c2e81317e619461bb268/RevHalt.lean#L162\">this line</a> which is at the start of your statement of T2, so I'm not sure how you proved anything about it</p>\n</blockquote>\n<p>True, your observation is correct.</p>\n<p>RevHalt’s architecture is intentionally two-level:</p>\n<ul>\n<li>\n<p><strong>Abstract level (<code>RevHalt.lean</code>)</strong>: T2 and T3 are structural theorems proved for an arbitrary external predicate <code>RealHalts</code> inside a <code>TuringGodelContext'</code>. T3 is stated in terms of <code>Truth</code> / <code>ProvableSet</code>. <code>Rev</code> does not appear there — that’s by design.</p>\n</li>\n<li>\n<p><strong>Instantiated level (<code>Unified/Bridge.lean</code>)</strong>: the <code>TGContext_from_RM</code> / <code>EnrichedContext_from_Encoded</code> construction instantiates <code>RealHalts := Rev0_K K (rmCompile M e)</code>, and then <code>encode_correct</code> connects this <code>RealHalts</code> to <code>Truth (HaltEncode e)</code>. At this level, the T3 statement (sound strict extension of <code>ProvableSet</code>) is obtained for that instantiated context, in the same chain as T1 + T2 (+ T2’).</p>\n</li>\n</ul>\n<p>So if the question is “where is the link between Rev and T3 proved?”, it’s in <code>Unified/Bridge.lean</code> (and the <code>Unified/*</code> modules), not in <code>RevHalt.lean</code> alone.</p>\n<p>edit: </p>\n<p>My goal is not “redo Gödel inside ZFC”, but to exhibit a common reference frame.</p>\n<p>The <code>Unified/*</code> folder makes this explicit by factoring the development through an <strong>M/L/A/E interface</strong>:</p>\n<ul>\n<li>\n<p><strong>M</strong> = computation model (<code>RigorousModel</code>, <code>RMHalts</code>, <code>rmCompile</code>, <code>diagonal_halting</code>, <code>no_complement_halts</code>)</p>\n</li>\n<li>\n<p><strong>L</strong> = logic (<code>SoundLogicDef</code>: <code>Provable</code>, <code>Truth</code>, <code>Not</code>, <code>FalseP</code>, soundness/consistency/absurd, <code>truth_not_iff</code>)</p>\n</li>\n<li>\n<p><strong>A</strong> = arithmetization (<code>Arithmetization.repr_provable_not</code>)</p>\n</li>\n<li>\n<p><strong>E</strong> = halting encoding (<code>HaltEncode</code> with <code>encode_correct : RMHalts M e ↔ Truth (HaltEncode e)</code>)</p>\n</li>\n</ul>\n<p>At the <strong>abstract level</strong> (<code>RevHalt.lean</code> / <code>Unified/Core.lean</code>), T2/T3 are proved as <strong>structural theorems</strong> for any context satisfying this interface (in particular, for an abstract external predicate <code>RealHalts</code> in <code>TuringGodelContext'</code>, and for <code>Truth/ProvableSet</code> in <code>EnrichedContext</code>). They do not depend on ZFC specifically.</p>\n<p>Then <code>Unified/Bridge.lean</code> is the <strong>instantiation glue</strong>: it sets<br>\n<code>RealHalts := Rev0_K K (rmCompile M e)</code> (via <code>TGContext_from_RM</code>), and uses T1 (<code>T1_traces</code>) plus <code>rm_compile_halts_equiv</code> and <code>encode_correct</code> to connect that <code>RealHalts</code> back to the semantic side <code>Truth (HaltEncode e)</code>. This is where the slogan “Rev (via this instantiation of <code>RealHalts</code>) yields a sound strict extension” becomes literal, with T1 + T2 (+ T2’) + T3 proved in one chain (<code>RevHalt_Master_Complete</code>).</p>\n<p>What this architecture is meant to <em>exhibit</em> is compositionality/portability: once a theory/model provides an instance of <strong>M/L/A/E</strong>, the whole T1 → T2 → T2’ → T3 chain transports without rewriting proofs. This turns the framework into a reference/mapping layer for comparing different theories and models in the same format.</p>\n<p>Then, you have the folder <code>Demo/*</code></p>",
        "id": 563608773,
        "sender_full_name": "John Doe",
        "timestamp": 1765620808
    },
    {
        "content": "<p>I understand, and will work on the side of the community</p>",
        "id": 565401544,
        "sender_full_name": "John Doe",
        "timestamp": 1766715380
    }
]