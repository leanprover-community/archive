[
    {
        "content": "<p>Consider the following definition for a monoid homomorphism:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">isMonoidHom</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g'</span>\n</code></pre></div>\n<p>I understand that the tag <code>: Prop</code> marks the definition as a proposition rather than a general type, which is apparently useful. What's an example of work I can do with <code>isMonoidHom</code> that wouldn't be possible if I removed <code>: Prop</code> from the structure definition?</p>\n<p>Additional question: Why does this definition work even without <code>{G H : Type*}</code> as a first argument?</p>",
        "id": 461936790,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1723490031
    },
    {
        "content": "<p>1: make <code>DecidablePred isMonoidHom</code> typecheck. <br>\n2: because of an option called <code>autoImplicit</code>, which automatically adds such assumptions for symbols that arent in scope yet. this is disabled by default in mathlib, however.</p>",
        "id": 461937572,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723490311
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 461937706,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723490373
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>  Can you elaborate more on your answer to (1)? I was imagining something like a proof example that uses <code>isMonoidHom</code> and fails if <code>isMonoidHom</code> is not a propositional type.</p>",
        "id": 461938532,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1723490650
    },
    {
        "content": "<p>i have to admit, my answer was a bit of a cop-out. i think in most cases the proofs should be <em>managable</em>. i do think that it should make equality proofs and the like rather easier. if you didn't know, in lean types which themselves have type <code>Prop</code> have at most 1 element. because of this, lean can do some optimisation in what to store for elements of such types.</p>",
        "id": 461939872,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723491088
    },
    {
        "content": "<p>i think you <em>could</em> prove that <code>isMonoidHom f</code> is a so-called <em>subsingleton type</em>, and all relevant theorems <em>should</em> probably still work, however it's a lot easier to just let lean figure that out, and still reap the profits.</p>",
        "id": 461940210,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723491187
    },
    {
        "content": "<p>i seem to recall that for other statements (such as <code>a = b</code>), them being <code>Prop</code> <em>is</em> crucial, as there are models (e.g. HOTT) where two proofs of such a statement (or elements of such types) are not definitionally equal.</p>",
        "id": 461940720,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723491354
    },
    {
        "content": "<p>Makes a bit of sense; I'm vaguely familiar with propositions being singleton types. My issue is that I don't yet see what profits are to be reaped. Consider the following, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">isMonoidHom₁</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g'</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">isMonoidHom₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">map_one</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">map_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">g'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g'</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isMonoidHom₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isMonoidHom₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Here only <code>isMonoidHom₁</code> is marked as a propositional type, but the proof at the bottom works equally well for both definitions. I expected the second <code>example</code> to fail since <code>isMonoidHom₂ (id : G → G)</code> is not a proposition. So I haven't yet witnessed a situation where it actually helps to specify the structure as a propositional type. Can I appreciate any of the benefits of propositional types as a Lean beginner, or are they more subtle?</p>",
        "id": 461942289,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1723491866
    },
    {
        "content": "<p>i'd say the benefits are mostly things you don't think about, or things which you expect to be the case without thinking.</p>",
        "id": 461943174,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723492174
    },
    {
        "content": "<p>someone else might be able to give a convincing example though?</p>",
        "id": 461943383,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723492258
    },
    {
        "content": "<p>I'm satisfied with that, thanks!</p>",
        "id": 461943940,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1723492510
    },
    {
        "content": "<p>for what it's worth, there are proof assistants which manage without. (for example i believe Agda is one of those)</p>",
        "id": 461944437,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723492695
    },
    {
        "content": "<p>As another datapoint, mathlib frequently accidentally made such structures <code>: Type</code> rather than <code>: Prop</code>, and usually this went un-noticed for a long time. Probably the most obvious way to notice is <code>IsMonoidHom f ↔ _</code> doesn't typecheck if <code>IsMonoidHom _ : Type</code></p>",
        "id": 461957535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1723496667
    },
    {
        "content": "<p>The big difference between <code>Prop</code> and <code>Type u</code> is that <code>Prop</code> has propext, and so Lean can treat all instances of that type the same. This mostly comes up when dealing with dependent types. As an example of the opposite behavior making trouble for you, consider <code>Fin n</code>, where <code>n</code> is a <code>Nat</code> and thus data. Lean is significantly more limited in how much simplification it can do with data at the type level; if I have a <code>Fin n</code> and a <code>Fin n - 1 + 1</code>, these are <em>definitionally different types</em> to the compiler, and a \"proof\" that they are the same actually resolves into a <em>type cast</em> between the two, plus an assurance that this will always work out. Sometimes, this isn't enough to prove the thing you want; always, it tends to make life (and automation) difficult.</p>",
        "id": 461993064,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1723512993
    },
    {
        "content": "<p>(This specific example came up recently for me, as a side note)</p>",
        "id": 461993098,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1723513006
    },
    {
        "content": "<p>Putting a <code>Prop</code> into that sort of position can make things easier -- I believe <code>Foo h1</code> and <code>Foo h2</code> for <code>h1 h2 : p</code>, <code>p : Prop</code> are still different types, but it's now an extremely standardized and simple case where you can make a bunch of API for the exact same specific use case and your life is much easier doing it.</p>",
        "id": 461993392,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1723513151
    },
    {
        "content": "<p>No, they aren't, as proof irrelevance is definitional:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"n\">irreducible_def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">of_eq</span><span class=\"w\"> </span><span class=\"n\">P_def</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">P_def</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 462003089,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1723517085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"733453\">Nick Attkiss</span> <a href=\"#narrow/stream/113489-new-members/topic/What.20do.20propositional.20types.20do.20for.20us.3F/near/461942289\">said</a>:</p>\n<blockquote>\n<p>So I haven't yet witnessed a situation where it actually helps to specify the structure as a propositional type. Can I appreciate any of the benefits of propositional types as a Lean beginner, or are they more subtle?</p>\n</blockquote>\n<p>I think it's linked to the difference between a property and type of its proofs.<br>\nIf you trust the system, it might tell you that some property holds, without telling you how.<br>\nYou can imagine I have a proof, and I dont want to show it to you, but I show it to Lean, who can thus broker that information (I would actually love that ability).  Of course this proof that is being handed to you has no \"computational content\" to begin with.</p>\n<p>To give an example I just saw  in <a href=\"https://arxiv.org/abs/2403.12733\">Small Scale Reflection for the Working Lean User</a> where they use the property Even on Nat , which gets translated to  the type \"even : Nat -&gt; Prop\"</p>\n<p>If we had a \"categorical\" type system, with a category of proposition E on top of  B, a category of  types, we would have Even \\in E  sitting on top of Nat \\in B. And we could reflect  a property of E into B in a precise way  (this is called a comprehension), just like we transport a presheaf to its category of elements</p>\n<div class=\"codehilite\"><pre><span></span><code>in E             Even\n                  -- \n                 |  |\nin B             Nat -------&gt; Bool \n               /              / true\n             \\int Even -----&gt; 1\n</code></pre></div>\n\n<p>In their example the \"category of elements\" of Even,  \\int Even, is an inductive type <code>even : Nat -&gt; Prop</code> with the obvious two constructors. They focus on the unique morphism Nat -&gt; Bool, to show that its' useful to go back and forth, but that's beside the point.</p>\n<p>The bottom line is that intuitively, if it has <strong>Prop</strong> in it, it comes from the logical system above, you can't inspect it, and can't use it except to produce other prop,  and ultimately give them back to the logical system. I see the presence of Prop as being really about this 2 level system, one of which, E, we can't manipulate through terms.</p>\n<p>Concretely, it means we get <code>propext {a b : Prop} : (a ↔ b) → a = b</code>.<br>\nWe get the strongest thing in the book, defeq, because <code>a</code> and <code>b</code> are <code>Prop</code>.</p>",
        "id": 462070281,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1723543364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/What.20do.20propositional.20types.20do.20for.20us.3F/near/462003089\">said</a>:</p>\n<blockquote>\n<p>No, they aren't, as proof irrelevance is definitional:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"n\">irreducible_def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">of_eq</span><span class=\"w\"> </span><span class=\"n\">P_def</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">P_def</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Huh. Okay, good to know. And yeah, in that case all the more so, using <code>Prop</code>s when possible will greatly simplify your life  working with dependent types.</p>",
        "id": 462415516,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1723668622
    }
]