[
    {
        "content": "<p>The way the Mathlib documentation is available on <a href=\"https://leanprover-community.github.io/mathlib4_docs/index.html\">https://leanprover-community.github.io/mathlib4_docs/index.html</a>, together with direct links to the source code, is IMHO a huge advantage of Lean - I keep spending hours just trying to browse it, but that's just because there are lots of thing in there.</p>\n<p>I assume the documentation pages are extracted automatically from the source code, but I am a bit puzzled when the program doing the extraction strips out some information that seems key to understanding what a given theorem is about.</p>\n<p>Here's an example, from <code>## Mathlib.Topology.Algebra.InfiniteSum.Group</code>. Theorems <code>Summable.subtype</code> and <code>summable_subtype_and_compl</code> are both about summability of a function defined over a type, and summability of its restriction to a subtype. <code>Summable.subtype</code> provides an implication: if the function is summable on the whole type, then it is summable on a subtype; and <code>summable_subtype_and_compl</code> provides an equivalence: the function is summable if and only if its restrictions to a subtype and is complement are both summable.</p>\n<p>When you look at the source code (which is really about infinite products and, I suppose, converted to infinite sums by a little bit of black magic, but I assume more people will be familiar with infinite sums than infinite products, so I picked the additive version for my example), both theorem statements explicitly mention the subtype (by coercion from a <code>Set</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Multipliable</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>Yet, when you look at the theorem statements online, the former removes the reference to <code>s</code> and the latter doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Summable</span><span class=\"w\"> </span><span class=\"n\">f</span>\n</code></pre></div>\n<p>Of course, if you know about infinite sums, it's pretty easy to guess what <code>Summable.subtype</code> is really about (there is, after all, a <code>Set</code> mentioned in the arguments, and the name kinda gives it away), but I still find this both puzzling (why the different treatments?) and annoying (I tend to look at the source code to check that I'm getting it right).</p>\n<p>Why is it this way?</p>",
        "id": 529499807,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1752858904
    },
    {
        "content": "<p>it's pretty-printed</p>",
        "id": 529499902,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752858955
    },
    {
        "content": "<p>using the pretty-printer</p>",
        "id": 529500015,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752859009
    },
    {
        "content": "<p>this absolutely destroys the readability of any category theory stuff</p>",
        "id": 529500046,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752859025
    },
    {
        "content": "<p>OK but in one case it leaves a type annotation, and in the other it doesn't, and I still don't get why it does this.</p>",
        "id": 529500304,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1752859161
    },
    {
        "content": "<p>it's the pretty printer</p>",
        "id": 529500365,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752859192
    },
    {
        "content": "<p>it's somewhat type aware</p>",
        "id": 529500380,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752859201
    },
    {
        "content": "<p>It's an important problem, but at the moment we don't have much of a solution to these pretty printer issues. (There's <code>pp.analyze</code>, but it's not enabled for docgen, and it also likely needs a good amount of work to get it into shape again.)</p>\n<p>With your examples, the type ascriptions show up for <code>fun</code> binders (I'm not sure exactly why), which is different from term type ascriptions. It's not surprising that there could be a difference here.</p>",
        "id": 529500650,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752859313
    },
    {
        "content": "<p>People pointing out annoying things about the pretty printer has helped it make incremental progress. Not too long ago, dot notation didn't even have links, for example.</p>",
        "id": 529500859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752859397
    },
    {
        "content": "<p>It's not so much that it's stripping any data, it's that doc gen tries to print code (using the pretty printer) from a parsed representation that has already lost much of the formatting information, and this process is sadly imperfect</p>",
        "id": 529509753,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1752863590
    },
    {
        "content": "<p>Ah OK, so it's not working from the source code. </p>\n<p>At least I know it's not just an oversight, I'm not sure I understand why but the problem doesn't seem to be easy to solve. Thanks!</p>",
        "id": 529515428,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1752866674
    },
    {
        "content": "<p>Doc-gen basically takes the output of <code>#check</code> with a handful of extra pretty printer settings and then uses all the hover information to linkify the result. That at least can give you an idea of what you might expect from it when working from within Lean.</p>",
        "id": 529516664,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752867309
    }
]