[
    {
        "content": "<p>I have the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo2</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar1</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">foo1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar2</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">foo2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar1</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo2</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar2</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My question is, what's theoretically wrong with case splitting on <code>b</code> in this case since its constructor is determined entirely by <code>f</code>? I can understand that if the constructor had any <code>Type</code> args, they wouldn't be usable, but if it only has other <code>Prop</code>s it shouldn't be any issue I'd think.  In a real example, I'm trying to define a recursive function where the inductive proposition constructors have <code>Prop</code> argsI need to make the recursive call. Is there a good workaround for what I'm trying to achieve here?</p>",
        "id": 341371784,
        "sender_full_name": "sgcs",
        "timestamp": 1678684477
    },
    {
        "content": "<p>I'm not sure I quite understand your question. The reason why your example doesn't work is given in the error message produced by Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">induction'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Bar.casesOn'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>That is, you can't take a <code>Prop</code> (like <code>Bar</code>) and produce a non-<code>Prop</code> (like <code>Nat</code>) from it. For example, you can't do this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">p₁</span>\n  <span class=\"bp\">|</span> <span class=\"n\">p₂</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pToBool</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">p₁</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">p₂</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n</code></pre></div>\n<p>If this were possible, you could prove <code>False</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">p₁_eq</span> <span class=\"o\">:</span> <span class=\"n\">pToBool</span> <span class=\"bp\">.</span><span class=\"n\">p₁</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- by rfl</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">p₂_eq</span> <span class=\"o\">:</span> <span class=\"n\">pToBool</span> <span class=\"bp\">.</span><span class=\"n\">p₂</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- by rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">p₁_eq</span> <span class=\"bp\">▸</span> <span class=\"n\">p₂_eq</span>\n</code></pre></div>",
        "id": 341382273,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1678690225
    },
    {
        "content": "<p>What happens under the hood is that we erase Prop things at compile time so they are not actually there anymore when you run your code. Hence you can also not pattern natch</p>",
        "id": 341382601,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1678690386
    },
    {
        "content": "<p>Also note that if the \"<code>can only eliminate into Prop</code>\"-error wasn't an issue here (e.g. by having <code>test</code> return some <code>Prop</code>), then you could even match directly on <code>b</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar1</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar2</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 341382890,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1678690552
    },
    {
        "content": "<p>I understand the error message, what I'm saying is that the only way <code>b</code> can be constructed is completely defined by the value <code>f</code> is it not? Like if <code>f = Foo.foo1</code>, then <code>b = Bar.bar1</code></p>",
        "id": 341389612,
        "sender_full_name": "sgcs",
        "timestamp": 1678693420
    },
    {
        "content": "<p>The point being is that you aren't gaining any extra information computationally from my understanding, so I wouldn't think it'd be problematic</p>",
        "id": 341390002,
        "sender_full_name": "sgcs",
        "timestamp": 1678693568
    },
    {
        "content": "<blockquote>\n<p>Is there a good workaround for what I'm trying to achieve here?</p>\n</blockquote>\n<p>You can write your own \"destructors\" <code>Bar foo1 -&gt; True</code>, <code>Bar foo2 -&gt; True</code> (insert your actual propositions instead of <code>True</code>) and use those instead of a pattern match. I don't know whether that will help you overall, but at least you won't be stuck locally.</p>",
        "id": 341391412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678694153
    },
    {
        "content": "<p>(You can also achieve the same thing locally using <code>have h : [...] := match b with [...]</code>.)</p>",
        "id": 341391623,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678694228
    },
    {
        "content": "<p>There are other approaches as well, such as making <code>Bar</code> a function defined by cases on <code>Foo</code>, for which the individual types <code>Bar foo1</code>, <code>Bar foo2</code> support large elimination.</p>",
        "id": 341391844,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678694332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Matching.20on.20prop/near/341391412\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is there a good workaround for what I'm trying to achieve here?</p>\n</blockquote>\n<p>You can write your own \"destructors\" <code>Bar foo1 -&gt; True</code>, <code>Bar foo2 -&gt; True</code> (insert your actual propositions instead of <code>True</code>) and use those instead of a pattern match. I don't know whether that will help you overall, but at least you won't be stuck locally.</p>\n</blockquote>\n<p>Thank you! That gave me a workable solution. I've updated my example to show overall what I was trying to do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo1</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo2</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo0</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar1</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">bar2</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f₁</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"n\">f₂</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo2</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">elim_bar1</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar1</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">elim_bar2</span> <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo2</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Bar</span> <span class=\"n\">f₁</span> <span class=\"bp\">∧</span> <span class=\"n\">Bar</span> <span class=\"n\">f₂</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">bar2</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">b₁</span><span class=\"o\">,</span> <span class=\"n\">b₂</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo0</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">elim_bar1</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo2</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">b₁</span><span class=\"o\">,</span> <span class=\"n\">b₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">elim_bar2</span> <span class=\"n\">b</span>\n      <span class=\"n\">test</span> <span class=\"n\">b₁</span> <span class=\"bp\">+</span> <span class=\"n\">test</span> <span class=\"n\">b₂</span>\n</code></pre></div>",
        "id": 341393330,
        "sender_full_name": "sgcs",
        "timestamp": 1678694930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/Matching.20on.20prop/near/341391844\">said</a>:</p>\n<blockquote>\n<p>There are other approaches as well, such as making <code>Bar</code> a function defined by cases on <code>Foo</code>, for which the individual types <code>Bar foo1</code>, <code>Bar foo2</code> support large elimination.</p>\n</blockquote>\n<p>I'm not familiar with the idea of large elimination, doing some reading on it now</p>",
        "id": 341393452,
        "sender_full_name": "sgcs",
        "timestamp": 1678694986
    },
    {
        "content": "<p>It's the fancy name for what you wanted to do: do case analysis on a proposition to produce an element of a non-proposition.</p>",
        "id": 341436284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678707624
    },
    {
        "content": "<p>Lean has some rules for when it is allowed which I believe boil down to that there should be at most one constructor, which has only Prop fields.</p>",
        "id": 341436388,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678707658
    },
    {
        "content": "<p>Out of curiosity, do you mind sharing an example on how you could use large elimination with the above code snippet I made? I've done some reading, and the Lean docs actually mention subsingleton elimination which seems to be what you're describing, but I don't see how that'd apply to the example I gave (since there's more than one constructor).</p>",
        "id": 341453379,
        "sender_full_name": "sgcs",
        "timestamp": 1678712298
    },
    {
        "content": "<p>Right, you can't and that's why you got the original error</p>",
        "id": 341454675,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678712629
    },
    {
        "content": "<p>If you want an example where you can match on a <code>Prop</code>, there's matching on the <code>rfl</code> case of <code>h : a = b</code></p>",
        "id": 341455857,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678712859
    },
    {
        "content": "<p>I was referring to your statement:</p>\n<blockquote>\n<p>There are other approaches as well, such as making Bar a function defined by cases on Foo, for which the individual types Bar foo1, Bar foo2 support large elimination.</p>\n</blockquote>\n<p>I thought you were suggesting something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo0</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo1</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n  <span class=\"bp\">|</span> <span class=\"n\">foo2</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"n\">Foo</span>\n\n<span class=\"kd\">mutual</span>\n\n  <span class=\"kd\">inductive</span> <span class=\"n\">Bar1</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n    <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">Bar1</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">Bar</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Bar1</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Bar</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">foo1</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span>  <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But the mutual block doesn't seem to work, just get \"invalid mutual block\"</p>",
        "id": 341456011,
        "sender_full_name": "sgcs",
        "timestamp": 1678712886
    },
    {
        "content": "<p>Ah okay, if the inductive family <code>Bar</code> was recursive then this approach won't work (unless you can invert the whole inductive family to a recursive function of the index).</p>",
        "id": 341516620,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678726034
    },
    {
        "content": "<p>For your original <code>Bar</code> you would just return <code>True</code> in both cases of <code>Bar</code>, and then there is no <code>Bar1</code>.</p>",
        "id": 341516895,
        "sender_full_name": "Reid Barton",
        "timestamp": 1678726100
    }
]