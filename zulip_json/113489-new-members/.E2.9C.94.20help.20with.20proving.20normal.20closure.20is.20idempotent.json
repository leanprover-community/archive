[
    {
        "content": "<p>I'm trying to see if I can formalise some number field/ring theoretic things in lean, and with the use of mathlib I already managed to formalize the statement \"a ring has a unique element if and only if it doesn't have a prime ideal\".  This just ended up being some rehashing of statements already in mathlib. However I noticed that mathlib doesn't have much on normal closures yet. So I thought maybe I can prove that taking a normal closure is idempotent. To be precise I am trying to remove the sorry from this statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">normalClosureIdempotent</span> <span class=\"o\">[</span><span class=\"n\">Normal</span> <span class=\"n\">F</span> <span class=\"n\">L</span><span class=\"o\">]:</span> <span class=\"n\">normalClosure</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"n\">IntermediateField.lift</span> <span class=\"o\">(</span><span class=\"n\">normalClosure</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">normalClosure</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>There are a few statements in mathlib already regarding normal closures, however they do not seem to be very usefull her. However the definition of normalClosure  in mathlib is quite short:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">normalClosure</span> <span class=\"o\">:</span> <span class=\"n\">IntermediateField</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">f.fieldRange</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"n\">algebraMap_mem'</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">le_iSup</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f.fieldRange</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">IsScalarTower.toAlgHom</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Essentially it says (if I am not mistaken), that given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><mi>K</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">F \\to K \\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> the normal closure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> is just the subfield of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> generated by the images of all the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> ranges over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><msub><mi>m</mi><mrow><mi>F</mi><mo>−</mo><mi>a</mi><mi>l</mi><mi>g</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>K</mi><mo separator=\"true\">,</mo><mi>L</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom_{F-alg}(K, L)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span>.  Mathematically this would now be a \"one line proof\" directly from the definition. Since if we let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>:</mo><mo>=</mo></mrow><annotation encoding=\"application/x-tex\">N := </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span></span></span></span> <code>normalClosure F K L</code> then any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>K</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">f : K \\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> factors via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> <em>by definition</em> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and hence the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> in  <code>(⨆ f : K →ₐ[F] L, f.fieldRange)</code> and <code>(⨆ f : K →ₐ[F] N, f.fieldRange)</code> range over <em>essentially</em> the same set of morphisms. <br>\nHowever, my problem is I have no idea where to start even in unpacking the statement of the definition in the proof.</p>\n<p>So my question is how would one start proving such a thing directly from the definition?</p>",
        "id": 384862912,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692036050
    },
    {
        "content": "<p>(a tip: double <code>$$...$$</code> not single <code>$...$</code>s for math)</p>",
        "id": 384863542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692036153
    },
    {
        "content": "<p>Thanks, I fixed the formatting</p>",
        "id": 384865321,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692036443
    },
    {
        "content": "<p>It's done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6163\">#6163</a> (<code>normalClosure_of_normal</code>)</p>",
        "id": 384871284,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692037775
    },
    {
        "content": "<p>It is a quick one-line proof, but I think that this is helped by the refactor in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6163\">#6163</a> that changes <code>normalClosure</code> from <code>IntermediateField K L</code> to <code>IntermediateField F L</code> (this refactor also gets rid of the <code>lift</code> in your statement).</p>",
        "id": 384871968,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692037924
    },
    {
        "content": "<p>Hi Thomas, Thanks for the pointer to that merge request.  The proofs in there look short and clean. However a large part my question was more in a didactical sense \"I want to learn how to proof this kind of stuff in lean myself\", rather then a \"where can I find how to do this\".  Could you maybe say a few words on that? Like what made you come up with the idea that changing <code>def normalClosure</code> would make this easier? Or for example what the first steps would be in some of the slightly longer proofs like <code>lemma normalClosure_def'</code> and <code>lemma normalClosure_def'</code>.</p>",
        "id": 384890621,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692042458
    },
    {
        "content": "<p>P.s. it  seems that the normalClosure_of_normal is really proving something different than what I was trying to prove. <code>normalClosure_of_normal</code> proofs that if <code>K</code> is normal over <code>F</code> then <code>K</code> equals its normal closure.  However what I am trying to proof is maybe something I shouldn't have called idempotence of normal closure. Namely, I'm trying to proof that it really doesn't matter which field <code>L</code> one is trying to compute the normal closure in, als long as it is normal. And as a special case I was trying to prove that computing the normal closure in <code>L</code> and the normal closure in <code>normalClosure F K L</code> are the same thing.</p>",
        "id": 384895730,
        "sender_full_name": "Maarten Derickx",
        "timestamp": 1692043562
    },
    {
        "content": "<p>The proofs of <code>normalClosure_def'</code> and <code>normalClosure_def''</code> are a bit golfed, but it can be expanded to something more understandable:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">normalClosure_def'</span> <span class=\"o\">:</span> <span class=\"n\">normalClosure</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"bp\">=</span> <span class=\"bp\">⨆</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">K.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">normalClosure_def</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">iSup_le</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_iSup_of_le</span> <span class=\"o\">(</span><span class=\"n\">f.liftNormal</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"n\">a</span>\n    <span class=\"n\">use</span> <span class=\"n\">a.2</span>\n    <span class=\"n\">exact</span> <span class=\"n\">f.liftNormal_commutes</span> <span class=\"n\">L</span> <span class=\"n\">a</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">iSup_le</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_iSup_of_le</span> <span class=\"o\">(</span><span class=\"n\">f.comp</span> <span class=\"n\">K.val</span><span class=\"o\">)</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span> <span class=\"n\">a</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The general proof strategy is: Use the definition of the normal closure, and now you are trying to prove that one compositum equals another compositum. So you show that each field of one compositum is contained in a field of the other compositum.</p>",
        "id": 384914439,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692048906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"637200\">Maarten Derickx</span> has marked this topic as resolved.</p>",
        "id": 385419810,
        "sender_full_name": "Notification Bot",
        "timestamp": 1692177116
    }
]