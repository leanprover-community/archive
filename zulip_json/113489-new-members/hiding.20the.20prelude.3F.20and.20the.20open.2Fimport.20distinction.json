[
    {
        "content": "<p>I would like to hide some of the identifiers in <code>Init.Prelude</code>: specifically <code>Type</code>, <code>Monad</code>, <code>Functor</code>, <code>Applicative</code>. How might I go about doing so? </p>\n<p>Ordinarily I would do <code>open Namespace hiding Idents</code>, but since <code>Init.Prelude</code> is opened by default, I do not know how to do this.</p>",
        "id": 535923316,
        "sender_full_name": "JJ",
        "timestamp": 1756065826
    },
    {
        "content": "<p>Ah hm. I must have been holding the search wrong, because I swear I looked and nothing popped up. Past threads:</p>\n<ul>\n<li><a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Lean.20Hide.20Root.20Names.2FMacros/with/240219586\">#lean4 &gt; Lean Hide Root Names/Macros</a> </li>\n<li><a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/hiding.20from.20prelude/with/157751098\">#new members &gt; hiding from prelude</a> </li>\n<li><a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20How.20to.20hide.20something.20from.20.60_root_.60.20using.20.60open.60.3F\">#lean4 &gt; âœ” How to hide something from &#96;_root_&#96; using &#96;open&#96;?</a> </li>\n</ul>\n<p>These are all decently old. Is there any better way (than putting my code in a namespace) now? I would quite like it if something like <code>open Init.Prelude hiding X</code> was special-cased to let you hide stuff from the prelude...</p>",
        "id": 535923610,
        "sender_full_name": "JJ",
        "timestamp": 1756066095
    },
    {
        "content": "<p>Well, sticking <code>prelude</code> at the top of my file <em>does</em> work, despite <a href=\"https://lean-lang.org/doc/reference/latest/Source-Files-and-Modules/#Lean___Parser___Module___prelude\">the docs</a> advising against doing so. However, I can only <code>import Init.Prelude</code> afterwards, not <code>open Init.Prelude hiding X</code>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">prelude</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Init</span><span class=\"bp\">.</span><span class=\"n\">Prelude</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Monad'</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Why is this? The documentation says that \"importing a module has no effect on the set of currently open namespaces\". This <code>import Init.Prelude</code> line seems like it is certainly having an effect on the set of currently open namespaces, given it gives me naming conflicts with <code>Monad</code>...</p>",
        "id": 535924314,
        "sender_full_name": "JJ",
        "timestamp": 1756066803
    },
    {
        "content": "<p>I don't believe so. Maybe with the new module system it will eventually be possible, but I'm not sure.</p>\n<p>By the way, <code>open</code> is for namespaces, not modules. Lean's name hierarchy is global. Importing modules installs declarations into this name hierarchy. Using <code>open</code> is for being able to refer to names somewhere in this hierarchy without needing to fully qualify them. It's sort of like adding a temporary symbolic link for the current section.</p>\n<p>I assume you want to do this to use these top-level names for your own uses. That is not possible, due to the fact that Lean uses this global name hierarchy to identify declarations. The only way this is possible is if you use the <code>prelude</code> keyword and do not import <code>Init</code> at all, but then you lose much of Lean's functionality.</p>\n<p>The closest you can get is to put things into your own namespace and work from within that namespace.</p>",
        "id": 535924320,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756066805
    },
    {
        "content": "<p>I didn't say it explicitly, but <code>Init.Prelude</code> is a module, not a namespace.</p>",
        "id": 535924361,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756066848
    },
    {
        "content": "<p>Hmm, interesting. That explains why I can't use <code>open</code> on it, then. How come stuff gets imported without a prefix when I type <code>import Init.Prelude</code>, though? Is that just how modules work? I guess that makes sense, given the line \"Modules may add names to any namespace\" from the documentation.</p>",
        "id": 535924446,
        "sender_full_name": "JJ",
        "timestamp": 1756066946
    },
    {
        "content": "<p>Where can I read about the new module system, by the way?</p>",
        "id": 535924457,
        "sender_full_name": "JJ",
        "timestamp": 1756066959
    },
    {
        "content": "<p>Sticking my stuff in a namespace is probably what I'll end up doing <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 535924540,
        "sender_full_name": "JJ",
        "timestamp": 1756067048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634325\">JJ</span> <a href=\"#narrow/channel/113489-new-members/topic/hide.20prelude.3F/near/535924446\">said</a>:</p>\n<blockquote>\n<p>How come stuff gets imported without a prefix when I type <code>import Init.Prelude</code>, though?</p>\n</blockquote>\n<p>It's because the declarations in that module are in the root namespace.</p>\n<p>If you're used to languages like Python, orthogonal namespace and module systems might be unfamiliar. This is like C++, Common Lisp, and and some others. It's convenient because libraries can add extensions into the name hierarchy.</p>\n<p>Prefixing would be complicated. Remember that in each compiled module, the expressions have hard-coded references to fully-qualified constant names. All of these would need to be updated while importing, instead of mmaping the object files in, unless there were some sophisticated system to dynamically remap things. Or, all names would need to start with a module prefix, and then it would be up to name resolution to keep track of the mapping from module prefix to namespace prefix.</p>",
        "id": 535924756,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756067294
    },
    {
        "content": "<p><a href=\"https://lean-reference-manual-review.netlify.app/The-Module-System/#module-system\">https://lean-reference-manual-review.netlify.app/The-Module-System/#module-system</a></p>",
        "id": 535924905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756067449
    },
    {
        "content": "<p>Thanks! I'll read through that.</p>",
        "id": 535925150,
        "sender_full_name": "JJ",
        "timestamp": 1756067685
    },
    {
        "content": "<p>The decoupling of namespaces and modules is unintuitive to me, yeah. I would expect the second behavior you outlined to be how things work. In particular this sort of thing has always struck me as an issue with decoupling them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Test/Foo.lean</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Bazinga</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Bazinga</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Test/Bar.lean</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Bazinga</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Bazinga</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Test.lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">Foo</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">Bar</span>\n<span class=\"c1\">-- import Test.Bar failed, environment already contains 'Bazinga.foo' from Test.Foo</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>But I suppose given I have not hit this issue yet before just now trying to explicitly trigger it might mean that it is not a problem in practice. Interesting.</p>",
        "id": 535925160,
        "sender_full_name": "JJ",
        "timestamp": 1756067692
    },
    {
        "content": "<p>The new module system currently lets you control whether imported modules are re-exported, and to control whether imports are for compile time or compile time and run time.</p>",
        "id": 535925186,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756067711
    },
    {
        "content": "<p>Very fancy!</p>",
        "id": 535925203,
        "sender_full_name": "JJ",
        "timestamp": 1756067725
    },
    {
        "content": "<p>That's certainly an issue, but we think that's a programmer error.</p>\n<p>Using <code>private</code> declarations is a way to avoid collisions, for one-off auxiliary definitions you wouldn't use again.</p>",
        "id": 535925313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756067819
    },
    {
        "content": "<p>I think I mostly share that view. I would be really interested to see how the new module system interacts with dynamic linking, tbh! Especially the comptime/runtime dependency split.</p>\n<p>Also, my understanding is this sort of namespacing being tied to modules is important there, for coherence purposes, i.e. <a href=\"https://toot.cat/@Gankra/113522745584196985\">https://toot.cat/@Gankra/113522745584196985</a></p>",
        "id": 535925479,
        "sender_full_name": "JJ",
        "timestamp": 1756067999
    }
]