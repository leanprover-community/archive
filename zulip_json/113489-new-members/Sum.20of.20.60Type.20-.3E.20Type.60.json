[
    {
        "content": "<p>Are there standard constructor like Sum  for <code>Type -&gt; Type</code> or for more general kinds ?</p>\n<p>In Init/Core.lean we have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`Sum α β`, or `α ⊕ β`, is the disjoint union of types `α` and `β`.</span>\n<span class=\"sd\">An element of `α ⊕ β` is either of the form `.inl a` where `a : α`,</span>\n<span class=\"sd\">or `.inr b` where `b : β`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Sum</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Left injection into the sum type `α ⊕ β`. If `a : α` then `.inl a : α ⊕ β`. -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n  <span class=\"sd\">/-- Right injection into the sum type `α ⊕ β`. If `b : β` then `.inr b : α ⊕ β`. -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span> <span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ⊕ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum</span>\n</code></pre></div>\n<p>Alternatively is it better to go through categorical non sense : we can inherit a sum for  <code>Type ⥤ Type</code> through the monoidal properties of <code>Type</code> (where are those derivations ?)</p>\n<p>I am trying to recreate the classic higher order \"toolkit\" for defining data types, to define various  folds as categorical constructions</p>",
        "id": 400103899,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699007043
    },
    {
        "content": "<p>I don't understand your question; are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a> ? For <code>(Type -&gt; Type) ⊕ (Type -&gt; Type)</code>?</p>",
        "id": 400106489,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699007758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Sum.20of.20.60Type.20-.3E.20Type.60/near/400106489\">said</a>:</p>\n<blockquote>\n<p>are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a> ? For <code>(Type -&gt; Type) ⊕ (Type -&gt; Type)</code>?</p>\n</blockquote>\n<p>Not quite.</p>\n<p>Going the <code>Type -&gt; Type</code> way, that would simply be </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sum'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl'</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr'</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sum'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>The ordinary <code>Sum</code> being a particular case with constant <code>f</code> mapping to <code>a</code> and <code>g</code> mapping to <code>b</code><br>\nThat can help to define say <code>List a</code> as a least fix point of <code>ListF r =  ( ctt 1 ⊕ a * _ )  r</code> where we combine type constructors (and prove that they are functor later on)</p>\n<p>But we can also look at the structure on the <code>Type</code> category and combine functors type through the bunch of extra categorical properties of <code>Type</code>, deriving the functor sum  with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">When `C` is any category, and `D` is a monoidal category,</span>\n<span class=\"sd\">the functor category `C ⥤ D` has a natural pointwise monoidal structure,</span>\n<span class=\"sd\">where `(F ⊗ G).obj X = F.obj X ⊗ G.obj X`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">functor_category_monoidal</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_category</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>In that case <code>ListF r =  ( ctt 1 ⊕ a * _ )  r</code>would immediately be a functor <code>Type ⥤ Type</code></p>\n<p>I wonder if there's anything agreed upon on those line or should I do my own combinator library..</p>",
        "id": 400141143,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699020563
    },
    {
        "content": "<p>Your <code>Sum' f g a</code> is the same thing as <code>Sum (f a) (g a)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Sum'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">Sum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n    <span class=\"n\">toFun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl'</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">l</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr'</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">l</span>\n    <span class=\"n\">invFun</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inl'</span> <span class=\"n\">l</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">inr'</span> <span class=\"n\">l</span>\n    <span class=\"n\">left_inv</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">right_inv</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 400148182,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699022876
    },
    {
        "content": "<p>indeed. this pointwise business is very trivial. i would prefer to not define my own combinators</p>",
        "id": 400176265,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699031783
    },
    {
        "content": "<p>Is this sufficient for you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Function.Sum</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">⊕</span> <span class=\"n\">g</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 400176840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699032014
    },
    {
        "content": "<p>My question is : Is this Function.Sum in a standard library ?</p>\n<p>My issue is code reuse, for me, and for other people who might use my stuff.<br>\nYou can imagine if there was different versions of, say, <code>Functor</code>, doing the same things. and people building on top of different versions.</p>",
        "id": 400267284,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699084722
    },
    {
        "content": "<p>This is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs#Sum</a></p>",
        "id": 400267307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699084749
    },
    {
        "content": "<p>Not quite, it's an indexed/pointwise version of  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sum#doc\">docs#Sum</a>. <br>\nThis can be used as a \"toolkit\" to define data type.</p>\n<p>For instance in haskell</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">newtype</span><span class=\"w\"> </span><span class=\"kt\">K</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">K</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"kt\">Functor</span><span class=\"w\">             </span><span class=\"c1\">-- K for konstant</span>\n<span class=\"cm\">{- fmap _ (K a) = K a -}</span>\n<span class=\"kr\">newtype</span><span class=\"w\"> </span><span class=\"kt\">I</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">I</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"kt\">Functor</span><span class=\"w\">               </span><span class=\"c1\">-- I for identity</span>\n<span class=\"cm\">{- fmap k (I x) = I (k x) -}</span>\n<span class=\"kr\">newtype</span><span class=\"w\"> </span><span class=\"kt\">P</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"ow\">=</span><span class=\"kt\">P</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"kt\">Functor</span><span class=\"w\"> </span><span class=\"c1\">--P for product</span>\n<span class=\"w\"> </span><span class=\"cm\">{- will give (Functor f, Functor g) =&gt; Functor (P f g), such that</span>\n<span class=\"cm\">   fmap k (P (f x, g x)) = P (fmap k f x, fmap k g x) -}</span>\n<span class=\"kr\">newtype</span><span class=\"w\"> </span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Either</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"w\">         </span><span class=\"c1\">-- S for sum</span>\n<span class=\"kr\">instance</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Functor</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Functor</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=&gt;</span><span class=\"w\"> </span><span class=\"kt\">Functor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fmap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Left</span><span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"w\">  </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Left</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">fmap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"n\">fmap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Right</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span><span class=\"w\">  </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Right</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">fmap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">))</span>\n</code></pre></div>\n<p>allows to view integer binary tree as the least fixed point of the endofunctor</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">TreeF</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">S</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">K</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">P</span><span class=\"w\"> </span><span class=\"kt\">I</span><span class=\"w\"> </span><span class=\"kt\">I</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Tree</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Mu</span><span class=\"w\"> </span><span class=\"kt\">TreeF</span>\n</code></pre></div>\n<p>etc..</p>",
        "id": 400268262,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699085617
    },
    {
        "content": "<p>you will have difficulty defining least fixed point in that way</p>",
        "id": 400268490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699085822
    },
    {
        "content": "<p>more generally, lean does not promote \"point free\" style as much as haskell, plus it doesn't have as many restrictions regarding functions at the kind level, so if you want a lambda you can just use a lambda</p>",
        "id": 400268577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699085911
    },
    {
        "content": "<p>you could write <code>TreeF</code> much more clearly as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">TreeF</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Int</span> <span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>instead of writing combinatory logic</p>",
        "id": 400268709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699086053
    },
    {
        "content": "<p>As a data type I think it would be <code>unsafe inductive</code>, but I imagine I can Church encode it.</p>\n<p>Good to keep in mind for the style.</p>",
        "id": 400268724,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699086077
    },
    {
        "content": "<p>the more idiomatic way to write <code>Tree</code> itself would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n</code></pre></div>\n<p>and you can use metaprogramming to prove that this type is the LFP of <code>TreeF</code></p>",
        "id": 400268851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699086183
    },
    {
        "content": "<p>Oh I see ! Can I then extract some <code>TreeF</code> (and then build a fold) for this using metaprogramming ?</p>\n<p>(I remember there is some trick to extract <code>TreeF</code> from <code>Tree</code> in Haskell)</p>\n<p>Having combinators helps to derive the map of morphisms instead of manually writing them.<br>\nMaybe there is some clever way to get them back as well using metaprogramming ?</p>\n<p>I imagine I should look at \"metaprogramming in lean\" for this LFP and the rest ?</p>",
        "id": 400269518,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699086806
    },
    {
        "content": "<p>some of the details for this are worked out in our <a href=\"http://www.contrib.andrew.cmu.edu/~avigad/Papers/qpf.pdf\">QPF paper</a> but admittedly it's somewhat complicated to automatically extract functorial structure from arbitrary inductives</p>",
        "id": 400269895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1699087126
    },
    {
        "content": "<p>For reference to haskellers or otherwise,</p>\n<p>To recover the underlying functor of a regular inductive data type in haskell, it pattern matches on the typed generic representation.<br>\nThis Generic mechanism is part of the trusted core and is at work in <code>deriving Generic</code>.</p>\n<p>I imagine a similar mechanism could be part of a standard metaprogramming library  in Lean ?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-# LANGUAGE DataKinds #-}</span>\n<span class=\"cm\">{-# LANGUAGE DeriveGeneric #-}</span>\n<span class=\"cm\">{-# LANGUAGE GADTs #-}</span>\n<span class=\"cm\">{-# LANGUAGE PolyKinds #-}</span>\n<span class=\"cm\">{-# LANGUAGE TypeFamilies #-}</span>\n<span class=\"cm\">{-# LANGUAGE TypeOperators #-}</span>\n<span class=\"cm\">{-# LANGUAGE UndecidableInstances #-}</span>\n\n<span class=\"kr\">module</span><span class=\"w\"> </span><span class=\"nn\">Scratch</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n\n<span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">Data.Functor.Compose</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">C</span>\n<span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">Data.Functor.Constant</span>\n<span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">Data.Functor.Identity</span>\n<span class=\"kr\">import</span><span class=\"w\"> </span><span class=\"nn\">GHC.Generics</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kr\">family</span><span class=\"w\"> </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">U1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Constant</span><span class=\"w\"> </span><span class=\"nb\">()</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">K1</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"kt\">:+:</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"kt\">:+:</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"kt\">:*:</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"kt\">:*:</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">D1</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">M1</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">k</span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kr\">family</span><span class=\"w\"> </span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Identity</span>\n<span class=\"w\">  </span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Compose</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"kt\">Distrib</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Constant</span><span class=\"w\"> </span><span class=\"n\">o</span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Rose</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Leaf</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Rose</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Rose</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">]</span>\n<span class=\"w\">  </span><span class=\"kr\">deriving</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Generic</span><span class=\"p\">)</span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">ToFunc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">FG</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Rep</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Fix</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Fix</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Fix</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">))</span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Fix'</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Fix</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">ToFunc</span><span class=\"w\"> </span><span class=\"n\">f0</span><span class=\"p\">)</span>\n\n<span class=\"o\">*</span><span class=\"kt\">Scratch</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"kt\">:</span><span class=\"n\">kind</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"kt\">Fix'</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Rose</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span>\n<span class=\"kt\">Fix'</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Rose</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"o\">*</span>\n<span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Fix</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Constant</span><span class=\"w\"> </span><span class=\"nb\">()</span><span class=\"w\"> </span><span class=\"kt\">:+:</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Constant</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">:*:</span><span class=\"w\"> </span><span class=\"kt\">Compose</span><span class=\"w\"> </span><span class=\"kt\">[]</span><span class=\"w\"> </span><span class=\"kt\">Identity</span><span class=\"p\">))</span>\n</code></pre></div>",
        "id": 400291975,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1699098329
    }
]