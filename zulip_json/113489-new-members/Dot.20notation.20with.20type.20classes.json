[
    {
        "content": "<p>Hi all. I've been enjoying playing around with this language. One thing I appreciate, which you wouldn't necessarily expect, is that the language supports dot notation for calling functions. However, as far as I can tell, two of Lean's nice language features, type classes and dot notation, do not mix. Here's a minimal example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Doubleable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">doubled</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Doubleable</span><span class=\"bp\">.</span><span class=\"n\">quadruple</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Doubleable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">doubled</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">doubled</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Doubleable</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">doubled</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This works.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Doubleable</span><span class=\"bp\">.</span><span class=\"n\">quadruple</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n\n<span class=\"c1\">-- However, calling quadruple via dot notation does not.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quadruple</span>\n</code></pre></div>\n<p>Of course the final line fails because <code>quadruple</code> isn't defined in the <code>Nat</code> namespace. However, it seems interesting that functions can be inherited from another namespace when you extend a structure, but not when you make an instance of a type class. (EDIT: Maybe it's just that when A extends B, A can be coerced to B for free, so any function defined in B's namespace can be called on values of type A via dot notation.)</p>\n<p>Could anyone please tell me if I'm missing a viable approach for using dot notation with generic functions whose types are constrained by type classes?</p>\n<p>Thanks!</p>",
        "id": 513518324,
        "sender_full_name": "misterdrgn",
        "timestamp": 1745298815
    },
    {
        "content": "<p>There was some discussion about this earlier related to Digraphs in this thread: <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Weak.20components.20of.20a.20digraph/with/486801883\">#Is there code for X? &gt; Weak components of a digraph</a>, where the goal was to develop a <code>HasAdj</code> typeclass. If I understand correctly, this is currently not possible, but it might become possible in the future, see <a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a>. Even with this PR, I think you still can't directly use dot notation from typeclasses (maybe because doing so would be really bad for performance if every time  you wrote <code>x.y</code> it had to resolve every possible typeclass for x?)</p>\n<p>Do you have a specific use case in mind? It might be that there's a workaround for your particular use case that doesn't require the full generality of the unreleased <code>dotParam</code> widget.</p>",
        "id": 513528197,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745303935
    },
    {
        "content": "<p>Thanks for the response. I don’t have a particular use case, I’m more just curious about how fully Lean supports dot notation, given that type classes are obviously a core feature of the language. </p>\n<p>I find it interesting exploring the parallels between Lean and the Swift language, despite the languages having massively different primary purposes of course (I’ve been using Swift for CS research). Both languages allow you to essentially use types as namespaces and support dot notation for functions defined in a type’s namespace. But in Swift you can define a method for a protocol (protocols are like type classes, but without HKTs), and then you can call it on values of any type that implements that protocol via dot notation. </p>\n<p>The PR you linked would allow the same in Lean, with a key extra step—you have to add the function to the namespace of a type that instantiates the type class manually before you can call it via dot notation. So this would require more forethought and planning before you get the convenience of dot notation. </p>\n<p>Unless that extra step could be automated via metaprogramming, which is a part of Lean I’ve been meaning to explore.</p>",
        "id": 513593143,
        "sender_full_name": "misterdrgn",
        "timestamp": 1745324034
    },
    {
        "content": "<p>I think a key difference between typeclasses and Swift protocols is that typeclasses are more like a way to define Lisp generic functions (which dispatch on <em>all</em> arguments), but Swift protocols have a distinguished receiver.</p>\n<p>Lean typeclasses do not need to be \"for\" any particular type. In <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> for example, is it \"for\" the alpha or the gamma type argument? I might say 'neither', though gamma is defensible.</p>\n<p>The way Lean's dot notation works uses a fairly simple rule (at least to first approximation). If you write <code>x.f</code>, it elaborates <code>x</code> to see it has type <code>T ...</code>, then it looks for <code>T.f</code>, and then it looks for an argument to <code>T.f</code> whose type is of the form <code>T ...</code>. (Complications: can try unfolding <code>T ...</code> to <code>T' ...</code> and look for <code>T'.f</code>, it can make use of aliases, it can try unfolding arguments when looking for matches, and it can even try coercing <code>T.f</code> to a function. Also, if <code>x</code> is a structure, it can also walk up the parent hierarchy an insert <code>toParent</code> coercions.)</p>\n<p>So, when it comes to typeclasses and dot notation, here are some problems:</p>\n<ul>\n<li>Typeclasses might be called <em>type</em>classes, but they're not for any particular type. (There might not even be any types! That's very rare though.)</li>\n<li>The fields of a typeclass might not obviously mention the type. (It's not like Swift where every protocol member has an implicit \"self\" argument. There <em>is</em> an implicit \"self\" argument for typeclass fields in Lean, but it's for the typeclass instance itself.) So, there may be no way to apply the function.</li>\n</ul>\n<p>Possibly we could have a way to annotate an instance (for arguments sake, suppose you add the attribute <code>@[protocol]</code>), which checks that the typeclass is protocol-like and registers the instance as being a way to resolve dot notation for that class for the specified type argument. Or, perhaps the class itself can be registered using <code>@[protocol]</code> and whenever an instance is made it registers dot notation. Something that would need to be answered here is exactly when in the dot notation resolution would protocol methods be considered. Also, for multi-parameter typeclasses, how you can specify which argument is the receiver. (One might also take the convention that the first explicit argument should be the receiver universally for protocols.)</p>\n<p>Niels linked to one PR (<a href=\"https://github.com/leanprover/lean4/pull/6267\">lean4#6267</a>, the dotParam widget). Another is <a href=\"https://github.com/leanprover/lean4/pull/6393\">lean4#6393</a>, for permanently exporting namespaces, which with dotParam would be a way to add \"mixins\" to a type (you would define an instance for a class and then <code>export</code> its fields into the type's namespace). These are ways to solve the more general problem \"how do I use generic functions using dot notation\". I think the <code>@[protocol]</code> idea could be implemented using these primitives, but you would need to manually add in <code>dotParam</code> widgets.</p>",
        "id": 513687334,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745349748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks for the long response. I take your point about the ambiguity in which type to treat as the “receiver” of a Lean type class’s generic functions. I do think the ‘dotParam’ keyword in the first PR does a decent job of resolving this ambiguity. In this case, the only issue is needing to export each generic function in the type class’s namespace into a type’s namespace before you can use dot notation with it. Maybe that other PR addresses that by allowing you to export the type class’s entire namespace all at once, but I wasn’t quite sure about that. </p>\n<p>Are these PRs on their way into Lean’s main branch, or are they still being considered?</p>\n<p>Thanks for the help.</p>",
        "id": 513852109,
        "sender_full_name": "misterdrgn",
        "timestamp": 1745409709
    }
]