[
    {
        "content": "<p>Reading <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html\">Mathematics in Lean</a>, I'm noticing examples showing alternative syntax for some patterns:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ubf</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ubg</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fnUb_add</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ubf</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ubg</span>\n<span class=\"w\">    </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fnUb_add</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ubg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FnHasUb</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ubf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ubg</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fnUb_add</span><span class=\"w\"> </span><span class=\"n\">ubfa</span><span class=\"w\"> </span><span class=\"n\">ubgb</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>This is how it's explained in the book:</p>\n<blockquote>\n<p>In the first example, if you put your cursor after <code>cases ubf</code>, you will see that the tactic produces a single goal, which Lean has tagged <code>intro</code>. (The particular name chosen comes from the internal name for the axiomatic primitive that builds a proof of an existential statement.) The <code>case</code> tactic then names the components. The second example is similar, except using <code>next</code> instead of <code>case</code> means that you can avoid mentioning <code>intro</code>. The word <code>match</code> in the last two examples highlights that what we are doing here is what computer scientists call “pattern matching.” Notice that the third proof begins by <code>by</code>, after which the tactic version of <code>match</code> expects a tactic proof on the right side of the arrow. The last example is a proof term: there are no tactics in sight.</p>\n<p>For the rest of this book, we will stick to <code>rcases</code>, <code>rintro</code>, and <code>obtain</code>, as the preferred ways of using an existential quantifier. But it can’t hurt to see the alternative syntax, especially if there is a chance you will find yourself in the company of computer scientists.</p>\n</blockquote>\n<p>I understand in general that when the syntax is expressive, there's often multiple ways to do the same thing. But these particular ones leave me curious:</p>\n<ul>\n<li>Is <code>next</code> really just a sugar for <code>case intro</code>? Is this sugar <em>that</em> necessary? Does it serve any other function than removing a single word?</li>\n<li>Is <code>matches</code> <em>that</em> uncomfortable for mathematicians that <code>cases</code> becomes necessary? Are mathematicians uncomfortable with pattern matching for whatever reason? This \"especially if there is a chance you will find yourself in the company of computer scientists\" explanation shows up in a few places in the book and I'm curious about the cultural reasons at play here.</li>\n</ul>\n<p>Overall is there any effort to streamline Lean going forward and reduce the variety of syntaxes that do the same thing? Or is the variety seen as a positive thing in this case, and different subsets of communities pick different styles?</p>",
        "id": 498616008,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739120576
    },
    {
        "content": "<p>I'm guessing maybe one way to think about it is that there's really two languages at play here. The underlying language where you only write in terms. And a higher-level macro language (tactic mode). And so <code>match</code> is a lower language construct (that is technically possible to use directly) while <code>cases</code> etc are the higher level construct (and fit better into the higher language's flow)?</p>",
        "id": 498616198,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739120730
    },
    {
        "content": "<ul>\n<li><code>next</code> gets the next goal, but <code>case intro</code> gets the goal named <code>intro</code> (you can see the goal names right above the goals in the infoview)</li>\n<li><code>matches</code> didn't exist originally, and also it has some slightly different properties. <code>cases</code> is able to drive the case analysis when there's no <code>with</code> clause too.</li>\n</ul>",
        "id": 498616282,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739120775
    },
    {
        "content": "<p>(Side note: <code>match</code> isn't the lower-level construct exactly, since its arms are tactic sequences. You can see in the file for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.evalMatch#doc\">docs#Lean.Elab.Tactic.evalMatch</a> that there's some code for translating to the term <code>match</code>. It's a fairly straightforward translation though, and it's fair to say that the tactic <code>match</code> \"is\" the term <code>match</code>. By the way, I wouldn't say that tactics are lower or higher than terms. Both tactics and terms can run arbitrarily complicated elaboration programs. The <code>match</code> term elaborator is significantly more complicated than the <code>cases</code> tactic elaborator.)</p>",
        "id": 498616639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739121061
    },
    {
        "content": "<p>I see <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>, so here's something to think about: Both tactic and term elaboration drive the lower-level metaprogramming interface. Both tactics and terms can use terms or tactics for elaboration (i.e., they can be macros for the other). It's not correct to say that tactic mode is \"a higher-level macro language\", and it's a common misconception. Tactics can be faster than the corresponding term proof; term elaboration is complicated.</p>\n<p>There's no frontend language that gives you direct access to the underlying expression language, but one could build one easily enough.</p>",
        "id": 498617224,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739121599
    },
    {
        "content": "<p>What's true is that the term language is very similar to the underlying expressions, so it does give you a good idea of low-level Lean, much better than the tactic language can give you, which is much more indirect.</p>",
        "id": 498617324,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739121652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20so.20many.20ways.20to.20do.20the.20same.20thing.3F/near/498617224\">said</a>:</p>\n<blockquote>\n<p>There's no frontend language that gives you direct access to the underlying expression language, but one could build one easily enough.</p>\n</blockquote>\n<p>What do you mean by this?</p>",
        "id": 498617467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739121784
    },
    {
        "content": "<p>The \"actual\" terms are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a>, and the terms you write in Lean are a higher-level language than that. I'm saying you could make a simple language that has very little elaboration overhead, if it were to engage with Lean.Expr more directly. It would be unpleasant to work with of course — the elaborator makes things significantly more convenient!</p>",
        "id": 498617905,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739122120
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 498619199,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739123093
    },
    {
        "content": "<p>Makes sense, thanks. Is there an easy way to see the underlying expressions in VS Code?</p>\n<p>Also, I'm still curious — how does one generally choose between <code>match</code> and <code>cases</code>? Is the convention to mostly use <code>cases</code> unless we bump into something it doesn't handle? Is there a general style guide for what's preferred to use over what?</p>",
        "id": 498619301,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739123167
    },
    {
        "content": "<p>I reach for <code>cases</code> out of old habit (I started with Lean 3), though the pattern language of <code>obtain</code> is powerful, and I use it more often than <code>cases</code>. It has the <code>rfl</code> pattern too, which <code>match</code> doesn't have.</p>\n<p>If you like <code>match</code>, then you should feel free to use it. One of the benefits is that it subsumes both <code>cases</code> and <code>induction</code> in a way, since with <code>match</code> you can recursively use the theorem being defined. If it's a valid recursion scheme, then the theorem goes through.</p>",
        "id": 498619451,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739123324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Why.20so.20many.20ways.20to.20do.20the.20same.20thing.3F/near/498619301\">said</a>:</p>\n<blockquote>\n<p>Makes sense, thanks. Is there an easy way to see the underlying expressions in VS Code?</p>\n</blockquote>\n<p>Does <code>#print declaration_name</code> show you want you want? You can also try adding <code>set_option pp.all true in</code> on the line before <code>#print</code> to see even more.</p>",
        "id": 498620934,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1739124574
    },
    {
        "content": "<p>You can also put <code>show_term</code> in front of specific terms or tactics that you want to see how they expand.</p>",
        "id": 498627067,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739129629
    }
]