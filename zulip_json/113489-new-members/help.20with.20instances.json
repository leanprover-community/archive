[
    {
        "content": "<p>Can somebody please help me understand what is going on here? I have a means of generating a preorder from a variable (2 variables in my mwe below). I would like to fix those variables for the scope of a section and introduce a preorder instance for the current scope. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">po</span> <span class=\"o\">:</span> <span class=\"n\">place</span> <span class=\"bp\">→</span> <span class=\"n\">preorder</span> <span class=\"n\">copland</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">po</span> <span class=\"n\">p</span> <span class=\"c1\">-- po p : preorder copland</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"kd\">instance</span> <span class=\"n\">xmpl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">copland</span> <span class=\"o\">:=</span> <span class=\"n\">po</span> <span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"n\">xmpl</span> <span class=\"c1\">-- xmpl : (place → preorder copland) → place → preorder copland</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">copland</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c1</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n<span class=\"c\">/-</span><span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">po : place → preorder copland,</span>\n<span class=\"cm\">p : place,</span>\n<span class=\"cm\">c1 c2 : copland</span>\n<span class=\"cm\">⊢ has_le copland-/</span>\n</code></pre></div>\n<p>So, basically, Lean knows <code>po p : preorder copland</code>, and I'm looking for a way of introducing that as an instance. But the only way I know of creating instances gives me a dependent type that creates instances from variables instead of the desired instance.</p>",
        "id": 305707568,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666558254
    },
    {
        "content": "<p>I believe the problem is that you're making the instance dependent on a variable <code>p</code>, which means every instance will depend on that variable. One solution would be to make the variables into constants, so that definitions don't depend on them as variables. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">po</span> <span class=\"o\">:</span> <span class=\"n\">place</span> <span class=\"bp\">→</span> <span class=\"n\">preorder</span> <span class=\"n\">copland</span>\n<span class=\"kd\">constant</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">po</span> <span class=\"n\">p</span> <span class=\"c1\">-- po p : preorder copland</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"kd\">instance</span> <span class=\"n\">xmpl</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"n\">copland</span> <span class=\"o\">:=</span> <span class=\"n\">po</span> <span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"n\">xmpl</span> <span class=\"c1\">-- xmpl : (place → preorder copland) → place → preorder copland</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">copland</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c1</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n</code></pre></div>",
        "id": 305709948,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666559708
    },
    {
        "content": "<p>You'll notice that the instance is now noncomputable. This is because we're saying \"we have the ingredients to create a preorder on <code>copland</code>, but we haven't defined them... we've only asserted that they're there.\" Lean can't compute without a definition to compute with.</p>",
        "id": 305710150,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666559849
    },
    {
        "content": "<p>I don't think making the variables implicit does what I want. I still get the error on the last line saying that Lean can't find an instance of <code>has_le</code> for copland.</p>",
        "id": 305710775,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560243
    },
    {
        "content": "<p>yeah sorry, I think I actually had it right the first time!</p>",
        "id": 305710827,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666560269
    },
    {
        "content": "<p>just reverted to the original</p>",
        "id": 305710832,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666560274
    },
    {
        "content": "<p>Indeed the constants work, but it feels unnatural.</p>",
        "id": 305710892,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560309
    },
    {
        "content": "<p>This might be an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem; what are you actually trying to do?</p>",
        "id": 305710915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666560327
    },
    {
        "content": "<p>Well, I'm in the middle of a project in which I have various ways of defining preorders on two different types that have similar (but not identical) structure. I'm trying to show that results about the preorders on one of the types transport to corresponding results about the preorders on the other.</p>",
        "id": 305711180,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560509
    },
    {
        "content": "<p>I can certainly make progress using constants as <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span>  suggested, but it seems like there should be another way.</p>",
        "id": 305711235,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560559
    },
    {
        "content": "<p>you might want to define two separate preorder instances rather than having them depend on variables... otherwise you're saying there are as many preorder instances are there are <code>p</code> and <code>po</code> (though maybe that's true?)</p>",
        "id": 305711363,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666560619
    },
    {
        "content": "<p>You're going against the design by defining several preorders on the same type.</p>",
        "id": 305711445,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666560672
    },
    {
        "content": "<p>The correct thing to do here is to use type synonyms of the types you're overloading.</p>",
        "id": 305711469,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666560693
    },
    {
        "content": "<p>In my project, <code>po</code> is actually not a variable, but <code>p</code> is.  And there really <em>are</em> as many preorders as there are <code>p</code>. But I don't care what <code>p</code> is. I just want to fix an arbitrary <code>p</code> for the duration of the development.</p>",
        "id": 305711574,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  I'm not sure I follow. Much of the point of the project is to show how to define different preorders on the same type. Are you suggesting I create carbon copies of the underlying type with a new name and define preorders on them? I'm not sure what type synonyms are or how they work.</p>",
        "id": 305711794,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666560892
    },
    {
        "content": "<p>Yeah, so do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[nolint unused_arguments]</span>\n<span class=\"kd\">def</span> <span class=\"n\">my_type_synonym</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">my_type_synonym</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 305711796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666560893
    },
    {
        "content": "<p>The point is that Lean can infer what <code>p</code> is from seeing <code>my_type_synonym p</code>. In constrast, when Lean sees <code>copland</code>, it has no idea what <code>p</code> should be!</p>",
        "id": 305711948,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666560998
    },
    {
        "content": "<p>I must be doing something wrong in the below. I still get the error in the last line.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coplandA</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">po</span> <span class=\"o\">:</span> <span class=\"n\">place</span> <span class=\"bp\">→</span> <span class=\"n\">preorder</span> <span class=\"n\">copland</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">coplandA</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">po</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">coplandA</span> <span class=\"n\">p</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c1</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n<span class=\"c\">/-</span><span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">po : place → preorder copland,</span>\n<span class=\"cm\">p : place,</span>\n<span class=\"cm\">c1 c2 : coplandA p</span>\n<span class=\"cm\">⊢ has_le (coplandA p)-/</span>\n</code></pre></div>",
        "id": 305712317,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666561220
    },
    {
        "content": "<p>I think <code>po</code> has to be a dependent Pi type?</p>",
        "id": 305712481,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666561335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> is this right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coplandA</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">po</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">),</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">coplandA</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">po</span> <span class=\"n\">p</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"kd\">instance</span> <span class=\"n\">xmpl</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">coplandA</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">po</span> <span class=\"n\">p</span>\n<span class=\"k\">#check</span> <span class=\"n\">xmpl</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">coplandA</span> <span class=\"n\">p</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c1</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n</code></pre></div>",
        "id": 305712532,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666561377
    },
    {
        "content": "<p>Surely <code>po</code> should not be a variable but an instance?</p>",
        "id": 305712589,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666561436
    },
    {
        "content": "<p>I expect you need to know its definition.</p>",
        "id": 305712657,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666561469
    },
    {
        "content": "<p>yeah sorry, I was just trying to fill in the blanks for <span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span>, I'm sure he can replace that with the actual definition</p>",
        "id": 305712763,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666561531
    },
    {
        "content": "<p><code>sorry</code> is a much clearer way to highlight what needs filling!</p>",
        "id": 305712855,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666561570
    },
    {
        "content": "<p>It works when I put that solution into my real project where <code>po</code> really is defined, and not a variable.</p>",
        "id": 305712896,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666561615
    },
    {
        "content": "<p>yeah I think Yael was just pointing out that I should've written it like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coplandA</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"kd\">instance</span> <span class=\"n\">xmpl</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">coplandA</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#check</span> <span class=\"n\">xmpl</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">c1</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">coplandA</span> <span class=\"n\">p</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c1</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n</code></pre></div>",
        "id": 305712924,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666561636
    },
    {
        "content": "<p>And at this point you can even scrap the <code>local attribute</code>.</p>",
        "id": 305713089,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666561737
    },
    {
        "content": "<p>true!</p>",
        "id": 305713154,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666561785
    },
    {
        "content": "<p>Right! The only reason I had it be local is because I didn't want to clobber any default instances. The type synonyms will ensure that each instance for its own copy of the type.</p>",
        "id": 305713177,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666561802
    },
    {
        "content": "<p>Yes exactly!</p>",
        "id": 305713223,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1666561813
    },
    {
        "content": "<p>This does feel much cleaner!</p>",
        "id": 305713230,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666561820
    },
    {
        "content": "<p>Thanks for the help (as always)</p>",
        "id": 305713245,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666561839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300396\">Paul Rowe</span> has marked this topic as resolved.</p>",
        "id": 305713257,
        "sender_full_name": "Notification Bot",
        "timestamp": 1666561849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300396\">Paul Rowe</span> has marked this topic as unresolved.</p>",
        "id": 305724976,
        "sender_full_name": "Notification Bot",
        "timestamp": 1666569523
    },
    {
        "content": "<p>It's not as smooth sailing as I had hoped! I actually rely heavily on the inductive structure of the underlying type for which I'm defining a type synonym. It seems the type synonym doesn't give me access to the constructors. Or rather, if I use them, Lean seems to coerce it back to the original type. </p>\n<p>I'm too tired to generate a mwe. I'll come back sometime tomorrow. But if there's any obvious advice in the meantime, I'll take it. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 305725525,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666569868
    },
    {
        "content": "<p>One way to fix that is to make copies of the constructors but with a type that uses the type synonym instead of the original</p>",
        "id": 305738689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666580252
    },
    {
        "content": "<p>I assume the <code>reducible</code> attribute wouldn't help here, right?</p>",
        "id": 305738751,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666580313
    },
    {
        "content": "<p>Instead of a type synonym, can the indices be added to the inductive type itself!</p>",
        "id": 305758229,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666594927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span>  I've never encountered the <code>reducible</code> attribute, but it seems to do the trick! The symptom was not being able to compare two terms of the new type synonym using <code>≤</code> if the constructors were explicit. Using <code>reducible</code> seems to make it work. I will look up what it does, but is there a nice explanation of what it does?</p>",
        "id": 305819902,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666618376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Does your suggestion essentially amount to creating a duplicate type without it being a true type synonym? If not, I'm not sure what you mean.</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  Are you suggesting I force the original type to carry the extra parameter <code>p</code>? I'm not sure I like that since other results about that type truly don't need it. Sorry if I'm misunderstanding.</p>",
        "id": 305820648,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666618588
    },
    {
        "content": "<p>like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">place</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">copland</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coplandA</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">copland</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coplandA.mk</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">coplandA</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">copland.mk</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">place</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">xmpl</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">coplandA</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">c2</span> <span class=\"o\">:</span> <span class=\"n\">coplandA</span> <span class=\"n\">p</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">coplandA.mk</span> <span class=\"mi\">5</span> <span class=\"bp\">≤</span> <span class=\"n\">c2</span>\n</code></pre></div>",
        "id": 305821029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666618706
    },
    {
        "content": "<p>it's up to you whether <code>p</code> needs to be explicit or not in <code>coplandA.mk</code></p>",
        "id": 305821113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1666618731
    },
    {
        "content": "<p>I see. What will happen if I try to apply <code>cases</code> to a term of type <code>coplandA p</code>? The type actually has numerous constructors.</p>",
        "id": 305821562,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666618849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span> I'm actually not completely sure what <code>reducible</code> does myself... also, I seem to have a habit of giving advice that technically works but isn't the right solution <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> so I hope someone else can come along and verify that <code>reducible</code> is appropriate here</p>\n<p>I'm curious to know if it's documented anywhere</p>",
        "id": 305862005,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666629872
    },
    {
        "content": "<p>One small wrinkle that I have run across with using <code>reducible</code> is that it breaks the separation of the type synonyms. What I mean is that if I have two type synonyms for the same type and they are both reducible, then they are in conflict. I can fix this by making the <code>reducible</code> attribute local, which eliminates one of the benefits of the approach. That said, I think I'll keep moving forward with this as it has provided me the least resistance so far.</p>",
        "id": 305862848,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666630150
    },
    {
        "content": "<p>Also found a nice reference sheet <a href=\"https://leanprover.github.io/tutorial/A1_Quick_Reference.html\">here</a>.</p>\n<p>From that reference: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">reducible</span>       <span class=\"o\">:</span> <span class=\"n\">unfold</span> <span class=\"n\">at</span> <span class=\"n\">any</span> <span class=\"n\">time</span> <span class=\"n\">during</span> <span class=\"n\">elaboration</span> <span class=\"k\">if</span> <span class=\"n\">necessary</span>\n<span class=\"n\">quasireducible</span>  <span class=\"o\">:</span> <span class=\"n\">unfold</span> <span class=\"n\">during</span> <span class=\"n\">higher</span> <span class=\"n\">order</span> <span class=\"n\">unification</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"n\">not</span> <span class=\"n\">during</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"n\">resolution</span>\n<span class=\"n\">semireducible</span>   <span class=\"o\">:</span> <span class=\"n\">unfold</span> <span class=\"n\">when</span> <span class=\"n\">performance</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">critical</span>\n<span class=\"n\">irreducible</span>     <span class=\"o\">:</span> <span class=\"n\">avoid</span> <span class=\"n\">unfolding</span> <span class=\"n\">during</span> <span class=\"n\">elaboration</span>\n</code></pre></div>",
        "id": 305866852,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666631442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span> nice! is it possible that something like <code>quasireducible</code> might provide the benefits without the drawbacks?</p>",
        "id": 305878199,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666632370
    },
    {
        "content": "<p>I also wonder if using <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#unfold\">tactic#unfold</a> manually would work</p>",
        "id": 305879056,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666632663
    },
    {
        "content": "<p>I thought about <code>quasireducible</code> too, but since I got unstuck, I'm having too much fun proving new things. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> You must be right about <code>unfold</code> since that's clearly what reducible is doing for me behind the scenes.</p>",
        "id": 305879340,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666632752
    },
    {
        "content": "<p>I don't think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quasireducible\">docs#quasireducible</a> (note: no suggestions provided by the docs) exists in Lean 3; I've never seen it in the wild</p>",
        "id": 305900843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666640295
    },
    {
        "content": "<p>Ah yes! I blew right by the comment at the top of the reference:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Note</span> <span class=\"n\">that</span> <span class=\"n\">this</span> <span class=\"n\">quick</span> <span class=\"n\">reference</span> <span class=\"n\">guide</span> <span class=\"n\">describes</span> <span class=\"n\">Lean</span> <span class=\"mi\">2</span> <span class=\"n\">only.</span>\n</code></pre></div>",
        "id": 305901620,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1666640621
    },
    {
        "content": "<p>Was it changed to <code>instance</code> reducible? That exists in lean 3 and isn't on that reference list.</p>",
        "id": 306632586,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1666955896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/113489-new-members/topic/help.20with.20instances/near/306632586\">said</a>:</p>\n<blockquote>\n<p>Was it changed to <code>instance</code> reducible? That exists in lean 3 and isn't on that reference list.</p>\n</blockquote>\n<p>How does that work? Is there documentation on it?</p>",
        "id": 306689245,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1666972104
    },
    {
        "content": "<p>I was thinking of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.transparency\">docs#tactic.transparency</a>, but it looks like that is somehow the opposite</p>",
        "id": 306696780,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1666974073
    }
]