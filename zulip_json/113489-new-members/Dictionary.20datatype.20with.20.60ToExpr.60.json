[
    {
        "content": "<p>I have been using <code>Std.HashMap K V</code> as a \"default choice\" when it comes to dictionary data structure.<br>\nToday, I encountered a case where I need a dictionary with <code>ToExpr</code> instance, but <code>Std.HashMap</code> doesn't seem to provide it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"c1\">-- this fails</span>\n</code></pre></div>\n<p>Would it be possible to derive <code>ToExpr</code> for <code>Std.HashMap</code> easily? I tried something like follows quickly, but it fails for unknown reason:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">List</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Prod</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">toExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">toExpr</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Std.HashMap.toList</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Level</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">toTypeExpr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">`Std.HashMap</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Level</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toTypeExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toTypeExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">))</span>\n<span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">boo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">10</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">30</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">50</span><span class=\"o\">)]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"n\">boo</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">toExpr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- fails to find typeclass instance but why??</span>\n</code></pre></div>\n<p>.<br>\n.</p>\n<p>If defining <code>ToExpr</code> for <code>Std.HashMap</code> is not straightforward, I am looking for an alternative dictionary data structure which</p>\n<ul>\n<li>is traversable (which excludes <code>K → Option V</code>)</li>\n<li>comes with <code>ToExpr</code></li>\n<li>easily serializable to/deserializable from <code>String</code></li>\n</ul>\n<p>I can compromise computational efficiency.</p>\n<p>I can think of something like <code>Lean.AssocList</code> or <code>K → Option V</code> together with its domain, would there be better choices?</p>",
        "id": 496474056,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738128646
    },
    {
        "content": "<p>I'm interested in this, too.</p>",
        "id": 496552454,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1738158565
    },
    {
        "content": "<p>If you want to serialize and deserialize from string why are you looking into <code>ToExpr</code>?</p>",
        "id": 496553540,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738158892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> Because I am using it inside my elaborator, and (I think) term elaborators should return <code>Expr</code> at the end of the day.</p>",
        "id": 496623110,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738177058
    },
    {
        "content": "<p>so why are you looking into serialisation from and to strings then?</p>",
        "id": 496623259,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738177091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  The elaborator returns this dictionary which gets used in other parts of my program, and in this \"other parts\" I need serialization/deserialization. Thinking again about it, being \"traversable\" kind of subsumes this constraint - for whatever dictionary type <code>Dict</code> that supports <code>toList/ofList</code>, I can serialize/deserialize using these that.</p>",
        "id": 496624446,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738177466
    },
    {
        "content": "<p>That sounds really hacky to me, can you give an example of what you are trying to achieve?</p>",
        "id": 496624513,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738177500
    },
    {
        "content": "<p>I expect you'd be better served by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.ToJson#doc\">docs#Lean.ToJson</a></p>",
        "id": 496625161,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738177738
    },
    {
        "content": "<p>Using <code>ToExpr</code> is like trying to do serialization/deserializing by turning data into executable programs that the receiver has to run. That can't be the best way! (Plus it has massive security implications if you're not in total control of the data.)</p>",
        "id": 496625400,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738177827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> If serialization/deserialization part sounds hacky to you, please forget about them: this was for debugging purposes. Fyi, I ended up using <code>AssocList</code> for my purpose and it worked, but I am still curious if I can stick to <code>Std.HashMap</code> somehow.</p>\n<p>And here is an example that explains why I want <code>ToExpr</code> for a dictionary. I am writing a term elaborator for SMT formula that additionally \"infer\"s declarations. For example, given this syntax: <code>S|x &amp;&amp; y</code>, I want it to be \"eventually\" translated to the following smtlib2 query.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">declare</span><span class=\"bp\">-</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">assert</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">check</span><span class=\"bp\">-</span><span class=\"n\">sat</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note that in the example above, the type of the variables <code>x</code> and <code>y</code> are not explicitly specified but inferred from the formula  (I know this is not always possible and I have ways to explicitly declare variables, but that is orthogonal). For this, I have wrote an elaborator that returns <code>Q(AST * Dict Ident Ty)</code> (an abstract syntax tree for the formula and a dictionary for inferred declarations). This <code>Dict Ident Ty</code> is then later used for generating the above smtlib2 query.</p>",
        "id": 496630018,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738179531
    },
    {
        "content": "<p>I would suggest to architecture your elaborator in such a way that the serialisation step to expr is simply not necessary in that case, I don't see why you should be forced to perform a serialisation step in order to achieve what you are trying to do</p>",
        "id": 496630201,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738179600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> To avoid possible confusion - I was using serialization only to mean serialization to <code>String</code>, and please forget about them. For <code>ToExpr</code> - isn't it the case that a term elaborator needs to return an <code>Expr</code> at the end?</p>",
        "id": 496631675,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738180163
    },
    {
        "content": "<p>Sure but I don't see the need to keep pushing and pulling any sort of map around to achieve that</p>",
        "id": 496631953,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738180261
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I don't see what you mean, can you elaborate?</p>",
        "id": 496632332,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738180410
    },
    {
        "content": "<p>If you are writing a term elaborator that elaborator can still maintain some internal datastructures and only return one big expression for an entire term that it is working on. You can have a quotation like <code>[smtlib| &lt;smtstuff here&gt;]</code> and write a single term elaborator that just does whatever you want and returns a final expression for your smtlib stuff in the end</p>",
        "id": 496632585,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738180508
    },
    {
        "content": "<p>But I can't be concrete unless you actually show us some code you are working on</p>",
        "id": 496632623,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738180524
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> </p>\n<blockquote>\n<p>If you are writing a term elaborator that elaborator can still maintain some internal datastructures and only return one big expression for an entire term that it is working on.</p>\n</blockquote>\n<p>Sure. If I am returning a <code>String</code> for smtlib expression directly from the elaborator in one go, I wouldn't need to expose those <code>AST</code> or <code>Dict Ident Ty</code> and just return <code>Q(String)</code> right away. But I have procedures outside the elaborator that act on <code>AST</code> and <code>Dict Ident Ty</code> type (e.g., doing traversal and some basic simplification). And here <code>Dict Ident Ty</code> is <em>not</em> just an internal data structure for an elaborator - this is a new information acquired during elaboration and gets used outside the elaborator.</p>\n<p>Anyway, I guess this specific example could lead us to a rabbit hole. Coming back to the original question: is it the case that quoting dictionary-like structure to <code>Expr</code> and returning it in the term elaboration considered a bad practice? If so, what would be the reason? (are there particular anti-patterns here?) I was thinking that it is fine to return anything (quoted to <code>Expr</code>) in the term elaborator.</p>",
        "id": 496638403,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738182793
    },
    {
        "content": "<p>Well clearly serializing and deserializing a datstructure over and over again within a single system is significant overhead that should never be necessary if the system was architectured properly.</p>",
        "id": 496638589,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738182867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"748258\">Youngju Song</span> <a href=\"#narrow/channel/113489-new-members/topic/Dictionary.20datatype.20with.20.60ToExpr.60/near/496638403\">said</a>:</p>\n<blockquote>\n<p>Coming back to the original question: is it the case that quoting dictionary-like structure to <code>Expr</code> and returning it in the term elaboration considered a bad practice?</p>\n</blockquote>\n<p>Yes, it's an anti-pattern.</p>\n<p>Generally complex elaborators are not built out of individual term elaborators. There's a single main entry point that sets up its own elaboration strategy with its own intermediate data structures.</p>",
        "id": 496638774,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738182953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I don't see how \"quoting dictionary-like structure to <code>Expr</code>\" has to mean serializing/deserializing over and over again. If you are talking about my specific example above, it doesn't: there is a function <code>elab_aux (...): TermElabM (AST × Dict Ident Ty)</code> that does the recursion and I call <code>ToExpr</code> only once in the main entry point <code>elab := (elab_aux ...) &lt;&amp;&gt; toExpr</code>. <br>\n<span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> For \"internal\" datastructures, yes, sure. I completely agree that it never needs to quote an \"internal\" data structure (that gets used only inside a term elaborator) to <code>Expr</code>. Just to be clear: I am not doing that. Those \"internal\" datastructures are set up in the \"single main entry point\" in my case as well. It is just that the dictionary here is genuinely <em>not</em> an \"internal\" data structure. And (from the conversation above) since it seemed like quoting a dictionary is considered evil regardless of its nature, I was curious to know why.</p>",
        "id": 496641359,
        "sender_full_name": "Youngju Song",
        "timestamp": 1738184040
    },
    {
        "content": "<p>It's not that quoting a dictionary is an antipattern — I don't see any problem with that, provided the dictionary data is not used in the current stage. The antipattern is reinterpreting the dictionary data from the Expr.</p>",
        "id": 496828724,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738257425
    }
]