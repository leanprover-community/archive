[
    {
        "content": "<p>I am still trying to understand what Mathlib knows about infinite sums (other than \"generally speaking, more than I do\"), and when browsing the documentation on github, I notice that sometimes the documentation leaves things out that make it hard to understand what is going on.</p>\n<p>An example is <code>Summable.summable_compl_iff</code> in Mathlib/Topology/Algebra/InfinteSum/Group.lean, which (as I understand by looking at the source code) says that if a sub-family is summable, then the complement sub-family is summable if and only if the full family is. But, when looking on github, the hypothesis appears as <code>hf: Summable (f o Subtype.val)</code>, and the same appears in the equivalence statement, leaving out _which_ subtype one is talking about. The name makes it somehow clearer, but I still find this confusing.</p>\n<p>Is this some secondary effect of the way the documentation is extracted from the source code? The statement in the source contains type annotation which are lost in the extracted documentation, and which make the meaning much clearer.</p>\n<p>Of course in this case I was looking for the right statement and the name helped me find it, but it seems likely that there will be other, similar cases, that are not that obvious.</p>\n<p>Also, on a slightly different matter, but still about infinite sums: Mathlib/Topology/Algebra/InfiniteSum/Real.lean has a lemma <code>summable_partition</code> that deals with the summability of an infinite family when it is arbitrarily partitioned - but only when the values are reals. Is there a good reason for this restriction? (I might very well be missing conditions that are required, but would something similar not hold in significantly more general situations?)</p>",
        "id": 482221262,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1731517658
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Summable.summable_compl_iff#doc\">docs#Summable.summable_compl_iff</a></p>",
        "id": 482227328,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1731519774
    },
    {
        "content": "<p>So I think what you're asking about is that in the source we have those expressions <code>(f ∘ (↑) : s → α)</code> and <code>(f ∘ (↑) : ↑sᶜ → α)</code> with explicit type annotation and those get lost in the rendered code in the documentation. What's going on here is that the documentation tooling parses the lean code, and then writes out some code from the parsed representation (this is called \"pretty printing\"), but this process can unfortunately lose information. We don't yet have code that will present the parsed representation into code that is guaranteed to be equivalent to the code you had in the first place. This is a known but hard problem</p>",
        "id": 482233764,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1731521973
    },
    {
        "content": "<p>If you want to know what the code actually means, your best bet is to write <code>#check the_theorem_name</code> in a live lean session, and then click around the result</p>",
        "id": 482234050,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1731522083
    },
    {
        "content": "<p>The reason <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=summable_partition#doc\">docs#summable_partition</a> is stated for series of non-negative reals is because it's false otherwise. Let <code>α = β = ℕ</code>, let <code>s n</code> be the finite set <code>{2 * n, 2 * n + 1}</code> and let <code>f n = (-1) ^n</code>. Then <code>f</code> is not summable, but the expression on the RHS is. So it needs the order assumption that <code>0 ≤ f</code>; that means it has to be stated in a complete linearly ordered space, and there aren't very many of those.</p>",
        "id": 482238363,
        "sender_full_name": "David Loeffler",
        "timestamp": 1731523671
    },
    {
        "content": "<p>Oh yeah, I missed the fact that the partition was quantified outside of the equivalence. So it was not, in fact, the lemma I was looking for - I was looking for one that would let me arbitrarily partition a summable family (and only looking for an implication, really, where <code>summable f</code> would be the assumption).</p>",
        "id": 482258144,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1731530835
    }
]