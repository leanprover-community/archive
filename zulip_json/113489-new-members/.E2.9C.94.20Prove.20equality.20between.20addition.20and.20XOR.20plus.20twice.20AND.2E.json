[
    {
        "content": "<p>Hi everyone, I'm trying to prove the following lemma: (n + m) = (n XOR m) + 2 * (n AND m).<br>\nThis is very useful one that could help convert addition into bitwise-compatible operations, which is easier to use. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">FiniteDimensional</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eq_iff_eq_all_bits</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h_eq</span><span class=\"w\"> </span><span class=\"c1\">-- h_eq : n = m</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h_all_bits</span><span class=\"w\"> </span><span class=\"c1\">-- h_all_bits: ∀ k, (n &gt;&gt;&gt; k) &amp;&amp;&amp; 1 = (m &gt;&gt;&gt; k) &amp;&amp;&amp; 1</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">eq_of_testBit_eq</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">testBit</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_and_eq_mod_two</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_two_bne_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">beq_eq_beq</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">and_one_is_mod</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_all_bits</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_all_bits</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">sum_eq_xor_plus_twice_and</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">^^^</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Initially, I intend to reason equality on each corresponding pair of bits of lhs and rhs (e.g. using <code>eq_iff_eq_all_bits</code> below). However, I still couldn't figure it out.<br>\nDo you have any idea on how to prove this? Thank you.</p>",
        "id": 524204351,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1750062520
    },
    {
        "content": "<p>As always, the strategy is to prove it on paper first.</p>",
        "id": 524204759,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750062668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.20equality.20between.20addition.20and.20XOR.20plus.20twice.20AND.2E/near/524204759\">said</a>:</p>\n<blockquote>\n<p>As always, the strategy is to prove it on paper first.</p>\n</blockquote>\n<p>Thank you so much for your great advice. I sat down and wrote out the proof draft on paper, and finally I managed to finish it using <code>Nat.binaryRec</code>, performing induction from the LSB to the MSB for both <code>n</code> and <code>m</code> in the same pace.</p>",
        "id": 524239419,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1750075028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815212\">Chung Thai Nguyen</span> has marked this topic as resolved.</p>",
        "id": 524239457,
        "sender_full_name": "Notification Bot",
        "timestamp": 1750075043
    }
]