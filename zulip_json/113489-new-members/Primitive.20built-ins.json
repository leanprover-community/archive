[
    {
        "content": "<p>Can I find somewhere a list of primitives that are not constructed using inductive types or other means? I would like to have this on an informal level. Something like </p>\n<ul>\n<li>Universes (<code>Sort u</code>)</li>\n<li>Function types (<code>→</code>)</li>\n<li>Lambda abstraction (<code>λ x ↦ ...</code>)</li>\n<li>Inductive type mechanism (<code>inductive</code>)</li>\n</ul>",
        "id": 515633842,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1746159260
    },
    {
        "content": "<p>Does the list of constructors for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr#doc\">docs#Lean.Expr</a> help? That covers your first three items, and I think after that only <code>inductive</code> types and <code>Quot</code> are the remaining primitives</p>",
        "id": 515634160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746159471
    },
    {
        "content": "<p>In that list, note that .mvar and .fvar only exists for terms that are currently being constructed, once a proof is finished it won't contain any .mvar or .fvar expressions. Also, .mdata, .lit, and .proj aren't really that important.</p>\n<p>So, if you just care about what Lean's expressions are made of, all that's left is</p>\n<ul>\n<li>Universes (<code>Sort u</code>)</li>\n<li>Dependent function types, aka forall types, aka pi types. Function types (<code>→</code>) are a special case</li>\n<li>Function application (i.e. if <code>f</code> is a function and <code>x</code> is a term then <code>f x</code> is a term)</li>\n<li>Lambda abstractions</li>\n<li>References to the variables bound by lambda abstractions (these use de Bruijn indices)</li>\n<li>References to <em>constants</em>, i.e. terms previously defined with <code>def</code>, <code>theorem</code>, <code>inductive</code>, <code>structure</code>, <code>axiom</code>, etc.</li>\n<li>Let expressions (i.e. <code>let x := a; b</code>)</li>\n</ul>",
        "id": 515642797,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746164648
    },
    {
        "content": "<p>Thanks a lot! </p>\n<p>A slightly tangential follow-up question: I am thinking <code>theorem</code> as a special case of <code>def</code>, and <code>structure</code> as a special case of <code>inductive</code>. Is there any reason not to?</p>",
        "id": 515644630,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1746165625
    },
    {
        "content": "<p>Structures are a special case of inductive types, distinguished by having exactly one constructor.</p>",
        "id": 515648952,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746167645
    },
    {
        "content": "<p><code>theorem</code> is basically a <code>def</code> and <code>structure</code> and <code>inductive</code>, yes. But you could still argue that non-recursive inductive types with exactly one are actually special cased in that they have the eta rule:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Because of this the recursor can also be reduced:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Example</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">≡</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n</code></pre></div>\n<p>In this sense you can also think of projections to be the primitive instead of the recursor for \"structure\" inductives.</p>",
        "id": 515703204,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1746189248
    },
    {
        "content": "<p>So these are all builtins:</p>\n<ul>\n<li>Universes (<code>Sort u : Sort (u + 1)</code>)</li>\n<li>Pi types (<code>(a : α) → β(a) : Sort (imax u v)</code> for <code>α : Sort u</code> and <code>β(a) : Sort v</code>)</li>\n<li>Function application (<code>f x : β(a)</code> for <code>f : (a : α) → β(a)</code> and <code>x : α</code>)</li>\n<li>Lambda abstractions (<code>fun x : α =&gt; f(x) : (a : α) → β(a)</code> for <code>f(x) : β(x)</code>)</li>\n<li>Let expressions (<code>let x : α := a; b(x) : β</code> for <code>b(a) : β</code>) (optional because equivalent to substitution)</li>\n<li>References to bound variables from <code>let</code>s and lambda abstractions and pi types</li>\n<li>Inductive types (e.g. <code>Nat : Sort (0 + 1)</code>)</li>\n<li>Constructors of inductive types (e.g. <code>Nat.zero : Nat</code> / <code>Nat.succ : Nat → Nat</code>)</li>\n<li>Projections for non-recursive inductive types with one constructor (e.g. <code>x.1 : α</code> for <code>x : Prod α β</code>)</li>\n<li>Recursors of other inductive types (e.g. <code>Nat.rec.{u} : {motive : Nat → Sort u} → motive Nat.zero → ((n : Nat) → motive n → motive (Nat.succ n)) → (n : Nat) → motive n</code>)</li>\n<li>Definitions (e.g. <code>Nat.add :  Nat → Nat → Nat</code>) (optional because equivalent to substitution)</li>\n<li>Quotient primitives (<code>Quot.{u} : {α : Sort u} → (α → α → Sort 0) → Sort u</code>, <code>Quot.mk.{u} : {α : Sort u} → (r : α → α → Sort 0) → α → Quot r</code>, <code>Quot.ind.{u} : {α : Sort u} → {r : α → α → Sort 0} → {β : Quot r → Sort 0} → ((a : α) → β (Quot.mk r a)) → (q : Quot r) → β q</code>, <code>Quot.lift.{u, v} : {α : Sort u} → {r : α → α → Sort 0} → {β : Sort v} → (f : α → β) → ((a : α) → (b : α) → r a b → Eq (f a) (f b)) → Quot r → β</code>)</li>\n<li>Axioms (e.g. <code>propext : {p : Sort 0} → {q : Sort 0} → Iff p q → Eq p q</code>)</li>\n</ul>\n<p>And then <code>Prop ≡ Sort 0</code>, <code>Type u ≡ Sort (u + 1)</code>, <code>\"theorem ≡ def\"</code>, <code>\"structure ≡ inductive\"</code> and so on</p>",
        "id": 515707576,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1746190609
    },
    {
        "content": "<p>Thanks a lot! This is very helpful. I would have two questions.</p>\n<ol>\n<li>When you say \"optional because equivalent to substitution\" what do you mean more precisely?</li>\n<li><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#what-makes-dependent-type-theory-dependent\">Dependent Type Theory section of Theorem Proving in Lean 4</a> mentions dependent function types and dependent Cartesian product types (or sigma types). What is the relation between these and Pi types?</li>\n</ol>",
        "id": 515832076,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1746239088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819062\">Lauri Oksanen</span> <a href=\"#narrow/channel/113489-new-members/topic/Primitive.20built-ins/near/515832076\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#what-makes-dependent-type-theory-dependent\">Dependent Type Theory section of Theorem Proving in Lean 4</a> mentions dependent function types and dependent Cartesian product types (or sigma types). What is the relation between these and Pi types?</li>\n</ol>\n</blockquote>\n<p>In Lean, Pi types are a built-in primitive, and Sigma types (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma#doc\">docs#Sigma</a>) are an inductive. \"dependent function type\" is another name for Pi type.</p>",
        "id": 515832828,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746239559
    }
]