[
    {
        "content": "<p>Hi everyone, I'm Daniel, a math student. For the past few years, I've been studying type theory, logic, and computability, and lately I've been very interested in working on formalization. This is my first project: a formalization of lambda calculus and a proof of the Church-Rosser theorem. It's nothing groundbreaking; I based it on other existing repositories.</p>\n<p><a href=\"https://github.com/Danelnov/Lambda-Calculus-Formalization\">project link</a></p>\n<p>I would appreciate any suggestions or recommendations regarding my project. My experience with Lean has been fascinating; I find it an incredible tool with great potential for research, which is why I've decided to write my undergraduate thesis on formalization. I plan to formalize some theorems.</p>",
        "id": 554740854,
        "sender_full_name": "Daniel Patiño",
        "timestamp": 1762791580
    },
    {
        "content": "<p>Mathlib has a list of 1000+ theorems --- and the Church-Rosser theorem is still listed as unformalised in Lean (which is no longer true). Would you like to make a PR adding your formalisation to the list? You want to modify <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/docs/1000.yaml\">https://github.com/leanprover-community/mathlib4/blob/master/docs/1000.yaml</a> (search for \"Church-Rosser\" to find the entry to tweak), and follow the instructions <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a> on how to contribute.</p>",
        "id": 554795353,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762810279
    },
    {
        "content": "<p>(If you prefer not to, somebody else can also do this for you: but since you did the work, in my opinion you also deserve the honour of making that pull request yourself.)</p>",
        "id": 554795431,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762810311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"988174\">Daniel</span> <a href=\"#narrow/channel/113489-new-members/topic/My.20first.20Lean.20project/near/554740854\">said</a>:</p>\n<blockquote>\n<p>I would appreciate any suggestions or recommendations regarding my project</p>\n</blockquote>\n<p>Would you be willing to submit this to cslib? They already have your <a href=\"https://github.com/leanprover/cslib/blob/61296f14bcbe0713eecfb377e5776006ae1f95bb/Cslib/Foundations/Data/Relation.lean#L22\">definition of <code>Diamond</code></a>, and a proof of <a href=\"https://github.com/leanprover/cslib/blob/61296f14bcbe0713eecfb377e5776006ae1f95bb/Cslib/Languages/CombinatoryLogic/Confluence.lean#L10-L17\">Church-Rosser for SKI calculus</a>, but not for lambda calculus AFAIK</p>",
        "id": 554803878,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1762813880
    },
    {
        "content": "<p>I had never considered the possibility of making a pull request. I would like to do it, but I consider this formalization of lambda calculus using de Bruijn indices to be very complicated and I don't think it's suitable for inclusion in any library. I'm currently working on a more elegant and less complicated formalization of the lambda calculus; I'll submit the pull request when I finish it. Thanks for the recommendations.</p>",
        "id": 554971300,
        "sender_full_name": "Daniel Patiño",
        "timestamp": 1762884704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"988174\">@Daniel</span> Sorry to not see this until now! I see from the README you referenced one my repos that eventually became part of CSLib. However we only moved over the locally nameless representation (for which we do have a proof of confluence <a href=\"https://leanprover.github.io/cslib/docs/Cslib/Languages/LambdaCalculus/LocallyNameless/Untyped/FullBetaConfluence.html#Cslib.LambdaCalculus.LocallyNameless.Untyped.Term.confluence_beta\">here</a>) and did not transfer this deBruijn indices representation, partially because of my own reservations about the shifting being a bit messy. Can I ask what \"less complicated formalization\" you're planning on next? If it is well scoped indices this has been on my TODO list, but we could certainly work in tandem.</p>",
        "id": 562346954,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765142116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> Your work was a great tool in guiding me through my formalization process. I was working on a simplification of the locally nameless representation; the formalization itself is quite beautiful and simple, but I didn't like some of the definitions. For example, I've shown things like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mtext>Lc </mtext><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi mathvariant=\"normal\">∃</mi><mi>L</mi><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo mathvariant=\"normal\">∉</mo><mi>L</mi><mo separator=\"true\">,</mo><mtext>Lc </mtext><msup><mi>N</mi><mi>x</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi mathvariant=\"normal\">∃</mi><mi>x</mi><mo mathvariant=\"normal\">∉</mo><mtext>fv</mtext><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mtext>Lc </mtext><msup><mi>N</mi><mi>x</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mtext>Lc </mtext><msup><mi>N</mi><mi>x</mi></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align*}\n\\text{Lc } (\\lambda N) &amp;\\iff \\exists L \\forall x \\notin L, \\text{Lc } N^x \\\\\n&amp;\\iff \\exists x \\notin \\text{fv}(N), \\text{Lc } N^x \\\\\n&amp;\\iff \\forall x, \\text{Lc } N^x\n\\end{align*}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:4.5em;vertical-align:-2em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">Lc </span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">L</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">∈</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Lc </span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">∈</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord text\"><span class=\"mord\">fv</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Lc </span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord text\"><span class=\"mord\">Lc </span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>This is a great advantage because in the hypotheses I can work with a universal quantifier, but prove with cofinite quantifiers. Even so, that project is in limbo because my supposed simplification has made it more complicated.</p>\n<p>Regarding well-scoped indices, I would love to work on them, but what would be the objective of working with this representation? I feel it is more complicated than de Bruijn indices, so I don't feel it is optimal for making proofs, even though I have read very little about it.</p>",
        "id": 562523382,
        "sender_full_name": "Daniel Patiño",
        "timestamp": 1765215452
    },
    {
        "content": "<p>Yes, the cofinite quantification can be difficult, and it is easy to back yourself into a corner. It also doesn't work well with certain automation like <code>grind</code> and is awkward if you want to do denotational or categorical semantics. </p>\n<p>My objective with well-scoped indices is that I think it is ultimately simpler than the other two approaches. I'd like to write something very close in implementation to Rocq's Autosubst2.</p>",
        "id": 562551324,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765225327
    },
    {
        "content": "<p>As I said, I've read very little. Could you send me some references I could use? I had read it before in the Rebound library in Haskell, and thanks to what you told me, I found Kathrin Stark's thesis, and it's very interesting.</p>",
        "id": 562561795,
        "sender_full_name": "Daniel Patiño",
        "timestamp": 1765229494
    },
    {
        "content": "<p>Maybe this is a helpful resource: <a href=\"https://github.com/sweirich/pl-semantics-and-types\">https://github.com/sweirich/pl-semantics-and-types</a></p>\n<p>This is from a course that Stephanie Weirich just taught that uses Autosubst2 in formalizations of several different systems. When you see <code>.sig</code> files, the corresponding <code>.v</code> is the Rocq code that is automatically produced by Autosubst. (It may seem long, but much of this I feel can be written compactly, especially if you involve <code>grind</code>.).  <a href=\"https://github.com/sweirich/pl-semantics-and-types/blob/main/notes/plst.pdf\">The notes</a> are very helpful for following along.</p>\n<p>From seeing what has been developed in Rocq and projects like <a href=\"https://github.com/sinhp/HoTTLean\">HoTTLean</a>, I am convinced that well-scoped indices sufficiently scale to letting us have more complex type systems in CSLib. I want to ultimately write a Lean implementation of Autosubst2, but in the meantime I'd like to have a regular \"by hand\" formalization so we can at least compare the ergonomics.</p>",
        "id": 562566205,
        "sender_full_name": "Chris Henson",
        "timestamp": 1765231412
    },
    {
        "content": "<p>Thanks Chris, I really appreciate the reference. I'll study those notes and try to write some code. If I have any updates, I'll share them with you.</p>",
        "id": 562837577,
        "sender_full_name": "Daniel Patiño",
        "timestamp": 1765330215
    }
]