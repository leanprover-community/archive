[
    {
        "content": "<p>I am trying to define a DAG as a subtype of a homebrewed directed graph implementation (as an exercise to learn Lean):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"n\">deriving</span>\n<span class=\"w\">  </span><span class=\"kn\">instance</span>\n<span class=\"w\">    </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n<span class=\"w\">  </span><span class=\"n\">for</span>\n<span class=\"w\">    </span><span class=\"n\">NodeId</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">childRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">parent</span><span class=\"w\"> </span><span class=\"n\">child</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">dg</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"o\">[</span><span class=\"n\">parent</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">child</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">children</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">descendantRel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NodeId</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Relation</span><span class=\"bp\">.</span><span class=\"n\">TransGen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">childRel</span><span class=\"w\"> </span><span class=\"n\">dg</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">descendantRel</span><span class=\"w\"> </span><span class=\"n\">dg</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DirectedAcyclicGraph</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">this</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>\n<p>However, when I go on to implement an <code>empty</code> function, I fail to see how I can leverage the fact that <code>nodes</code> is an empty HashMap in the proof of <code>acyclic</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DirectedAcyclicGraph</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">emptyWithCapacity</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_nodes_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">nodes</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">emptyWithCapacity</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rfl</span>\n<span class=\"w\">        </span><span class=\"sd\">/-- error:</span>\n<span class=\"sd\">        tactic 'rfl' failed, the left-hand side</span>\n<span class=\"sd\">          g.nodes</span>\n<span class=\"sd\">        is not definitionally equal to the right-hand side</span>\n<span class=\"sd\">          Std.HashMap.emptyWithCapacity</span>\n<span class=\"sd\">        --/</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 533675530,
        "sender_full_name": "Oleks",
        "timestamp": 1754858719
    },
    {
        "content": "<p>When you write <code>acyclic {this} : acyclic this</code>, <code>this</code> does not refer to the structure being defined, you accidentally have \"all directed graphs are acyclic\"</p>",
        "id": 533675686,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754858891
    },
    {
        "content": "<p>Hover over the <code>acyclic</code> field in the <code>structure</code> to see what type it has</p>",
        "id": 533675702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754858917
    },
    {
        "content": "<p>It's possible to refer to the parent using the projection field for that parent. The default name puts <code>to</code> in front:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DirectedAcyclicGraph</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">DirectedGraph</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">acyclic</span><span class=\"w\"> </span><span class=\"n\">toDirectedGraph</span>\n</code></pre></div>",
        "id": 533675753,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754858959
    },
    {
        "content": "<p>You can see it in the local context.</p>",
        "id": 533675764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754858973
    }
]