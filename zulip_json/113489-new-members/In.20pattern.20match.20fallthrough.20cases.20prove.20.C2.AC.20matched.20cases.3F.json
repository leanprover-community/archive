[
    {
        "content": "<p>Is it possible in a match expression to prove for the fallthrough pattern that the value you're matching on is none of the previously matched patterns?</p>\n<p>I feel like this should be possible since Lean should be able to see that you have already matched on the other cases and therefore this fallthrough is none of those cases</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fromA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromA</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromB</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"c1\">-- I want to be able to use `h` here to prove that `t` is neither `.a` or `.b`</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 522973580,
        "sender_full_name": "aron",
        "timestamp": 1749384131
    },
    {
        "content": "<p>Without this, the only alternative is to stick a potentially very large number of patterns in your match expression. Depending on the number of variants you have and how many values you're matching on in the same pattern this could result in an enormous number of patterns to match. Whereas if you could access the proof that the value is none of the constructors you're interested in, you could handle them all in parallel using tactics</p>",
        "id": 522973774,
        "sender_full_name": "aron",
        "timestamp": 1749384353
    },
    {
        "content": "<p>Here's a real life example for the number of patterns I need to add to eliminate false cases – and this is just a small sample of all the patterns I'm going to have to add <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> the unhappy paths outnumber the happy ones by 5 to 1. There must be a better way to do this</p>\n<p><a href=\"/user_uploads/3121/tZcjXiJ9w-yydbrWF66_hGv4/Screenshot-2025-06-08-at-13.21.22.png\">Screenshot 2025-06-08 at 13.21.22.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tZcjXiJ9w-yydbrWF66_hGv4/Screenshot-2025-06-08-at-13.21.22.png\" title=\"Screenshot 2025-06-08 at 13.21.22.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"989x830\" src=\"/user_uploads/thumbnail/3121/tZcjXiJ9w-yydbrWF66_hGv4/Screenshot-2025-06-08-at-13.21.22.png/840x560.webp\"></a></div>",
        "id": 522974636,
        "sender_full_name": "aron",
        "timestamp": 1749385452
    },
    {
        "content": "<p>Would if-then-else expressions work?</p>",
        "id": 522979496,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749391856
    },
    {
        "content": "<p>Alas no. For two reasons: 1 if/else expressions are more tedious especially for large numbers of checks, plus 2. you can only check boolean equalities with them, you can't use them to pattern match. So there's no way to do something like <code>.prim _</code></p>",
        "id": 522980353,
        "sender_full_name": "aron",
        "timestamp": 1749392834
    },
    {
        "content": "<p>I know the <code>cases</code> tactic can handle this kind of stuff, but for <code>match</code> I don't know of any way to do it.</p>",
        "id": 522980668,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749393228
    },
    {
        "content": "<p>Can cases be used in the same way as match can? For types also or just props?</p>",
        "id": 522981789,
        "sender_full_name": "aron",
        "timestamp": 1749394473
    },
    {
        "content": "<p>Like is there a difference between them other than some minor ergonomics?</p>",
        "id": 522981814,
        "sender_full_name": "aron",
        "timestamp": 1749394501
    },
    {
        "content": "<p>You can, though I think there's a chance you might need to mark the result <code>noncomputable</code> since the compiler doesn't yet support raw recursors, and also you have little control over the term it produces.</p>",
        "id": 522983623,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749396470
    },
    {
        "content": "<p>Ah ok that would be a problem because I want to match on real values, not just props</p>",
        "id": 522983832,
        "sender_full_name": "aron",
        "timestamp": 1749396710
    },
    {
        "content": "<p>What do you mean \"match on real values\"?</p>",
        "id": 522984731,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749397708
    },
    {
        "content": "<p>Well this is for code to actually run in a program, so doesn't that mean it needs to be computable?</p>",
        "id": 522985002,
        "sender_full_name": "aron",
        "timestamp": 1749397986
    },
    {
        "content": "<p>You can of course <code>compile_inductive</code> to force computability, but if your inductives are recursive this will not be performant</p>",
        "id": 522986622,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749399641
    },
    {
        "content": "<p>Actually, since <code>cases</code> uses the <code>.casesOn</code> which does not expose the induction hypothesis, you might just be fine</p>",
        "id": 522986760,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749399811
    },
    {
        "content": "<p>The problem is <code>induction</code> which uses the <code>.rec</code></p>",
        "id": 522986773,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749399828
    },
    {
        "content": "<p>This is done automatically, but for splitter theorems, not match statements directly. So for example if you have a match statement in your goal and want to prove something about it, you can use the <code>split</code> tactic and it will introduce hypotheses for the wildcard cases</p>",
        "id": 522990466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1749404237
    },
    {
        "content": "<p>You could make it return a <code>Bool</code> and then prove the theorem after</p>",
        "id": 522990540,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749404337
    },
    {
        "content": "<p>Like how prelude sets up <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.beq#doc\">docs#Nat.beq</a> before using it to get <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decEq#doc\">docs#Nat.decEq</a></p>",
        "id": 522990650,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749404478
    },
    {
        "content": "<p>Here's a way to exploit the fact that <code>split</code> is basically <code>match</code> but with these extra hypotheses to perform the case split you want, by splitting a match with the right structure but nothing else of interest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromA</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromB</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">⟨‹_›</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‹_›⟩</span>\n</code></pre></div>",
        "id": 522990674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1749404517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> mmmm very interesting! although this feels a bit like magic to me atm.</p>\n<p>So basically by constructing an otherwise useless value <code>x</code> whose definition involves a match expression according to the cases that you want, the <code>split</code> tactic will give you the hypotheses that the fallback case is none of the previously matched patterns?</p>",
        "id": 523054587,
        "sender_full_name": "aron",
        "timestamp": 1749460802
    },
    {
        "content": "<p>putting this here as a note for myself for how to extend this pattern when your constructors take some data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fromA</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fromB</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"w\">  </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromA</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fromB</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">⟨‹_›</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">‹_›⟩</span>\n</code></pre></div>",
        "id": 523057253,
        "sender_full_name": "aron",
        "timestamp": 1749461903
    }
]