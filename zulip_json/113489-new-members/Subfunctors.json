[
    {
        "content": "<p>I have the following code to define <a href=\"https://en.wikipedia.org/wiki/Subfunctor\">subfunctors</a> into <code>ModuleCat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"c1\">--Persistence modules over some (small) category C.</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">FunctCat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"w\">   </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Subfunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunctCat</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">BaseFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunctCat</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">  </span><span class=\"n\">sub_obj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">--I want to express that BaseFunctor.obj(X) is a subset</span>\n<span class=\"w\">  </span><span class=\"c1\">-- of F.obj X</span>\n</code></pre></div>\n<p>How can I express the condition that <code>BaseFunctor.obj(X) </code> is a submodule of <code> F.obj X</code>? I had a look at the submodule structure, but I can't do something like <code>sub_obj (X : C) := (BaseFunctor.obj X : Submodule R (F.obj X)) </code> since that causes a type mismatch. How can I work around this?</p>",
        "id": 451613043,
        "sender_full_name": "VayusElytra",
        "timestamp": 1721072801
    },
    {
        "content": "<p>A submodule is a term, not a type. Just write down an injective R-module hom instead?</p>",
        "id": 451617286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721073531
    },
    {
        "content": "<p>See also <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Adjunction/Evaluation.html#CategoryTheory.NatTrans.mono_iff_mono_app\">CategoryTheory.NatTrans.mono_iff_mono_app</a></p>",
        "id": 451624055,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1721075094
    },
    {
        "content": "<p>You may use a variant of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.GrothendieckTopology.Subpresheaf#doc\">docs#CategoryTheory.GrothendieckTopology.Subpresheaf</a>, or as Adam implies, you may consider monomorphisms in the functor category.</p>",
        "id": 451631052,
        "sender_full_name": "Joël Riou",
        "timestamp": 1721077805
    },
    {
        "content": "<p>Thank you all. Is something like this what you had in mind? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Subfunctor</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunctCat</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">baseFunctor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FunctCat</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">  </span><span class=\"n\">targetFunctor</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">F</span>\n<span class=\"w\">  </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">baseFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">inj_cond</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">restriction</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">baseFunctor</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">baseFunctor</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">asHom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"c1\">--careful with asHom! This breaks if you use asHom injection Y instead.</span>\n</code></pre></div>",
        "id": 452061806,
        "sender_full_name": "VayusElytra",
        "timestamp": 1721220961
    },
    {
        "content": "<p>No, what I intended was a variation of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">Subpresheaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"w\"> </span><span class=\"bp\">⥤</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `G` is a sub-presheaf of `F`, then the sections of `G` on `U` forms a subset of sections of</span>\n<span class=\"sd\">    `F` on `U`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F.obj</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- If `G` is a sub-presheaf of `F` and `i : U ⟶ V`, then for each `G`-sections on `U` `x`,</span>\n<span class=\"sd\">    `F i x` is in `F(V)`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">F.map</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>\n<p>Instead of <code>Set</code> (which in mathlib means \"subset of\"), it would be <code>Submodule</code>.</p>\n<p>Alternatives would be <code>MonoOver F</code> which is the category of monomorphisms  with target object <code>F</code>, or the variant <code>Subobject F</code>.</p>",
        "id": 452075231,
        "sender_full_name": "Joël Riou",
        "timestamp": 1721223866
    }
]