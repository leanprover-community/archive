[
    {
        "content": "<p>I'm aware of the overall concept of the <a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2023/Part_B/typesandterms.html#the-universe-prop\">Prop universe</a> and theorems as types.</p>\n<p>But looking at the code I realize it still doesn't quite click for me. Here's one example. I'm starting going through the <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C03_Logic.html\">third MIL chapter</a> and it has this snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FnUb</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>This makes sense but its return type is a <code>Prop</code>. Okay. But so far I've mostly seen <em>theorems</em>, and although they supposedly return propositions, their return types are more \"concrete\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">epos</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul_lt_mul_right</span><span class=\"w\"> </span><span class=\"n\">epos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Here, it doesn't return a <code>Prop</code>, it returns <code>|x| * ε &lt; 1 * ε</code>.</p>\n<p>So what is the relationship between the <code>|x| * ε &lt; 1 * ε</code> <em>type</em> and the <code>Prop</code> <em>type</em>? Is one a subtype of the other? Is <code>Prop</code> kind of like <code>Object</code> in Java, the mother of all props? Or is it a type at some different \"level\"? Can things ever be cast between a concrete prop type like <code>|x| * ε &lt; 1 * ε</code> and the generic <code>Prop</code>? Does <code>Prop</code> only appear in some other contexts?</p>",
        "id": 498392319,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738950015
    },
    {
        "content": "<p>I'm guessing maybe types are values, and so each type has a type, etc? So then a value of type <code>|x| * ε &lt; 1 * ε</code> is a proposition, but <code>|x| * ε &lt; 1 * ε</code> itself is a value of type <code>Prop</code>?</p>",
        "id": 498392795,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738950198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20think.20about.20the.20Prop.20type.20vs.20specific.20propositions.3F/near/498392795\">said</a>:</p>\n<blockquote>\n<p>I'm guessing maybe types are values, and so each type has a type, etc? So then a value of type <code>|x| * ε &lt; 1 * ε</code> is a proposition, but <code>|x| * ε &lt; 1 * ε</code> itself is a value of type <code>Prop</code>?</p>\n</blockquote>\n<p>A value of type <code>|x| * ε &lt; 1 * ε</code> is a proof of the statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>x</mi><mi mathvariant=\"normal\">∣</mi><mo>⋅</mo><mi>ε</mi><mo>&lt;</mo><mn>1</mn><mo>⋅</mo><mi>ε</mi></mrow><annotation encoding=\"application/x-tex\">|x| \\cdot \\varepsilon &lt; 1 \\cdot \\varepsilon</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">x</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">ε</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ε</span></span></span></span>, and <code>|x| * ε &lt; 1 * ε</code> does have type <code>Prop</code>.</p>",
        "id": 498393458,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738950353
    },
    {
        "content": "<p>I like \"mother of all props\" (-;</p>",
        "id": 498393580,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738950364
    },
    {
        "content": "<p><code>|x| * ε &lt; 1 * ε</code> (and all other terms of type <code>Prop</code>) are propositions and (as mentioned above) terms of type <code>|x| * ε &lt; 1 * ε</code> are <em>proofs</em> of <code>|x| * ε &lt; 1 * ε</code>.</p>",
        "id": 498393747,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1738950389
    },
    {
        "content": "<p>Ahh I see. So this explains why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FnUb</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>doesn't need to \"prove\" anything. It's just a factory for propositions (which themselves are types). And then if I wanted to construct a value of those types, I'd have to write a proof.</p>",
        "id": 498394249,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738950477
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">I_am_a_type_of_numbers</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">I_am_a_number</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I_am_a_type_of_numbers</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">I_am_a_prop_you_can_prove_me</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">I_am_such_a_proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I_am_a_prop_you_can_prove_me</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 498394502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738950563
    },
    {
        "content": "<p><del>Whoops, that works modulo silly mistakes, it was untested.</del> Edit: fixed</p>",
        "id": 498394632,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738950612
    },
    {
        "content": "<p>I think we often link to this post by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> on this: <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a></p>",
        "id": 498394753,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1738950664
    },
    {
        "content": "<p>It's interesting to me that the <code>Prop</code> carries has no information in it at all. I guess it's because it's as \"basic\" as a boolean (but at a different level). But it still feels a bit surprising.</p>\n<p>Maybe it would help my intuition to have some examples of where manipulating <code>Prop</code> objects directly is handy. Like are there any higher level theorems you can write where the arguments themselves are <code>Prop</code>? Is that common?</p>",
        "id": 498394859,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738950716
    },
    {
        "content": "<p>Sure! Things like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=and_comm#doc\">docs#and_comm</a></p>",
        "id": 498395004,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1738950771
    },
    {
        "content": "<p>The ones that jump to mind are things like logical connectives. Ah, Johan beat me to it!</p>",
        "id": 498395170,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1738950797
    },
    {
        "content": "<p>OK thanks, this is very helpful! I think it clicked for me now.</p>",
        "id": 498395343,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738950822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 498395348,
        "sender_full_name": "Notification Bot",
        "timestamp": 1738950824
    },
    {
        "content": "<p>How does <code>False</code> fit into this conceptually? Is there a good way to develop intuition for that?</p>\n<p>I understand <code>False</code> has a type of <code>Prop</code>, and that there are no terms of the type <code>False</code>. I.e. you can't construct a proof of <code>False</code>. I also understand that proving \"not P\" is expressed as proving <code>P -&gt; False</code>.</p>\n<p>But I don't feel it intuitively clicking, in the sense of \"what this trick allows us to model\".</p>",
        "id": 498452985,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738976803
    },
    {
        "content": "<p>Do you understand how the truth of a proposition is modeled as whether or not it has a proof? If so, then <code>False</code> is a proposition that's false in that sense.</p>",
        "id": 498453289,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977015
    },
    {
        "content": "<p>So a term of type Prop is an assertion, that can be either true or false. For example, both <code>2+2=4</code> and <code>2+2=5</code> are of type Prop. You can now construct a term whose type is <code>2+2=4</code>, but you won't (shouldn't) be able to construct a term with type <code>2+2=5</code></p>",
        "id": 498453528,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738977225
    },
    {
        "content": "<p>About \"not\": there is no term of type False. So if you can derive a term of type False from a term of type P, a term of type P (that is, a proof of the proposition P) can <em>also</em> not exist</p>",
        "id": 498453801,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738977406
    },
    {
        "content": "<p>One of the axioms of Lean is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a>, which asserts that if two propositions are logically equivalent then they are equal. Every proposition that's false is equal to <code>False</code> because of this. Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">propext</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>The point here is that <code>False</code> is some specific false proposition that we can refer to, and every false proposition is equal to it anyway.</p>",
        "id": 498453854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977462
    },
    {
        "content": "<p>Or Ruben's example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">propext</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 498454091,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977611
    },
    {
        "content": "<blockquote>\n<p>Do you understand how the truth of a proposition is modeled as whether or not it has a proof? If so, then <code>False</code> is a proposition that's false in that sense.</p>\n</blockquote>\n<p>Yes, that makes sense. I still feel like I was missing some related \"aha\" moments — maybe in how this connects to other topics or what \"falls out\" of it. </p>\n<p>Would it be fair to say that NOT's truth table is identical to the P -&gt; FALSE truth table so it makes sense to reuse the concept instead of introducing NOT as a separate thing into the prop/type system? So this is the motivation for making NOT desugar to -&gt; FALSE.</p>\n<blockquote>\n<p>About \"not\": there is no term of type False. So if you can derive a term of type False from a term of type P, a term of type P (that is, a proof of the proposition P) can <em>also</em> not exist</p>\n</blockquote>\n<p>Ah ok this is interesting. So I guess you could say that falseness propagates back through the implication chain due to the implication truth table, and together with how equality is defined on propositions, makes <code>False</code> work \"as a value\" even when it's not explicitly specified in types like <code>P -&gt; False</code>.</p>",
        "id": 498454119,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738977637
    },
    {
        "content": "<p>Are there just two distinct values of the <code>Prop</code> type?</p>",
        "id": 498454267,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738977742
    },
    {
        "content": "<p>Yes, every <code>Prop</code> is either equal to <code>True</code> or to <code>False</code>.</p>",
        "id": 498454290,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977768
    },
    {
        "content": "<p>(This is a consequence of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a>)</p>",
        "id": 498454314,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977797
    },
    {
        "content": "<p>The relevant theorem here is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.propComplete#doc\">docs#Classical.propComplete</a></p>",
        "id": 498454345,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738977837
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.propEquivBool#doc\">docs#Equiv.propEquivBool</a> is that <code>Prop</code> and <code>Bool</code> have a bijection between them.</p>",
        "id": 498454569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738977993
    },
    {
        "content": "<p>Have you seen yet that if you have <code>b : Bool</code>, then Lean's coercion system lets you use it as a <code>Prop</code> too? It converts it to the proposition <code>b = true</code>, which is <code>True</code> when <code>b</code> is <code>true</code>, and <code>False</code> otherwise.</p>",
        "id": 498454613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738978027
    },
    {
        "content": "<p>Great, thanks, these are all helpful.</p>\n<p>This is maybe going on a tangent, but does this mean LOEM and/or AOC are deeply baked in? Or is choosing to use them / rely on them still explicit? I'm not actually knowledgeable about either, I think I just read somewhere that there are mathematical frameworks that avoid them, so I'm curious if Lean allows expressing those.</p>",
        "id": 498454720,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738978100
    },
    {
        "content": "<p>You can see that choice is an <code>axiom</code> in the source code. You can avoid it if you want to.</p>\n<p>However, tactics don't necessarily go out of their way to help you avoid them.</p>",
        "id": 498454782,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738978172
    },
    {
        "content": "<p>Notice by the way that the equivalence I linked to is <code>noncomputable</code>. Computable would mean that propositions can be decided (roughly speaking). However, Gödel proved that there's no general decision procedure (that's the incompleteness theorem).</p>",
        "id": 498454951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738978285
    },
    {
        "content": "<p>This is the big difference between Bool and Prop practically. Bool is a type with computational content, and so definitions that return a Bool <em>must</em> normalize to <code>true</code> or <code>false</code>. Prop on the other hand is a type universe and there's no such computational content.</p>",
        "id": 498455425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738978676
    },
    {
        "content": "<p>re: the law of excluded middle, that's proved in Lean using the Axiom of Choice and <a href=\"http://en.wikipedia.org/wiki/Diaconescu%27s_theorem\">Diaconescu's theorem</a></p>",
        "id": 498460303,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1738982760
    },
    {
        "content": "<p>you can see the proof here: <a href=\"https://github.com/leanprover/lean4/blob/93d4ae6635c0c755c9f7368f9b99483d4557b7a6/src/Init/Classical.lean#L31-L63\">https://github.com/leanprover/lean4/blob/93d4ae6635c0c755c9f7368f9b99483d4557b7a6/src/Init/Classical.lean#L31-L63</a></p>",
        "id": 498460401,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1738982842
    },
    {
        "content": "<p>so using excluded middle in Lean means that you're relying on the axiom of choice</p>",
        "id": 498460631,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1738983008
    },
    {
        "content": "<p>(though there's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable.em#doc\">docs#Decidable.em</a>, which doesn't need Choice because a decidable proposition is clearly either true or false)</p>",
        "id": 498460810,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1738983170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20How.20to.20think.20about.20the.20Prop.20type.20vs.20specific.20propositions.3F/near/498454290\">said</a>:</p>\n<blockquote>\n<p>Yes, every <code>Prop</code> is either equal to <code>True</code> or to <code>False</code>.</p>\n</blockquote>\n<p>(Added a mention of this to the <code>Prop</code> docstring: <a href=\"https://github.com/leanprover/lean4/pull/6998\">lean4#6998</a>)</p>",
        "id": 498526002,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739040717
    }
]