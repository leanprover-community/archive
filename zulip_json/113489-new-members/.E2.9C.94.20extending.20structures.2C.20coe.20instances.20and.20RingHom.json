[
    {
        "content": "<p>My brain is probably too used to subtypes, but I was a bit surprised that even with <code>extends</code> structures don't pick up Coe rules to the extending structures</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ex1</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"bp\">.</span><span class=\"n\">toT1</span><span class=\"w\"> </span><span class=\"c1\">-- needed explicit cast to T1</span>\n</code></pre></div>\n<p>but of course one can write it themselves</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ex1</span><span class=\"w\"> </span><span class=\"n\">t2</span>\n</code></pre></div>\n<p>This is prompted by reading in MIL Ch7.2</p>\n<blockquote>\n<p>A much more important one is that lemmas about monoid morphisms won’t directly apply to ring morphisms. This leaves the alternative of either juggling with <code>RingHom₁.toMonoidHom₁</code> each time we want to apply a monoid morphism lemma or restate every such lemmas for ring morphisms. Neither option is appealing so Mathlib uses a new hierarchy trick here.</p>\n</blockquote>\n<p>which was surprising to me since RingHom plainly extended MonoidHom, prompting the example above.</p>\n<p>So I wondered if instead of creating an <code>F</code> parametrized class <code>MonoidHomClass</code>, why can't one add an explicit <code>Coe</code> instance between <code>RingHom</code> and <code>MonoidHom</code> like I did for <code>T1</code> and <code>T2</code> and call it a day? Well, actually I tried it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">RingHom₁</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonoidHom₁</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RingHom₁</span><span class=\"bp\">.</span><span class=\"n\">toMonoidHom₁</span>\n</code></pre></div>\n<p>and got an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RingHom₁</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">map_inv_of_inv₁</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">-- still error here</span>\n\n<span class=\"c1\">-- typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"c1\">--  Monoid ?m.26294</span>\n</code></pre></div>\n<p>which I don't understand?</p>\n<p>(to paraphrase an old saying, looks like every problem is solved with one more layers of type classes, except the problem of too many type classes :))</p>",
        "id": 504331502,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741479230
    },
    {
        "content": "<p>There's a coercion-like feature for structure parents, via dot notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"bp\">.</span><span class=\"n\">ex1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"bp\">.</span><span class=\"n\">ex1</span>\n</code></pre></div>",
        "id": 504331841,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741479501
    },
    {
        "content": "<p>The Coe class has a notable limitation, which is that it's not able to work unless the types are completely known (it's not able to assign metavariables in the types). I think that's what's going on with your example.</p>",
        "id": 504331842,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741479502
    },
    {
        "content": "<p>You're right that many problems can be solved with more typeclass. For example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddHomClass#doc\">docs#AddHomClass</a> is for function-like types that are additive homomorphisms.</p>",
        "id": 504332015,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741479685
    },
    {
        "content": "<p>Even if the coercion worked, <code>rw</code> wouldn't be able to use it as easily as in the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RingHom</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">map_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_one</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Unification can't insert coercions.</p>",
        "id": 504332229,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741479904
    },
    {
        "content": "<p>(That is, how should it know that in <code>f m * f m'</code> the <code>f : RingHom</code> should be <code>(f : MonoidHom)</code>.)</p>\n<p>There's a feature called unification hints that likely could work here, but mathlib opted to use more typeclasses.</p>",
        "id": 504332357,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741480009
    },
    {
        "content": "<blockquote>\n<p>The Coe class has a notable limitation, which is that it's not able to work unless the types are completely known</p>\n</blockquote>\n<p>Ah that makes sense, here is a smaller repo:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T2a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T2a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex1a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t1a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"c1\">-- the point is to reuse ex1a in ex2a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ex1a</span><span class=\"w\"> </span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"c1\">-- error, coercions are not applied</span>\n</code></pre></div>\n<p>but now I want to try the other coer-like feature you showed me <code>MonoidHom.&lt;some theorem&gt;</code> to use for a <code>RingHom</code>, which probably would also break due to free type variables?</p>",
        "id": 504332495,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741480113
    },
    {
        "content": "<p>It probably would work for <code>exact</code>, but with <code>rw</code> an issue is that the theorem would involve <code>f.toMonoidHom</code>, not <code>f</code> itself.</p>",
        "id": 504332892,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741480430
    },
    {
        "content": "<blockquote>\n<p>(That is, how should it know that in <code>f m * f m'</code> the <code>f : RingHom</code> should be <code>(f : MonoidHom)</code>.)</p>\n</blockquote>\n<p>Years of working with subtype based type systems scream at me I wrote <code>class RingHom extends MonoidHom</code>  so \"obviously\" the MonoidHom rewrites rules should apply :) But I get it, we are not in Kansas any more.</p>",
        "id": 504333006,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741480557
    },
    {
        "content": "<p>Or maybe you are saying the rw won't be logically correct to apply (i.e. beyond developer experience of having to explicitly add casts)? I need to think a bit more about this</p>",
        "id": 504333189,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741480721
    },
    {
        "content": "<p>Also, watch out, 'subtype' means something else now too :-)</p>\n<p>In a class-based system, you get an \"is-a\" relationship between a child class and its parent class. With \"is-a\", if B is an A, then a variable of type A can contain a value of type B. Even though a value of type B can have more fields and different methods, so it's not, mathematically, something of type A.</p>\n<p>In Lean, 'subtype' means a type that is a subset of the type. A <code>RingHom</code> is not a subtype of <code>MonoidHom</code>. There is a projection from <code>RingHom</code> to its parent <code>MonoidHom</code>. Once projected, the original <code>RingHom</code> cannot be recovered, it lost data.</p>",
        "id": 504333365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741480875
    },
    {
        "content": "<p>Object oriented programming avoids this projection problem by having a virtual function table (or at least an extra field with a class descriptor that lets polymorphic functions be able to work out how to access the data they need from an object's fields)</p>",
        "id": 504333464,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741480945
    },
    {
        "content": "<p>oh, I see. Yes the <code>T1.ex1</code> does work </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"bp\">.</span><span class=\"n\">ex1a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t1a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"c1\">-- the point is to reuse ex1a in ex2a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">t2a</span><span class=\"bp\">.</span><span class=\"n\">ex1a</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>and I convinced myself that I definitely don't want the rewrites for substructures to work</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"bp\">.</span><span class=\"n\">ex1a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t1a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T1a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t1a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t1a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"c1\">-- the point is to reuse ex1a in ex2a</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex2a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2a</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t2a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">t2a</span><span class=\"bp\">.</span><span class=\"n\">toT1a</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"c1\">-- this shouldn't work, because maybe y is different</span>\n</code></pre></div>",
        "id": 504333545,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741481038
    },
    {
        "content": "<p>In Lean, classes like <code>AddHomClass</code> are implementing the idea of virtual function tables. Rather than having the table be passed as part of the objects themselves, they're being explicitly passed as separate arguments.</p>",
        "id": 504333549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741481040
    },
    {
        "content": "<p>Anything that implements <code>AddHomClass</code> is a subclass of <code>AddHom</code> in the object oriented \"is-a\" sense.</p>",
        "id": 504333636,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741481090
    },
    {
        "content": "<blockquote>\n<p>Also, watch out, 'subtype' means something else now too :-)</p>\n</blockquote>\n<p>Haven't gotten to that chapter yet, assume I use terminology in a very vague sense, since I haven't picked up proper Lean terminology yet :) </p>\n<blockquote>\n<p>In Lean, 'subtype' means a type that is a subset of the type. A <code>RingHom</code> is not a subtype of <code>MonoidHom</code>. There is a projection from <code>RingHom</code> to its parent <code>MonoidHom</code>. Once projected, the original <code>RingHom</code> cannot be recovered, it lost data.</p>\n</blockquote>\n<p>Funny enough, my mathematical training also doesn't help here, because from math perspective since the underlying sets are the same, RingHom should be a subset of MonoidHom (and all are subsets of the SetHom), and as customary in math one doesn't think of explicit projection into subset. Or am I missing some math subtlety here?</p>\n<p>I am not used to thinking of type theory as something deeply different from sets. I have gotten quite far in other languages (notably typed extensions to dynamic languages like TypeScript) by just thinking of types as \"sets of possible runtime values, that are instead reasoned with during compile time\".</p>",
        "id": 504334404,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741481762
    },
    {
        "content": "<p>btw, in case it is not clear, none of this is a critique of Lean (I am in no position to do any critique, I know too little), just thinking out loud and sharing my experience. I am getting a lot useful commentary back (again big thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> and everyone else that chimes in), which speeds up my learning.</p>",
        "id": 504334714,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741482004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/extending.20structures.2C.20coe.20instances.20and.20RingHom/near/504333365\">said</a>:</p>\n<blockquote>\n<p>In a class-based system, you get an \"is-a\" relationship between a child class and its parent class. With \"is-a\", if B is an A, then a variable of type A can contain a value of type B. Even though a value of type B can have more fields and different methods, so it's not, mathematically, something of type A.</p>\n</blockquote>\n<p>I don't quite understand this paragraph. To me, \"B is a subtype of A\" means there is a suitably well-behaved coercion from B to A.</p>",
        "id": 504334929,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741482156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/extending.20structures.2C.20coe.20instances.20and.20RingHom/near/504334404\">said</a>:</p>\n<blockquote>\n<p>RingHom should be a subset of MonoidHom</p>\n</blockquote>\n<p>I suppose you're right. I was thinking about the case of structures in general, but with <code>RingHom</code> and <code>MonoidHom</code>, the only actual data is the <code>toFun</code> field. Everything else is a proof field. That means <code>RingHom</code> can be identified with a subset of <code>MonoidHom</code>.</p>",
        "id": 504334936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741482161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> That paragraph is about objected oriented programming notions. I've never heard anyone in OO talk about \"well-behaved coercions\" (and even so, the OO subtype relation is definitely not about coercions — if you \"cast\" a value of B to the type A, it still remembers that it's a value of B)</p>",
        "id": 504335117,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741482326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/extending.20structures.2C.20coe.20instances.20and.20RingHom/near/504335117\">said</a>:</p>\n<blockquote>\n<p>if you \"cast\" a value of B to the type A, it still remembers that it's a value of B</p>\n</blockquote>\n<p>This is why I'm not an object oriented programmer.</p>",
        "id": 504335243,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741482463
    },
    {
        "content": "<blockquote>\n<p>I am not used to thinking of type theory as something deeply different from sets.</p>\n</blockquote>\n<p>I generally think about them as sets. The only thing that's different is that \"at compile time\" we need to remember for each element we talk about which specific set it's an element of.</p>",
        "id": 504335246,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741482469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> It's just modeling a different thing, one that's still useful, and one that we do use in Lean with our typeclass hierarchy. We're just not saying that <code>[Field X]</code> means that the type of <code>X</code> is <code>Field</code>.</p>",
        "id": 504335503,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741482721
    },
    {
        "content": "<p>but why does it <strong>remember</strong></p>",
        "id": 504335598,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741482780
    },
    {
        "content": "<p>Are you asking why as in \"why did they do it that way\" or \"how does the mechanism work\"? The short answer is that OO objects like like bundled classes, and there's a mechanism to be able to make bundled classes 'cast' to parent classes without needing to compute a projection.</p>",
        "id": 504335768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741482956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/extending.20structures.2C.20coe.20instances.20and.20RingHom/near/504334404\">said</a>:</p>\n<blockquote>\n<p>I have gotten quite far in other languages (notably typed extensions to dynamic languages like TypeScript) by just thinking of types as \"sets of possible runtime values, that are instead reasoned with during compile time\".</p>\n</blockquote>\n<p>I think it's worth thinking about exactly which set of runtime values a particular class consists of, if the language allows you to subclass it at any moment, extending what set of runtime values are in that set. In Lean, types are fixed at definition time and can't be extended.</p>",
        "id": 504335854,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741483026
    },
    {
        "content": "<p>(Re casting: It's not just an optimization, but key to the system, since objects can generally be mutated. A method up the class hierarchy might call a method whose implementation lower in the class hierarchy modifies a field that's not present in the projection to the parent class.)</p>",
        "id": 504336134,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741483277
    },
    {
        "content": "<blockquote>\n<p>of runtime values a particular class</p>\n</blockquote>\n<p>Yes, optionally typed systems for dynamic languages are quite far from this because the runtime is very permissive - just objects with fields, and types are now static descriptions that can be naturally tighter or looser (i.e. smaller or bigger subsets of possible runtime values). So there is very little \"fixing\", everything is structural. I think I am starting to understand the claim in this blog post - <a href=\"https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/\">https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/</a> that mathematicians grok structural types because that's how set theory works.</p>",
        "id": 504336692,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741483707
    },
    {
        "content": "<p>With what I was saying, I was thinking of non-optional type systems, like Java.</p>\n<p>When you say \"structural types\", do you mean Lean-style structures, or TypeScript-style structural types? My understanding of TypeScript is that there's effectively a single universal type J of runtime values (J for JavaScript), and every TypeScript type is a subset of J. The structural type of those structures with a <code>name : String</code> field contains quite a lot of stuff.</p>\n<p>In Lean, there's no such universe. Each Lean type has its own runtime representation for its values, and at runtime one can't tell which runtime object is corresponding to which type. Even so, we want to prove things; how would equality work for structures if values might actually have a number of additional unspecified fields?</p>\n<p>A difference is that TypeScript structural types are the \"largest\" type that has certain features (and it is represented as a subset of J). Lean structures are the \"smallest\".</p>\n<p>However, typeclasses are essentially letting us do structural typing, and that's why the typeclass hierarchy works in a reasonably natural way.</p>\n<p>It's working keeping apart the concepts of a type: (1) the data being represented (that's Lean's types) and (2) what you can do with data (abstractable with typeclasses). OO tends to merge these.</p>",
        "id": 504338658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741485445
    },
    {
        "content": "<blockquote>\n<p>When you say \"structural types\", do you mean Lean-style structures, or TypeScript-style structural types?</p>\n</blockquote>\n<p>TS types, i.e. it doesn't matter how the object is constructed, if the type is <code>{name: String}</code> and the object has a field of name <code>name</code> of type <code>String</code>, the type system will accept it as part of that type without any explicit coercion. Extra fields don't matter either, the things we want to do with that type - notably call <code>obj.name</code> and get a <code>String</code> back - work even if there extra fields. This is unsound with mutation present, but I assume Lean has immutable objects only (haven't even started programming with Lean).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">R'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">K'</span><span class=\"o\">}}</span><span class=\"bp\">;</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"o\">}}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">;</span>\n<span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">R'</span><span class=\"o\">}</span><span class=\"bp\">;</span>\n<span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">name</span><span class=\"bp\">.</span><span class=\"n\">last</span><span class=\"bp\">.</span><span class=\"n\">charCodeAt</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">boom</span>\n</code></pre></div>\n<blockquote>\n<p>OO tends to merge these.</p>\n</blockquote>\n<p>Yeah, I am not coming from a strict Java/C++ style OOP, and have no issues with typeclasses as alternative mechanism for virtual tables and not having functions as methods together with data.</p>\n<p>To summarize my original confusion, in Chapter 7.2 we have RingHom defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RingHom₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">MonoidHom₁</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddMonoidHom₁</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">S</span>\n</code></pre></div>\n<p>So no extra fields (props or types), just extending two structures, which also share a single non-prop field (toFun, Lean handles the diamond field part without a problem). So I think of RingHom as an union of the MonoidHom and AddMonoidHom props against the same field that contains a function. </p>\n<p>But then we are told:</p>\n<blockquote>\n<p>lemmas about monoid morphisms won’t directly apply to ring morphisms.</p>\n</blockquote>\n<p>That is surprising from math intuition perspective, because as you said: <code>RingHom</code> can be identified with a subset of <code>MonoidHom</code> and vaguely expect to move between subsets without much explicit ceremony.</p>\n<p>Also surprising from PL perspective, because I saw two other powerful mechanisms that was hoping can help with that:</p>\n<ul>\n<li>Coe - which helps fulfill my subset expectation for  N -&gt; Q -&gt; R (at least from what I understand)</li>\n<li><code>extends</code> which looks like powerful syntactic sugar and expected it to work with Coe to solve the problem. Now I understand that Coe is limited in the presence of free type variables.</li>\n</ul>\n<p>Since neither of those work, the solution we are shown is using typeclasses. I understand how that works and have no questions about them (at least in this thread). It does feel heavy-handed to have to type class parametrize with the super free F, only to have it then instantiate only with <code>RingHom</code> and <code>MonoidHom</code> which are \"obviously\" connected at construction :)</p>\n<blockquote>\n<p>Are you asking why as in \"why did they do it that way\" or \"how does the mechanism work\"?</p>\n</blockquote>\n<p>Good question :) I think I am <code>why did they do it that way</code> - that way being typeclass F, which implicitly means <code>how else would you do it</code> - to which I thought <code>Coe, extend-magic</code> and you answered - <code>well, that's not how Coe and extends work</code>. So I think we can resolve this.</p>\n<p>P.S. The more I think about this might be a form of <a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\">https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern</a> if one squints at it</p>",
        "id": 504348933,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741492300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> has marked this topic as resolved.</p>",
        "id": 504349127,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741492458
    },
    {
        "content": "<p>(the reason why 'subtype' has a specific meaning in lean might be due to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a>)</p>",
        "id": 504369762,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741509920
    },
    {
        "content": "<p>I think it's called <code>Subtype</code> because in type theory it's known as a subtype :-) Here's the page of HoTT that defines it <a href=\"https://homotopytypetheory.org/wp-content/uploads/2013/03/hott-online-323-g28e4374.pdf#page=123\">https://homotopytypetheory.org/wp-content/uploads/2013/03/hott-online-323-g28e4374.pdf#page=123</a> (there, it's notation for a sigma type).</p>\n<p>It's the same kind of sub- as a subgroup, but in the category theory sense (there's no subset relation between types, but instead you can define what subobjects are in terms of monomorphisms). There's also a formal correspondence between <code>Set X</code> and isomorphism classes of subtypes of <code>X</code>. (In particular, the isomorphism class for an injection <code>f : S -&gt; X</code> is determined by its range set.)</p>",
        "id": 504371648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741511450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> Yeah, with structural types the type represents what you can do with the type, not how you can construct elements of the type. I was talking about OO and mentioning Java because TS is merging these notions with structural typing, and I wanted to emphasize that it's not because of optional typing. Like in your example, it seems to me that <code>y.name = {first: 'R'}</code> is unjustified because the types don't say what structure values you can construct, only which fields are guaranteed to exist. (To answer your question: Lean has immutable objects, but there are ways to write code that either simulates mutation or actually uses mutation at runtime, but via pointer-like objects.)</p>\n<p>Back to Lean, parent projections can have co/contra-variance issues, which makes Coe totally impossible as a solution. Look at how the type is <code>T</code> in the <code>#check</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"c1\">-- t.add 3 : T</span>\n</code></pre></div>\n<p>And, as you saw, even if it's a proof field, the projected version will be in terms of the projection to the parent. The only way to fix these issues using only structures is to redefine all the fields for each structure. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>It's possible to mimic the TS-like structural typing with typeclasses. For example, a type is an \"<code>XClass</code>\" if it supports getting and setting an \"<code>x</code> field\". It supports proper variance of input and output.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">XClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">setX</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">XClass</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">addX</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">XClass</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">setX</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">XClass</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">setX</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">XClass</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getX</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">setX</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T2</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">addX</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"c1\">-- addX t 3 : T</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">addX</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"c1\">-- addX t2 3 : T2</span>\n</code></pre></div>\n<p>I think you're right that this is like that template pattern in the link.</p>",
        "id": 504374658,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741513901
    },
    {
        "content": "<p>This makes a lot of sense. The curious thing (from language design standpoint) is that in your example you had to repeat the T2 Xclass instance definition character for character. Extends allow you to not repeat when defining the structure, but it didn’t help with carrying T1 instances to T2 (even though they share the base structure so it feels like the T1 instance would just work for T2). Am I missing some gotcha - like a bigger example where inheriting the instance would get you in trouble or is jt maybe a performance issue or style issue (some explicit repetition is sometimes good)</p>",
        "id": 504408690,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741537669
    },
    {
        "content": "<p>It's neither about avoiding getting into trouble, nor about performance, nor about style. It's <em>impossible</em> to inherit the <code>XClass T1</code> instance. The definitions are character-for-character identical, but that's a testament to the convenience of Lean's notations — still, they give very different definitions.</p>\n<p>Look carefully at the type of <code>#check t.add 3</code> in the example right before <code>XClass</code>. Then try defining <code>T2.add</code>, and look at the type of <code>#check t.add 3</code> again.</p>",
        "id": 504415892,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741543145
    }
]