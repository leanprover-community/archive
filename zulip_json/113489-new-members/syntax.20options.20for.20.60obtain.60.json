[
    {
        "content": "<p>So far I have seen <code>obtain</code> used in the following two ways:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">-- where h is a disjunction</span>\n\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"c1\">-- where h is a conjunction</span>\n</code></pre></div>\n<p>I was trying to decode the syntax (couldn't find any explanatory documentation) because the syntax doesn't appear to be consistent.</p>\n<p>I'd welcome an explanation or a pointer to docs. here are my immediate questions / assumptions:</p>\n<ul>\n<li>I guess the | is part of a pattern that unifies with disjunctions.</li>\n<li>I guess the comma is part of a pattern that unifies with conjunctions.</li>\n<li>But why does one have brackets and the other not?</li>\n</ul>\n<p>Are there other patterns used with <code>obtain</code>?</p>",
        "id": 472072319,
        "sender_full_name": "rzeta0",
        "timestamp": 1727029582
    },
    {
        "content": "<p><code>|</code> is if you have an inductive type with multiple variants; <code>\\&lt;&gt;</code> matches the syntax for constructors of types with multiple fields</p>",
        "id": 472072935,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727030106
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> I don't know what those words mean - sorry I am a beginner.</p>\n<p>I can't see any connection between induction (inductive proofs) and a disjunctive statement.</p>\n<p>Similarly I can't see the connection between constructors (object orients programming?) and conjunctive statements.</p>\n<p>I appreciate you trying to help. Are the words you are using from \"type theory\" ?</p>",
        "id": 472075499,
        "sender_full_name": "rzeta0",
        "timestamp": 1727031775
    },
    {
        "content": "<p>\"Inductive type\" is a general concept, and they are defined using the <code>inductive</code> and <code>structure</code> commands. If you've heard of \"algebraic data type\" from other languages, it's similar.</p>",
        "id": 472075611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031877
    },
    {
        "content": "<p>The notation <code>⟨a, b, c, ...⟩</code> is used in Lean for creating data using a constructor, and so <code>obtain</code> uses it to extract data from a constructor.</p>\n<p>The <code>|</code> is used in the <code>inductive</code> command for separating all the constructors, and so <code>obtain</code> uses it to separate each alternative.</p>",
        "id": 472075755,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031964
    },
    {
        "content": "<p>Basically, you can have two kinds of types:</p>\n<ul>\n<li>a type where you have fields a, b, c, and a value of your type has all of those. For example: a rational number given by a numerator and denominator</li>\n<li>a type where you have one of several options: e.g. an integer defined as <em>either</em> a nonnegative number <em>or</em> a negative one &lt;-- these are inductive types</li>\n</ul>",
        "id": 472075833,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727032069
    },
    {
        "content": "<p><code>⟨ha | hb⟩</code> would mean \"match a value from a type with a unique constructor whose first value is from a type with two constructors, and bind the result to <code>ha</code> or <code>hb</code>, respectively.\"</p>",
        "id": 472075836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727032070
    },
    {
        "content": "<p>They're called \"inductive types\" because they come with induction principles. The definition of <code>Nat</code> in Lean as an inductive type automatically gives the usual induction principle for natural numbers.</p>",
        "id": 472075923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727032137
    },
    {
        "content": "<p>A value of the first kind can be written as <code>{ a := ..., b := ..., c := ... }</code> or shorter as <code>⟨..., ...., ...⟩</code></p>",
        "id": 472075940,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1727032155
    },
    {
        "content": "<p>Explicitly, if you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">three</span>\n</code></pre></div>\n<p>then you would use this with <code>obtain</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>",
        "id": 472088832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727042976
    },
    {
        "content": "<p>thanks for the replies, I will have to print this out ands study it</p>",
        "id": 472201003,
        "sender_full_name": "rzeta0",
        "timestamp": 1727090607
    },
    {
        "content": "<p>The syntax is documented in the docstring of <code>rcases</code>. If <code>obtain</code>s docstring does not point to that, we should fix that.</p>",
        "id": 472219406,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1727095376
    }
]