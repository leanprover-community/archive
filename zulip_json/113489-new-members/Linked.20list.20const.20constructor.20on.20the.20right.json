[
    {
        "content": "<p>Hi! For a project I'm working on I would like to have a type that's like <code>List Nat</code>, but with a constructor for appending a natural on the right instead of the left. I guess I could make an inductive type myself, but I also want to use all of Mathlib's functions on lists and lemmas about lists. I'd like to have appending to the right as a constructor, so that proofs by cases will work. Is there a canonical way to do this?</p>",
        "id": 520148112,
        "sender_full_name": "C7X",
        "timestamp": 1748048220
    },
    {
        "content": "<p>Why can't you just use <code>List Nat</code> and read all the list right-to-left?</p>",
        "id": 520148305,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748048368
    },
    {
        "content": "<p>I currently have code that's based on the programmer writing all List literals in reverse and having to swap left and right in their head, but I think it might be more convenient to have code which doesn't require accounting for left-to-right reflection in the programmer's head</p>",
        "id": 520148541,
        "sender_full_name": "C7X",
        "timestamp": 1748048551
    },
    {
        "content": "<p>Why don't you write your own custom recursor for lists and instead of cases do <code>induction x using List.myrecursor</code>?</p>",
        "id": 520174942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748073290
    },
    {
        "content": "<p>There might even be an option to change the default recursor for an inductive type but I can't remember whether you'd need a core change to access this functionality for <code>List</code> or whether it can be done locally in a file</p>",
        "id": 520175050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748073405
    },
    {
        "content": "<p>I think it can be done locally with <code>@[cases_eliminator]</code> and <code>@[induction_eliminator]</code></p>",
        "id": 520184738,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748082512
    },
    {
        "content": "<p>Or if this is really for programmers, you could use Array and push</p>",
        "id": 520200829,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748095901
    },
    {
        "content": "<p>Thanks, I can try this! I'm relatively new to Lean so I can't guarantee that I will be able to write a recursor yet, but I'll see what I can do!</p>",
        "id": 520227213,
        "sender_full_name": "C7X",
        "timestamp": 1748116936
    },
    {
        "content": "<p>You can practice by writing the induction principle first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hnil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hsnoc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">last</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 520229331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1748118989
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>It already exists as</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.reverseRecOn#doc\">docs#List.reverseRecOn</a></p>\n</div></div>",
        "id": 520234900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748124122
    }
]