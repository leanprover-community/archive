[
    {
        "content": "<p>What does the <code>LT</code> in <code>LT.lt.not_lt</code> mean?</p>\n<p>I read this as a <strong>namespace</strong> similar to the <code>Nat</code> namespace under which several lemmas related to natural numbers reside.</p>\n<p>What namespace is <code>LT</code>?</p>",
        "id": 485978854,
        "sender_full_name": "rzeta0",
        "timestamp": 1733270453
    },
    {
        "content": "<p>It's a notation typeclass, in particular a structure.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT.lt#doc\">docs#LT.lt</a> is a projection of the structure.</p>",
        "id": 485979807,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1733270809
    },
    {
        "content": "<p>It is a namespace, as you guessed, but it was automatically generated when the typeclass <code>LT</code> was defined. So <code>LT</code> is both a namespace and a typeclass. (Technically, namespaces aren't \"generated\", since they are basically just a prefix for an identifier, but in any case the <code>lt</code> was automatically added to the <code>LT</code> namespace)</p>",
        "id": 485982261,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733271894
    },
    {
        "content": "<p>What's a type class?</p>\n<p>Is it things like <code>LinearOrdered</code> ? If so, what properties define an object in the type class <code>LT</code> ?</p>\n<p>This is far outside my comfort zone so feel free to tell me to ignore this question for now.</p>\n<p>The reason I pursued it is because  the naming convention for lemmas isn't as intuitive or predicable as I had hoped.</p>",
        "id": 485983445,
        "sender_full_name": "rzeta0",
        "timestamp": 1733272470
    },
    {
        "content": "<p>Type classes are a bit of a complicated subject. Semi-formally, a typeclass is a structure or inductive type that is allowed to appear in [] brackets as arguments to a <code>def</code>,<code>lemma</code>,<code>theorem</code>,etc. and is allowed to appear as the type of an <code>instance</code> definition. Don't worry if that didn't make sense right now.</p>\n<p>Typeclasses basically serve the same role as <code>interface</code>s from Java and C#, or <code>trait</code>s in Rust. You can read about them in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a></p>\n<p>For your specific problem, basically note that mathematicians didn't want to have to reprove the same theorem for Nat and Int and Real if the theorem only used the &lt; symbol. So the same theorem in Mathlib might work for Nat and some other types. So instead of <code>Nat.le_trans</code>, the theorem might just be named <code>le_trans</code>.</p>",
        "id": 485988543,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733275073
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT#doc\">docs#LT</a> shows that it is a type with an <code>lt</code> function.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrder#doc\">docs#LinearOrder</a> shows that not only does it have <code>lt</code>, but 15 other fields as well.</p>",
        "id": 485989968,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733275828
    },
    {
        "content": "<p>(Fun fact <span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span>, namespaces actually do have some reality, and an <code>LT</code> namespace is created at some point. I think Lean keeps track of namespaces for resolving names and giving completions. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Environment.registerNamespace#doc\">docs#Lean.Environment.registerNamespace</a>)</p>",
        "id": 485990396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276054
    },
    {
        "content": "<p>Oh that's interesting, I didn't know that. This is usually not relevant to the end-user though, right?</p>",
        "id": 485990986,
        "sender_full_name": "Niels Voss",
        "timestamp": 1733276402
    },
    {
        "content": "<p>I <em>think</em> it's pretty much just an optimization, so that Lean can consult a list of all the namespaces without needing to traverse the complete set of all declarations to compute it.</p>",
        "id": 485991264,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1733276524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20is.20LT.20in.20.60LT.2Elt.2Enot_lt.60.3F/near/485983445\">said</a>:</p>\n<blockquote>\n<p>The reason I pursued it is because the naming convention for lemmas isn't as intuitive or predicable as I had hoped.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> please note: the name of this lemma is <em>special</em>. It is not meant to be as natural as you might expect, it's explicitly useful for <em>dot notation</em>. In particular, if you have <code>h : a &lt; b</code>, then you can write <code>h.not_lt</code> for a proof of <code>Â¬ b &lt; a</code>.</p>\n<p>In fact, if you look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT.lt.not_lt#doc\">docs#LT.lt.not_lt</a>, you'll see that this is an <code>alias</code> for the lemma with the proper name: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_asymm#doc\">docs#lt_asymm</a>.</p>",
        "id": 485992926,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1733277332
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=not_lt_of_lt#doc\">docs#not_lt_of_lt</a>, which is yet another alias of <code>lt_asymm</code>.</p>",
        "id": 485993126,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1733277408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> Maybe the following also helps to explain the name.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- a &lt; b : Prop</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- LT.lt a b : Prop</span>\n</code></pre></div>\n<p>So <code>a &lt; b</code> doesn't really fit into the low-level way that Lean thinks about the world: functions applied to other things by juxtaposition, like <code>f x</code>.<br>\nIt does fit into a higher-level way that Lean understands, by using a notation system that allows infix operators. So at some point <code>a &lt; b</code> was introduced as notation for <code>LT.lt a b</code>, and the latter is an ordinary function application again.</p>\n<p>So if you have <code>h : a &lt; b</code>, then under the hood that means <code>h : LT.lt a b</code>. And therefore you can use dot-notation:</p>\n<ul>\n<li>lemmas with names of the form <code>LT.lt.foobar</code></li>\n<li>that take an argument <code>(hyp : x &lt; y)</code></li>\n<li>can be can be called as `h.foobar</li>\n<li>and will have <code>h</code> passed as the argument <code>hyp</code>.</li>\n</ul>\n<p>Just like if you have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Whenever you have a <code>k : Nat</code> floating around, you can call <code>k.factorial</code>. Because Lean will inspect the type of <code>k</code>, and find that it is <code>Nat</code>. So then it looks for <code>Nat.factorial</code>, and passes <code>k</code> as the first argument of type <code>Nat</code>.</p>\n<p>If you write <code>h.not_lt</code> then Lean inspects the type of <code>h</code>, finds that it has type <code>LT.lt a b</code>, and therefore looks for a lemma called <code>LT.lt.not_lt</code>. Then passes <code>h</code> as the first argument of type <code>LT.lt _ _</code> to that lemma.</p>",
        "id": 486016976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1733290761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/what.20is.20LT.20in.20.60LT.2Elt.2Enot_lt.60.3F/near/485991264\">said</a>:</p>\n<blockquote>\n<p>I <em>think</em> it's pretty much just an optimization, so that Lean can consult a list of all the namespaces without needing to traverse the complete set of all declarations to compute it.</p>\n</blockquote>\n<p>not just an optimization, it impacts how <code>open</code> resolves, as well as whether it will error</p>",
        "id": 486279637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733397089
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">A</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- unknown namespace 'foo'</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"c1\">-- resolves to _root_.bar</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"c1\">-- ok</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\">  </span><span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\">  </span><span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"c1\">-- ok</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"c1\">-- resolves to A.bar</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 486280931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733397561
    }
]