[
    {
        "content": "<p>I'm trying out LEAN for the first time and I'm very interested. I'm a functional analyst, so fine with math. I'm a quite accomplished Python coder, so not new to (imperative) programming. </p>\n<p>After some weeks of reading up on how dependent type theory works and watching proofs on the Xena project youtube channel, I thought to try to prove 1+2+3+...+n = n*(n+1)/2 by induction using LEAN without any help, but got stuck at the steps that are obvious to humans, e.g., finding proofs of simple equalities like</p>\n<p>N * (N - 1) + 2*N = N *(N +1)   with N : nat.</p>\n<p>Is there any advice on overcoming such trivial and mathematically uninteresting roadblocks? My question is maybe more general than \"which are the one or two tactics to use in this situation?\", but perhaps rather: </p>\n<p>1) How should I approach learning what will be useful and where to find it, or how to produce something useful myself, when 'suggest' and 'library_search' or an obvious rewrite fails to produce anything? </p>\n<p>2) How does a beginner understand what a tactic actually does when its source code is a bit opaque to the beginner? If I'm more interested in getting on with the math, are the inner workings important to understand? E.g. encountering \"exact congr_fun rfl\" is easy to understand if you have a basic understanding of the type theory poke around in the source a bit, but something like what EXACTLY \"linarith\" does is harder to understand, but perhaps not as important.</p>\n<p>3) How should one approach reading LEAN and writing LEAN for readability? I struggle sometimes to 'see the math' in LEAN code. E.g., Say a human wants to understand the mathematics in a formal proof written in LEAN with all comments deleted? I assume in practice that it will be far easier to step through a proof with the LEAN infoview than to try to only use ONLY the source code itself.</p>",
        "id": 270700614,
        "sender_full_name": "Miek Messerschmidt",
        "timestamp": 1643973558
    },
    {
        "content": "<p>I would say the best thing is what you are already doing: trying to formalize simple results, getting stuck (we've all been there!) and asking for help. Hare you tried the natural number game?</p>",
        "id": 270701553,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643974034
    },
    {
        "content": "<p>In your specific example, you can try <code>ring</code> that may be close the goal immediately (<code>ring</code> should automatically do simple computations like this), or using a chain of <code>rw</code>. For example <code>rw mul_add</code> it's a start.</p>",
        "id": 270701739,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643974140
    },
    {
        "content": "<p>You probably shouldn't try to read the implementation of complicated tactics like <code>linarith</code>, at least until you are quite skilled at reading lean code. Much better to read the tactic documentation: <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#linarith\">tactic#linarith</a></p>",
        "id": 270701741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643974140
    },
    {
        "content": "<p>Welcome! Indeed, figuring out how to easily do the obvious is still the biggest challenge for me, and I'd say I'm pretty experienced with Lean :)</p>",
        "id": 270701797,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643974184
    },
    {
        "content": "<ol>\n<li>Generally my process for finding relevant results is <code>library_search</code>/<code>suggest</code> → <code>simp?</code> → search for useful-sounding strings → ask on the <a class=\"stream\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F\">#Is there code for X?</a> stream: <code>simp?</code> will sometimes tell you how to rephrase your goal in a way that the library is more useful for. And code search is more powerful than I initially expected since we use a very predictable naming scheme. So for your goal <code>n * (n - 1)</code> I'd try searching for \"mul_sub_one\" and \"mul_pred\" (no results unfortunately).</li>\n</ol>",
        "id": 270701852,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643974205
    },
    {
        "content": "<p>the key point to understanding what it can do is the line \"<code>linarith</code> should prove any goal that is true in the theory of linear arithmetic over the rationals\". That's a bit of jargon but it means that linarith can prove things like <code>x + y &lt; z -&gt; x &lt; 2 -&gt; 2 + y &lt; z</code></p>",
        "id": 270701940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643974271
    },
    {
        "content": "<ol start=\"2\">\n<li>Mathlib is unfortunately written in a style that makes it harder than necessary for beginners. When I want to understand how to use an area of the library, I'll just go through the statements and ignore the proofs, then later come back and see how specific things are done. Sometimes there are nicely-structured proofs but often we just want to finish it as quickly as possible.</li>\n</ol>",
        "id": 270701976,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643974300
    },
    {
        "content": "<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>",
        "id": 270701981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643974304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/some.20general.20beginner.20questions/near/270701981\">said</a>:</p>\n<blockquote>\n<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>\n</blockquote>\n<p>This kind of advice can sometimes be found in the module documentation at the top of files. And sometimes it's a bit of community wisdom that you just have to be around long enough to pick up.</p>",
        "id": 270702243,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643974461
    },
    {
        "content": "<p>Another good decision procedure to have under your belt is the <code>ring</code> tactic, which handles equations over a commutative ring or semiring. This is the closest thing to your goal, so that's what I would try, but as Riccardo says the subtraction and division will cause problems because they are not ring operations (subtraction on <code>nat</code> saturates on underflow), so a reasonable approach to proving the theorem is to first get rid of these operations using lemmas about subtraction and division, and then once everything is <code>+</code> and <code>*</code> then <code>ring</code> will finish the goal</p>",
        "id": 270702252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643974471
    },
    {
        "content": "<p>In that case I'd <br>\n<span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/some.20general.20beginner.20questions/near/270701981\">said</a>:</p>\n<blockquote>\n<p>Also, beware that working with expressions like <code>n*(n-1)/2</code>, for <code>n : nat</code> can be <em>very</em> frustrating . Try to avoid statement involving division of natural/integer numbers.</p>\n</blockquote>\n<p>In that case, I'd advise using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.asc_factorial\">docs#nat.asc_factorial</a></p>",
        "id": 270702316,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643974534
    },
    {
        "content": "<p>Since the statement includes subtraction only in <code>N - 1</code>, I'd handle <code>n = 0</code> as a special case, giving something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">N</span> <span class=\"bp\">=</span> <span class=\"n\">N</span> <span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">N</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 270702420,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1643974598
    },
    {
        "content": "<p>Thank you for the responses everyone. Definitely helpful.  As <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>  suggests I probably just need to keep playing around (and yes, it certainly makes sense to not be dividing stuff living in nat).</p>",
        "id": 270721072,
        "sender_full_name": "Miek Messerschmidt",
        "timestamp": 1643984482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"471725\">Miek Messerschmidt</span> has marked this topic as resolved.</p>",
        "id": 270721078,
        "sender_full_name": "Notification Bot",
        "timestamp": 1643984485
    },
    {
        "content": "<p>For discovering useful lemmas, I find <code>library_search</code> very helpful but I rarely get anything helpful from <code>suggest</code>.  Another useful general-purpose tactic is <code>tidy?</code>, which does as much as it can to solve the problem and then reports back the exact sequence of tactics it found.  The output of <code>tidy?</code> is often ugly and overpowered, but you can usually edit it down to something more sensible that gets the job done.</p>",
        "id": 270721498,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643984663
    },
    {
        "content": "<p>Have you seen the documentation on the tactics? (<a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html\">https://leanprover-community.github.io/mathlib_docs/tactics.html</a>)</p>",
        "id": 270722220,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643985027
    },
    {
        "content": "<p>So, for example, <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#linarith\">tactic#linarith</a> explains what <code>linarith</code> does and how to use it without having to read the source code.</p>",
        "id": 270722406,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643985134
    },
    {
        "content": "<p>mathlib code is not intended to be read as an inert block of text on the screen (as you might read Python code, for example).  For almost any proof more than a couple of lines long the only way to follow it is interactively by stepping through it in an editor like Visual Studio Code, where you can see what happens to the premises and the goal at each step.</p>",
        "id": 270722929,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643985426
    },
    {
        "content": "<p>Another good method of discovery is to cast wishes with <code>have</code> and then make them come true with <code>library_search</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> That is, you say \"I'm pretty sure XYZ must be true\",  and write <code>have : XYZ, { sorry }</code>.  Then you ask <code>library_search</code> to fill in the <code>sorry</code>.  You can sometimes outline the whole structure of a proof like this, formalising each sentence that a mathematician would write in an informal proof, and then go back and fill in all the <code>sorry</code>s once Lean has confirmed that this sequence of stepping-stones really would get you to the goal.</p>",
        "id": 270723849,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643985886
    },
    {
        "content": "<p>If you're using an editor with suggested auto-completions like VS Code then you can take advantage of mathlib's naming convention.  For example, if you start typing <code>have := nat.mul_sub</code> then the editor will open a list of theorems containing those characters in that order, which hopefully will include something involving multiplication and subtraction of natural numbers.</p>",
        "id": 270724560,
        "sender_full_name": "Stuart Presnell",
        "timestamp": 1643986221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422543\">Stuart Presnell</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20some.20general.20beginner.20questions/near/270723849\">said</a>:</p>\n<blockquote>\n<p>Another good method of discovery is to cast wishes with <code>have</code> and then make them come true with <code>library_search</code></p>\n</blockquote>\n<p>Yes, this is a basic one that I saw somewhere. </p>\n<blockquote>\n<p>mathlib code is not intended to be read as an inert block of text on the screen (as you might read Python code)</p>\n</blockquote>\n<p>I've gotten spoiled, I see. In Python world, the code itself is often good documentation! Besides that, I kept googling and poking around the LEAN documentation instead of realizing that mathlib is separate and I should look there too. Thanks! From the mathlib docs <code>tidy?</code> looks the tool I really was hoping would exist and to try with some basic exercises.</p>",
        "id": 270729076,
        "sender_full_name": "Miek Messerschmidt",
        "timestamp": 1643988183
    },
    {
        "content": "<p>Note that when it comes to readability, in Lean there is quite a difference in learning curve between <em>statements</em> and <em>proofs</em>.<br>\nGenerally, the statements and definitions should be quite readable.<br>\nProofs are a different beast.</p>",
        "id": 270729302,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1643988265
    }
]