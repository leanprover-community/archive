[
    {
        "content": "<p>I'm trying to reproduce <a href=\"https://jrdngr.github.io/pngme_book/\">https://jrdngr.github.io/pngme_book/</a> in Lean, but there seems to be many problems about low-level bytes interpretation.<br>\nAs an example, I have the following structures defined in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ancillary</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span>\n<span class=\"w\">  </span><span class=\"n\">private_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span>\n<span class=\"w\">  </span><span class=\"n\">reserved</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span>\n<span class=\"w\">  </span><span class=\"n\">safe_to_copy</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Char</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Chunk</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">chunk_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\">       </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">UInt8</span>\n<span class=\"w\">  </span><span class=\"n\">crc</span><span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n</code></pre></div>\n<p>If I want to read a binary file with <code>IO.FS.readBinFile</code>, it returns <code>ByteArray</code>. How do I turn this <code>ByteArray</code> into a <code>Chunk</code>?<br>\nI've tried some FFI to handle the transformation between <code>UInt32</code> and <code>UInt8</code>, but it's quite ugly. Is there a right way to turn a <code>UInt32</code> to 4 <code>UInt8</code>? More generally, for any data type, how to turn it into a <code>ByteArray</code>?</p>",
        "id": 499224520,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1739364783
    },
    {
        "content": "<p>You're asking two questions here, one is how do we deserialize binary structures and the other is how do we serialize them.</p>\n<p>For deserializing the best thing I can offer is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Internal.Parsec.ByteArray.Parser#doc\">docs#Std.Internal.Parsec.ByteArray.Parser</a> which is currently not a stabilized API but works well for high performance parsing of binary data as for example implemented in the LRAT checker for <code>bv_decide</code>.</p>\n<p>For serializing data there does not really exist a framework yet. Do note that it is possible to turn a <code>UInt32</code> into a <code>UInt8</code> in at least two ways (little and big endian) so there is quite some work to be done to support a comprehensive serialisation framework for stuff like this.</p>",
        "id": 499236759,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739367807
    },
    {
        "content": "<p>It seems much more complicated than in Rust. I wonder why we don't have implementation for something like <code>.bytes()</code> and <code>.from_bytes()</code> for the basic data types.<br>\nCurrently I don't quite understand how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Internal.Parsec.ByteArray.Parser#doc\">docs#Std.Internal.Parsec.ByteArray.Parser</a> works. At first glance I need to manually implement a parser for my structure.<br>\nAnyway thanks for your answer. I will try to figure it out.</p>",
        "id": 499249152,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1739370811
    },
    {
        "content": "<blockquote>\n<p>It seems much more complicated than in Rust. I wonder why we don't have implementation for something like <code>.bytes()</code> and <code>.from_bytes()</code> for the basic data types.</p>\n</blockquote>\n<p>Because nobody has done it, it is entirely possible but we do not have infinite time.</p>\n<blockquote>\n<p>At first glance I need to manually implement a parser for my structure.</p>\n</blockquote>\n<p>Yes, nobody has implemented automated generation of parsers yet because there was no demand and time is not infinite.</p>\n<p>You have to keep in mind that you are asking for a niche feature in an eco system that is currently mostly focused on developing everything you need for proving stuff and has only recently started systematically working on programming related APIs while Rust has had a literal decade of hundreds of people writing open source libraries to do these kind of things. If you want this kind of feature you could be the person that writes the library that people end up using^^</p>",
        "id": 499252754,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739371768
    },
    {
        "content": "<p>Do we have anyone working on the infinite time problem? That seems nice to solve.</p>",
        "id": 499253862,
        "sender_full_name": "Julian Berman",
        "timestamp": 1739372034
    },
    {
        "content": "<p>I should have more or less all the main pieces to get this working. (with one caveat, it can support only fixed size arrays in a struct i.e. you have to use <code>Vector</code> instead of <code>Array</code>)</p>\n<p>In the library I'm working on, SciLean, I have a class <a href=\"https://github.com/lecopivo/SciLean/blob/53f112d9c99068a8231454c078525facd4ca2404/SciLean/Data/DataArray/PlainDataType.lean#L40\"><code>PlainDataType X</code></a> allowing you write <code>X</code> to/from <code>ByteArray</code>. One restriction is that <code>X</code> has to have fixed bit/byte size hence you can't provide in instance <code>PlainDataType (Array X)</code> but you can provide an instance <code>PlainDataType (Vector X n)</code>.</p>\n<p>(Also a warning: there are no proofs and the spec is most likely incomplete and likely inconsistent in some very niche scenarios. Anyway the code runs and so far I have not found any bugs)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>PlainDataType</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">BitType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span>\n<span class=\"w\">  </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\">  </span><span class=\"c1\">-- we consider only types fitting into a single byte</span>\n<span class=\"w\">  </span><span class=\"n\">fromByte</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">toByte</span><span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span>\n<span class=\"w\">  </span><span class=\"c1\">-- TODO: Add condition that toByte sets all unused bits to zero</span>\n<span class=\"w\">  </span><span class=\"c1\">-- TODO: Add condition that fromByte does not use any of the unused bits</span>\n<span class=\"w\">  </span><span class=\"n\">fromByte_toByte</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromByte</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toByte</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span>\n<span class=\"w\">  </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\">  </span><span class=\"c1\">-- for one byte types use BitType</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Read `a : α` from byte array `b` starting at the byte `i` -/</span>\n<span class=\"w\">  </span><span class=\"n\">fromByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"n\">bytes</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Write `a : α` from byte array `b` starting at the byte `i` -/</span>\n<span class=\"w\">  </span><span class=\"n\">toByteArray</span><span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"n\">bytes</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b.size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span>\n\n<span class=\"w\">  </span><span class=\"sd\">/-- `toByteArray` does not modify ByteArray size -/</span>\n<span class=\"w\">  </span><span class=\"n\">toByteArray_size</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b.size</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- we can recover `a` from bytes -/</span>\n<span class=\"w\">  </span><span class=\"n\">fromByteArray_toByteArray</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fromByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `toByteArray` does not affect other bytes -/</span>\n<span class=\"w\">  </span><span class=\"n\">fromByteArray_toByteArray_other</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">uget</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b.uget</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">btype</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">⊕</span><span class=\"w\"> </span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n</div></div>\n<p>To write structures from/to byte arrays can use mathlib's <code>proxy_equiv%</code> which generates equivalence between structure and some canonical type. For example, <code>proxy_equiv% ChunkType</code> returns  <code>(_ : Char) × (_ : Char) × (_ : Char) × Char ≃ ChunkType</code></p>\n<p>To get this working we need two pieces.</p>\n<ol>\n<li><code>PlainDataType</code> instance for sigma type(dependent product <code>(_ : α) × β</code>) </li>\n<li>translate instance <code>PlainDataType</code> along an equivalence</li>\n</ol>\n<p>With all of this you can do this: <br>\n(I switched from <code>Char</code> to <code>UInt64</code> as for <code>Char</code> I would have to provide <code>BitType</code> instead of <code>ByteType</code>. This way it made it a bit simpler for me.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ancillary</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">private_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">reserved</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">safe_to_copy</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n\n<span class=\"c1\">-- translate instance `PlainDataType ((_ : UInt64) × (_ : UInt64) × (_ : UInt64) × UInt64)` to `PlainDataType ChunkType `</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"bp\">.</span><span class=\"n\">ofEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- turn `ChunkType` into `ByteArray` (the function is a bit of a mess because of missing API)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"bp\">.</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">PlainDataType</span><span class=\"bp\">.</span><span class=\"n\">btype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ByteArray</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">mkArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sorry_proof</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"c1\">-- [1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ChunkType</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">256</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"mi\">65536</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">+</span><span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"mi\">16777216</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toByteArray</span>\n</code></pre></div>\n<p>mwe using SciLean<br>\n(you can just rip this <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Data/DataArray/PlainDataType.lean\">file</a> out of the project, you will have to remove the <code>import SciLean.Data.IndexType</code> and the corresponding instance somewhere in the file)</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">SciLean.Data.DataArray.PlainDataType</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic.ProxyType</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">SciLean</span>\n\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">Prod.byteTypeSigma</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ta</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ta.bytes</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">tb.bytes</span>\n<span class=\"w\">    </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n\n<span class=\"w\">    </span><span class=\"n\">fromByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"o\">⟨</span><span class=\"n\">ta.fromByteArray</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span><span class=\"o\">,</span>\n<span class=\"w\">       </span><span class=\"n\">tb.fromByteArray</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"n\">ta.bytes</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span><span class=\"o\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ta.toByteArray</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">          </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tb.toByteArray</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"n\">ta.bytes</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">toByteArray_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"n\">fromByteArray_toByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"n\">fromByteArray_toByteArray_other</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ByteType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"n\">fromByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"n\">toByteArray_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"n\">fromByteArray_toByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"n\">fromByteArray_toByteArray_other</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"n\">instPlainDataTypeSigma</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">ta</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">tb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">_</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">×</span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">btype</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ta.btype</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tb.btype</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">aBitType</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">bBitType</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">aBitType</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">bByteType</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">aByteType</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">bBitType</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"s2\">\"not implemented\"</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">aByteType</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">bByteType</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Prod.byteTypeSigma</span><span class=\"w\"> </span><span class=\"n\">aByteType</span><span class=\"w\"> </span><span class=\"n\">bByteType</span>\n\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">PlainDataType.ofEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">btype</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">p.btype</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">bt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">bits</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.bits</span>\n<span class=\"w\">      </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.h_size</span>\n<span class=\"w\">      </span><span class=\"n\">fromByte</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bt.fromByte</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">toByte</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.toByte</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f.symm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">fromByte_toByte</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">bt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.bytes</span>\n<span class=\"w\">      </span><span class=\"n\">h_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.h_size</span>\n<span class=\"w\">      </span><span class=\"n\">fromByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bt.fromByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bt.toByteArray</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f.symm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">toByteArray_size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">      </span><span class=\"n\">fromByteArray_toByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">      </span><span class=\"n\">fromByteArray_toByteArray_other</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sorry_proof</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ancillary</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">private_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">reserved</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n<span class=\"w\">  </span><span class=\"n\">safe_to_copy</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PlainDataType.ofEquiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">proxy_equiv</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">ChunkType.toByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ByteArray</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">PlainDataType.btype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">getRight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">|&gt;.</span><span class=\"n\">toByteArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ByteArray.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array.mkArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sorry_proof</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ChunkType.mk</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"mi\">256</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"bp\">+</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"mi\">65536</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"bp\">+</span><span class=\"mi\">4</span><span class=\"bp\">*</span><span class=\"mi\">16777216</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toByteArray</span>\n</code></pre></div>\n</div></div>",
        "id": 499280516,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739378682
    },
    {
        "content": "<p>So for your application you need to</p>\n<ol>\n<li>do a complete implementation of the instance <code>instPlainDataTypeSigma</code>. This should be just copy/paste of <a href=\"https://github.com/lecopivo/SciLean/blob/53f112d9c99068a8231454c078525facd4ca2404/SciLean/Data/DataArray/PlainDataType.lean#L175\"><code>instPlainDataTypeProd</code></a>  where you switch from <code>(,)</code> to <code>⟨,⟩</code> where appropriate</li>\n<li>provide instance <code>PlainDataType α → PlainDataType (Vector α n)</code></li>\n<li>redefine <code>Chunk</code> to</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Chunk</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">chunk_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span>\n<span class=\"w\">  </span><span class=\"n\">data_size</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\">       </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">data_size</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">crc</span><span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n</code></pre></div>",
        "id": 499281841,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739379047
    },
    {
        "content": "<p>I would be happy for a PR to SciLean doing this :) also together with a <code>deriving</code> extension such that you can just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Chunk</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">chunk_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\">       </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">crc</span><span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">PlainDataType</span>\n</code></pre></div>",
        "id": 499282582,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739379256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20read.20binary.20files.20into.20Lean's.20type.3F/near/499281841\">said</a>:</p>\n<blockquote>\n<p>So for your application you need to</p>\n<ol>\n<li>do a complete implementation of the instance <code>instPlainDataTypeSigma</code>. This should be just copy/paste of <a href=\"https://github.com/lecopivo/SciLean/blob/53f112d9c99068a8231454c078525facd4ca2404/SciLean/Data/DataArray/PlainDataType.lean#L175\"><code>instPlainDataTypeProd</code></a>  where you switch from <code>(,)</code> to <code>⟨,⟩</code> where appropriate</li>\n<li>provide instance <code>PlainDataType α → PlainDataType (Vector α n)</code></li>\n<li>redefine <code>Chunk</code> to</li>\n</ol>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Chunk</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">length</span><span class=\"w\">     </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">chunk_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ChunkType</span>\n<span class=\"w\">  </span><span class=\"n\">data_size</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"w\">       </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"n\">data_size</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">crc</span><span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt32</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It looks promising, I'll try. Nice idea to have a <code>PlainDataType</code> class.</p>",
        "id": 499384188,
        "sender_full_name": "Yicheng Tao",
        "timestamp": 1739425772
    },
    {
        "content": "<p>Ah I missed one thing, <code>Chunk</code> still does not have a fixed byte size as defined which is necessary for <code>PlainDataType</code>. There are two options:</p>\n<ol>\n<li>Work with <code>Chunk data_size</code> i.e. parametrize <code>Chunk</code> by the size of <code>data</code>. Now you have a type with a fixed byte size. </li>\n<li>Generalize <code>PlainDataType</code> to types that don't have fixed byte size. Probably every type will have a well defined minimal byte size and from reading this minimal part you can infer the actual size of the element.</li>\n</ol>\n<p>Of course you can kind of mix 1 and 2. Store at the beginning <code>ByteArray</code>  the value of <code>data_size</code> and after that store <code>Chunk data_size</code>.</p>",
        "id": 499506930,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1739461281
    }
]