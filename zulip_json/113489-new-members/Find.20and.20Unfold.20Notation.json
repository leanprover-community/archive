[
    {
        "content": "<p>Hello,</p>\n<p>I am trying to find the definition of and unfold a particular notation in my Lean 4 proofs.</p>\n<p>Specifically, I am trying to unfold the <code>⋃ _ ∈ _, _</code> notation, which I believe is for union of indexed families of sets. I believe this is for <code>Set.iUnion</code>, but I would like to unfold this notation in the proof context to see exactly what is happenning and if there are any implicit arguments.</p>\n<p>Furthermore, I was attempting to find lemmas with <code>⋃ _ ∈ _, _</code> via</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"s2\">\"⋃ _ ∈ _, _\"</span><span class=\"w\"> </span><span class=\"c1\">-- does not show anything?</span>\n<span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- gives an error</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">elaboration</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Notation3</span><span class=\"bp\">.«</span><span class=\"n\">termExpand_binders</span><span class=\"bp\">%</span><span class=\"o\">(</span><span class=\"bp\">_=&gt;_</span><span class=\"o\">)</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"bp\">_»'</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">implemented</span>\n<span class=\"w\">  </span><span class=\"n\">expand_binders</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>Is there a way for me to unfold and find lemmas with these notations?</p>\n<p>Thanks!</p>",
        "id": 499795009,
        "sender_full_name": "Rudy Peterson",
        "timestamp": 1739554791
    },
    {
        "content": "<p>Those lemmas will probably have the word <code>biUnion</code> in their name, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.biUnion_pair#doc\">docs#Set.biUnion_pair</a> . You hopefully don't need to unfold the notation to figure out what's going on.</p>",
        "id": 499801590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739557095
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">--set_option pp.notation false , or just hover on notation to see the declaration</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">iUnion</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ ⨆ i ∈ s, F i = ⊤</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">iSup</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">sSup</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">instSupSet</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- you'll probably not get any further than this</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But as I say, this is not really the way to do it; hopefully the lemmas you need are there for bounded indexed unions.</p>",
        "id": 499802011,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1739557278
    },
    {
        "content": "<p>Notations don't need unfolding, they're purely a pretty printing phenomenon. If you hover over a notation in the Infoview, you can see what it stands for.</p>\n<p>You can use <code>set_option pp.notations false</code> outside your proof if you don't want to see any notations pretty printed.</p>",
        "id": 499835629,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739569333
    },
    {
        "content": "<p>Is there a way to search for lemmas and theorems with notations?</p>\n<p>My background is mainly from Coq where you can do stuff like:</p>\n<div class=\"codehilite\" data-code-language=\"Coq\"><pre><span></span><code><span class=\"kn\">Search</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">_</span> <span class=\"bp\">∈</span> <span class=\"o\">_,</span> <span class=\"o\">_)</span> <span class=\"o\">(_</span> <span class=\"bp\">∈</span> <span class=\"o\">_).</span>\n</code></pre></div>\n<p>Does the <code>#find</code> command in lean 4 allow one to do something similar?</p>\n<p>Thanks!</p>",
        "id": 499920155,
        "sender_full_name": "Rudy Peterson",
        "timestamp": 1739631083
    },
    {
        "content": "<p>Also, in my case, I was trying to rewrite the goal, and while the notation made the goal and the lemma appear exactly the same, the lemma had <code>match_2</code>, whereas the goal had <code>match_1</code>.</p>\n<p>What is the difference in lean 4?</p>",
        "id": 499920645,
        "sender_full_name": "Rudy Peterson",
        "timestamp": 1739631458
    },
    {
        "content": "<p>i believe <code>#loogle</code> is something which might suit your needs... As for your second question, can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 499921053,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739631756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/Find.20and.20Unfold.20Notation/near/499921053\">said</a>:</p>\n<blockquote>\n<p>i believe <code>#loogle</code> is something which might suit your needs... As for your second question, can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>\n</blockquote>\n<p>I tried using <code>#loogle</code> but maybe this specific notation is not supported?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">loogle</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Loogle</span><span class=\"w\"> </span><span class=\"n\">search</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">elaboration</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Notation3</span><span class=\"bp\">.«</span><span class=\"n\">termExpand_binders</span><span class=\"bp\">%</span><span class=\"o\">(</span><span class=\"bp\">_=&gt;_</span><span class=\"o\">)</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"bp\">_»'</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">implemented</span>\n<span class=\"w\">  </span><span class=\"n\">expand_binders</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">iUnion</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I'll do my best to come up with a MWE for the <code>match_1</code> <code>match_2</code> thing.</p>",
        "id": 499921704,
        "sender_full_name": "Rudy Peterson",
        "timestamp": 1739632215
    },
    {
        "content": "<p>the issue there is that the notation <code>⋃ _ ∈ _, _</code> refers to does not accept an underscore as bound variable, so it <em>doesn't elaborate</em>. replacing it with <code>x</code> instead <em>does</em> work</p>",
        "id": 499923281,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739633356
    },
    {
        "content": "<p>i.e. <code>#loogle (⋃ x ∈ _, _), (_ ∈ _)</code> works</p>",
        "id": 499923482,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739633477
    },
    {
        "content": "<p>(this is not a flaw of loogles, it's a flaw of how the notation for unions is implemented)</p>",
        "id": 499923519,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739633522
    },
    {
        "content": "<p>Are you sure it's not just the missing comma before <code>(_ ∈ _)</code>?</p>",
        "id": 499923617,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1739633581
    },
    {
        "content": "<p>oh right, that was another issue</p>",
        "id": 499923635,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739633594
    },
    {
        "content": "<p>Ah, my bad. Thanks!</p>",
        "id": 499923684,
        "sender_full_name": "Rudy Peterson",
        "timestamp": 1739633633
    },
    {
        "content": "<p>I'm surprised no one's reported that you can't use <code>_</code> for a binder for scoped notation yet! I guess everyone writes <code>_x</code> or something for unused binders?</p>",
        "id": 499933499,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739641105
    },
    {
        "content": "<p>Ah, I see why it's not currently supported: expanding <code>⋃ _ ∈ _, _</code> to <code>Set.iUnion fun _ ↦ Set.iUnion fun (h : _ ∈ _) ↦ _</code> would be a mistake. We need to generate a new name <code>x</code> to instead expand it to <code>Set.iUnion fun x ↦ Set.iUnion fun (h : x ∈ _) ↦ _</code>, to link the variable to the binder predicate</p>",
        "id": 499934364,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739641561
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/21924\">#21924</a> makes it possible to use <code>_</code> for the binder in <code>⋃ _ ∈ _, _</code></p>",
        "id": 499939072,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739643547
    }
]