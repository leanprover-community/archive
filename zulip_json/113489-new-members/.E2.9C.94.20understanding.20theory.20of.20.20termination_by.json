[
    {
        "content": "<p>I'm working through MoP and have found a gap in my understanding around <code>termination_by</code>.</p>\n<p>I wanted to check my understanding of the theory:</p>\n<ul>\n<li>it is possible to define recursive functions which don't terminate</li>\n<li>one way to determine if a function terminates is to define a measure (evaluated using parameters that depend on the current state of the recursion) that decreased to zero with each iteration</li>\n<li>it can be <strong>any</strong> measure, it just needs to decrease to zero</li>\n<li>if we, or lean, can prove it decreases to zero that is a <strong>sufficient</strong> condition to prove termination</li>\n</ul>\n<p>I made the above off the top of my head - I have no background in this theory.</p>\n<p>It seems to me that some measures may decreased towards zero, but then \"go past\" zero and continue to get larger as negative numbers. Is this a problem?</p>",
        "id": 499617544,
        "sender_full_name": "rzeta0",
        "timestamp": 1739496338
    },
    {
        "content": "<p>In reference to your first bullet point, I think it is helpful to emphasize that by default lean does not allow a definition of a function that does not terminate. For example, you can look at the error that this gives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">does_not_terminate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">does_not_terminate</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>However, if you add the word <code>partial</code> to your definition then lean will allow it. As in the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">does_not_terminate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">does_not_terminate</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 499626185,
        "sender_full_name": "Eric Paul",
        "timestamp": 1739501250
    },
    {
        "content": "<blockquote>\n<ul>\n<li>it is possible to define recursive functions which don't terminate</li>\n</ul>\n</blockquote>\n<p>I don't think you can (in Lean), without explicitly opting-out of termination checking.</p>\n<blockquote>\n<ul>\n<li>one way to determine if a function terminates is to define a measure (evaluated using parameters that depend on the current state of the recursion) that decreased to zero with each iteration</li>\n</ul>\n</blockquote>\n<p>The termination measure doesn't have to be a <code>Nat</code>, it can return anything. It turns out that most of the time you will still be indirectly depending on <code>Nat</code> and its <code>&lt;</code> through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instWellFoundedRelationOfSizeOf#doc\">docs#instWellFoundedRelationOfSizeOf</a>. If you provide your own instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedRelation#doc\">docs#WellFoundedRelation</a> then Lean will use that instead. As an example, you will find lots of <code>termination_by</code> which is not based on <code>Nat</code> in <a href=\"https://tqft.net/mathlib4files/SetTheory/Ordinal/NaturalOps\">file#SetTheory/Ordinal/NaturalOps</a>.</p>\n<blockquote>\n<ul>\n<li>it can be <strong>any</strong> measure, it just needs to decrease to zero</li>\n</ul>\n</blockquote>\n<p>It can be any measure, as long as you (or Lean) can prove it <strong>decreases</strong> with every recursive call. If the measure is not based off of <code>Nat</code>, then this may or may not be \"to zero\".</p>\n<blockquote>\n<ul>\n<li>if we, or lean, can prove it decreases to zero that is a <strong>sufficient</strong> condition to prove termination</li>\n</ul>\n</blockquote>\n<p>Yes. It is also in some way necessary, in that if you can prove a function terminates, then there exists a termination measure which witnesses it (but not necessarily on <code>Nat</code>).</p>",
        "id": 499628949,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739502997
    },
    {
        "content": "<p>thanks this is extremely helpful</p>\n<p>last question -  if a measure decreases, but doesn't reach a terminal value eg zero or one, how do we know the function will terminate?</p>\n<p>for example, if the measure is 1/n where n is the nth iteration, then it decreases but doesn't terminate?</p>",
        "id": 499629906,
        "sender_full_name": "rzeta0",
        "timestamp": 1739503754
    },
    {
        "content": "<p>The measure needs to be ordered with a well founded relation (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedRelation#doc\">docs#WellFoundedRelation</a>), so there cannot be infinite descending chains. The usual order in reals or rationals is not well founded, so the measure 1/n won't be accepted by Lean, if you are using the usual <code>&lt;</code>.</p>",
        "id": 499644258,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1739510800
    },
    {
        "content": "<p>And <code>1/n</code> also goes in the wrong direction, when <code>n</code> decreases, <code>1/n</code> increases.</p>",
        "id": 499646325,
        "sender_full_name": "Walter Moreira",
        "timestamp": 1739511800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> has marked this topic as resolved.</p>",
        "id": 499716815,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739533485
    }
]