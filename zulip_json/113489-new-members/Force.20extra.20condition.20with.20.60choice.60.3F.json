[
    {
        "content": "<p>Currently studying a deterministic string rewriting system, and I want to prove that a rewriting system either halts, loops, or produces ever increasingly long strings. I have a \"completed\" proof, except for a small hole. The idea is that if the system doesn't diverge on a string, there must be a string that repeats since the length of strings is bounded. The problem is that the way I'm applying the axiom of choice and pigeonhole principle doesn't give me a way to prove that <code>j i₁ ≠ j i₂</code>. I wonder if there's a way to make a \"better\" choice without loss of generality, or maybe there's a way to use a different PHP theorem like <code>Finite.exists_infinite_fiber</code> to obtain the stronger condition I need. Perhaps one of the kind Lean experts here could point me in the right direction to fix my proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ShortList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">ShortList</span><span class=\"bp\">.</span><span class=\"n\">finite</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ShortList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">finite_length_le</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_diverges'_halts_or_loops</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">diverges'</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">halts</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">loops</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `T.diverges A := ∀n : ℕ, ∃i : ℕ, ∀j &gt; i, (T.next^[j] A).length &gt; n`</span>\n<span class=\"w\">  </span><span class=\"c1\">-- so `¬T.diverges A ↔ ∃n : ℕ, ∀i : ℕ, ∃j &gt; i, (T.next^[j] A).length ≤ n`</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">diverges'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">i₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">i₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `h` says that there's some string length `n` such that after any number of steps `i`, we can</span>\n<span class=\"w\">    </span><span class=\"c1\">-- find another number of steps `j &gt; i` such that the length of the resulting string is less</span>\n<span class=\"w\">    </span><span class=\"c1\">-- than `n`. Use the axiom of choice to obtain `j : ℕ → ℕ`, which gives the index of a</span>\n<span class=\"w\">    </span><span class=\"c1\">-- subsequent short string from a previous one.</span>\n<span class=\"w\">    </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- With this function j, we have an infinite sequence of indices of strings shorter than `n`, of</span>\n<span class=\"w\">    </span><span class=\"c1\">-- which there are finitely many. By the pigeonhole principle, some string must repeat.</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ShortList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right</span>\n<span class=\"w\">      </span><span class=\"bp\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">π</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">exists_ne_map_eq_of_infinite</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">A'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h3'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">exists_infinite_fiber</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Let `i₁ i₂ : ℕ` such that `j i₁` and `j i₂` are indices which produce a repeated string.</span>\n<span class=\"w\">    </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h4</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h5</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h6</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h5</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">val_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h5</span>\n<span class=\"w\">      </span><span class=\"n\">assumption</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- TODO: we have that i₁ ≠ i₂, but the current use of axiom of choice and pigeonhole principle</span>\n<span class=\"w\">    </span><span class=\"c1\">-- doesn't guarantee j i₁ ≠ j i₂. It should be possible to force such a choice, but I'm not sure</span>\n<span class=\"w\">    </span><span class=\"c1\">-- how to do this in Lean...</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h7</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">    </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₁</span>\n<span class=\"w\">    </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i₂</span>\n\n<span class=\"w\">  </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">  </span><span class=\"n\">wlog</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">i₂</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ne_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_le_of_ne</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- At this point, we must have either halted or found a loop. We can tell these cases apart easily</span>\n<span class=\"w\">  </span><span class=\"c1\">-- by checking if the length of the string is less than `T.v`.</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_or_ge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">i₁</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h₄</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">i₁</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h₄</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">right</span>\n<span class=\"w\">      </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">i₁</span>\n<span class=\"w\">      </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i₁</span>\n<span class=\"w\">      </span><span class=\"n\">constructor</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i₁</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">i₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">h₃</span>\n<span class=\"w\">        </span><span class=\"n\">constructor</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₃</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">iterate_add_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_add_cancel</span><span class=\"w\"> </span><span class=\"n\">h₁'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 500531040,
        "sender_full_name": "Jacob Weightman",
        "timestamp": 1739921812
    },
    {
        "content": "<p>Could you include the definition of <code>T</code> and any imports? It's easier for people to help when it's a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 500532471,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739922563
    },
    {
        "content": "<p>Could you use <code>Finite.exists_ne_map_eq_of_infinite (f ∘ j)</code> instead and then <del>use that <code>j</code> is strictly monotone (therefore injective) to get that <code>j i₁ ≠ j i₂</code></del>?</p>",
        "id": 500532904,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739922784
    },
    {
        "content": "<p>You have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.extraction_of_frequently_atTop%27#doc\">docs#Filter.extraction_of_frequently_atTop'</a> statement. Extract a function that indexes your short strings, instead of having a function that finds the next one. This will make it easier to prove stuff, because the new function is injective.</p>",
        "id": 500534233,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739923428
    },
    {
        "content": "<p>Thank you so much <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> , <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.extraction_of_frequently_atTop%27#doc\">docs#Filter.extraction_of_frequently_atTop'</a> did exactly what I needed it to do!</p>",
        "id": 500794749,
        "sender_full_name": "Jacob Weightman",
        "timestamp": 1740027884
    }
]