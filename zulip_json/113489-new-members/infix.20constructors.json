[
    {
        "content": "<p>Is it possible to use an inductive type constructor as prefix in some places and infix in others, using something like backticks to make it infix, as in Haskell?</p>",
        "id": 272732269,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645475363
    },
    {
        "content": "<p>It's notation which is infix, not the constructor itself. With notation you can put it in brackets, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">4</span> <span class=\"c1\">-- 12</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"mi\">3</span> <span class=\"mi\">4</span> <span class=\"c1\">-- 12</span>\n</code></pre></div>",
        "id": 272732708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645475690
    },
    {
        "content": "<p>I'm sorry, I'm not sure if I completely follow. For example, I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive decidable_eq]</span> <span class=\"kd\">inductive</span> <span class=\"n\">formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">bottom</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">top</span> <span class=\"o\">:</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">not</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">imp</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n<span class=\"bp\">|</span> <span class=\"n\">iff</span> <span class=\"o\">:</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span> <span class=\"bp\">→</span> <span class=\"n\">formula</span>\n</code></pre></div>\n<p>Then in some places I would like to use <code>and</code>, <code>or</code>, <code>imp</code> and <code>iff</code> as infix, but not everywhere.</p>",
        "id": 272732889,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645475848
    },
    {
        "content": "<p>The default being prefix.</p>",
        "id": 272732960,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645475891
    },
    {
        "content": "<p>You could define some notation like <code>notation x ` AND ` y := formula.and x y</code> (add precedence to taste) and so on</p>",
        "id": 272732993,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645475930
    },
    {
        "content": "<p>Then I would need to use <code>AND</code> for infix and <code>formula.and</code> for prefix?</p>",
        "id": 272733097,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645476009
    },
    {
        "content": "<p>There have been some experiments in having pseudo-Haskell infix notation here, but the closest Lean has to an infix form of an application is dot notation, like <code>x.and y</code>.</p>\n<p>Here's an example of a Haskell-like notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">1023</span> <span class=\"n\">f</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">foo</span>\n<span class=\"bp\">|</span> <span class=\"n\">baz</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">foo.baz</span><span class=\"o\">]</span> <span class=\"mi\">3</span>\n<span class=\"c1\">-- parses as `foo.baz 2 3`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- parses as `f 2 3 + 1`</span>\n</code></pre></div>\n<p>(I'm not recommending this, but it's interesting it sort of can be done in a general way. It doesn't pretty print, which is a downside.)</p>",
        "id": 272733329,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645476204
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 272733596,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645476406
    },
    {
        "content": "<p>Example of dot notation: <code>formula.bottom.and (formula.top.imp formula.bottom)</code></p>\n<p>It even pretty prints that way by default. You can turn this off with the <code>pp_nodot</code> attribute on individual constructors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">pp_nodot</span><span class=\"o\">]</span> <span class=\"n\">formula.and</span>\n</code></pre></div>",
        "id": 272733705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1645476509
    },
    {
        "content": "<p>Cool. Thank you.</p>",
        "id": 272734698,
        "sender_full_name": "Patrick Thomas",
        "timestamp": 1645477293
    },
    {
        "content": "<p>By any chance was support for Haskell like backtick infix notation added in Lean 4?</p>",
        "id": 377886447,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690132826
    },
    {
        "content": "<p>In lean4 you can define infix notation even without backticks. Any particular reason you want backticks?</p>",
        "id": 377917640,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1690141226
    },
    {
        "content": "<p>No, it doesn't need to be backticks. Is that new in Lean 4?</p>",
        "id": 377937125,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690149236
    },
    {
        "content": "<p>My understanding is that backtick notation lets you infix _any_ function without defining any new notation; is that what you mean? So <code> a `f` b = f a b</code> for <em>arbitrary</em> <code>f</code>?</p>",
        "id": 377937254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690149303
    },
    {
        "content": "<p>Yes, that is what I meant.</p>",
        "id": 377937273,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690149321
    },
    {
        "content": "<p>What I believe Adam is describing is that for a particular <code>f</code> you can declare a specialized notation</p>",
        "id": 377937294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690149342
    },
    {
        "content": "<p>I see. That was doable in Lean 3 as well?</p>",
        "id": 377937359,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690149369
    },
    {
        "content": "<p>Yes, but it's more powerful in Lean 4</p>",
        "id": 377937375,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690149383
    },
    {
        "content": "<p>Ok. Thank you.</p>",
        "id": 377937443,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690149440
    },
    {
        "content": "<p>I would imagine it is not too difficult to define a custom notation that implements <code>a `f` b = f a b</code>, but I don't think it's likely that Lean will come with it by default</p>",
        "id": 377937462,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690149461
    },
    {
        "content": "<p>This is probably an odd question, but is there a way to define just the symbol, and just the symbol and fixity, without giving a precedence and not have Lean default to a precedence but instead force the use of parentheses? For example, a way to make this work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pred_const_</span> <span class=\"o\">:</span> <span class=\"n\">PredName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pred_var_</span> <span class=\"o\">:</span> <span class=\"n\">PredName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">eq_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">imp_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">iff_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">forall_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">exists_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">def_</span> <span class=\"o\">:</span> <span class=\"n\">DefName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">infix</span> <span class=\"s2\">\" .= \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq_</span>\n<span class=\"s2\">\" .T \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true_</span>\n<span class=\"s2\">\" .F \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false_</span>\n<span class=\"kd\">prefix</span> <span class=\"s2\">\" .¬ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_</span>\n<span class=\"kd\">infix</span> <span class=\"s2\">\" .→ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">imp_</span>\n<span class=\"kd\">infix</span> <span class=\"s2\">\" .∧ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">and_</span>\n<span class=\"kd\">infix</span> <span class=\"s2\">\" .∨ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">or_</span>\n<span class=\"kd\">infix</span> <span class=\"s2\">\" .↔ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iff_</span>\n<span class=\"kd\">prefix</span> <span class=\"s2\">\" .∀ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forall_</span>\n<span class=\"kd\">prefix</span> <span class=\"s2\">\" .∃ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exists_</span>\n</code></pre></div>\n<p>and give an error if parentheses are not used around each except <code>.T</code> and <code>.F</code>.</p>",
        "id": 377947104,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690155343
    },
    {
        "content": "<p>Barring that, do you know where the notation for the mathlib builtin equivalent of these constructors is defined?</p>",
        "id": 377947291,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690155481
    },
    {
        "content": "<p>Also, is there a way to make notation context sensitive, in order to not need the dot in front of each to avoid clashes with the builtin versions?</p>",
        "id": 377958094,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690160580
    },
    {
        "content": "<p>Maybe the dot actually means something in Lean here?</p>",
        "id": 377963278,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690162705
    },
    {
        "content": "<p>Note that Lean interprets <code>.mk a</code> as <code>TargetType.mk a</code></p>",
        "id": 377964512,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690163315
    },
    {
        "content": "<p>This can interfere with your notation (not sure how exactly)</p>",
        "id": 377964539,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690163332
    },
    {
        "content": "<p>Yeah, I think the problem might actually be something else. I changed it to a following underscore, and it still doesn't seem to work right.<br>\nI have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" =_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq_</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\" T_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true_</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\" F_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false_</span>\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"s2\">\" ¬_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"s2\">\" →_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">imp_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ∧_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">and_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ∨_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">or_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ↔_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iff_</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ∀_ \"</span> <span class=\"n\">x</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forall_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" E_ \"</span> <span class=\"n\">x</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exists_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n</code></pre></div>\n<p>There is something wrong I am doing with the forall and exists it seems.</p>",
        "id": 377964985,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690163551
    },
    {
        "content": "<p>If I do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">IsPropAxiom</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"c1\">-- ⊢ ⊤</span>\n  <span class=\"bp\">|</span> <span class=\"n\">prop_true_</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsPropAxiom</span> <span class=\"n\">true_</span>\n\n  <span class=\"c1\">-- ⊢ phi → (psi → phi)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">prop_1_</span>\n    <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(</span><span class=\"n\">phi.imp_</span> <span class=\"o\">(</span><span class=\"n\">psi.imp_</span> <span class=\"n\">phi</span><span class=\"o\">))</span>\n\n  <span class=\"c1\">-- ⊢ (phi → (psi → chi)) → ((phi → psi) → (phi → chi))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">prop_2_</span>\n    <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"n\">chi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsPropAxiom</span> <span class=\"o\">((</span><span class=\"n\">phi.imp_</span> <span class=\"o\">(</span><span class=\"n\">psi.imp_</span> <span class=\"n\">chi</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">imp_</span> <span class=\"o\">((</span><span class=\"n\">phi.imp_</span> <span class=\"n\">psi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp_</span> <span class=\"o\">(</span><span class=\"n\">phi.imp_</span> <span class=\"n\">chi</span><span class=\"o\">)))</span>\n\n  <span class=\"c1\">-- ⊢ (¬ phi → ¬ psi) → (psi → phi)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">prop_3_</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(((</span><span class=\"n\">not_</span> <span class=\"n\">phi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp_</span> <span class=\"o\">(</span><span class=\"n\">not_</span> <span class=\"n\">psi</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">imp_</span> <span class=\"o\">(</span><span class=\"n\">psi.imp_</span> <span class=\"n\">phi</span><span class=\"o\">))</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">def_false_</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(</span><span class=\"n\">F_</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">T_</span><span class=\"o\">))</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">def_and_</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(</span> <span class=\"o\">((</span><span class=\"n\">phi</span> <span class=\"bp\">∧</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">))</span> <span class=\"o\">)</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">def_or_</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(</span> <span class=\"o\">((</span><span class=\"n\">phi</span> <span class=\"bp\">∨</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">phi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">))</span> <span class=\"o\">)</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">def_iff_</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"n\">psi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">(</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(((</span><span class=\"n\">phi</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">phi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">psi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"n\">phi</span><span class=\"o\">)))</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">phi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">psi</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"n\">phi</span><span class=\"o\">))</span> <span class=\"bp\">→</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"n\">psi</span><span class=\"o\">)))</span> <span class=\"o\">)</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">def_exists_</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">((</span><span class=\"bp\">∃</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span><span class=\"o\">)</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">phi</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>There is a red underscore under the <code>phi</code> in <code>∃_ x phi</code> at the bottom and a message saying <code>expected ','</code>.</p>",
        "id": 377965228,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690163666
    },
    {
        "content": "<p>If I change it to <code>exists_ x phi</code> then the message moves to the <code>phi</code> in the <code>(∀_ x (¬_ phi)))</code>. If I change that to <code>(forall_ x (¬_ phi)))</code> then the message goes away.</p>",
        "id": 377965640,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690163864
    },
    {
        "content": "<p>Full example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Lint.Frontend</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Util.CompileInductive</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">FOL</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The type of variable names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">VarName</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">VarName</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The string representation of variable names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">VarName.toString</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"n\">VarName.mk</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">VarName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toString</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">VarName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toString.toFormat</span> <span class=\"o\">}</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The type of predicate names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">PredName</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">PredName</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The string representation of predicate names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">PredName.toString</span> <span class=\"o\">:</span> <span class=\"n\">PredName</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PredName.mk</span> <span class=\"n\">X</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">PredName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X.toString</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">PredName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X.toString.toFormat</span> <span class=\"o\">}</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The type of definition names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">DefName</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">DefName</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The string representation of definition names.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">DefName.toString</span> <span class=\"o\">:</span> <span class=\"n\">DefName</span> <span class=\"bp\">→</span> <span class=\"n\">String</span>\n  <span class=\"bp\">|</span> <span class=\"n\">DefName.mk</span> <span class=\"n\">X</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">DefName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X.toString</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Repr</span> <span class=\"n\">DefName</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">reprPrec</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">X</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">X.toString.toFormat</span> <span class=\"o\">}</span>\n\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  The type of formulas.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Formula</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pred_const_</span> <span class=\"o\">:</span> <span class=\"n\">PredName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pred_var_</span> <span class=\"o\">:</span> <span class=\"n\">PredName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">eq_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">true_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">not_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">imp_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">iff_</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">forall_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">exists_</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"bp\">|</span> <span class=\"n\">def_</span> <span class=\"o\">:</span> <span class=\"n\">DefName</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">VarName</span> <span class=\"bp\">→</span> <span class=\"n\">Formula</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"n\">compile_inductive</span><span class=\"bp\">%</span> <span class=\"n\">Formula</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Formula</span>\n\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" =_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq_</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\" T_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true_</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\" F_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false_</span>\n<span class=\"kd\">prefix</span><span class=\"o\">:</span><span class=\"mi\">40</span> <span class=\"s2\">\" ¬_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"s2\">\" →_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">imp_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ∧_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">and_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ∨_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">or_</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ↔_ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iff_</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ∀_ \"</span> <span class=\"n\">x</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forall_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" E_ \"</span> <span class=\"n\">x</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exists_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsPropAxiom</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">def_exists_</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">((</span><span class=\"bp\">∃</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span><span class=\"o\">)</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">phi</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 377966440,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690164239
    },
    {
        "content": "<p><code>expected ','</code></p>",
        "id": 377966617,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690164324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> fixed it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ∀_ \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forall_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">30</span> <span class=\"s2\">\" ∃_ \"</span> <span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">max</span> <span class=\"n\">phi</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exists_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">IsPropAxiom</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">def_exists_</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">VarName</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">phi</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">IsPropAxiom</span> <span class=\"o\">((</span><span class=\"bp\">∃</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">phi</span><span class=\"o\">)</span> <span class=\"bp\">↔</span><span class=\"n\">_</span> <span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">_</span> <span class=\"n\">phi</span><span class=\"o\">)))</span>\n</code></pre></div>\n<p>The <code>∃_</code> in the notation was misspelled as <code>E_</code> and I needed to add the <code>:max</code>.</p>",
        "id": 377974496,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1690168075
    }
]