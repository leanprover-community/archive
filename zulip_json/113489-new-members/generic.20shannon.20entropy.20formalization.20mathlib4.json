[
    {
        "content": "<p>Hello! I’ve been learning Lean for a few months and I’m starting to formalize some basic concepts from information theory. As a first step, I’m defining a generic Shannon entropy for <code>PMF</code>, since the existing file <code>Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean</code> focuses on Bernoulli distributions.</p>\n<p>My current definition is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">InfiniteSum</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">InfiniteSum</span><span class=\"bp\">.</span><span class=\"n\">ENNReal</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Probability</span><span class=\"bp\">.</span><span class=\"n\">ProbabilityMassFunction</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Probability</span><span class=\"bp\">.</span><span class=\"n\">ProbabilityMassFunction</span><span class=\"bp\">.</span><span class=\"n\">Constructions</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Probability</span><span class=\"bp\">.</span><span class=\"n\">ProbabilityMassFunction</span><span class=\"bp\">.</span><span class=\"n\">Monad</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">Log</span><span class=\"bp\">.</span><span class=\"n\">NegMulLog</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">BinaryEntropy</span>\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Probability</span><span class=\"bp\">.</span><span class=\"n\">Distributions</span><span class=\"bp\">.</span><span class=\"n\">Uniform</span>\n\n<span class=\"n\">public</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">MeasureTheory</span><span class=\"w\"> </span><span class=\"n\">NNReal</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">InformationTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">entropy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I can prove that the entropy of a PMF is nonneg:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">entropy_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">entropy</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">entropy</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">tsum_nonneg</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog_nonneg</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_nonneg</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_le_of_le_ofReal</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">zero_le_one'</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">ofReal_one</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">coe_le_one</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Now I'm trying to write a sanity-check for uniform distributions as an example def</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">entropy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFinset</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">entropy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFinset</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We compute: - (1/2) * log(1/2) - (1/2) * log(1/2) = - log(1/2) = log 2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_inv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_ofNat</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>at the sorry, I end up with the following goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">∑'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>At this point, I expected to be able to split the sum using <code>tsum_add</code>, but <code>tsum_add</code> is an unknown identifier in my file. I can see and use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">tsum_add</span>\n<span class=\"c1\">-- ENNReal.tsum_add.{u_1} {α : Type u_1} {f g : α → ℝ≥0∞} : ∑' (a : α), (f a + g a) = ∑' (a : α), f a + ∑' (a : α), g a</span>\n</code></pre></div>\n<p>but this only applies to functions valued in <code>ℝ≥0∞</code>, whereas my goal is in <code>ℝ</code>.</p>\n<p>My questions are:</p>\n<ol>\n<li>\n<p><strong>Design question:</strong> since Shannon entropy is nonnegative, would it be more idiomatic in mathlib to define <br>\n<code>\n     entropy : PMF α → ℝ≥0∞`? \n     </code><br>\n     instead of <code>ℝ</code>, and only coerce to <code>ℝ</code> when needed?  <br>\n    This would allow direct use of lemmas like <code>ENNReal.tsum_add</code> and might avoid some of the friction I’m   seeing. On the other hand, the usual analytic definition involves <code>Real.log</code> and <code>Real.negMulLog</code>, so I’m not sure what the preferred approach is in mathlib.</p>\n</li>\n<li>\n<p>What is the correct lemma (and import) for splitting a <code>tsum</code> of <code>ℝ</code>-valued functions? Is there an <code>ℝ</code> analogue of <code>ENNReal.tsum_add</code> that I should be using, possibly under a different name or requiring extra hypotheses?</p>\n</li>\n<li>If such a lemma is not readily available in this context, what is the idiomatic mathlib way to handle a finitely-supported <code>tsum</code> like this?</li>\n</ol>",
        "id": 570443975,
        "sender_full_name": "Semar Augusto",
        "timestamp": 1769557699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> tsum, _ + _</p>",
        "id": 570444222,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769557850
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/InfiniteSum/Basic.html#tsum_bool\">tsum_bool</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Algebra/InfiniteSum/Basic.html#Summable.tsum_add\">Summable.tsum_add</a>, and <a href=\"https://loogle.lean-lang.org/?q=tsum%2C%20_%20%2B%20_\">117 more</a></p>",
        "id": 570444224,
        "sender_full_name": "loogle",
        "timestamp": 1769557852
    },
    {
        "content": "<p>try <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Summable.tsum_add#doc\">docs#Summable.tsum_add</a></p>",
        "id": 570444252,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1769557877
    },
    {
        "content": "<p>Ok, I'll try it out! thank you!</p>",
        "id": 570444853,
        "sender_full_name": "Semar Augusto",
        "timestamp": 1769558311
    },
    {
        "content": "<p>Here's my take on your proof, inspired by my attempts to work with PMF measures in my project:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">entropy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFinset</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">classical</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">entropy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFinset</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We compute: - (1/2) * log(1/2) - (1/2) * log(1/2) = - log(1/2) = log 2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">2</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_inv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal_ofNat</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">negMulLog</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ENNReal</span><span class=\"bp\">.</span><span class=\"n\">toReal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsumm1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hasSum_ite_eq</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsumm2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasSum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hasSum_ite_eq</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Summable</span><span class=\"bp\">.</span><span class=\"n\">tsum_add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HasSum</span><span class=\"bp\">.</span><span class=\"n\">summable</span><span class=\"w\"> </span><span class=\"n\">hsumm1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HasSum</span><span class=\"bp\">.</span><span class=\"n\">summable</span><span class=\"w\"> </span><span class=\"n\">hsumm2</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">tsum_ite_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_halves</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 570643335,
        "sender_full_name": "Peter Kosenko",
        "timestamp": 1769628386
    },
    {
        "content": "<p>There are somehow more methods available with HasSum compared to Summable as I have found</p>",
        "id": 570643554,
        "sender_full_name": "Peter Kosenko",
        "timestamp": 1769628460
    },
    {
        "content": "<p>I was able to close the proof but this is a LOT cleaner, <br>\nReally like the HasSum approach, I'll try to replicate this in my other proofs as well, very helpful, thanks!</p>",
        "id": 570665738,
        "sender_full_name": "Semar Augusto",
        "timestamp": 1769636682
    },
    {
        "content": "<p>Since this is called \"generic formalization\", I'd like to continue discussion here on how we want to formalize generalizations. I'm very happy to see <a href=\"https://github.com/leanprover-community/mathlib4/pull/34773\">https://github.com/leanprover-community/mathlib4/pull/34773</a> and am personally in favor of merging the definition using <code>PMF</code>.</p>\n<p>Looking ahead, I see two directions for generalization:</p>\n<ol>\n<li>Application beyond <code>PMF</code></li>\n</ol>\n<p>One could define <a href=\"https://en.wikipedia.org/wiki/Differential_entropy\">differential entropy</a> as KL-divergence to Lebesgue measure. This is a generalization of Shannon entropy, though apparently a flawed one. One should maybe instead go for <a href=\"https://en.wikipedia.org/wiki/Limiting_density_of_discrete_points\">Limiting density of discrete points</a>? Though I must admit that I don't understand some of the subtleties there and how to best formalize it (I'm eager to help with proving/writing some lemmas though when we get there).</p>\n<p>Another question is whether one should view the various quantum information theory notions as generalizations/extensions, or whether only physicists care about those and they have no place in Mathlib at all?</p>\n<ol start=\"2\">\n<li>Rényi entropy, conditional entropy, mutual information</li>\n</ol>\n<p>How do we want to define these and at what level of generality? If we define all of them for <code>PMF</code>s now, will it be easy to generalize without breaking the API?</p>",
        "id": 573846026,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1771027739
    },
    {
        "content": "<p>I don't know a lot of things about entropy, but I think whenever one encounters a definition in probability one should define it measure theoretically in Mathlib. After you have a definition for a general (probability) measure, you can then show some nice things happen in the discrete case.</p>",
        "id": 573856596,
        "sender_full_name": "Yongxi Lin (Aaron)",
        "timestamp": 1771036976
    },
    {
        "content": "<p>For the more general <code>Measure</code> case we already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/InformationTheory/KullbackLeibler/Basic.html#InformationTheory.klDiv\">InformationTheory.klDiv</a> (the Kullback-Leibler divergence). In the finite case on a type of card N, entropy is <code>H(P) = log N - KL(P, uniform)</code> and that equality could be used to reuse proofs about KL.<br>\nIt also makes sense to define Rényi divergence and mutual information on <code>Measure</code> (and they could both be defined very easily using the KL). I don't know about the discrete case for those, I never work with that.</p>",
        "id": 573875398,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1771055832
    },
    {
        "content": "<p>But although we have <code>klDiv</code>, we don't have yet two of the most important properties of the KL divergence: the chain rule and the data processing inequality. The chain rule is in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34841\">#34841</a> (depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/35014\">#35014</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/35015\">#35015</a>) and the proof I have in mind for the data processing inequality will need Jensen's inequality for the conditional expectation (<a href=\"https://github.com/leanprover-community/mathlib4/pull/27953\">#27953</a>) as well as the results of <a href=\"https://github.com/leanprover-community/mathlib4/pull/35089\">#35089</a>.</p>",
        "id": 573877760,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1771058309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"350992\">@Rémy Degenne</span> Is there something there someone like me might be able to help with? Proving some lemmas, etc.?</p>",
        "id": 573896956,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1771075005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"669043\">Yongxi Lin (Aaron)</span> <a href=\"#narrow/channel/113489-new-members/topic/generic.20shannon.20entropy.20formalization.20mathlib4/near/573856596\">said</a>:</p>\n<blockquote>\n<p>I don't know a lot of things about entropy, but I think whenever one encounters a definition in probability one should define it measure theoretically in Mathlib. After you have a definition for a general (probability) measure, you can then show some nice things happen in the discrete case.</p>\n</blockquote>\n<p>I agree but the implications for Shannon entropy aren't very clear. Do we use <a href=\"https://en.wikipedia.org/wiki/Differential_entropy\">differential entropy</a> as KL-divergence to Lebesgue measure, or something like <a href=\"https://en.wikipedia.org/wiki/Limiting_density_of_discrete_points\">Limiting density of discrete points</a>, which I personally don't know how to define for general measures, (but would likely work in terms of KL-divergence)?</p>",
        "id": 573897137,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1771075248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"350992\">Rémy Degenne</span> <a href=\"#narrow/channel/113489-new-members/topic/generic.20shannon.20entropy.20formalization.20mathlib4/near/573877760\">said</a>:</p>\n<blockquote>\n<p>But although we have <code>klDiv</code>, we don't have yet two of the most important properties of the KL divergence: the chain rule and the data processing inequality. The chain rule is in <a href=\"https://github.com/leanprover-community/mathlib4/pull/34841\">#34841</a> (depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/35014\">#35014</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/35015\">#35015</a>) and the proof I have in mind for the data processing inequality will need Jensen's inequality for the conditional expectation (<a href=\"https://github.com/leanprover-community/mathlib4/pull/27953\">#27953</a>) as well as the results of <a href=\"https://github.com/leanprover-community/mathlib4/pull/35089\">#35089</a>.</p>\n</blockquote>\n<p>Wasn't the data processing inequality in your project with <span class=\"user-mention\" data-user-id=\"638899\">@Lorenzo Luccioli</span> ?</p>",
        "id": 573902596,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1771080244
    },
    {
        "content": "<p>Yes it was (link to the project: <a href=\"https://github.com/RemyDegenne/testing-lower-bounds/\">https://github.com/RemyDegenne/testing-lower-bounds/</a>). 3 proofs of it in fact.</p>\n<p>The only one we had fully sorry-free was the one you can find for example in the <a href=\"https://www.cambridge.org/highereducation/books/information-theory/CFF2F02ED54398148B7D8AA26E55B2BC#overview\">book by Polyanskiy and Wu</a>, which had the downside of working only in spaces such that Radon-Nikodym derivatives of kernels exist (standard Borel spaces for example).</p>\n<p>The second one, which we had up to one annoying sorry in an integration by part lemma, was the proof that can be found for example in <a href=\"https://library.utia.cas.cz/separaty/2009/SI/vajda-fdivergences%20sufficiency%20deficiency%20and%20testing%20of%20hypotheses.pdf\">this paper of Liese and Vajda</a> which writes the KL as an integral of risks in Bayesian testing experiments. This second proof works in any measurable space, but it was not fully sorry-free. Also the definition of KL in Mathlib is not the one we had in that project (we changed some type choices about Real vs ENNReal vs EReal when moving to Mathlib).</p>\n<p>The third proof uses conditional Jensen (which is a <code>sorry</code> in our project, but is now in a Mathlib PR by <span class=\"user-mention silent\" data-user-id=\"669043\">Yongxi Lin (Aaron)</span> ) and is more direct, and follows the arguments from Csiszar's 1963 paper <em>Eine informationstheoretische Ungleichung und ihre Anwendung auf den Beweis der Ergodizität von Markoffschen Ketten</em>. Many of the things needed for that proof are already proved in our project and the PRs I opened recently that I mentioned above are mostly just me adapting code from it (but I also changed the chain rule proof a bit to avoid a standard Borel space assumption).<br>\nSo the data processing inequality is mostly just waiting for Jensen for conditional expectations to reach Mathlib. I just meant that it was not yet in Mathlib. I was not suggesting that somebody works on it, sorry if that was confusing.</p>",
        "id": 573904018,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1771081716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">Adomas Baliuka</span> <a href=\"#narrow/channel/113489-new-members/topic/generic.20shannon.20entropy.20formalization.20mathlib4/near/573846026\">said</a>:</p>\n<blockquote>\n<p>whether one should view the various quantum information theory notions as generalizations/extensions, or whether only physicists care about those and they have no place in Mathlib at all?</p>\n<p>Rényi entropy, conditional entropy, mutual information</p>\n</blockquote>\n<p>We have several of these in progress at <a href=\"http://github.com/Timeroot/Lean-QuantumInfo\">http://github.com/Timeroot/Lean-QuantumInfo</a>. If you're interested in that kind of stuff, come drop in <a class=\"stream-topic\" data-stream-id=\"508986\" href=\"/#narrow/channel/508986-Quantum-information/topic/channel.20events/with/532818149\">#Quantum information &gt; channel events</a> :)</p>",
        "id": 574654476,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771480503
    }
]