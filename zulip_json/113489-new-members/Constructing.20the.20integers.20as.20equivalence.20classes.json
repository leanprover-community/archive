[
    {
        "content": "<p>I have tried solving some of the exercises in Terence Tao’s Analysis 1. In chapter 4, he constructs the integers as equivalence classes of pairs of natural numbers. To do the exercises, I would like  construct them this way in Lean. Here is what I have done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Equiv.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int_equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.1</span> <span class=\"bp\">+</span> <span class=\"n\">b.2</span> <span class=\"bp\">=</span> <span class=\"n\">b.1</span> <span class=\"bp\">+</span> <span class=\"n\">a.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">c.snd</span> <span class=\"bp\">=</span> <span class=\"n\">c.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">a.snd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"n\">a.fst</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">c.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">this</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">intEquiv</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">int_equiv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">integer_setoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">intEquiv</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">integer_setoid</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" — \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">—</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">—</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The main problem is that I can’t seem to project out the components of an integer, and so just defining addition is not doable. Is my approach fundamentally flawed?</p>",
        "id": 377927373,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690144396
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.lift#doc\">docs#Quotient.lift</a></p>",
        "id": 377927509,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690144457
    },
    {
        "content": "<p>For addition you probably want <code>Quotient.map\\_2</code></p>",
        "id": 377927715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690144549
    },
    {
        "content": "<p>The reason you can't project out the components of the integer is that whenever you use the data that the Quotient encapsulates you need to prove that the function respects the relation. If you had a function <code>f</code> which gets the first coordinate of <code>⟦(a,b)⟧</code> then you would have <code>⟦(1,2)⟧ = ⟦(3,4)⟧</code> but <code>f ⟦(1,2)⟧ ≠ f ⟦(3,4)⟧</code>, which is a contradiction. So to define a function <code>g : integer -&gt; X</code> you need to both define a function <code>h : ℕ × ℕ -&gt; X</code> and also prove that <code>h</code> respects <code>int_equiv</code> (then you use <code>Quotient.lift</code>, mentioned above). Defining a binary function is harder so you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Quot.html#Quotient.map%E2%82%82\">Quotient.map₂</a> as mentioned above.</p>",
        "id": 377968636,
        "sender_full_name": "Niels Voss",
        "timestamp": 1690165289
    },
    {
        "content": "<p>Thanks for all the replies! Both for the tips and the explanation of why projections are not allowed. Concepts like quotient and setoids are very unfamiliar territory for me, but I think I managed to define both addition and multiplication using <code>Quotient.map\\_2</code>  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"bp\">@</span><span class=\"n\">Quotient.map₂</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">A.1</span> <span class=\"bp\">+</span> <span class=\"n\">B.1</span><span class=\"o\">,</span> <span class=\"n\">A.2</span> <span class=\"bp\">+</span> <span class=\"n\">B.2</span><span class=\"o\">)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">rAB</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">rCD</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">instHasEquiv</span> <span class=\"n\">integer_setoid</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">C.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">D.snd</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">D.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">C.snd</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rCD</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">rAB</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"bp\">@</span><span class=\"n\">Quotient.map₂</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">A.1</span> <span class=\"bp\">*</span> <span class=\"n\">B.1</span> <span class=\"bp\">+</span> <span class=\"n\">A.2</span> <span class=\"bp\">*</span> <span class=\"n\">B.2</span><span class=\"o\">,</span> <span class=\"n\">A.1</span> <span class=\"bp\">*</span> <span class=\"n\">B.2</span> <span class=\"bp\">+</span> <span class=\"n\">A.2</span> <span class=\"bp\">*</span> <span class=\"n\">B.1</span><span class=\"o\">)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">rAB</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">rCD</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">instHasEquiv</span> <span class=\"n\">integer_setoid</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">add_left_cancel_iff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"o\">(</span><span class=\"n\">B.fst</span> <span class=\"bp\">*</span> <span class=\"n\">C.fst</span><span class=\"o\">)]</span>\n  <span class=\"n\">ring_nf</span>\n\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">rCD</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">B.fst</span> <span class=\"bp\">*</span> <span class=\"n\">C.fst</span><span class=\"o\">)]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">C.fst</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rAB</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">B.fst</span> <span class=\"bp\">*</span> <span class=\"n\">C.snd</span><span class=\"o\">)]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">C.snd</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">C.snd</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rAB</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">C.fst</span> <span class=\"bp\">*</span> <span class=\"n\">B.snd</span><span class=\"o\">),</span> <span class=\"n\">mul_comm</span> <span class=\"n\">A.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">rCD</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span>  <span class=\"n\">C.fst</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Is there a tactic that would have made the task a bit easier? Also: at the moment <code>#check 3 — 2 = 2 — 1</code> is shown in infoview as <code>Quotient.mk integer_setoid (3, 2) = Quotient.mk integer_setoid (2, 1) : Prop</code>. Is there a way to force a nicer notation?</p>",
        "id": 377981186,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690171081
    },
    {
        "content": "<p>IIRC <code>nlinarith</code> is quite good at solving all the goals that show up in the construction of the ring structure on the integers</p>",
        "id": 378009897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690181718
    },
    {
        "content": "<p>Constructing a ring structure of my integers is the next big step :) But right now I just want to making working with my integers a bit more pleasant. As mentioned, <code>#check 3 — 2 = 2 — 1</code> is shown in the Infoview as <code>Quotient.mk integer_setoid (3, 2) = Quotient.mk integer_setoid (2, 1) : Prop</code>. This obscures what is going on. Any ideas of how to deal with this? Maybe build a type on top my integers?</p>",
        "id": 378302037,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690244766
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 378302267,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690244860
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378302267\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Equiv.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">int_equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.1</span> <span class=\"bp\">+</span> <span class=\"n\">b.2</span> <span class=\"bp\">=</span> <span class=\"n\">b.1</span> <span class=\"bp\">+</span> <span class=\"n\">a.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">c.snd</span> <span class=\"bp\">=</span> <span class=\"n\">c.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">a.snd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"n\">a.fst</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">c.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">this</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">intEquiv</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">int_equiv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">integer_setoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">intEquiv</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">integer_setoid</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" — \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"mi\">3</span> <span class=\"bp\">—</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">—</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 378302738,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690245019
    },
    {
        "content": "<p>You can <code>def integer.mk (a b : Nat) : integer := ⟦(a, b)⟧</code>, then use <code>integer.mk</code> in <code>infix</code></p>",
        "id": 378303301,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690245212
    },
    {
        "content": "<p>(not tested)</p>",
        "id": 378303316,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1690245217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378303301\">said</a>:</p>\n<blockquote>\n<p>You can <code>def integer.mk (a b : Nat) : integer := ⟦(a, b)⟧</code>, then use <code>integer.mk</code> in <code>infix</code></p>\n</blockquote>\n<p>Seems to work beautifully!. Thanks :)</p>",
        "id": 378304281,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690245538
    },
    {
        "content": "<p>As mentioned, I would like to show my integers form a ring, so why not start with showing addition is commutative. This problem is with how <code>add</code> unfolds. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Equiv.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int_equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.1</span> <span class=\"bp\">+</span> <span class=\"n\">b.2</span> <span class=\"bp\">=</span> <span class=\"n\">b.1</span> <span class=\"bp\">+</span> <span class=\"n\">a.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">c.snd</span> <span class=\"bp\">=</span> <span class=\"n\">c.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">a.snd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"n\">a.fst</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">c.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">this</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">intEquiv</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">int_equiv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">integer_setoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">intEquiv</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">integer_setoid</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">integer</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" — \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Quot.mk</span> <span class=\"n\">Setoid.r</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"bp\">@</span><span class=\"n\">Quotient.map₂</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">A.1</span> <span class=\"bp\">+</span> <span class=\"n\">B.1</span><span class=\"o\">,</span> <span class=\"n\">A.2</span> <span class=\"bp\">+</span> <span class=\"n\">B.2</span><span class=\"o\">)</span>\n  <span class=\"n\">intro</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">rAB</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">rCD</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">instHasEquiv</span> <span class=\"n\">integer_setoid</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">dsimp</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">C.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">D.snd</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">D.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">C.snd</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rCD</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">rAB</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">a</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">add</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">integer</span>\n</code></pre></div>\n<p>Is there any remediation for this or is this just (one of the reasons) why integers aren't defined as equivalence classes in Mathlib?</p>",
        "id": 378586874,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690313776
    },
    {
        "content": "<p>What's the problem?</p>",
        "id": 378596868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690316699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378596868\">said</a>:</p>\n<blockquote>\n<p>What's the problem?</p>\n</blockquote>\n<p>At the moment <code>add</code> unfold into <code>Quotient.map₂ (fun A B =&gt; (A.fst + B.fst, A.snd + B.snd)) add.proof_1 x y =  Quotient.map₂ (fun A B =&gt; (A.fst + B.fst, A.snd + B.snd)) add.proof_1 y x</code> which doesn't seem very pleasant to work with. So unpleasant that I can't figure out to  how to show commutativity (hence the <code>sorry</code>). How do i deal with this? Some sort of congruence argument?</p>",
        "id": 378598463,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690317147
    },
    {
        "content": "<p>Did you look at how I did this construction? I'm on mobile but I'm pretty sure I've formalised this in a few places</p>",
        "id": 378602617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690318578
    },
    {
        "content": "<p>There are no problems doing it at all especially if you have access to the <code>ring</code> tactic to prove the auxiliary nat goals.</p>",
        "id": 378602725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690318608
    },
    {
        "content": "<p>You'll need to induct on x and y, then <code>dsimp</code> should clean up the goal</p>",
        "id": 378605224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690319562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378602617\">said</a>:</p>\n<blockquote>\n<p>Did you look at how I did this construction? I'm on mobile but I'm pretty sure I've formalised this in a few places</p>\n</blockquote>\n<p>Are you referring to the version of the integers built into Lean? Or is there some alternative construction somewhere in Mathlib? </p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378605224\">said</a>:</p>\n<blockquote>\n<p>You'll need to induct on x and y, then <code>dsimp</code> should clean up the goal</p>\n</blockquote>\n<p>How do I induct on x and y, when my integers are not an inductive type?</p>",
        "id": 378609186,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690321120
    },
    {
        "content": "<blockquote>\n<p>Are you referring to the version of the integers built into Lean?</p>\n</blockquote>\n<p>No -- those integers are mathematically disgusting; they are optimised for computer scientists.</p>\n<blockquote>\n<p>Or is there some alternative construction somewhere in Mathlib?</p>\n</blockquote>\n<p>No! The whole <em>point</em> of mathlib is that you have one definition of everything, and we're using Lean so we're stuck with Lean's integers.</p>\n<p>I'm referring to teaching materials such as <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2022/blob/master/src/section06quotients/sheet4Z.lean\">https://github.com/ImperialCollegeLondon/formalising-mathematics-2022/blob/master/src/section06quotients/sheet4Z.lean</a> which work through the mathematical definition (unfortunately still in Lean 3 but before I teach the course again I'll translate everything into Lean 4).</p>",
        "id": 378620256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690325626
    },
    {
        "content": "<blockquote>\n<p>How do I induct on x and y, when my integers are not an inductive type?</p>\n</blockquote>\n<p>Induction also works on quotient types! Though you'll want to use <code>induction x using Quotient.inductionOn</code> to make sure it give you the spelling you want.</p>",
        "id": 378621477,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1690326224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378620256\">said</a>:</p>\n<blockquote>\n<p>No! The whole <em>point</em> of mathlib is that you have one definition of everything, and we're using Lean so we're stuck with Lean's integers.</p>\n<p>I'm referring to teaching materials such as <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2022/blob/master/src/section06quotients/sheet4Z.lean\">https://github.com/ImperialCollegeLondon/formalising-mathematics-2022/blob/master/src/section06quotients/sheet4Z.lean</a> which work through the mathematical definition (unfortunately still in Lean 3 but before I teach the course again I'll translate everything into Lean 4).</p>\n</blockquote>\n<p>That looks like exactly what I was trying to do. Thank you very much :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/378621477\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>How do I induct on x and y, when my integers are not an inductive type?</p>\n</blockquote>\n<p>Induction also works on quotient types! Though you'll want to use <code>induction x using Quotient.inductionOn</code> to make sure it give you the spelling you want.</p>\n</blockquote>\n<p>That worked!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">add_comm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">add</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"n\">using</span> <span class=\"n\">Quotient.inductionOn</span>\n  <span class=\"n\">induction</span> <span class=\"n\">y</span> <span class=\"n\">using</span> <span class=\"n\">Quotient.inductionOn</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Quotient.sound</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">instHasEquiv</span> <span class=\"n\">integer_setoid</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">ring_nf</span>\n</code></pre></div>\n<p>Thanks for the tip.</p>",
        "id": 378626834,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690329030
    },
    {
        "content": "<p>So I have played around with my integers a bit further, and often run into a situation like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Equiv.Functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">int_equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">a.1</span> <span class=\"bp\">+</span> <span class=\"n\">b.2</span> <span class=\"bp\">=</span> <span class=\"n\">b.1</span> <span class=\"bp\">+</span> <span class=\"n\">a.2</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int_equiv.trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">int_equiv</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">int_equiv</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">c.snd</span> <span class=\"bp\">=</span> <span class=\"n\">c.fst</span> <span class=\"bp\">+</span> <span class=\"n\">b.snd</span> <span class=\"bp\">+</span> <span class=\"n\">a.snd</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n    <span class=\"n\">ring</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span> <span class=\"n\">a.fst</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span> <span class=\"n\">c.fst</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">add_left_cancel</span> <span class=\"n\">this</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">intEquiv</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">int_equiv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">refl</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">integer_setoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">int_equiv</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">intEquiv</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">integer</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">integer_setoid</span>\n\n<span class=\"kd\">notation</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"n\">lhs</span><span class=\"o\">:</span><span class=\"mi\">65</span> <span class=\"s2\">\" — \"</span> <span class=\"n\">rhs</span><span class=\"o\">:</span><span class=\"mi\">66</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Quot.mk</span> <span class=\"n\">Setoid.r</span> <span class=\"o\">(</span><span class=\"n\">lhs</span><span class=\"o\">,</span> <span class=\"n\">rhs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">int_prod_pair</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a.1</span> <span class=\"bp\">—</span> <span class=\"n\">a.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">A</span> <span class=\"n\">using</span> <span class=\"n\">Quotient.inductionOn</span>\n  <span class=\"n\">simp</span>\n      <span class=\"c1\">-- CONTEXT</span>\n      <span class=\"c1\">-- case h</span>\n      <span class=\"c1\">-- a✝: ℕ × ℕ</span>\n      <span class=\"c1\">-- ⊢ ∃ a b, Quotient.mk integer_setoid a✝ = a — b</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- EDIT solved it as</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">int_prod_pair'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">integer</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a.1</span> <span class=\"bp\">—</span> <span class=\"n\">a.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">Quot.recOn</span> <span class=\"n\">A</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">use</span> <span class=\"n\">a</span>\n  <span class=\"n\">intro</span> <span class=\"n\">B</span> <span class=\"n\">D</span> <span class=\"n\">P</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>What is the meaning of the <code>✝</code>- symbol? I have noticed that it also shows up when I accidentally use a variable name twice.</p>",
        "id": 379258753,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690481315
    },
    {
        "content": "<p>That's the symbol for inaccessible names. An inacessible name like <code>a✝</code> is \"dead\" in the sense that typing <code>a</code> in the current context does not resolve to the variable in the <code>a✝</code> line, either because of shadowing or because of macro hygiene.</p>",
        "id": 379262700,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1690482105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/379262700\">said</a>:</p>\n<blockquote>\n<p>That's the symbol for inaccessible names. An inacessible name like <code>a✝</code> is \"dead\" in the sense that typing <code>a</code> in the current context does not resolve to the variable in the <code>a✝</code> line, either because of shadowing or because of macro hygiene.</p>\n</blockquote>\n<p>Thank you for the answer. I'm still a bit unsure of what exactly causes a variable to become inaccessible. Could you please elaborate just a bit on 'shadowing'  and ' macro hygiene'?</p>",
        "id": 379265801,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690482721
    },
    {
        "content": "<p>You can't have two variables both called <code>x</code>. That's shadowing. If a tactic creates a variable and the user doesn't name it there and then, then the computer ensures that the user will never be able to talk about it explicitly. That's macro hygiene.</p>",
        "id": 379270596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690483656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/379270596\">said</a>:</p>\n<blockquote>\n<p>You can't have two variables both called <code>x</code>. That's shadowing. If a tactic creates a variable and the user doesn't name it there and then, then the computer ensures that the user will never be able to talk about it explicitly. That's macro hygiene.</p>\n</blockquote>\n<p>Then how can I name it (from a dead state)?</p>",
        "id": 379271458,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690483836
    },
    {
        "content": "<p>First, you shouldn't be in the situation of having a dead variable which you want to use at all. If it's coming from macro hygiene then you should have named it when you ran the tactic. If it's coming from two variables having the same name you should have called them different names.</p>",
        "id": 379272023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690483946
    },
    {
        "content": "<p>But there is a tactic called <code>rename_i</code> which you can use to name these dead variables. It's a code smell though.</p>",
        "id": 379272740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690484110
    },
    {
        "content": "<p>With the induction' tactic you can say <code>induction' A using Quotient.inductionOn with my_name</code> to choose a name yourself (which will be accessible)</p>",
        "id": 379274011,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1690484398
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/379272023\">said</a>:</p>\n<blockquote>\n<p>First, you shouldn't be in the situation of having a dead variable which you want to use at all. If it's coming from macro hygiene then you should have named it when you ran the tactic. If it's coming from two variables having the same name you should have called them different names.</p>\n</blockquote>\n<p>That explains very well. Thank you. Sometimes the correct tactics syntax can be a bit difficult to get right, I guess. At least I think it was easier to read the Lean3 documentation.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/stream/113489-new-members/topic/Constructing.20the.20integers.20as.20equivalence.20classes/near/379274011\">said</a>:</p>\n<blockquote>\n<p>With the induction' tactic you can say <code>induction' A using Quotient.inductionOn with my_name</code> to choose a name yourself (which will be accessible)</p>\n</blockquote>\n<p>Thank you! I thought I had tried exactly just that, but turns out I had used <code>induction</code> and not  <code>induction'</code>.</p>",
        "id": 379278888,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1690485597
    },
    {
        "content": "<blockquote>\n<p>Sometimes the correct tactics syntax can be a bit difficult to get right, I guess. At least I think it was easier to read the Lean3 documentation.</p>\n</blockquote>\n<p>You can see documentation for a tactic in Lean 4 by hovering over it, and in my experience Lean 4 tactics are documented better than Lean 3 ones. If you have a specific example of where something is unclear then please point it out -- or even better make a PR to fix it. Lean and mathlib are open source projects and the community genuinely wants to make the software better.</p>",
        "id": 379279648,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1690485796
    }
]