[
    {
        "content": "<p>how to make <code>dec_trivial</code> work when I have an instance of all propositions decidable? MWE:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n</pre></div>",
        "id": 193701447,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1586680466
    },
    {
        "content": "<p>oh wow I thought this stuff had been solved.</p>",
        "id": 193701463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586680510
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! -/</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n</pre></div>\n\n\n<p>Oh I see. This works</p>",
        "id": 193701475,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586680544
    },
    {
        "content": "<p>The <code>classical</code> tactic adds <code>_inst : Π (a : Prop), decidable a</code> to the type class inference system but ideally it would add it with priority 10</p>",
        "id": 193701518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586680599
    },
    {
        "content": "<p><code>classical</code> puts decidability in your context, and I think that gets maximum precedence</p>",
        "id": 193701521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586680614
    },
    {
        "content": "<p>Could <code>classical</code> instead do what <code>open_locale classical</code> does?</p>",
        "id": 193701586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1586680699
    },
    {
        "content": "<p>I don't think so? Changing declarations in the environment in the middle of a proof is kind of weird</p>",
        "id": 193701595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586680743
    },
    {
        "content": "<p>Certainly it can't do everything that <code>open_locale</code> can do because <code>open_locale</code> runs in the parser monad and hence has the ability to inject commands into the file that tactics can't do</p>",
        "id": 193701664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586680813
    },
    {
        "content": "<p>but maybe <code>open_locale classical</code> just sets some precedences and those might be doable</p>",
        "id": 193701669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1586680841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/dec_trivial.20in.20classical/near/193701475\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! -/</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>\n<p>Oh I see. This works</p>\n</blockquote>\n<p>It seems to me that this does not work. It reports an error: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">exact</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">given</span> <span class=\"n\">expression</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">true</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">as_true</span> <span class=\"o\">(</span><span class=\"mi\">127</span><span class=\"bp\">.</span><span class=\"n\">coprime</span> <span class=\"mi\">128</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">as_true</span> <span class=\"o\">(</span><span class=\"mi\">127</span><span class=\"bp\">.</span><span class=\"n\">coprime</span> <span class=\"mi\">128</span><span class=\"o\">)</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"mi\">127</span><span class=\"bp\">.</span><span class=\"n\">coprime</span> <span class=\"mi\">128</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 243605727,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624422103
    },
    {
        "content": "<p>this is an old thread, things have changed since last april</p>",
        "id": 243607503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624424778
    },
    {
        "content": "<p>in particular, I think the issue this is hitting is that definitions by well founded recursion no longer compute in the kernel, and <code>gcd</code> is defined by well founded recursion</p>",
        "id": 243607529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624424819
    },
    {
        "content": "<p>Uhmmm, then are we still able to close the goal <code>example : nat.coprime 127 128 :=</code> by a dec related tactic (or by any other convenient way)?</p>",
        "id": 243610646,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624428931
    },
    {
        "content": "<p>Yes, using a <code>norm_num</code> plugin I just implemented in <a href=\"https://github.com/leanprover-community/mathlib/issues/8053\">#8053</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 243621308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624437154
    },
    {
        "content": "<p>Alternatively you could prove <code>nat.coprime n (n+1)</code> for all n. Alternatively you could write down two integers x and y (found e.g. using a computer algebra system, although probably not in this case) such that 127x+128y=1 and then use a lemma in the library showing that this guarantees gcd=1.</p>",
        "id": 243621470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624437259
    },
    {
        "content": "<p>That latter option is in fact what the tactic does</p>",
        "id": 243621508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624437290
    },
    {
        "content": "<p>the proof that the gcd/coprime fact is correct doesn't use the euclidean algorithm</p>",
        "id": 243621555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624437332
    },
    {
        "content": "<p>right, the algorithm \"is\" finding x and y.</p>",
        "id": 243621640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624437378
    },
    {
        "content": "<p>the \"computer algebra system\" here is using <code>#eval</code> with the extended euclidean algorithm to get x and y</p>",
        "id": 243621695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624437411
    },
    {
        "content": "<p>Oh interesting! So the tactic uses <code>#eval</code> and then comes up with a proof that the kernel accepts!</p>",
        "id": 243621746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624437444
    },
    {
        "content": "<p>writing norm_num plugins is always fun because you end up with algorithms that look nothing like what you find in the books</p>",
        "id": 243621860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624437502
    },
    {
        "content": "<p>I guess I saw this phenomenon in Chris' MSc thesis -- he implemented an algorithm in group theory, didn't formally prove it worked, but then just passed the proofs it discovered to the kernel and the kernel was happy.</p>",
        "id": 243621876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624437518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/dec_trivial.20in.20classical/near/243621308\">said</a>:</p>\n<blockquote>\n<p>Yes, using a <code>norm_num</code> plugin I just implemented in <a href=\"https://github.com/leanprover-community/mathlib/issues/8053\">#8053</a>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">nat.coprime</span> <span class=\"mi\">127</span> <span class=\"mi\">128</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>How can I update my mathlib?</p>",
        "id": 243738700,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624506412
    },
    {
        "content": "<p>Are you working on mathlib directly or in another project which depends on mathlib as a dependency?</p>",
        "id": 243751335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624520557
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8053\">#8053</a> hasn't yet been merged anyway</p>",
        "id": 243752635,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624521467
    },
    {
        "content": "<p>Alex could still use the branch Mario made</p>",
        "id": 243752740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624521541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/dec_trivial.20in.20classical/near/243751335\">said</a>:</p>\n<blockquote>\n<p>Are you working on mathlib directly or in another project which depends on mathlib as a dependency?</p>\n</blockquote>\n<p>I am in the second case.</p>",
        "id": 243753124,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1624521839
    },
    {
        "content": "<p>Well then if you want Mario's changes <em>NOW</em> before they have even been merged to master, then probably the simplest way is to just edit the <code>leanpkg.toml</code> of your project manually. Assuming your toml says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">lean_version</span> <span class=\"bp\">=</span> <span class=\"s2\">\"leanprover-community/lean:3.30.0\"</span>\n</code></pre></div>\n<p>then it will be as simple as changing  the <code>rev =</code> bit of the <code>mathlib = ...</code> line to the commit corresponding to Mario's PR, and then running <code>leanproject get-mathlib-cache</code> (or <code>leanproject get-m</code> if you want to type less) and then <code>leanproject build</code> to rebuild your project.</p>\n<p>If you are happy to wait until it's merged to master, then any time after that's happened you can type <code>leanproject up</code> and you'll have the latest version.</p>",
        "id": 243755253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624523305
    },
    {
        "content": "<p>You can also copy the contents of the PR file (it's a pure addition) to some file in your repo</p>",
        "id": 243782005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624539785
    },
    {
        "content": "<p>I know this is an old thread, but I think the phenomenon that Kevin noticed is called \"<a href=\"https://en.wikipedia.org/wiki/Certifying_algorithm\">Certifying algorithm</a>\".</p>\n<p>Incidentally, is there a way to use the extended euclidean algorithm from <code>norm_num</code> to get an upper bound, mod m on the <code>x</code> an <code>y</code> that Mario talked about in the thread?</p>\n<p>The specific upper bound that I need is called \"Thue's lemma\", and is essentially a square root of <code>m</code> (there are other, more general ways to express that upper bound):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">thue</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">),</span><span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Maybe it's too much to ask for from the poor <code>norm_num</code> and I'll need to write my own implementation of the extended euclidean algorithm tracking the properties of <code>x</code> and <code>y</code> at each step.</p>",
        "id": 449456598,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1720253220
    },
    {
        "content": "<p>Are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.xgcd#doc\">docs#Nat.xgcd</a> ? I think the main interface for that is supposed to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcdA#doc\">docs#Nat.gcdA</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcdB#doc\">docs#Nat.gcdB</a>, and you can see them tied together in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd_eq_gcd_ab#doc\">docs#Nat.gcd_eq_gcd_ab</a></p>",
        "id": 449538030,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720288851
    },
    {
        "content": "<p>Could you say more about what you're expecting <code>norm_num</code> to do here? That tactic is for concrete calculations, and in fact you can see <a href=\"https://github.com/leanprover-community/mathlib4/blob/06352df94c59a012c8424d2ce0d5518d108c8714/Mathlib/Tactic/NormNum/GCD.lean#L92-L125\">here</a> that it uses extended GCD to certify its calculations, but I'm not sure how <code>norm_num</code> could have anything to say about proving <code>thue</code>.</p>",
        "id": 449538744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720289114
    },
    {
        "content": "<p>Thanks Kyle, all good points. I think the connection here is tangential.</p>\n<p>I'll check out the <code>Nat.xgcd</code> interface. I might be able to adapt to prove Thue's lemma.</p>",
        "id": 449606234,
        "sender_full_name": "Adam Kurkiewicz",
        "timestamp": 1720328913
    }
]