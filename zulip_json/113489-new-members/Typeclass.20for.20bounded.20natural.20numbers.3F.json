[
    {
        "content": "<p>Hi everyone,<br>\nvery new to Lean4 (and dependently typed languages in general). I want to explore Lean's capability as a functional programming language and wanted to pose myself a non-trivial challenge; I came up with implementing a B-tree. This is a data structure in which there's a constraint on the amount of child nodes a node can have depending on whether it's a root node or an internal one. This seemed like a good place to try and make use of a dependent type system.</p>\n<p>I came up with the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Bounded</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isBounded</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">max</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Root</span>\n<span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">Bounded</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Internal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Internal</span>\n<span class=\"w\">      </span><span class=\"o\">[</span><span class=\"n\">Bounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)]</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Internal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but I have no idea if this is idiomatic (or even in the slightest whether or not this is the right way to go about defining such a type). The main problem I'm facing is this: for any triple of natural numbers (n, m, p) with n ≤ m ≤ p, I can trivially synthesise an instance of this typeclass:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bounded</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">isBounded</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>however, I don't know how to do this \"automatically\", i.e. how to tell Lean that the typeclass should be synthesised for natural numbers that satisfy my constraints. As a result, I can't use this datatype in general cases right now, which is kind of a bummer.</p>\n<p>Does anyone have any input on how to approach this? I come from a Haskell background, if that helps.<br>\nMany thanks in advance from an enthousiastic maths student :)</p>",
        "id": 493135622,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736637792
    },
    {
        "content": "<p>Oh, by the way, only just read the channel guidelines: I'm Simeon, currently in the second year of my bachelor in mathematics at KU Leuven. I'm very interested in category, type and homotopy theory and everything that surrounds it, but all of that stuff is currently a bit too advanced for me at the moment <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 493136581,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736638759
    },
    {
        "content": "<p>You could consider replacing <code>[Bounded _ _ _]</code> with <code>(h : Bounded _ _ _ := by decide)</code> (using autoParams instead of typeclasses), or alternatively using <code>ln : Fin b</code></p>",
        "id": 493137028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736639183
    },
    {
        "content": "<p>(you can disable the feature that gives you <code>ln : Nat</code> implicitly with <code>set_option autoImplicit false</code>)</p>",
        "id": 493137058,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736639232
    },
    {
        "content": "<p>Actually, I think you're being tripped up by <code>autoImplicit</code> defaulting to true, and the code you wrote doesn't mean what you think it does; the <code>Vector Internal</code> is not referring to the <code>| Internal</code> line, but to an unrelated and invisible <code>Internal : Type _</code> variable</p>",
        "id": 493137263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736639479
    },
    {
        "content": "<p>Thanks for the advice! I'm home in like 15min, I'll try it out then</p>",
        "id": 493137457,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736639661
    },
    {
        "content": "<p>So if I've got this right, the square brackets sort of, \"pull\" an instance of a typeclass from the context, and the parentheses <code>(h : ...)</code> notation specifically provides a value for it?</p>",
        "id": 493137517,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736639760
    },
    {
        "content": "<p>The <code>(h :</code> suggestion is \"don't use a typeclass at all, just use a regular argument\". I suppose I should have said to replace <code>class</code> with <code>structure</code> at the same time</p>",
        "id": 493138469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736640619
    },
    {
        "content": "<p>But I think you should address the autoImplicit issue first, you have bigger concerns here</p>",
        "id": 493139109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736641217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Typeclass.20for.20bounded.20natural.20numbers.3F/near/493137058\">said</a>:</p>\n<blockquote>\n<p>(you can disable the feature that gives you <code>ln : Nat</code> implicitly with <code>set_option autoImplicit false</code>)</p>\n</blockquote>\n<p>But I do _want_ to use <code>ln</code> as a value to use in the type for the <code>Vector</code>s, right? how can I get rid of the \"unknown identifier <code>ln</code>\" error? (Sorry for the amateurishly posed question, I feel like a littl'un writing their first Stack Overflow question again haha)</p>",
        "id": 493139131,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736641240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Typeclass.20for.20bounded.20natural.20numbers.3F/near/493139109\">said</a>:</p>\n<blockquote>\n<p>But I think you should address the autoImplicit issue first, you have bigger concerns here</p>\n</blockquote>\n<p>Okay, I'll try working on that (i.e. reading some more). Thanks in any case :))</p>",
        "id": 493139161,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736641270
    },
    {
        "content": "<blockquote>\n<p>how can I get rid of the \"unknown identifier <code>ln</code>\" error?</p>\n</blockquote>\n<p>The problem is pretty simple: you're not passing in a variable named <code>ln</code>. It's like writing a function <code>add (a : Nat) : Nat := a + b</code> and getting an \"unknown identifier <code>b</code>\" error. Where is it coming from?</p>\n<p>This is why it's important to add <code>set_option autoImplicit false</code> at the top, at least when you're a beginner... Lean is making choices for you behind the scenes and you might not be aware of them.</p>",
        "id": 493140502,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736642621
    },
    {
        "content": "<p>Also don't worry at all about \"amateurish\" questions... that's why it's the <strong>New Members</strong> channel! Feel free to ask anything</p>",
        "id": 493140595,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736642704
    },
    {
        "content": "<p>Okay, after thinking about this for a bit (and studying for my Algebra final) I've furthered my progress a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span>\n<span class=\"w\">  </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>although, this gives an error I can't quite wrap my head around: <code>(kernel) invalid nested inductive datatype 'Vector', nested inductive datatypes parameters cannot contain local variables.</code>, in the definition of <code>BTreeNode</code>. I suppose the error itself makes sense, because, well, the <code>Vector</code> <em>does</em> depend on the local variable <code>ln</code>. But I have no clue on how to fix this, I came across <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20requiring.20proofs.20on.20inductive.20constructors\">this thread</a> but I can't quite grasp how to apply the solution presented there to the situation at hand.</p>",
        "id": 493223866,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736717609
    },
    {
        "content": "<p>At least I learned something new about the parameter/index distinction hahah</p>",
        "id": 493223952,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736717677
    },
    {
        "content": "<p>You may have more luck representing the child nodes as a function from <code>Fin n</code> to the nodes... for example, this avoids the error (though idk if it does what you want):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span>\n<span class=\"w\">  </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 493234427,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736726821
    },
    {
        "content": "<p>Lean has a decent amount of API for working with tuples represented as functions from <code>Fin n</code>:</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fin/Tuple/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fin/Tuple/Basic.html</a></p>",
        "id": 493234664,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736727014
    },
    {
        "content": "<p>Okay, here I am again. I've got it down to something that typechecks at least:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PosNum</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nil</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">         </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">children</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PosNum</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">ln</span>\n<span class=\"w\">  </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BTreeNode</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ln</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PosNum</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BTree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">bf</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">children</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mkVector</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">BTreeNode</span><span class=\"bp\">.</span><span class=\"n\">Nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bf</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mkEmpty</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>One thing I don't understand yet, is that I can  simply supply the <code>λ (_: 0 &lt; ↑bf) =&gt; Vector.mkEmpty 0</code> as a value for <code>keys</code>. My intention is to need to somehow provide a proof for the proposition that the <code>ln</code> parameter is <em>actually</em> less than the <code>bf</code> parameter (for example using <code>PosNum.cast_pos</code>, I suppose?) but I haven't had to provide a concrete proof here. <br>\nWhere does my mental model not correspond to what Lean is actually doing?</p>",
        "id": 493611351,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1736868791
    }
]