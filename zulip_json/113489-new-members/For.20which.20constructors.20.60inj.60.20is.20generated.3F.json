[
    {
        "content": "<p>I would like to formulate a rule telling for which constructors an injectivity theorem is generated. My guesses are \"Lean generates an injectivity theorem for each constructor taking fields\" or perhaps \"Lean generates an injectivity theorem for each constructor taking fields, unless those fields are determined by the constructor’s codomain.\". These would explain why <code>Eq.refl</code> does not have <code>inj</code> while most other constructors do have it. If this is explained in the language reference, I would appreciate a pointer. </p>\n<p>(My terminology is, based on <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/with/574800302\">help</a> from <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>: \"The parameters of an inductive type consist of the largest prefix of arguments shared by the type constructor and all the constructors. The remaining arguments of the type constructor are called indices, and the remaining arguments of a constructor are called <strong>fields</strong>.\")</p>",
        "id": 575146959,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771748812
    },
    {
        "content": "<p>Eq is a proposition, all proofs of a proposition are equal, so no useful injectivity theorem can exist here.</p>",
        "id": 575149169,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1771751706
    },
    {
        "content": "<p>This is not solely about <code>Prop</code> vs. <code>Type</code>. The following doesn't have <code>inj</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">.</span><span class=\"n\">autoPromoteIndices</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span>\n</code></pre></div>\n<p>The <code>#print</code> command fails with <code>Unknown constant ...</code>. This example says, in fact, that \"Lean generates an injectivity theorem for each constructor taking fields\" is not correct.</p>",
        "id": 575158490,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771762890
    },
    {
        "content": "<p>Have you already checked the Lean code for a more detailed answer?</p>",
        "id": 575158516,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1771762929
    },
    {
        "content": "<p>No, I haven't studied the code at all. I guess that I need to do that at some point if I want to understand Lean thoroughly. But there are quite a few other things to learn before that, I think.</p>",
        "id": 575158739,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771763199
    },
    {
        "content": "<p>Ok, let me then do that for you real quick, I'm also curious</p>",
        "id": 575158756,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1771763220
    },
    {
        "content": "<p>Some checks are done here:<br>\n<a href=\"https://github.com/leanprover/lean4/blob/2e7fe7e79d151ee91039f086b8036252cdf9b725/src/Lean/Meta/Injective.lean#L187-L191\">https://github.com/leanprover/lean4/blob/2e7fe7e79d151ee91039f086b8036252cdf9b725/src/Lean/Meta/Injective.lean#L187-L191</a><br>\nnamely</p>\n<ul>\n<li>not if <code>genInjectivity</code> option is unset</li>\n<li>not if <code>Eq.propIntro</code> is not declared (only relevant during <code>Init</code> processing)</li>\n<li>not for inductive predicates</li>\n<li>not for unsafe inductives.</li>\n</ul>\n<p>Another reason for it to not generate any is if it runs into this line of code:</p>\n<p><a href=\"https://github.com/leanprover/lean4/blob/2e7fe7e79d151ee91039f086b8036252cdf9b725/src/Lean/Meta/Injective.lean#L61\">https://github.com/leanprover/lean4/blob/2e7fe7e79d151ee91039f086b8036252cdf9b725/src/Lean/Meta/Injective.lean#L61</a></p>\n<p>This happens if <code>mkAnd? eqs</code> returns none. I assume this simply means “no equations present”, which in the case of <code>Wrap</code> is not surprising – <code>mk n1 = mk n2</code> can only hold if <code>n1 = n2</code> (because they are indices), so no equation can be “injected out” here, and the theorem would be vacuous</p>",
        "id": 575159071,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1771763524
    },
    {
        "content": "<p>Yeah, and if I'm reading that code correctly, it doesn't actually take the distinction between parameters and indices into account (except that, as an optimization, it skips parameters since they're already known to be equal across constructors).</p>\n<p>It makes the assumption that any constructor argument appearing in its return type (or in the type of any subexpression of its return type) is determined by the return type and skips creating an equality hypothesis for that argument. This detects all \"parameter-like\" fields. If there are no equality hypotheses, it skips creating the <code>inj</code> theorem.</p>\n<p>That assumption is however an approximation, and it's possible to trick it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"c1\">-- unknown constant</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapped'</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 575180863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771784676
    },
    {
        "content": "<p>Good catch! There is also the case where the index is a function (like <code>/2</code>). Then there are useful injectivity theorems for certain specific insides, but you cannot actually write them down easily. At that point, just use <code>noConfusion</code> directly</p>",
        "id": 575186245,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1771789080
    },
    {
        "content": "<p>Thanks a lot! Without trying to read the code, my interpretation of this is that \"Lean generates an injectivity theorem for each constructor taking fields, unless those fields appear in constructor’s codomain\" is reasonably accurate.</p>",
        "id": 575226031,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771823118
    }
]