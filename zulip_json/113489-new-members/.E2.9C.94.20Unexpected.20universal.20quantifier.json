[
    {
        "content": "<p>Hello! I hope this is the right place to ask a noob question. I'm working through the tutorial <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html\">here</a>, and I'm having trouble reusing a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">de_morgan_1</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">hnpq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">byContradiction</span>\n    <span class=\"k\">fun</span> <span class=\"n\">not_conclusion</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">hpq</span><span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">/\\</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span>\n        <span class=\"o\">(</span><span class=\"n\">byContradiction</span>\n          <span class=\"k\">fun</span> <span class=\"n\">hnp</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">hnp</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">byContradiction</span>\n          <span class=\"k\">fun</span> <span class=\"n\">hnq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">not_conclusion</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">hnq</span><span class=\"o\">))</span>\n    <span class=\"n\">hnpq</span> <span class=\"n\">hpq</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"n\">de_morgan_1</span>\n</code></pre></div>\n<p>I expected <code>de_morgan_1</code> to have the same type that I wrote in it's signature, but it's getting some extra universal quantifiers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">./././</span><span class=\"n\">Main.lean</span><span class=\"o\">:</span><span class=\"mi\">120</span><span class=\"o\">:</span><span class=\"mi\">32</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">de_morgan_1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Can someone explain why this universal quantifier is being introduced implicitly and why it doesn't match the type of <code>example</code>?</p>",
        "id": 390171412,
        "sender_full_name": "Duncan",
        "timestamp": 1694371014
    },
    {
        "content": "<p>The effect of <code>variable</code> is to universally quantify these variables if they occur in lemma statements. So <code>de_morgan_1</code>'s type starts with forall, and if you want to use it, you have to pass suitable arguments (or make the variables implicit using <code>variable {a}</code>).</p>",
        "id": 390171763,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694371260
    },
    {
        "content": "<p>The way <code>variable</code> works is that it's like every variable that gets used is inserted into a theorem as an extra argument. For example, you could also write <code>theorem de_morgan_1 (p q : Prop) : ¬(p ∧ q) → ¬p ∨ ¬q</code>. The effect of this is that <code>de_morgan_1</code> is universally quantified over <code>p</code> and <code>q</code>.</p>\n<p>Solution 1: when you invoke <code>de_morgan_1</code> you pass in these additional arguments, like <code>de_morgan_1 p q</code> (or <code>de_morgan_1 _ _</code> if you think Lean can figure it out based on context alone)</p>\n<p>Solution 2: change it to <code>variable {p q : Prop}</code> so that the variables become implicit. Implicit variables are basically filled in with <code>_</code>'s automatically. That way you can refer to <code>de_morgan_1</code> and even though it's technically universally quantified it will immediately be specialized.</p>",
        "id": 390171808,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1694371315
    },
    {
        "content": "<p>Thank you both! I think I understand now the effect of <code>variable</code> is to add arguments to a definition that uses them in its type. So \"solution 1\" seems appropriate to me. Solution 2 seems to break some other parts of my code, so I might try to figure that out later.</p>",
        "id": 390172560,
        "sender_full_name": "Duncan",
        "timestamp": 1694371913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648351\">Duncan</span> has marked this topic as resolved.</p>",
        "id": 391063452,
        "sender_full_name": "Notification Bot",
        "timestamp": 1694747066
    }
]