[
    {
        "content": "<p>Vectors, lists indexed by their size, are the \"Hello World\" of dependently-typed functional programming. Defining vectors of natural numbers as an indexed inductive type was straightforward for the novice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">NatVec</span>\n</code></pre></div>\n<p>One of the basic operations on (indexed) lists is appending. The novice's first attempt was to define <code>append</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">        </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.add_assoc</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, the novice was soon informed that tactics should not be used to define executable code like <code>append</code>. So, the novice tried again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.add_assoc</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>While pleased with the accomplishment, the novice’s friends shared their Agda equivalent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">_</span><span class=\"bp\">++</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">[]</span><span class=\"w\">       </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∷</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∷</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The novice reminded the friends that Lean’s verbosity was the price of its fine control over unfolding and stepwise reasoning. The novice also pointed out with some better encoding of the datatype, like swapping <code>1 + n</code> to <code>n + 1</code> in <code>cons</code>, the issue goes away and the issue is not particularly unique to Lean. However, after writing a few more definitions involving vectors, the novice’s code began to feel burdensome:</p>\n<ul>\n<li>tactics required explicit type annotations,</li>\n<li>these type annotations needed naming implicit types, and</li>\n<li>worst of all, the proofs were trivial facts about natural numbers, unrelated to the \"theory of vectors\".</li>\n</ul>\n<p>So, the novice tried tagging every relevant definition with <code>@[inline]</code> but failed (e.g., <a href=\"https://github.com/leanprover/lean4/issues/5808\">no inline on recursives</a>); attempted using coercions and failed; and of course failed to use quotients to work \"up to\" certain equivalences of natural numbers.</p>\n<p>Dear experienced Lean users,<br>\nall the novice wanted was to write code where certain equalities definitionally hold. What do you suggest?</p>\n<p>Regards,<br>\n<em>The Novice</em></p>",
        "id": 478357350,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729626876
    },
    {
        "content": "<p>i'm not sure it matters a lot, but it might help down the line if you use <code>n+1</code> rather than <code>1+n</code>, because i believe lean recognises this as a common way to express <code>n.succ</code>.</p>",
        "id": 478359060,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729627515
    },
    {
        "content": "<p>This is entirely due to Agda using a different argument to do recursion on in the definition of <code>Nat.add</code>. This works for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">NatVec</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 478359347,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729627637
    },
    {
        "content": "<p>Actually I'm confused, <a href=\"https://agda.github.io/agda-stdlib/v2.1.1/Data.Nat.Base.html#5411\">https://agda.github.io/agda-stdlib/v2.1.1/Data.Nat.Base.html#5411</a> suggests that the argument-swapped addition has special syntax.</p>",
        "id": 478359636,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729627757
    },
    {
        "content": "<p>In any case, this works, assuming the <code>1 + n</code> to <code>n + 1</code> fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 478359708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729627794
    },
    {
        "content": "<p>ah, the induction for <code>(. + .)</code> is on the right argument, while for <code>append</code>, it's on the left argument...</p>",
        "id": 478359939,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729627890
    },
    {
        "content": "<p>Yeah, Agda has exactly the same issues as Lean when it comes to definitional equalities and addition. It's just about either being clever about what you induct/recurse on, or deciding to be OK with doing rewrites</p>",
        "id": 478360098,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729627969
    },
    {
        "content": "<p>The key issue, the novice wants to stress, is that in Agda, unlike Lean, definitions are unfolded by default. Notice recursive functions should not even be tagged with <code>@[inline]</code> in Lean. Moreover,  there<code>{#-REWRITE ...#-}</code> can save the day. Of course, in simpler cases <code>1 + n</code> vs <code>n + 1</code> helps.</p>",
        "id": 478360509,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729628165
    },
    {
        "content": "<p>This isn't the issue, the definitions are in fact unfolded. It's just not defeq.</p>",
        "id": 478360879,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628330
    },
    {
        "content": "<p>Unless <code>REWRITE</code> can automatically insert that <code>1 + n = n + 1</code>? That's not something Lean can do.</p>",
        "id": 478360939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628368
    },
    {
        "content": "<p>(<code>@[inline]</code> isn't what marks things for being more unfoldable, it's <code>@[reducible]</code>. The <code>@[inline]</code> attribute marks things for the compiler to inline as an optimization. Still, the default for definitions is semireducible, which unfolds automatically in defeq checks.)</p>",
        "id": 478361093,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628414
    },
    {
        "content": "<p>looking at the way this is done in mathlib, i guess hijacking <code>List</code> for <code>Vector a n := {l:List a // l.length = n}</code> does simplify all this because in lean, proofs of the same thing are equal...</p>",
        "id": 478361098,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729628416
    },
    {
        "content": "<p>it just requires you have the api for <code>List.length</code></p>",
        "id": 478361196,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729628458
    },
    {
        "content": "<p>for reference, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Vector/Defs.html#Mathlib.Vector\">Mathlib.Vector</a></p>",
        "id": 478361280,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729628494
    },
    {
        "content": "<p>Here's the Agda page on REWRITE: <a href=\"https://agda.readthedocs.io/en/latest/language/rewriting.html\">https://agda.readthedocs.io/en/latest/language/rewriting.html</a></p>\n<p>Presumably this is why the Agda <code>_++_</code> goes through?</p>\n<p>Notice <span class=\"user-mention\" data-user-id=\"762283\">@middle adjunction</span> that I wrote <code>append'</code> without any rewriting and it worked — I'm just pointing this out again to stress that Lean <em>does</em> unfold definitions. It just fails if in the end the indices aren't defeq.</p>",
        "id": 478361543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628614
    },
    {
        "content": "<p>It would be neat if Lean had this feature, but I'm not sure if or when that would happen...</p>",
        "id": 478361702,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478361093\">said</a>:</p>\n<blockquote>\n<p>(<code>@[inline]</code> isn't what marks things for being more unfoldable, it's <code>@[reducible]</code>. The <code>@[inline]</code> attribute marks things for the compiler to inline as an optimization. Still, the default for definitions is semireducible, which unfolds automatically in defeq checks.)</p>\n</blockquote>\n<p>aha, if recursive functions can be labelled as @[reducible], then some of the needed definitional equalities are restored.<br>\nI don't know what \"defeq\" is btw.</p>",
        "id": 478361837,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729628729
    },
    {
        "content": "<p>\"defeq\" is short for \"definitional equality\"</p>",
        "id": 478361888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628752
    },
    {
        "content": "<p>as in, \"X and Y are defeq\" if \"Lean can find a sequence of definitional equalities between X and Y\"</p>",
        "id": 478361982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628777
    },
    {
        "content": "<p>You shouldn't need to label anything as <code>@[reducible]</code> to make defeq succeed here. Do you have an example?</p>",
        "id": 478362044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"762283\">middle adjunction</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478357350\">said</a>:</p>\n<blockquote>\n<p>and of course failed to use quotients to work \"up to\" certain equivalences of natural numbers.</p>\n</blockquote>\n<p>By the way, quotients do not add definitional equalities to a type. It just makes it possible to propositionally prove that more things are equal.</p>",
        "id": 478362125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729628847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478362044\">said</a>:</p>\n<blockquote>\n<p>Do you have an example?</p>\n</blockquote>\n<p>I'm sure I posted a few examples on the Discord server. I will try to come up with some good examples.</p>",
        "id": 478362278,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729628908
    },
    {
        "content": "<p>To stress this more, since you said that Lean has \"fine control over unfolding and stepwise reasoning\", Lean is perfectly happy to unfold definitions when checking definitional equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">myAdd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">myAdd</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">myAdd</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">30</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>It's like Agda here.</p>",
        "id": 478362609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729629031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478362125\">said</a>:</p>\n<blockquote>\n<p>By the way, quotients do not add definitional equalities to a type. It just makes it possible to propositionally prove that more things are equal</p>\n</blockquote>\n<p>Yep, it was a desperate attempt to simulate working \"up to\" certain equivalence</p>",
        "id": 478362727,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729629078
    },
    {
        "content": "<p>Here we go, the definition of <code>_+_</code> in Agda: it recurses on the first argument, not the second like in Lean.</p>\n<p>Agda: <a href=\"https://agda.github.io/agda-stdlib/v2.1.1/Agda.Builtin.Nat.html#336\">https://agda.github.io/agda-stdlib/v2.1.1/Agda.Builtin.Nat.html#336</a><br>\nLean: <a href=\"https://github.com/leanprover/lean4/blob/eddbdd77b85c44728e0a749fd224d3ce31770976/src/Init/Prelude.lean#L1538-L1540\">https://github.com/leanprover/lean4/blob/eddbdd77b85c44728e0a749fd224d3ce31770976/src/Init/Prelude.lean#L1538-L1540</a></p>",
        "id": 478362956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729629163
    },
    {
        "content": "<p>It's not doing anything fancy (no REWRITE pragmas), it's just using a <code>+</code> whose definition helps you with the \"hello world\" of dependently typed functional programming. (In practice, we find the type that <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478361098\">Edward mentioned</a> to be better to work with.)</p>",
        "id": 478363112,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729629230
    },
    {
        "content": "<p>Just to summarise </p>\n<ul>\n<li>no Agda does not need and use REWRITE pragmas for this</li>\n<li>such REWRITES are considered unsafe (but I did use them before to utilise equalities like 0 + n = n as rewrites)</li>\n<li>after what you mentioned (e.g., semireducible), I am not actually sure how to compare Agda's unfolding with Lean's</li>\n<li>now I understand at least <code>@[reducible]</code> is the right annotation (not <code>@[inline]</code>), so I can play with it</li>\n<li>Agda-style unfolding  or not,  <code>n + 1</code> or <code>1 + n</code>, the core issue, in both Agda (minus rewrite pragmas) and Lean remains, no? In more complex cases (examples pending) where equality on indices is not as simple (e.g., can be resolved with <code>1 + n</code>) the code gets quickly  burdensome, so much that I actually prefer <code>append</code> over <code>append'</code>.</li>\n</ul>",
        "id": 478366224,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729630696
    },
    {
        "content": "<p>One of the design patterns you can use is writing an index casting function</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"c1\">-- Basic API:</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cast_rfl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cast_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n''</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This is better than using the triangle, since you can make algebraic rules for <code>cast</code>.</p>\n<p>In both Lean and Agda, you'd need something like this to express that <code>append</code> is associative.</p>",
        "id": 478366730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729630928
    },
    {
        "content": "<p>More or less, what reducible is for is controlling what tactics and typeclasses will unfold when doing pattern matching. It shouldn't affect what's defeq to what in basic cases.</p>",
        "id": 478367271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729631179
    },
    {
        "content": "<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 478367722,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729631413
    },
    {
        "content": "<p>Ok, this setup seems pretty promising!  Especially since it appears that:</p>\n<ul>\n<li>there is one cast only per branch, </li>\n<li>there is no need to provide explicit type annotations,  and</li>\n<li>there is no need for bringing into scope implicit variables just for type annotations.</li>\n</ul>",
        "id": 478367769,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729631439
    },
    {
        "content": "<p>Yeah, this is one of our \"Charons\" for navigating dependently type hell. A cost is making cast-normalization simp lemmas, but it's not so bad to work with. Here's <code>append_append</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons_cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst_vars</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cast_append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst_vars</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">append_cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">subst_vars</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">append_append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">zs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">zs</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 478369476,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729632320
    },
    {
        "content": "<p>I'm sure someone could figure out how to make automation for these. The formula is \"given a function that returns NatVec, wherever an argument with NatVec, make a lemma that pushes a cast there to the output\"</p>",
        "id": 478370045,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729632601
    },
    {
        "content": "<p>(Why push outward? In my experience, that causes them to merge using <code>cast_trans</code> and, hopefully, become eliminated entirely.)</p>",
        "id": 478370225,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729632667
    },
    {
        "content": "<p>I am playing with your suggestion...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">        </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\">                     </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is clean, and pedagogically as expected: part related to lists before |&gt; and part related to indices after, and also it is stable under swapping between <code>n+1</code>and <code>1 + n</code> so no need to rely on a \"trick\"  (e.g., by looking at the definition of _+_ , instead of taking it as abstract)</p>",
        "id": 478370982,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729633059
    },
    {
        "content": "<p>I don't even need to come up an equational theory to give me a rewriting system as I have the full power of omega</p>",
        "id": 478371170,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729633180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  Is this pattern documented somewhere?</p>",
        "id": 478412567,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729659627
    },
    {
        "content": "<p>I'm not sure. I haven't looked into the history of it, but I've used it in mathlib, and I point it out whenever I notice someone trying to work with a <code>Vector</code>-like type on this Zulip.</p>",
        "id": 478413030,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729659824
    },
    {
        "content": "<p>It seems like the boilerplate code is reimplementing a variant of <code>simp</code> tactic: <code>M |&gt;.cast (by omega)</code> looks like <code>by simp [...]; exact M</code> of the first variant of <code>append</code>. It makes me wonder where is the line between bad uses of tactics for defining executable code versus these morally correct uses. Afterall, if I know morally that my uses of tactics are only applying propositions to rewrite the types, the run-time behaviour of the code should be unaffected.  When is it not the case in this context?</p>",
        "id": 478417361,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729662846
    },
    {
        "content": "<p>It's different because <code>cast</code> is constraining the proof to be inside a function that you can reason about. Otherwise, you get unrestricted <code>Eq.rec</code>s that you have no hope getting <code>simp</code> to do anything about.</p>",
        "id": 478418323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729663357
    },
    {
        "content": "<p>It's still a rewrite, but it's a constrained rewrite that has algebraic rules you can exploit.</p>\n<p>Sometimes there are types that let you sink the rewrite into a constructor and get some nice defeq properties. <a href=\"https://github.com/leanprover/lean4/blob/01d414ac36dc28f3e424dabd36d818873fea655c/src/Init/Data/Fin/Basic.lean#L181-L181\">Fin.cast</a> comes to mind. If you define your vector type as a Subtype, like in Edward's suggestion, you could do this too.</p>",
        "id": 478418640,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729663528
    },
    {
        "content": "<p>ok let me try to redescribe: what would be the issue to write a tactic <code> M |&gt;Nat_Theory</code>where</p>\n<ul>\n<li>M is executable</li>\n<li><code>_ |&gt;Nat_Theory</code> has access to goal type and type of M</li>\n<li><code>_ |&gt;Nat_Theory</code> generates code in effect of  <code>(have p :  type_of_goal = type_of_M := simp [Nat_Theory]); p  ▸ M</code><br>\nThis tactic/macro generates casts only, but unlike <code>|&gt;.cast</code>, works on arbitrary type (as long as simp supports them).<br>\nHaving access to goal and term type in this macro/tactic, somehow affects the execution behaviour?</li>\n</ul>",
        "id": 478419675,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729664069
    },
    {
        "content": "<p>I don't think there's anything that would affect the execution behavior. It's more of a matter of whether you can prove anything about your functions.</p>",
        "id": 478419775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664144
    },
    {
        "content": "<p>It could affect whether defeqs are preserved, though the <code>NatVec.cast</code> function doesn't have any good defeqs except when you're rewriting using rfl.</p>",
        "id": 478419999,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664267
    },
    {
        "content": "<p>Here are some examples of defeqs you can get with the Subtype version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">NatVec</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Things tend to commute with <code>cast</code> in this case.</p>",
        "id": 478420202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478419775\">said</a>:</p>\n<blockquote>\n<p>I don't think there's anything that would affect the execution behavior. It's more of a matter of whether you can prove anything about your functions.</p>\n</blockquote>\n<p>Can you explain what you mean?</p>\n<p>All the <code>_ |&gt;Nat_Theory</code> macro is doing  is to replace the handwritten bits like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_add</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>\n<p>with </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"n\">Nat_Theory</span>\n</code></pre></div>\n<p>No boilerplate code needed.</p>",
        "id": 478420284,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729664419
    },
    {
        "content": "<p>Think about the theorems you'd write <em>about</em> this function.</p>",
        "id": 478420373,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664469
    },
    {
        "content": "<p>append nil xs = xs</p>",
        "id": 478420428,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729664512
    },
    {
        "content": "<p>The point is that in the proofs you have to work with whatever the tactic proof in the definition of <code>append</code> happened to create.</p>\n<p>With <code>cast</code> functions, you will see very constrained terms that you can reason about algebraically.</p>",
        "id": 478420538,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664561
    },
    {
        "content": "<p>Unrestricted Eq.rec (which is what you're suggesting using) is \"dependently typed hell\". It's possible to navigate it, but it's better to take some care and make some preparations.</p>",
        "id": 478420708,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664655
    },
    {
        "content": "<p>An exercise is to write the <code>append_append</code> theorem from before</p>",
        "id": 478420805,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664733
    },
    {
        "content": "<p>If you don't care about proving things, then there's probably no harm in using simple tactics in your definitions.</p>",
        "id": 478420904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664772
    },
    {
        "content": "<p>Sorry, I am a bit confused:  you are saying  even <code>append'</code> from the original post causes issues with reasoning (e.g., <code>append_append</code>)?</p>",
        "id": 478421000,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729664858
    },
    {
        "content": "<p>Yeah, I've found that sort of thing to cause a lot of problems. It's worth trying to prove <code>append_append</code></p>",
        "id": 478421164,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664933
    },
    {
        "content": "<p>I thought we were comparing <code>append</code> vs <code>append'</code>, not <code>append'</code> vs  <code>append''</code></p>",
        "id": 478421237,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729664990
    },
    {
        "content": "<p>You'll have to remind me which these are all. My main argument here is that \"it's better to define <code>append</code> with a <code>cast</code> function if you want to do reasoning, if you have to do rewrites at all\"</p>",
        "id": 478421392,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729665056
    },
    {
        "content": "<p>Here are the three variants:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">        </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.add_assoc</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat.add_assoc</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- definitions related to cast and pushing it around types</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">        </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\">                     </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- definitons related to hypothetical macro _ |&gt;Nat_Theory</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">append'''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NatVec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\">        </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\">                     </span><span class=\"bp\">|&gt;</span><span class=\"n\">Nat_Theory</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">append</span><span class=\"w\"> </span><span class=\"n\">xs'</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"n\">Nat_Theory</span>\n</code></pre></div>",
        "id": 478421620,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729665178
    },
    {
        "content": "<p>There's not too much of a difference between the first two, and the third is easier to prove things about. The second is probably somewhat easier to prove things about than the first, since <code>▸</code> elaborates to a single <code>Eq.rec</code>.</p>",
        "id": 478421887,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729665301
    },
    {
        "content": "<p>The key is that <code>cast</code> constrains the rewrite to the index. In the first two, the rewrite is for the whole <code>NatVec</code> type, and it's hard to do anything with type equalities.</p>",
        "id": 478422042,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729665378
    },
    {
        "content": "<p>For example, from <code>NatVec n = NatVec m</code> you can't prove that <code>n = m</code>. But, with a <code>cast</code> function, you have <code>n = m</code> immediately available.</p>",
        "id": 478422155,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729665451
    },
    {
        "content": "<p>I see. I believe there are three separate dimensions to this discussion (based on <a href=\"#narrow/channel/113489-new-members/topic/The.20Novice.20vs.20Indexed.20Types.20in.20Lean.3A.20A.20Short.20Story/near/478421620\">code</a>):</p>\n<ul>\n<li>whether there should be casts: <ul>\n<li><code>append</code> has no explicit casts, but</li>\n<li><code>append'</code>, <code>append''</code> and <code>append'''</code> have casts</li>\n</ul>\n</li>\n</ul>\n<p>We agree there should casts.</p>\n<ul>\n<li>whether casts should be restricted to indices or entire type:<ul>\n<li>in <code>append'</code> casts are unrestricted, but </li>\n<li>in <code>append''</code> (and potential <code>append'''</code>)  casts are restricted to indices</li>\n</ul>\n</li>\n</ul>\n<p>We agree restricted casts are better.</p>\n<ul>\n<li>syntactic burden (and boilerplates): <ul>\n<li><code>append''</code> is easier to write compared to <code>append</code> and <code>append'</code> except the generic boilerplate (e.g., <code>NatVec.cast_rfl</code>) needed for pushing casts around</li>\n<li>the proposed macro/tactic <code>_|&gt;Nat_Theory</code> in  <code>append'''</code> attempts to simulate <code>append''</code> style without the boilerplate</li>\n</ul>\n</li>\n</ul>\n<p>Finally, to summarise what <code>_|&gt;Nat_Theory</code> means:<br>\nfor <code>M : NatVec n</code>, and goal type <code>NatVec m</code> the macro <code>M |&gt;Nat_Theory</code> generates </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">Nat_theory</span><span class=\"w\"> </span><span class=\"o\">]</span>\n<span class=\"n\">M.cast</span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Do you foresee any issues with the macro <code>_|&gt;Nat_Theory</code>?</p>",
        "id": 478431411,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729669402
    },
    {
        "content": "<p>I don't think there are any issues with that, and it would be nice automation to have.</p>\n<p>It would also be nice if there were reasoning automation that could automatically push casts around.</p>",
        "id": 478532643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729699554
    },
    {
        "content": "<p>Thank you for your replies <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>!<br>\nEncouraged by this, I am currently reading Metaprogramming in Lean 4, and am  deep in Lean's metaprogramming libraries.<br>\nI am not sure this thread is the right venue to delve into details of developing such automation, so I will open a new thread.<br>\nAfter a few days, I plan to come back and add a sequel to this story with summarising conclusions.</p>",
        "id": 478534298,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729700114
    },
    {
        "content": "<p>Stay tuned...</p>",
        "id": 478560755,
        "sender_full_name": "Dean Young",
        "timestamp": 1729708842
    }
]