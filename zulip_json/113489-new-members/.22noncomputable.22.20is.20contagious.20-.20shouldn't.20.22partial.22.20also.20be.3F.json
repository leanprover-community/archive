[
    {
        "content": "<p>It seems definitions using \"noncomputable\" definitions are righteously required to be \"noncomputable\" as well, but that doesn't seem to be the case for \"partial\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- \"noncomputable\" is required here</span>\n\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gg</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"w\"> </span><span class=\"c1\">-- this type checks without \"partial\"</span>\n</code></pre></div>\n<p>To be clear: I am not saying that there is any soundness risk. But it feels like \"gg\" should also be required to be marked with \"partial\" - otherwise, all \"partial\" definitions can be wrapped into definitions without \"partial\" keyword, and then there is not much point for having \"partial\" as a keyword...? (its only use is to specify whether to use termination checking or non-emptiness checking in the return type?)</p>",
        "id": 491462461,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735698942
    },
    {
        "content": "<p>The non-contagion makes sense if you read <code>partial</code> as \"you may not leverage the definition of this function within proofs\"</p>",
        "id": 491463556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735700130
    },
    {
        "content": "<p>Mathematically (i.e. in the kernel), <code>partial</code> functions are just black boxes, which is why the output type needs to be <code>Inhabited</code>.  If I recall correctly, you can’t prove anything about them except for properties which hold for all functions of that type.  (So you can prove <code>gg = ff</code> or that <code>(gg n) + 1 &gt; gg n</code>, but you can’t prove <code>gg n = 0</code> or <code>ff n = 0</code>.</p>\n<p>But for compilation and evaluation (<code>main</code> functions or <code>#eval</code>) they are computable in that you can run them in code.  Also, the point of <code>partial</code> is to write unbounded recursion like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">collatz_steps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">collatz_steps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">collatz_steps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So you don’t have to prove the function terminates (which in this example would be a bit tricky).</p>",
        "id": 491463615,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735700180
    },
    {
        "content": "<p>That definition is useless if you want to prove anything about <code>collatz_step 5</code> though; I would imagine there are previous discussions about stating collatz-related results without having to first prove the conjecture</p>",
        "id": 491463726,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735700334
    },
    {
        "content": "<p>Actually I think I misunderstood the question.  Your answer <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is better.  (collatz_step was just a silly example of a function which doesn’t provably terminate.  I didn’t mean it to be a realistic way to talk about the collatz conjecture mathematically).</p>",
        "id": 491463972,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735700525
    },
    {
        "content": "<blockquote>\n<p>So you can prove <code>gg = ff</code> or that <code>(gg n) + 1 &gt; gg n</code>, but you can’t prove <code>gg n = 0</code> or <code>ff n = 0</code></p>\n</blockquote>\n<p>I might be misunderstanding you but how could you prove that one black box function equals another? Do you just mean like a <code>rfl</code> proof where they're definitionally equal? Or do you mean when the output type is a subsingleton?</p>",
        "id": 491468325,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735705482
    },
    {
        "content": "<p>ff is a function, but lean’s kernel can see its definition so it is opaque.  gg is not opaque.  lean’s kernel can see its definition and that it equals ff.  (It happens to be a rfl proof, but that isn’t important here.)</p>",
        "id": 491474313,
        "sender_full_name": "Jason Rute",
        "timestamp": 1735711555
    },
    {
        "content": "<p>Thank you for the explanations, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> and <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span> ! That indeed makes sense and is quite interesting. If I understand correctly, if seen from the \"proof world\", <code>partial</code> is basically the same as <code>axiom</code> and thus it need not be contagious.<br>\nI can also see the virtue of non-contagion in the context of programming - one may have a sub-procedure whose definition does not really affect the correctness of the whole-program and one does not want to care about termination of this sub-procedure (e.g., CompCert uses a register allocator written in OCaml without termination proofs, and it remains opaque in the proof of CompCert).</p>",
        "id": 491644719,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735840336
    },
    {
        "content": "<p>No <code>partial</code> is not the same as <code>axiom</code>. If you propose an axiom you do not need to show that its type is inhabited, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>\n<p>if you propose a partial function you need to show that its type is inhabited:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- will fail</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>So an <code>axiom</code> can make your proof system inconsistent while a <code>partial</code> cannot.</p>\n<p>The second paragraph is correct though yes.</p>",
        "id": 491647014,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1735841529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  Ah yes, my wording above was wrong. Thank you for pointing this out!</p>",
        "id": 491666800,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735852412
    },
    {
        "content": "<p>(From the \"proof world\", <code>partial</code> is the same as <code>opaque</code>, which is like <code>axiom</code> but requires evidence that the type is inhabited. The <code>partial</code> modifier is more convenient than going through the steps of (1) creating the <code>opaque</code> declaration, (2) creating an <code>unsafe</code> declaration with the body of the definition, and (3) adding an <code>@[implemented_by]</code> attribute so that the compiler calls the <code>unsafe</code> declaration when the <code>opaque</code> one is invoked.)</p>",
        "id": 491669245,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735853900
    },
    {
        "content": "<p>Is there a way to query whether a definition is partial (or depends on a partial), in the same way that <code>#print axioms mydef</code> can tell me if it depends on Classical.choice?</p>",
        "id": 491734590,
        "sender_full_name": "Freddie Nash",
        "timestamp": 1735899032
    },
    {
        "content": "<p>Would you also want to identify <code>opaque</code> and <code>implemented_by</code>? What exactly are you trying to identify?</p>",
        "id": 491754411,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735909170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thank you for letting me know about <code>opaque</code> and <code>unsafe</code> keywords! It seems the <code>partial</code> keyword is indeed desugared to definitions with <code>opaque</code> and <code>unsafe</code> (<a href=\"https://lean-lang.org/lean4/doc/lean3changes.html\">https://lean-lang.org/lean4/doc/lean3changes.html</a>) as you described, which makes very much sense.</p>",
        "id": 491788405,
        "sender_full_name": "Youngju Song",
        "timestamp": 1735925775
    },
    {
        "content": "<p>Good question: I want to know whether a function is provably total or not; I'm not familiar with <code>opaque</code> and <code>implemented_by</code>, but based on the discussion above and some assumptions, I imagine both of those would also signal a potentially non-total function.</p>",
        "id": 491788472,
        "sender_full_name": "Freddie Nash",
        "timestamp": 1735925818
    },
    {
        "content": "<p>Do you mean \"total at runtime\" or \"total within the theory somehow\"?</p>",
        "id": 491788606,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735925885
    },
    {
        "content": "<p>This is a slippery concept (hence 'somehow'). Every function in the theory is \"total\" in the sense that, no matter how <code>f : Nat -&gt; Nat</code> is defined, then <code>f n</code> is a <code>Nat</code>.</p>",
        "id": 491788709,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735925954
    },
    {
        "content": "<p>But \"at runtime\" is also a useless concept, because <code>Nat.add</code> while total on the lean side, is at compile time translated into an unrelated function that calls <code>malloc</code> at runtime, and whether this is total is a problem for your OS</p>",
        "id": 491788867,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735926036
    },
    {
        "content": "<p>Variations:</p>\n<ol>\n<li>Does <code>#eval f n</code> terminate for each <code>n</code>? That's a runtime version of totality. (Let's assume an ideal evaluator to avoid Eric's OS issue.)</li>\n<li>Does <code>f n</code> reduce to a constructor application for each <code>n</code>? That's the 'lambda calculus' version of totality. There are two variants though: (a) reduction in the kernel and (b) reduction in the elaborator. These can be a bit different. Even (b) can vary depending on what reducibility settings are in effect, or which declarations are artificially <code>@[irreducible]</code>.</li>\n<li>Does <code>f n</code> simplify to a normal form for each <code>n</code> using <code>simp</code> or some other metaprogram? This is some kind of meta-evaluation version of totality.</li>\n</ol>",
        "id": 491789181,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735926226
    },
    {
        "content": "<p>I've clearly underappreciated the slipperyness of this, a lot of this terminology is going over my head: I'll have to go away and give it some thought and look back at the scenario where I first confronted this to see what I was trying to get at. Certainly I'm not worried about resource exhaustion in the runtime, so it's definitely a theoretical consideration; this minute it feels like I want to know whether it is - if only theoretically - possible to prove the function in question evaluates to some terminated value for any input someone might want to give me, i.e. there is no value for which our ideal evaluator would not necessarily produce the same terminated value every time. Again, the distinctions between variations 2 and 3 are lost on me right now, so it's probably on me to understand those.</p>",
        "id": 491790230,
        "sender_full_name": "Freddie Nash",
        "timestamp": 1735926742
    },
    {
        "content": "<p>It's possible to have something that <em>does</em> transitively use <code>partial</code>, but also permits full \"evaluation\" (in the proving sense you mention) of the function in question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- `partial` needs this to work</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- a function we can't prove much about</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">makeList</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- fails, can't look inside `partial`</span>\n\n<span class=\"c1\">-- but we can use it to define a function that we can fully characterize:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">derived</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">derived</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">derived</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 491790960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735927096
    },
    {
        "content": "<p>2 vs 3 is roughly definitional equality vs propositional equality. The first is that the raw lambda calculus rules never get stuck (so the typechecker can validate the computation directly), and the second is that you are willing to have to rely on generating \"execution traces\" when you want to have a validated computation. The \"execution trace\" means a proof, like a sequence of rewrites or something similar. Tactics such as <code>norm_num</code> generate an \"execution trace\" while evaluating numeric expressions. This lets you do arithmetic in settings that aren't generally computable, like for the real numbers.</p>",
        "id": 491791072,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735927166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"715788\">Freddie Nash</span> <a href=\"#narrow/channel/113489-new-members/topic/.22noncomputable.22.20is.20contagious.20-.20shouldn't.20.22partial.22.20also.20be.3F/near/491790230\">said</a>:</p>\n<blockquote>\n<p>this minute it feels like I want to know whether it is - if only theoretically - possible to prove the function in question evaluates to some terminated value for any input someone might want to give me, i.e. there is no value for which our ideal evaluator would not necessarily produce the same terminated value every time.</p>\n</blockquote>\n<p>This should be possible, by recursively looking through all constants that appear in a definition to see if anything is <code>opaque</code> and has an <code>@[implemented_by]</code> attribute.</p>\n<p>You probably don't need to worry about <code>@[csimp]</code> lemmas, unless you worry about definitions that have <code>@[implemented_by]</code> that may not be equivalent... That <em>shouldn't</em> happen, but it's not machine-checked. It depends on just being really careful.</p>",
        "id": 491791850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1735927501
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">makeList</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That certainly wrecks my instinctive suggestion (suggests I'm probably interested in definitional equality, because I want to compare the whole, not properties about it). I'm going to have to go away and think about this: thanks both for writing this much up: it's certainly shaken my picture of things. I'll try to come back later with a better question.</p>",
        "id": 491792075,
        "sender_full_name": "Freddie Nash",
        "timestamp": 1735927613
    },
    {
        "content": "<p>Well, \"the whole\" could refer to <code>derived</code> above; it sounds like you have to mean \"every subexpression of \"the whole\", even if those subexpressions turn out not to matter for the final result\"?</p>",
        "id": 491793633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735928460
    },
    {
        "content": "<p>Aye, what I had in-mind was roughly what Kyle said above about recursively checking if anything even mentions something potentially iffy (I'm not looking for a tight specification; afterall, you can prove things that are true with <code>sorry</code> so seeing <code>sorryAx</code> doesn't imply anything). Even if a function doesn't appear to depend on any part of a result it would feel like a problem to me, but I have no idea now if that's a meaningful question to ask without understanding the specifics of lean's evaluator.</p>",
        "id": 491794544,
        "sender_full_name": "Freddie Nash",
        "timestamp": 1735928910
    }
]