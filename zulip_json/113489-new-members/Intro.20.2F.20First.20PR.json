[
    {
        "content": "<p>Hi, I'm Knala. I'm new here and just wanted to pop in and say hi, as I have made my first PR to mathlib. Inspired by a TODO I saw in the docs, I defined the von Neumann hierarchy in ZFC, and connected my definition with ZFSet.rank. <a href=\"https://github.com/knalasol/mathlib4/blob/von-Neumann/Mathlib/SetTheory/ZFC/VonNeumann.lean\">File here</a>. I would appreciate any feedback on code or style if anyone has capacity to offer, as I did not have much experience with lean prior to this project.</p>",
        "id": 526283856,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751218783
    },
    {
        "content": "<p>Wow, the code looks really neat! Well done!</p>",
        "id": 526284386,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751219382
    },
    {
        "content": "<p>Next time please link to the PR as well! <a href=\"https://github.com/leanprover-community/mathlib4/pull/26518\">#26518</a></p>",
        "id": 526284445,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751219447
    },
    {
        "content": "<p>thanks!</p>",
        "id": 526284527,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751219521
    },
    {
        "content": "<p>Unfortunately, I am seeing now that my PR did not pass CI <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span>. it seems to be because I was not able to run <code>lake exe mk_all</code> on my own machine before pushing. Here is the error message I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">dyld</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Symbol</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">ZNKSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEE3strEv</span>\n<span class=\"w\">  </span><span class=\"n\">Referenced</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">HOME</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---v4.21.0-rc3/bin/../lib/libLLVM.dylib (which was built for Mac OS X 10.19)</span>\n<span class=\"w\">  </span><span class=\"n\">Expected</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"n\">usr</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">/</span><span class=\"n\">libc</span><span class=\"bp\">++.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">dylib</span>\n<span class=\"n\">error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">external</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">'$</span><span class=\"n\">HOME</span><span class=\"bp\">/.</span><span class=\"n\">elan</span><span class=\"bp\">/</span><span class=\"n\">toolchains</span><span class=\"bp\">/</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---v4.21.0-rc3/bin/clang' exited with code 134</span>\n</code></pre></div>\n<p>The error appears not when trying to exe my new file, but rather on a series of Mathlib files I have not modified. I suspect that it may have to do with my OS version (I am using mac OS 10.15 Catalina, which according what I can see is sufficent for lake), but I am a little confused as I am not sure that \"Mac OS X 10.19\" even exists...</p>",
        "id": 526284544,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751219548
    },
    {
        "content": "<p>What do you mean \"trying to exe my new file\"? You should just run <code>lake exe mk_all</code> once in the main directory (the directory containing .gitignore and all the other relevant files)</p>",
        "id": 526284765,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751219745
    },
    {
        "content": "<p>that is what i did. I just meant that the error came up before lake reached the file I modified.</p>",
        "id": 526284918,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751219906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> this is not really recommended, but you can go to <code>Mathlib.lean</code> (which is sorted alphabetically) and manually add your file to the list.</p>",
        "id": 526285240,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751220171
    },
    {
        "content": "<p>do you have any idea what would be causing the dyld error?</p>",
        "id": 526285507,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751220471
    },
    {
        "content": "<p>I've never seen that, sorry; maybe you can try asking GPT</p>",
        "id": 526285597,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751220562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/Intro.20.2F.20First.20PR/near/526285240\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"933047\">Knala Solomon</span> this is not really recommended, but you can go to <code>Mathlib.lean</code> (which is sorted alphabetically) and manually add your file to the list.</p>\n</blockquote>\n<p>wait... you are not supposed to manually edit Mathlib.lean? I have done that for at least three merged PRs <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 526285805,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1751220807
    },
    {
        "content": "<p>It's not forbidden :)</p>",
        "id": 526285956,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1751221010
    },
    {
        "content": "<p>The intended course of action is to run <code>lake exe mk_all</code></p>",
        "id": 526286541,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751221726
    },
    {
        "content": "<p>i got it to work!</p>",
        "id": 526293128,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751228798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> how did you fix it?</p>",
        "id": 526293286,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751228953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> (btw if you're wondering why there's been nothing, I'm still reviewing your PR)</p>",
        "id": 526294920,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751230744
    },
    {
        "content": "<p>I set my <code>DYLD_LIBRARY_PATH</code> to pull from the Homebrew version of llvm rather than the system one</p>",
        "id": 526294932,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751230761
    },
    {
        "content": "<p>I'm patient. I imagine there are lots of PR's for ppl to review.</p>",
        "id": 526294977,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751230829
    },
    {
        "content": "<p>no i'm actually only reviewing your PR</p>",
        "id": 526295114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751230980
    },
    {
        "content": "<p>cool, thanks!</p>",
        "id": 526295132,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751231008
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> I left a big review <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> Feel free to ask me questions, but I'll probably take a break for now.</p>",
        "id": 526297847,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751234753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> I've added the \"awaiting-author\" tag because you seem to be editing the file. Feel free to remove the tag after you've finished editing, and then I'll review further.</p>",
        "id": 526303184,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751242171
    },
    {
        "content": "<p>thanks again for your review. I do have a some questions whenever you get a chance:</p>\n<ol>\n<li>is it preferred for mathlib that everything be golfed down to its shortest form?</li>\n<li>is it preferred to use simp for as much as possible? if so, why? that seems to obfuscate the proof.</li>\n<li>can you elaborate on constructivism?</li>\n</ol>",
        "id": 526344809,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751271704
    },
    {
        "content": "<p>CC <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> he PR summary comment job <a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/15966317833/job/45027381874?pr=26518\">fails</a> on this PR with an error \"needs merge\": is this expected (or a known issue)?</p>",
        "id": 526346342,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1751272195
    },
    {
        "content": "<p>These two red crosses don't seem related to your pull request: for the time being, ignoring them is safe.</p>",
        "id": 526346436,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1751272220
    },
    {
        "content": "<ol>\n<li>no, but we prefer not making proofs longer than is useful. The limit to that is often up to personal opinion :)</li>\n</ol>",
        "id": 526347061,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1751272434
    },
    {
        "content": "<p>Besides the error that suggests to merge, there is also a merge conflict, so possibly resolving that would make the action work?</p>",
        "id": 526347108,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1751272450
    },
    {
        "content": "<p>i'm also actively editing the code so the pr is not ready to move forward atm</p>",
        "id": 526347196,
        "sender_full_name": "Knala Solomon",
        "timestamp": 1751272483
    },
    {
        "content": "<p>My take on \"how much golfing\", which I believe is somewhat shared, is the following:</p>\n<ul>\n<li>we want code to be maintainable going forward: absolute golfing down to a soup of ASCII characters (as you see in some code golf competitions on the internet) is not a goal, because editing that is a mess</li>\n<li>unnecessarily long code also means extra maintenance work: if there's a more succinct, equally nice proof, we prefer that.</li>\n<li>if a proof has \"almost no mathematical content\", it's fine to golf that. This last item requires a judgement call.</li>\n</ul>",
        "id": 526358397,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1751275894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933047\">Knala Solomon</span> <a href=\"#narrow/channel/113489-new-members/topic/Intro.20.2F.20First.20PR/near/526344809\">said</a>:</p>\n<blockquote>\n<p>thanks again for your review. I do have a some questions whenever you get a chance:</p>\n<ol>\n<li>is it preferred for mathlib that everything be golfed down to its shortest form?</li>\n<li>is it preferred to use simp for as much as possible? if so, why? that seems to obfuscate the proof.</li>\n<li>can you elaborate on constructivism?</li>\n</ol>\n</blockquote>\n<ol>\n<li>I think length serves as a good indicator of how much \"stuff\" there is in a given proof, or in other words the complexity of a proof. Golfing it down helps to make main steps of the proof more clear. For example,</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The stages of the von Neumann hierarchy are transitive as sets,</span>\n<span class=\"sd\">meaning that every element of a stage is a subset of it. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isTransitive_stage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stage</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">IsTransitive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">limitRecOn</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"bp\">.</span><span class=\"n\">powerset</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">isLimit</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">olim</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsTransitive</span><span class=\"bp\">.</span><span class=\"n\">sUnion'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>If I see this proof, then I can immediately know that the main step is an induction, and the substeps are \"trivial\" (i.e. just <code>simp</code>).</p>\n<ol start=\"2\">\n<li>Again, it helps to clear out the obvious parts and makes the structure clearer.</li>\n<li>So, in short, constructivism is classical logic but without the law of excluded middle (<code>P or not P</code>) and without double negation elimination (<code>(not not P) implies P</code>), and is actually the core of Lean's logic (i.e. using type theory with inductive types).</li>\n</ol>\n<p>The story of type theory representing proofs is that we use inductive types and somehow everything works out to be constructivist logic. Recall the very famous example <code>Nat</code> where we have the principle of induction (which is why they're called <strong>inductive</strong> types):</p>\n<p>We have these two axiomatic constructors of <code>Nat</code> (i.e. \"how to build a natural number\"):</p>\n<ol>\n<li><code>zero : Nat</code></li>\n<li><code>succ : Nat -&gt; Nat</code><br>\nWhen I say \"axiomatic\", I mean that these are basically declared without any proof, as in, I just declare that there is a way to construct the natural number called \"zero\", and then given a natural number, I declare that you can just form its successor called \"succ\".</li>\n</ol>\n<p>And then implicitly we have a \"smallness\" constraint, i.e. saying that \"every natural number is formed only using those constructors\". How do we say this? One way to translate it is to say:</p>\n<blockquote>\n<p>If any set S of natural numbers contains 0, and satisfies the extra requirement that \"whenever n is in S, n+1 is also in S\", then S has to contain all the natural numbers.</p>\n</blockquote>\n<p>So now in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But also recall that in Mathlib, <code>Set nat</code> just means <code>nat -&gt; Prop</code>, and then when you do that step, you've basically recovered Lean's <code>Nat.rec</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>So, in summary, an inductive type has axiomatic constructors, and then a \"recursion principle\" that has <strong>one argument per constructor</strong>.</p>\n<p>Now here are the objects you'll see in Prop and their induction principles:</p>\n<ul>\n<li>True:<ul>\n<li>One constructor <code>intro : True</code></li>\n<li>You basically don't need induction.</li>\n</ul>\n</li>\n<li>False:<ul>\n<li>No constructor (you can't make False)</li>\n<li><code>False.rec.{u} : (motive : False → Sort u) → (t : False) → motive t</code> (no constructors, so no additional arguments)</li>\n</ul>\n</li>\n<li>And:<ul>\n<li>Constructor: <code>intro : p → q → p ∧ q</code></li>\n<li>Recursor: <code>rec : (p → q → r) → ((p ∧ q) → r)</code></li>\n</ul>\n</li>\n<li>Or:<ul>\n<li>Constructors: <code>left : p → p ∨ q</code>, <code>right : q → p ∨ q</code></li>\n<li>Recursor: <code>rec : (p → r) → (q → r) → (p ∨ q → r)</code></li>\n</ul>\n</li>\n</ul>\n<p>(<code>Not</code> is not an atom, <code>¬p</code> is just shorthand for <code>p → False</code>.)</p>\n<p>So from these axioms built from the theory of \"inductive types\", you'll hopefully be convinced that there's actually no way to prove <code>p or not p</code> or <code>(not not p) -&gt; p</code>. Basically, why it's called constructivism is because to prove <code>p or q</code>, you essentially have to either supply a proof of <code>p</code> or a proof of <code>q</code>, so you have to construct something, rather than doing a proof by contradiction.</p>\n<p>So the way to get around this is that you have an axiom <code>Classical.em : p or not p</code> (it is not an actual axiom but it follows from another axiom, this is just a technicality), from which you can also deduce <code>(not not p) -&gt; p</code>, which let me stress again, you're free to use this as many times as you want in Mathlib.</p>\n<p>But the point I'm trying to make here is that Lean is more \"inherently\" constructivist, so it's easier to use a statement that looks like <code>p → q</code> than a statement that looks like <code>¬q → ¬p</code>, which I call \"you added extra negations for no reason\"; and it's easier to use a statement that looks like \"induction\" (which should have no \"not\"s anywhere) rather than a statement that \"eliminates possibilities\".</p>\n<p>So, the example is ZFSet's induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Induction on the `∈` relation. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>You can see how \"neat\" this is because it does not have any unnecessary negations.</p>\n<p>The mathematician's formulation of this might instead look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">Mathematician's_induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hyx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hyx</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>(which you can check that it fails to compile! because Lean really doesn't see this as a sort of induction!)</p>\n<p>So, in summary, when we state \"induction principles\", we prefer a formulation without negations that builds \"from the ground up\", rather than a formulation with negations that \"negates possibilities from top to bottom\", and that's the core idea of constructivism. (again lemme stress that Classical is not forbidden in Mathlib at all)</p>",
        "id": 526358889,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751276065
    },
    {
        "content": "<blockquote>\n<p>is it preferred to use simp for as much as possible? if so, why? that seems to obfuscate the proof.</p>\n</blockquote>\n<p>If you're reading that file, you can always use <code>simp?</code> to find out which lemmas were used.</p>\n<p>In practice, I find that many <code>simp</code> steps would translate to \"we simplify the term in a standard way\" on paper.  This is not where a \"new mathematical idea\" is hiding --- and if you want to see more detail, <code>simp?</code> already helps.<br>\nThis is my personal opinion, yours may be different!</p>",
        "id": 526360451,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1751276632
    },
    {
        "content": "<p>I agree with the given translation here.</p>",
        "id": 526361935,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751277099
    },
    {
        "content": "<p>Note that there's already <a href=\"https://github.com/leanprover-community/mathlib4/pull/17027\">#17027</a>; it helps to <a href=\"https://github.com/search?q=repo%3Aleanprover-community%2Fmathlib4+von+neumann&amp;type=pullrequests\">search</a> for open pull requests<br>\n(I'd like to cc <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> but she's not subscribed to this channel)</p>",
        "id": 526387367,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1751285792
    },
    {
        "content": "<p>I don't know what to say.</p>",
        "id": 526387828,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751285947
    },
    {
        "content": "<p>I think the membership theorems there would be a good addition to this PR:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vonNeumann_mem_of_lt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mem_vonNeumann</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">rank</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">o</span>\n</code></pre></div>\n<p>as well as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">iUnion_vonNeumann</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n</code></pre></div>\n<p>In addition, I think naming it <code>vonNeumann</code> with the notation <code>V_</code> is also a good idea.</p>",
        "id": 526388162,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751286048
    },
    {
        "content": "<p><code>vonNeumann</code> is a better name than <code>stage</code>, and <code>V_</code> avoids the complaint that the name is too long to type.</p>",
        "id": 526388221,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751286063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"933047\">@Knala Solomon</span> would you like to add these to your PR?</p>",
        "id": 526388299,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751286086
    },
    {
        "content": "<p>Also these two:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vonNeumann_mem_vonNeumann_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vonNeumann_subset_vonNeumann_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">V_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 526388456,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751286142
    },
    {
        "content": "<p>I've request a review from Violeta on GitHub, and hopefully you can then coordinate to decide what to keep from each PR :)</p>",
        "id": 526388593,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1751286180
    },
    {
        "content": "<p>I propose we move to a new thread.</p>",
        "id": 526389199,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751286374
    }
]