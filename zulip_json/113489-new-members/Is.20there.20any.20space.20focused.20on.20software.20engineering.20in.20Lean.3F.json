[
    {
        "content": "<p>I'm interested in Lean exclusively as a programming language, because of it's metaprogramming capabilities.<br>\nI have no interest in theorem proving of any sort, not even proving properties of my programs.</p>\n<p>Due to my goals I perceive some <em>cultural</em> friction when interacting with Lean users. Everyone has always been extra welcoming and nice, but there's a big gap which affects every conversation I have: we talk about the same things using a different language (which makes mutual understanding harder), we find that the interesting or difficult bits are different, we have different preferences and styles, we value different things, about code written in Lean.</p>\n<p>I've noticed a similar <em>cultural</em> barrier with other functional programming languages as well. As a native speaker of C++ it's hard to communicate with most Haskellers, for instance.<br>\nBut with Lean this feels much stronger. I haven't met any other Leaner yet who has a complete lack of interest in proofs. Even in this Zulip, the \"metaprogramming\" channel is mixed in with \"tactics\". Even the Leaners who describe themselves primarily as programmers, seem to be mainly interested in theoretical computer science, which lives on the ridge between math and software engineering IMO.</p>\n<p>Is there any space, group, community or channel focused mainly on using Lean for software engineering, while ignoring the proof-related capabilities of Lean?</p>",
        "id": 491937466,
        "sender_full_name": "Blue",
        "timestamp": 1736054920
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"816713\">@Blue</span>, I'm fairly new and not the right one to speak for the community's needs, but since I'm also closer to the software engineering side I figured I'd chime to show there is some interest.</p>\n<p>I've been in the industry 17 years and have been learning Formal Methods for the last year. Admittedly what draws me to Lean is the verification capabilities, that's the only reason I could picture trying to understand a language with dependent types tbh - but maybe that will be more normal someday. Still, I use Lean to model the design of real production code and I'd love to use it as an implementation language at some point too.</p>\n<p>You're probably aware that one of the main Lean books is programming-focused: <a href=\"https://leanprover.github.io/functional_programming_in_lean/\">Functional Programming in Lean</a>. It's a good start, better than exists for most other provers. Aside from having very sophisticated meta programming as you mention, another benefit that doesn't require proofs is that even encoding something in a \"provable\" language tends to make it somewhat rigorous. Exhaustive pattern matching and various other features make it more natural to avoid bugs by default. (Most ML-family would have these benefits, like Haskell, Gleam, OCaml, Elm).</p>\n<p>If someday it becomes normalized to code in a proof-aware language, then that would make the job of verification <strong>so much easier</strong>. So you're on the frontier but I think there's promise.</p>",
        "id": 491954939,
        "sender_full_name": "Ray Myers",
        "timestamp": 1736072039
    },
    {
        "content": "<p>Users who aren't interested at all in verification are of course very welcome! There isn't currently a channel \"Programming in Lean\", but it seems pretty reasonable that we should create one.</p>\n<p>It would be unreasonable to forbid discussion of verification or proofs there (e.g. sometimes even \"pure programming\" applications care about a proof for performance sake, e.g. to avoid runtime array bounds checks!) but it might still help achieve what you are looking for.</p>",
        "id": 491999930,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1736112468
    },
    {
        "content": "<p>I think a \"Programming in Lean\" channel would be nice!</p>",
        "id": 492000129,
        "sender_full_name": "nrs",
        "timestamp": 1736112613
    }
]