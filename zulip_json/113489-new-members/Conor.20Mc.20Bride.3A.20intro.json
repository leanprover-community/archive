[
    {
        "content": "<p>Is this where new people say hello?</p>",
        "id": 504319511,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741469394
    },
    {
        "content": "<p>Yes.</p>",
        "id": 504320747,
        "sender_full_name": "suhr",
        "timestamp": 1741470310
    },
    {
        "content": "<p>By the way (pardon my blunt question), what brings a famous Agda enjoyer here?</p>",
        "id": 504321641,
        "sender_full_name": "suhr",
        "timestamp": 1741471023
    },
    {
        "content": "<p>Yeah this is the right place</p>",
        "id": 504333320,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1741480836
    },
    {
        "content": "<p>Curiosity, mostly. I see pros and cons in all sorts of systems, and am always looking for new directions.</p>",
        "id": 504384696,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741520715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"217807\">@Freek Wiedijk</span>  once emphasized to me how much he sees the cons in all the available proof assistants. He'd love to use one but basically I got the impression that he hated all of them (but for each one he had a bespoke specific reason for hating it, it wasn't just annoyance with the area in general, it seemed to be that each one was problematic for him in a different way)</p>",
        "id": 504388992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741523402
    },
    {
        "content": "<p>Sounds about right. Of course one should retain the capacity for (and habit of) critical thinking, even if one's engagement verges on enthusiasm. I am always on the lookout for obstructions to articulacy which prevent the merely systematic from becoming a system. Most proof assistants have plenty.</p>",
        "id": 504390253,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741524369
    },
    {
        "content": "<p>(Hi Conor!) \"How much he sees the cons\" sounds too strong, but yes, I'm a difficult person. I would like to \"commit\" to one system (like Kevin has to Lean 4, and I expect Conor has to Agda?), but I haven't been able to thus far. Which I hate, I like to have a vehicle for formal proof that makes me happy and that I know well. As Kevin also mentions, I love formalizing in any system, despites the various little irritations.</p>\n<p>So let me try to analyse why I haven't been jumping on the Lean bandwagon yet, despite a strong feeling that it is the right thing for me to do. For one thing, installing it has been a turn off... but with some help I think I'm past that now, despite the fact that I still feel it's an impolite system, putting junk in all kinds of places.</p>\n<p>But my two real issues are that I haven't bought into the way typeclasses are organised in mathlib. I have been watching <span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> work on something, and then there were two questions for which I don't see the \"right\" approach yet. One was whether some number that occurred in the proof should be in <code>nat</code> or in <code>int</code> (excuse me, I guess those actually were some unicode blackboard-bold symbols instead of these identifiers). I <em>hate</em> having to decide between that, it seems like it should be a non-issue to me. And the other was the way in which elements of the ring of integers of a number field related to the elements of the field itself. There were silly up-arrows in the terms. Again, I hate that kind of thing. (Really, I think these were the same issues.)</p>\n<p>The other issue is that I don't know whether there is anything like \"meson\" or \"metis\" in Lean to not have to think about simple first order proofs, and also whether there is a \"hammer\" on top of this like in Isabelle. I can imagine that there is co-pilot that provides something like that, but having Sledgehammer is <em>so</em> nice in Isabelle...</p>\n<p>And finally, not a real issue, but a matter of taste: in Isabelle/Isar one has \"structured proofs\", which I like better than tactic proofs. In Lean one <em>can</em> have those too, but I don't think it is used much, and I wonder why.</p>",
        "id": 504400176,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741531586
    },
    {
        "content": "<p>I'm not at all committed to Agda, although it has been my workhorse of late. I use my own rather sketchy proof assistant, <code>ask</code>, with my first years, and we use Agda with the fourth years, but me and my gang are always experimenting with prototypes which push beyond what the \"production\" systems currently support. My role is thinking about technologies, rather than whole systems, and trying to be a persuader for progress in the systems people already use. I suspect I have had some influence on Lean already.</p>",
        "id": 504400685,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741531951
    },
    {
        "content": "<p>I wish I could be like that. But I'm always a spectator/critic on the side lines, as <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> observed. I hate that, but it's difficult to be different. For a while I really was into Mizar, but that has faded...</p>",
        "id": 504400778,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741532042
    },
    {
        "content": "<p>I really like Mizar's declarative take on proof. I kind of headed that way with <code>ask</code>, which has quite different presentations for things you <code>prove</code> and things you <code>define</code>. My major criticism of proof assistants based on dependent type theory is that in fifty years, we have (with a few honourable exceptions, none of which have cut through) thought no harder about normalisation of open terms than how to get stuck when a free variable gums up the machinery. We have been turning up to an algebra fight armed only with arithmetic.</p>",
        "id": 504401494,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741532534
    },
    {
        "content": "<p>But is normalisation for proof terms important too? My take on that is that proof terms are really like machine code for programming, it should be invisible/irrelevant to the user. And I <em>love</em> the fact that in Lean proof irrelevance is hard-wired in. When playing with Lean that felt <em>so</em> liberating! I still had the hidden worry about difference between proof terms causing trouble, and letting go of that worry was heaven.</p>",
        "id": 504401608,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741532630
    },
    {
        "content": "<p>Normalisation for <em>proofs</em> of mere propositions is not remotely important, except as one means to argue consistency. Definitional proof irrelevance is a delight when it's available. One should be mindful of when it's not, but one should not give it up lightly when it is.</p>",
        "id": 504401912,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741532859
    },
    {
        "content": "<p>Of course in Lean it causes trouble with subject reduction/normalisation/transitivity of definitional equality. But for me those are <em>not</em> the kind of \"cons in proof assistants\" that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> was talking about. As long as the system is consistent and I can nicely express my proofs, I'm happy.</p>",
        "id": 504402051,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741532964
    },
    {
        "content": "<blockquote>\n<p>And finally, not a real issue, but a matter of taste: in Isabelle/Isar one has \"structured proofs\", which I like better than tactic proofs. In Lean one <em>can</em> have those too, but I don't think it is used much, and I wonder why.</p>\n</blockquote>\n<p>By the way, this is a strong reason to prefer Lean over Coq.</p>\n<blockquote>\n<p>But is normalisation for proof terms important too?</p>\n</blockquote>\n<p>A <em>guided</em> reduction of proofs would be very welcome. I even made a topic askin for it: <a href=\"#narrow/channel/270676-lean4/topic/Controlled.20reduction.20of.20proofs\">https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/Controlled.20reduction.20of.20proofs</a></p>",
        "id": 504402137,
        "sender_full_name": "suhr",
        "timestamp": 1741533011
    },
    {
        "content": "<p>Using a proof assistant without guided reduction is like having a symbolic simplifier but not being able to use it.</p>",
        "id": 504402419,
        "sender_full_name": "suhr",
        "timestamp": 1741533216
    },
    {
        "content": "<p>Regarding structured proofs: my <em>impression</em> is that this might be part of some kind of culture clash here. Lean's maths library <code>mathlib</code> is full of tens of thousands of proofs and the vast majority are completely mathematically trivial; in particular the details of how they are proved are of absolutely no interest to me, they are just there because the mathlib community has understood that making a really solid and general API has lots of great advantages. And sometimes I speak to computer scientists and they start going on about forward proofs and backward proofs and structured proofs and proofs with lots of <code>have</code> statements in and readability etc etc and ask for my opinions, and my honest answer is that I have no opinions and I find the entire question completely boring and irrelevant because who cares in practice about the details of how the proof is implemented? The details have nothing to teach anybody. They are forgotten by the system after the proof is processed, the mathematical content is almost certainly at a trivial level (this is becoming less true but it's still true that the vast majority of statements in mathlib are statements which are completely standard and well-known to mathematicians). I am still quite bewildered by why it even matters what proofs look like. If you want to see a readable proof or a proof in your favourite style then just go and read a regular book. Right now the problem is that mathlib is still proving theorems which were known 100 years ago or which are completely trivial. The objective is to get the job done.</p>",
        "id": 504402695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741533388
    },
    {
        "content": "<p>Are these standard proofs obvious to undergraduates too? Could they easily reproduce one themself?</p>",
        "id": 504402873,
        "sender_full_name": "suhr",
        "timestamp": 1741533538
    },
    {
        "content": "<p>This maybe is also an artifact of the lack of meson/metis/sledgehammer I was complaining about. The idea is that you only want to write the steps as they are meaningful to you, and let the \"trivial level\" be handled by the automation. But you are right, that currently the proof scripts are \"proof irrelevant\" on a human level too.</p>\n<p>Still, as a user, with declarative/structured proof I feel more in control. At least, that's how it was when I switched from Coq to Mizar twenty-five years ago. Instead of searching for the appropriate tactic, it's searching for the appropriate statement that corresponds to the next step in the proof.</p>\n<p>It would be very interesting to confront how you feel about this with what Larry Paulson has to say about this. Maybe if the \"99 theorems\" workshop ever happens, we can have a panel discussion about this? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>\n<p>It's a bit like saying that in computer programming, once you have implemented something, what the code looks like doesn't matter anymore. I'm sure not all programmers will agree to that!</p>",
        "id": 504402881,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741533544
    },
    {
        "content": "<p>I find \"guided reduction\" a contradiction in terms. I want a clear distinction between what machines can do for humans and what humans must do for themselves, together with the means for humans to explain how whole classes of task can be mechanized. I want computers to compute! In every (highly non-vacuous) system I've ever implemented with definitional proof irrelevance, I've ensured that proof reduction is entirely unnecessary (at least for proof checking).</p>",
        "id": 504403055,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741533674
    },
    {
        "content": "<p>I don't want to expand definitions manually and would like to ask a computer to do it and see the result.</p>",
        "id": 504403287,
        "sender_full_name": "suhr",
        "timestamp": 1741533874
    },
    {
        "content": "<p>In the fundamental \"is peg same shape as hole?\" problem, I would like computers to compute without me having to ask them. Some things should just work, without being kicked. Addition is associative.</p>",
        "id": 504403538,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741534060
    },
    {
        "content": "<p>I think my (too strong) sense of aesthetics gets into the way of buying into <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s \"just get things done\" attitude. Yes, that's how you get somewhere. But I don't want to get somewhere, I just want to be in a place that I <em>like</em>. So, my complaint about having to choose between <code>nat</code> and <code>int</code> (sorry, I still don't know how to type unicode here <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span>) is of the same nature, I'm sure.</p>\n<p>It's like the discussion about whether zero is a natural number or not. One attitude about that is \"who cares?\" With Humpty Dumpty, you can define natural numbers any way you like. But I feel strongly that having zero be a natural number is the \"right\" thing to have.</p>",
        "id": 504404485,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741534648
    },
    {
        "content": "<p>Working, as I do, on the thirteenth (numbered from one) floor of a Glasgow office block, I have been known to point out the window and shout \"COUNT THE FISH!\".</p>",
        "id": 504404714,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741534815
    },
    {
        "content": "<p>In the C committee mailing list there recently has been a huge discussion about whether <code>a[17]</code> should be called the 17th or the 18th element of the array <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>\n<p>(I forgot the actual number, if you look up the mail discussion, replace 17 by what was talked about if you like.)</p>",
        "id": 504404804,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741534883
    },
    {
        "content": "<p>17 will do just fine. I was only saying to my students, the other day, \"Mathematicians, especially those of us who work with computers, count like ZERO, ONE, TWO, WHY AM I DOING THIS?\"</p>",
        "id": 504404998,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741535012
    },
    {
        "content": "<p>Oh my god, I'm jealous! I would <em>love</em> to be on a thirteenth floor! (Malkovich, Malkovich <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span>)</p>",
        "id": 504405105,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741535082
    },
    {
        "content": "<p>\"count the fish\"???</p>",
        "id": 504405191,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741535154
    },
    {
        "content": "<p>Thm 4.2.7: The number of polar bears at an italian funeral is always even <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 504405258,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741535184
    },
    {
        "content": "<p><span aria-label=\"huh\" class=\"emoji emoji-1f90c\" role=\"img\" title=\"huh\">:huh:</span> &lt;- for some reason, the emoji \"huh\"</p>",
        "id": 504405292,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741535210
    },
    {
        "content": "<p>It was the twelfth floor when I started, but we were expensively renumbered. Around about the same time, Health Scotland started a campaign to persuade people to take the stairs instead of the lift, with signs that said \"If you walk to here every day instead of taking the lift you'll have climbed N munros.\" (A munro is a hill in Scotland at least 3000 feet high.) Quite apart from it being pedantically a blatant untruth, because the whole point of munros is that the feet are connected spatially and in vertical sequence, the signs had very big digital representations of N and were intended as floor indicators. Thus, for us, the N=1 sign was placed on the <em>ground</em> floor, recently renumbered 1. I remember thinking \"This is exactly the sort of off-by-one error which was bound to happen.\" as I unilaterally moved all the posters up one floor, thus attracting some frankly innumerate graffiti to which I was politely but lethally scathing in return.</p>",
        "id": 504405959,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741535755
    },
    {
        "content": "<p>0: Naming things<br>\n1: Cache invalidation<br>\n2: Off-by-one errors</p>\n<p>(Sorry, for the silly jokes, please ignore.)</p>",
        "id": 504406641,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741536169
    },
    {
        "content": "<p>Quite the reverse. And from the same people who brought you...</p>\n<p>There are three things which go wrong in a packet-switching network:<br>\n\\3. Packets arriving in the wrong order.<br>\n\\2. Packets being duplicated.<br>\n\\2. Packets being duplicated.</p>",
        "id": 504407427,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741536683
    },
    {
        "content": "<p>I just reread <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s original comment that drew me in to this discussion: it's not just that I <em>would</em> love to use a proof assistant, I actually <em>do</em> love to use each and every proof assistant. Formalising is one the best things in life, even with all the \"ifs\" and \"buts\".</p>",
        "id": 504407873,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741536967
    },
    {
        "content": "<p>Right! And when we're grumpy, it's with the motivation of making good things better.</p>",
        "id": 504408073,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741537149
    },
    {
        "content": "<p>I don't know what a structured proof is, so maybe that's why I don't miss it :)</p>",
        "id": 504412161,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741540315
    },
    {
        "content": "<p>I do think we could put more effort in making proofs easier to follow, but somehow mathlib hasn't made that a priority</p>",
        "id": 504412918,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741540911
    },
    {
        "content": "<p>Mathlib proofs are semi-structured (there's <code>have</code>, <code>suffices</code>, blocks and even some type annotations), so you indeed don't miss it. It could be better (see Isabelle/HOL) but also could be much worse (see Coq).</p>",
        "id": 504412931,
        "sender_full_name": "suhr",
        "timestamp": 1741540921
    },
    {
        "content": "<p>A comparison of styles:</p>\n<ul>\n<li>Isabelle/HOL proof style: <a href=\"https://www.isa-afp.org/sessions/padic_ints/#Padic_Integers\">https://www.isa-afp.org/sessions/padic_ints/#Padic_Integers</a></li>\n<li>Mathlib proof style: <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Multiplicity.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/NumberTheory/Multiplicity.lean</a></li>\n<li>Coq proof style (without SSReflect): <a href=\"https://github.com/thery/coqprime/blob/master/src/Coqprime/PrimalityTest/Lagrange.v\">https://github.com/thery/coqprime/blob/master/src/Coqprime/PrimalityTest/Lagrange.v</a></li>\n</ul>",
        "id": 504413827,
        "sender_full_name": "suhr",
        "timestamp": 1741541595
    },
    {
        "content": "<p>Coq with SSReflect allows to achieve the state of the art of proof unreadability. Which is impressive, since Coq proofs are already unreadable.</p>",
        "id": 504414203,
        "sender_full_name": "suhr",
        "timestamp": 1741541919
    },
    {
        "content": "<p>which is ironic, given Microsoft's key role in the obscurity of SSReflect. Sometimes ghastly hacks are the best you can do because you're not allowed to improve the machinery.</p>",
        "id": 504414528,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741542156
    },
    {
        "content": "<blockquote>\n<p>It's a bit like saying that in computer programming, once you have implemented something, what the code looks like doesn't matter anymore. I'm sure not all programmers will agree to that!</p>\n</blockquote>\n<p>But I don't think that it is like that. This is a proof, not a program. People who think these are the same thing have been brainwashed. Proofs are run once and then literally forgotten, they are erased at runtime (disclaimer: I have no idea what that phrase means or what runtime is, I just heard someone else say it and I learnt it by heart). The way mathematics works is that you can use other people's theorems and you don't need to care about how the proofs worked or even whether they were 10 lines or 10000 lines; such issues have literally 0 effect on your work. This is very different to using someone else's function, where you might care a lot about what happens if e.g. you input a 10000-digit number.</p>",
        "id": 504415405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741542807
    },
    {
        "content": "<p>In other words, everything that is already proven is trivial. Yet for some reason textbooks contain proofs of already known things.</p>",
        "id": 504415654,
        "sender_full_name": "suhr",
        "timestamp": 1741542975
    },
    {
        "content": "<p>Mm, I think there's ideas of \"clean\" or \"well-structured\" programs that go further than the kind of concerns you're referring to here, Kevin</p>",
        "id": 504415688,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741542997
    },
    {
        "content": "<p>The question is whether one wants to <em>learn</em> from the proofs (which is the role of a textbook) or just use the proofs (which is case for me when I am writing Lean code which uses other people's work). Similarly I am not expecting other people to learn anything from the Lean code I write in the FLT proof. The only thing I require from that code is that it is easy to maintain as Lean and mathlib move on. If people want to learn what I am doing in the proof of FLT I'm formalizing, they should read the <a href=\"https://imperialcollegelondon.github.io/FLT/blueprint/Adele_miniproject.html\">blueprint</a>. This is a human-readable document intended to teach the mathematical ideas which I am formalizing. The Lean code is playing an entirely different role.</p>",
        "id": 504415908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741543162
    },
    {
        "content": "<p>Computer scientists have said to me \"are you formalizing FLT because you think it's wrong?\" and my response is \"absolutely not: I'm formalizing it because I know it's right\". Mathematicians will learn nothing nontrivial from my work and I don't expect them to. All of the mathematical ideas are already in the references and are well-understood by experts. My motivation is to expand mathlib in the direction of modern number theory and thus get the library closer to modern research. The internal structure of the proofs is hence of no relevance to me.</p>",
        "id": 504416445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741543455
    },
    {
        "content": "<p>Proofs and programs may be made of the same stuff, but they are not, either culturally or psychologically, the same thing. For a start, there is the huge difference between arguing that a type is inhabited at all and selecting from amongst the variety of a type's inhabitants.</p>\n<p>I can understand the motivation to reduce the gap between the formalised canon and the canon by any means available. But it is also worth looking back at what was too much like hard work, especially for the early stuff that one imagines should be \"trivial\", in order to make the means available more effective in future.</p>\n<p>I seldom think that individuals who use the word \"trivial\" not in quotation have spent enough time thinking about what that word might mean in practice.</p>",
        "id": 504416676,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741543621
    },
    {
        "content": "<p>Lean code has two advantages over static text: it is complete (no details are missing), and navigable (you can do \"go to definition\" as far as you wish). It is not a bad source for learning if proofs are readable.</p>",
        "id": 504416690,
        "sender_full_name": "suhr",
        "timestamp": 1741543633
    },
    {
        "content": "<p>Yeah I am using trivial in the arrogant way that mathematicians use it (i.e. anything they understand is now trivial because they have now forgotten what their brain felt like when they didn't understand it).</p>",
        "id": 504416890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741543758
    },
    {
        "content": "<p>I am not convinced that the current mathlib design philosophy aligns at all with this idea that you should be able to learn why a theorem is true from its proof in mathlib. Right now the philosophy seems to be \"crush the theorem in as few characters as possible and hang readability, because this thing is going to be compiled hundreds of times per day and we want to save electricity. Just worry about maintainability.\"</p>",
        "id": 504417064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741543894
    },
    {
        "content": "<p>But since Mathlib proofs do not look like Coq proofs but look like something between Coq and Isabelle/HOL, there's some convergence between readability and maintainability. Which could be developed further.</p>",
        "id": 504417321,
        "sender_full_name": "suhr",
        "timestamp": 1741544078
    },
    {
        "content": "<p>Yes, this is the arrogant way in which mathematicians use \"trivial\". As an Irish person who interacted with that community and ran away, and as a person hugely squicked by overly masculine modes of doing business, I can only beg \"Could youse not?\".</p>",
        "id": 504417756,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741544416
    },
    {
        "content": "<p>[Conor trigger warning: arrogant usage of trivial occurs several times in this post]</p>\n<p>I think also that the policy might be in need of an overhaul. It was impressed on me in the 2010s that everything in the library was trivial and hence the proofs did not need to be readable because there was nothing to read; everything was either (a) obvious or (b) fighting with dependent type theory. But back then everything in mathlib <em>was</em> obvious: it contained no theorems which weren't in a standard undergraduate mathematics degree and most of the theorems were of an even more trivial nature (e.g. hundreds of lines of stuff like \"two subgroups which are equal as subsets are equal as subgroups\" or whatever, which would not even be stated in a mathematics course because the statement is completely vacuous mathematically; most mathematicians would have their trouble even putting their finger on what needs to be said here, because their concept of a subgroup is more fluid than formal).</p>\n<p>However things have moved on since then. For example we have got a bunch of graduate level algebraic geometry now, and some of the proofs are not at all trivial. In my <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Topology/Algebra/Module/ModuleTopology.lean\">mathlib work on topologies on modules</a> (which is original research in the sense that I don't know a reference, although it is completely trivial in another sense (i.e. I understand it and moreover any mathematician worth their salt would be able to work out the details themselves)) I have been liberally commenting the proofs so that they are human-readable, but this is really because I cannot refer the reader to a textbook and I don't want to put them through the chore of having to figure out the proofs themselves when I've already done this work for them (or, in many cases, copied the proofs from Will Sawin's answer in <a href=\"https://mathoverflow.net/a/477763/1384\">the associated mathoverflow post</a> ). But I didn't think \"how best to write this Lean code\", I just wrote the Lean code in the standard impenetrable style, and then wrote the comments afterwards to explain what was happening.</p>",
        "id": 504418121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741544715
    },
    {
        "content": "<p>Thank you for the warning. Show me the comments. Today's comments are tomorrow's programs, when I get to work.</p>",
        "id": 504418456,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741544951
    },
    {
        "content": "<p>I should warn you that the file I linked to with the comments is very much the exception rather than the rule around here, and as I say I was only motivated to do this because that file is just developing some theory for which the community could find no reference in the dead tree literature.</p>",
        "id": 504418583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741545041
    },
    {
        "content": "<p>It's a huge thing for me. What do people say to each other that they can't (yet) say to the machines? I have only to hang out to get fuel.</p>",
        "id": 504419068,
        "sender_full_name": "Conor Mc Bride",
        "timestamp": 1741545365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113489-new-members/topic/hello.3F/near/504416690\">said</a>:</p>\n<blockquote>\n<p>Lean code has two advantages over static text: it is complete (no details are missing), and navigable (you can do \"go to definition\" as far as you wish). It is not a bad source for learning if proofs are readable.</p>\n</blockquote>\n<p>I think that medium-term, an automated informaliser is a much more readable way of browsing mathlib proofs. There is a current prototype at <a href=\"https://kmill.github.io/\">https://kmill.github.io/</a> (scroll down to \"informalisation).</p>",
        "id": 504425145,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1741549471
    },
    {
        "content": "<p>I'm looking forward to that a lot, but I imagine that would benefit even more from having more structure in the proof itself (though mathlib often tends to structure proofs by splitting out lemmas)</p>",
        "id": 504426132,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741550278
    },
    {
        "content": "<p>Let me say that we do not all agree with Kevin here. For me, proof readability is important both for maintainability and adaptability: if you want to prove a new result whose proof has similarities to the proof of a result already in mathlib, there is a much higher chance you can reuse and adapt this proof if it has been written with the reader in mind, not only the machine. And having nicely written proofs is also much nicer to your reviewer!</p>",
        "id": 504426915,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1741550827
    },
    {
        "content": "<p>Hello</p>",
        "id": 504457510,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1741573398
    },
    {
        "content": "<p>Am I allowed to ask questions here?</p>",
        "id": 504457874,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1741573663
    },
    {
        "content": "<p>go ahead</p>",
        "id": 504462659,
        "sender_full_name": "Huỳnh Trần Khanh",
        "timestamp": 1741576993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"874606\">@Anh Nguyễn</span> You should start your own thread if your questions are unrelated to the conversation above</p>",
        "id": 504464593,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1741578328
    },
    {
        "content": "<p>3 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/can.20lean.20express.20any.20kind.20of.20mathematics.3F/with/504464725\">#new members &gt; can lean express any kind of mathematics?</a> by <span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span>.</p>",
        "id": 504465109,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741578705
    },
    {
        "content": "<p>I see I missed a lot of discussion. As for <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s \"once it's proved, it's done\", isn't keeping the library working when the system changes an issue here? Or when there's a lemma that can be \"improved\", shouldn't one adapt the proof to that too?</p>",
        "id": 504532405,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741602198
    },
    {
        "content": "<ol>\n<li>yes, that's an issue, though Kevin also mentioned it above (\"that it is easy to maintain as Lean and mathlib move on\"). We do have some requirements and linters on code within mathlib, at least (e.g. non-terminal uses of <code>simp</code> must use <code>simp only</code>, so newly added <code>simp</code> lemmas can't be applied unexpectedly, and when a tactic creates multiple goals, we require the use of the focusing dot to see where each subgoal should be fixed), as well as a deprecation system to help libraries downstream of mathlib. Also, in mathlib, whoever breaks a proof also has to fix it, so that helps :)</li>\n<li>\"should\" - maybe not, but certainly \"could\". That tends to be relatively low priority though, unless there's a specific reason to go back to touch an existing proof</li>\n</ol>",
        "id": 504535917,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741603055
    },
    {
        "content": "<p>So I'm not saying declarative proof is \"better\" in any sense, just that I preferred it in the past myself. De gustibus non est disputandum, I guess.</p>",
        "id": 504536399,
        "sender_full_name": "Freek Wiedijk",
        "timestamp": 1741603171
    }
]