[
    {
        "content": "<p>At the start of Ch. 5 of FPiL, there is an example that motivates Monads.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">andThen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">infixl</span><span class=\"o\">:</span><span class=\"mi\">55</span><span class=\"w\"> </span><span class=\"s2\">\" ~~&gt; \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">andThen</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">firstThirdInfix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">third</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">third</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Section 4.6 discussed automatic conversions from types to <code>Option α</code>, showing that <code>some</code> can be omitted.<br>\nIn light of that, I tried to omit <code>some</code>.  Now this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">firstThirdInfix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">third</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">third</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but this does not</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">first</span>\n</code></pre></div>\n<p>Even more confusingly, the error talks about <code>failed to synthesize\n  GetElem? (List α) Nat (Option α) ?m.1690</code> rather anything to do with the <code>Option</code> conversion.   (I understand the function is just \"identity\" and is unnecessary but I'm still puzzled by the error)</p>\n<p>What's happening here?</p>\n<p>Thanks!</p>",
        "id": 471533560,
        "sender_full_name": "Tom",
        "timestamp": 1726767004
    },
    {
        "content": "<p>Following up, thanks!</p>",
        "id": 471833033,
        "sender_full_name": "Tom",
        "timestamp": 1726866419
    },
    {
        "content": "<p>Here's a clue! Including a type annotation helps the type system figure it out .</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this also type checks</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">):(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>this does not </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">:(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>before adding type annotations, the inferred type of <code>(fun first =&gt; first)</code> was <code>Option α → Option α</code>, which, as you mentioned should be: <code>α → Option α</code>.</p>",
        "id": 471835092,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1726867331
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"317929\">@Derek Rhodes</span> </p>\n<p>Thank you for your help.  I think I understand what's happening now.</p>\n<p>Without the type annotation on the function, since the <code>fun first =&gt; first</code> is really just <code>id</code> in disguise, I assume the (bidirectional?) type-checker works from the return type of <code>Option α</code> and hence infers the type of the function as <code>Option α -&gt; Option α</code>, which is why no conversion is inserted since the types \"match\".   (I still don't fully understand why this manifests by an error in <code>GetElem?</code> though or how to interpret it)</p>\n<p>I think your first example with <code>fun (first:α) =&gt; first</code> works because the type checker figures out that the function must be <code>α -&gt; Option α</code> but the annotation would force it to be <code>α -&gt; α</code>, so the type checker/inferencer realizes it must include a conversion.</p>\n<p>I think by the same token, this is why your last example doesn't work: <code>fun first =&gt; (first:(Option α))</code>.  If <code>fun first =&gt; first</code> is <code>β -&gt; β</code>, then adding the type ascription on just the return type would cause the type to become <code>Option α -&gt; Option α</code>, which is the same result as my original broken code.</p>\n<p>Finally, I think I was able to convince myself of some of this by modifying <code>justFirst</code> to return a tuple again like the original <code>firstThirdInfix</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>In this case, the <code>fun</code> must be deduced to be something like <code>α -&gt; Nat × α</code>.  Since this doesn't match <code>Option (Nat × α)</code>, the coercion gets auto-inserted.</p>\n<p>Does this sound about right to you?</p>\n<p>Thanks!</p>",
        "id": 471967472,
        "sender_full_name": "Tom",
        "timestamp": 1726946228
    },
    {
        "content": "<p>Tom, that was my reasoning on all counts.  But then again, I'm just learning the ropes as you are.  Hopefully, if the language authorities see this post they can squash any uncertainty  <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 471969470,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1726948013
    },
    {
        "content": "<p>Yeah, the main issue is that <code>fun first =&gt; first</code> elaborates as <code>fun first : ?ty =&gt; first</code>, which has type <code>?ty -&gt; ?ty</code>. There's also a complication that <code>0</code> doesn't become a <code>Nat</code> until a later step.</p>\n<p>The order of elaboration for <code>andThen xs[0]? (fun first =&gt; first)</code> with expected type is <code>Option α</code> is:</p>\n<ul>\n<li>We first start with thinking <code>andThen</code> as being specialized to <code>andThen : Option ?a -&gt; (?a -&gt; Option ?b) -&gt; Option ?b</code> with fresh metavariables <code>?a</code> and <code>?b</code>.</li>\n<li>We are about to visit the first explicit argument, so we consider the expected type. We can unify <code>Option α</code> with <code>Option ?b</code> with solution <code>?b := α</code>.</li>\n<li>We visit <code>xs[0]?</code> with expected type <code>Option ?a</code>. The <code>xs[0]?</code> elaborates as <code>GetElem?.getElem? xs 0</code> with <code>0</code> not yet resolved, and it has type <code>Option ?a</code>. Solving for the <code>GetElem? (List α) ?_ ?a ?_</code> instance makes no progress, and it is deferred since it still has metavariables.</li>\n<li>We visit <code>fun first =&gt; first</code> with expected type <code>?a -&gt; Option α</code>. As we enter this, <code>first : ?a</code> is introduced as a new local variable. The body <code>first</code> is elaborated with expected type <code>Option α</code>. This triggers unification of <code>?a</code> with <code>Option α</code>, which can be done with <code>?a := Option α</code>.</li>\n<li>Note: at this point <code>GetElem?.getElem? xs 0</code> is expected to have type <code>Option (Option α)</code>.</li>\n<li>Eventually, default instances are considered. One of the instances resolves <code>0</code> to have type <code>Nat</code>.</li>\n<li>All that is left is solving for a <code>GetElem? (List α) Nat (Option α) ?_</code> instance. This fails (there's no instance that returns <code>Option α</code>, just one that would return <code>α</code>!).</li>\n</ul>",
        "id": 471969886,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726948418
    },
    {
        "content": "<p>This default instance business is important to this particular failure occurring. It sort of makes the second argument to <code>andThen</code> elaborate before the first argument.</p>\n<p>If you specify the type of <code>0</code> with an ascription, the problem goes away.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">justFirst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">xs</span><span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">~~&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">first</span>\n</code></pre></div>",
        "id": 471969972,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726948486
    },
    {
        "content": "<p>The <code>fun first : α =&gt; first</code> suggestion also works because it says what <code>?a</code> should be, rather than drawing the type from the expected type.</p>",
        "id": 471970023,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726948550
    },
    {
        "content": "<p>Wow, thanks for the detailed answer!  If you don't mind me asking, did you just \"trace\" this based on your understanding of the type system, or is there an option/inspection/... that produces this information?</p>",
        "id": 471970141,
        "sender_full_name": "Tom",
        "timestamp": 1726948650
    },
    {
        "content": "<p>I have a general idea for how the elaborator works from reading the code.</p>\n<p>There's a difference between the type system and elaboration by the way. Elaboration is a lot of heuristics to make it so things you write \"just work\". But clearly it's not \"just working\" here!</p>",
        "id": 471970365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726948808
    },
    {
        "content": "<p>Ah, your explanation also made me realize another mistake of mine.  When I saw the error from <code>GetElem?</code>, <code>GetElem? (List α) Nat (Option α)</code> I misread the type class and assumed that <code>(Option α)</code> was the \"return type\", when in fact it's <code>getElem? : coll → idx → **Option elem**</code>.  Hence <code>Option Option α</code>  and why the types didn't align!  It all makes sense now.</p>\n<p>Since this has come up previously, when you say \"type checker\" do you mean just the \"kernel\" (?), i.e. the minimal implementation of dependent types; and the Elaborator is effectively what converts the surface syntax to the minimal terms that the \"type checker\" can understand?  I want to make sure I use the correct terminology moving forward.  I've not had a chance to read \"Metaprogramming in Lean\" yet, still working through some of the other intro texts.</p>",
        "id": 471970980,
        "sender_full_name": "Tom",
        "timestamp": 1726949329
    },
    {
        "content": "<p>I've filed this as <a href=\"https://github.com/leanprover/lean4/pull/5414\">lean4#5414</a> by the way. I think it ought to elaborate.</p>",
        "id": 471971125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726949437
    },
    {
        "content": "<blockquote>\n<p>when you say \"type checker\"</p>\n</blockquote>\n<p>I said \"type system\" to be clear. That's the the whole system of expressions, the specification for expressions having types, the specification for what is type correct, and the specification for what's defeq to what.</p>\n<p>The elaborator takes syntax and \"compiles\" it into expressions that fill in all the details missing from the syntax. For example, filling in all the implicit arguments is the role of the elaborator.</p>\n<p>A \"type checker\" is something that takes an expression and determines whether or not it is type correct. There is a type checker in the kernel. When a new definition is added to the environment at the end of the elaboration process, the kernel checks that this new definition is type correct. The environment is a key data structure that must be well-formed for it to have any mathematical meaning. There is also a type checker in the elaborator itself, which is used at various points during elaboration.</p>",
        "id": 471971474,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726949734
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> !</p>",
        "id": 471972143,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1726950307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> has marked this topic as resolved.</p>",
        "id": 471979337,
        "sender_full_name": "Notification Bot",
        "timestamp": 1726956717
    }
]