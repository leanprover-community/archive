[
    {
        "content": "<p>I am confused about existential quantifiers and Sigma types.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Why is <code>Σ x</code> syntactically incorrect whereäs both <code>Π x</code> and <code>∀ x</code> are syntactically correct (and mean the same thing)? Isn't <code>∀</code> just a syntactic sugar for <code>Π</code> in the same way that <code>∃</code> is, at least I supposed, a syntactic sugar for <code>Σ</code> under the assumption that <code>p x : Prop</code> ?</p>",
        "id": 264328034,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639067876
    },
    {
        "content": "<p>(First, all of these are <em>syntactically</em> correct.)<br>\n<code>∀</code> and <code>Π</code> are indeed the same, but <code>∃</code> and <code>Σ</code> are completely separate: the first is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists\">docs#Exists</a> and the second is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma\">docs#sigma</a>.</p>",
        "id": 264328721,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639068146
    },
    {
        "content": "<p>Oh, sorry, I considered type mismatch to be a kind of syntactic error.</p>",
        "id": 264328868,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639068220
    },
    {
        "content": "<p>How can I find a similar documentation for Pi instead of Sigma?</p>",
        "id": 264329958,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639068632
    },
    {
        "content": "<p>Pi is a primitive. There's some info on it in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/quantifiers_and_equality.html#the-universal-quantifier\">section 4.1 of TPIL</a>.</p>",
        "id": 264330353,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639068803
    },
    {
        "content": "<p>What is the difference between Pi being primitive and Sigma not being primitive? Does Pi have a constructor (as a structure) as well?</p>",
        "id": 264331067,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069104
    },
    {
        "content": "<p>No, it doesn't have a constructor. Pi/forall is a kind of expression that the kernel handles directly because it's  'part of the system'. Sigma is an inductive type that gets declared by users.</p>",
        "id": 264332195,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639069525
    },
    {
        "content": "<p>Oh, thank you!</p>",
        "id": 264332407,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069601
    },
    {
        "content": "<p>This leaves me with the last question: Why cannot <code>∃</code> be translated to <code>Σ</code> in the similar way how <code>∀</code> is translated to <code>Π</code> (or maybe not translated to the other symbol but both being translated to the same kernel expression)?</p>",
        "id": 264332818,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069775
    },
    {
        "content": "<p><code>∀</code> only exists in the pretty printer and as notation (for <code>Π a, p a</code> when <code>p a : Prop</code>), there's no real translation happening. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma\">docs#sigma</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Exists\">docs#Exists</a> are different types.</p>",
        "id": 264332977,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069831
    },
    {
        "content": "<p>Yes, thanks, but why do they need to be different types?</p>",
        "id": 264333102,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639069876
    },
    {
        "content": "<p>Because they reside in different universes</p>",
        "id": 264333147,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069891
    },
    {
        "content": "<p>Respectively, <code>sigma p : Type (max u v)</code>, <code>psigma p : Sort (max 1 u v)</code>, <code>Exists p : Prop</code></p>",
        "id": 264333348,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639069963
    },
    {
        "content": "<p>arguably we don't need both <code>sigma</code> and <code>psigma</code>, beyond the fact that <code>Sort (max 1 u v)</code> isannoying vs <code>Type (max u v)</code></p>",
        "id": 264333494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070021
    },
    {
        "content": "<p>I can now see that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"mi\">3</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>is also correct.</p>",
        "id": 264333563,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070042
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264333147\">said</a>:</p>\n<blockquote>\n<p>Because they reside in different universes</p>\n</blockquote>\n<p>But why can <code>Π x : α</code> eat <code>p : α -&gt; Sort 0</code> which <code>Σ x : α</code> rejects?</p>",
        "id": 264334144,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070231
    },
    {
        "content": "<p><code>sigma</code> rejects that because it's defined to reject that</p>",
        "id": 264334301,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070291
    },
    {
        "content": "<p><code>psigma</code>, <code>Σ' x, p x</code> doesn't, but is more annoying to work with</p>",
        "id": 264334311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070296
    },
    {
        "content": "<p>Yes, I see, but why is <code>Π</code> ok with that?</p>",
        "id": 264334364,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070322
    },
    {
        "content": "<p>Because it's not defined like sigma?</p>",
        "id": 264334422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070345
    },
    {
        "content": "<p>The similarities end with the syntax being similar</p>",
        "id": 264334468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070364
    },
    {
        "content": "<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>",
        "id": 264334582,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070405
    },
    {
        "content": "<p>maybe this helps compare the exact differences:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"c1\">-- the most general form of pi, just so that we can #check</span>\n<span class=\"kd\">def</span> <span class=\"k\">Pi</span><span class=\"bp\">'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"k\">Pi</span><span class=\"bp\">'.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>    <span class=\"c1\">-- Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">psigma.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"c1\">-- Π {α : Sort u}, (α → Sort v) → Sort (max 1 u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">sigma.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>  <span class=\"c1\">-- Π {α : Type u}, (α → Type v) → Type (max u v)</span>\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">Exists.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>   <span class=\"c1\">-- Π {α : Sort u}, (α → Prop)   → Prop</span>\n</code></pre></div>",
        "id": 264334879,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639070531
    },
    {
        "content": "<p>Oh, it seems to be the magic inside <code>imax</code>.</p>",
        "id": 264335845,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639070939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264334582\">said</a>:</p>\n<blockquote>\n<p>Is there a fundamental reason why <code>Π</code> can be more versatile than <code>Σ</code> is?</p>\n</blockquote>\n<p>That's just how the type theory works. Inductive types have to abide by certain rules to keep things from being inconsistent.</p>",
        "id": 264335925,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639070972
    },
    {
        "content": "<p>A variation on <code>psigma</code> with the type <code>Π {α : Sort u}, (α → Sort v) → Sort (imax u v)</code> would not be desirable, because it would not have a first projection (like exists) and would also not have proof irrelevance, so it is sort of the worst of both worlds</p>",
        "id": 264336948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071362
    },
    {
        "content": "<p><code>(p)sigma</code> and <code>exists</code> have fundamentally different ways of getting information out of them: <code>sigma</code> has first and second projections, while <code>Exists</code> uses <code>Exists.rec</code> which only works for proving propositions, but on the other hand satisfies equations like <code>\\&lt;0, trivial\\&gt; = \\&lt;1, trivial\\&gt;</code> (as elements of, say, <code>\\exists n : nat, true</code>)</p>",
        "id": 264337426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071558
    },
    {
        "content": "<p><del>(I assume you meant \"like (p)sigma\" and not \"like exists\")</del> words are hard, \"would not (have X like Y)\" vs \"(would not have X) like Y\"</p>",
        "id": 264337443,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639071565
    },
    {
        "content": "<p>the parenthetical refers to the previous 6 words, not just the last 2</p>",
        "id": 264337599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639071620
    },
    {
        "content": "<p>Can you please check for me that I extracted the main informations correctly?<br>\n<a href=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/YiVyy1H7BjkVRBGb5l4_fuLL/image.png\"></a></div>",
        "id": 264338638,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639072040
    },
    {
        "content": "<p>\"they don't have a constructor; they live kind of beyond the system\" is inaccurate. <code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.const\">docs#expr.const</a> for various choices of constant</p>",
        "id": 264339261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072283
    },
    {
        "content": "<p>Maybe it would also help to get rid of the type theory language. Let's just define a \"proposition\" to be a set with at most one element. If we form the product of a bunch of propositions, the result is again a proposition. However if we form the sum of a bunch of propositions, there's no reason why the result should have at most one element. Then I can decide to either truncate it to make a proposition again, or not. That's the difference between <code>Exists</code> and <code>sigma</code>.</p>",
        "id": 264339284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639072295
    },
    {
        "content": "<p><code>α × β</code> is not shorthand syntax for <code>Σ _ : α, β</code>. The former uses <code>prod</code> and the latter uses <code>sigma</code>. (Yes, this is not consistent with the behavior for <code>→</code> / <code>∀</code>.)</p>",
        "id": 264339489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072385
    },
    {
        "content": "<p>But it could have been, right? It just would have been annoying to use had it been defined that way.</p>",
        "id": 264340357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639072710
    },
    {
        "content": "<p>Yes, you could conceivably define it that way. You would probably want more builtin sugar for it</p>",
        "id": 264340434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072748
    },
    {
        "content": "<p>I'm sure there are examples where the type inference is not as good</p>",
        "id": 264340519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639072788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261\">said</a>:</p>\n<blockquote>\n<p><code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> .</p>\n</blockquote>\n<p>I think introducing <code>meta inductive expr</code> sort of overloads the statement \"Pi has a constructor\" in a way that might not be helpful to someone learning the type theory.</p>",
        "id": 264342036,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639073363
    },
    {
        "content": "<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>",
        "id": 264343186,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639073710
    },
    {
        "content": "<p>True. But \"beyond the system\" was the main thing I wanted to address. It is more primitive than usual, but still something in the system</p>",
        "id": 264343223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639073718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264339261\">said</a>:</p>\n<blockquote>\n<p>\"they don't have a constructor; they live kind of beyond the system\" is inaccurate. <code>Pi</code> has a constructor, it is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.pi\">docs#expr.pi</a> . It is a builtin term constructor, unlike all other constructors which use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/expr.const\">docs#expr.const</a> for various choices of constant</p>\n</blockquote>\n<p>What does <code>(elaborated : bool := tt)</code> mean, please?</p>",
        "id": 264343739,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639073911
    },
    {
        "content": "<p>To simplify representation, lean uses the same inductive type for both <code>expr := expr tt</code> and <code>pexpr := expr ff</code>, but <code>pexpr</code> (pre-expression) is only used during parsing and you can ignore it for the purpose of learning the theory</p>",
        "id": 264344045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639074039
    },
    {
        "content": "<p>Thank you all for your replies! It will take me a longer while to understand it and summarize it. Until then, my study notes will contain those mistakes that were pointed out above.</p>",
        "id": 264344428,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639074210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186\">said</a>:</p>\n<blockquote>\n<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>\n</blockquote>\n<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>",
        "id": 264461198,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639149392
    },
    {
        "content": "<p>Current version of my notes contains:<br>\n<a href=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/PdBSOHHdE6O4kqq7oNyWL5fF/image.png\"></a></div>",
        "id": 264465640,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151349
    },
    {
        "content": "<p>It's hard to rell from the pixels, but you seem to be using <code>(a, b)</code> as notation for <code>sigma.mk</code>, whereas it's actually notation for <code>prod.mk</code>. Maybe those are angle brackets and the image is too small to tell though.</p>",
        "id": 264466071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639151516
    },
    {
        "content": "<p>Is <code>z = (a, b)</code> incorrect?</p>",
        "id": 264466234,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151574
    },
    {
        "content": "<p>Eh. The tuple notation in parenthesis is for <code>prod</code>, right? For <code>sigma</code>, I should have used chevrons (langle and rangle), right?</p>",
        "id": 264467091,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639151900
    },
    {
        "content": "<p>\"chevrons\" work for all inductive types with one constructor, so both prod and sigma. <code>(_, _, ...)</code> is only for <code>prod</code></p>",
        "id": 264471704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639153708
    },
    {
        "content": "<p>Can I do a product of three types without nesting them? Or is it a property of the ˙( )˙ that it gets flattened?</p>",
        "id": 264472132,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639153917
    },
    {
        "content": "<p>The chevrons associate to the right, so <code>\\&lt;_,\\&lt;_,_\\&gt;\\&gt;</code> is the same as <code>\\&lt;_,_,_\\&gt;</code>.</p>",
        "id": 264473155,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154375
    },
    {
        "content": "<p>Does the same apply for parentheses?</p>",
        "id": 264473273,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639154408
    },
    {
        "content": "<p>I would imagine so...</p>",
        "id": 264473294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154416
    },
    {
        "content": "<p>As long as you don't define your triple product at <code>(A \\x B) \\x C</code>, but rather use <code>A \\x B \\x C</code>, you should be able to write <code>(a,b,c)</code> (or with <code>\\&lt;...\\&gt;</code>)</p>",
        "id": 264473373,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639154458
    },
    {
        "content": "<p>Oh yes. And \\times associates in the same way. For example <code>int × Type × nat</code> is a short for <code>int × (Type × nat)</code>.</p>",
        "id": 264473676,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639154615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264461198\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris B</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264343186\">said</a>:</p>\n<blockquote>\n<p>E.g. TPIL introduces Pi as something that's explicitly not an inductive: <code>in Lean’s library, every concrete type other than the universes and every type constructor other than Pi is an instance of a general family of type constructions known as inductive types</code>.</p>\n</blockquote>\n<p>This sentence doesn't refer to the meaning of the word instance that is connected to typeclasses, does it?</p>\n</blockquote>\n<p>It does not.</p>",
        "id": 264477435,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1639156279
    },
    {
        "content": "<p>Did I get it right, please?<br>\n<a href=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/wC_6-9QTQ_TQGk6tjClPb3oi/image.png\"></a></div>",
        "id": 264482490,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639158574
    },
    {
        "content": "<p>The parentheses don't stand for <code>g.mk</code>, but for <code>prod.mk</code>. In your notations <code>g</code> is a term of a product type, the prefix is the name of the type, not the term</p>",
        "id": 264485709,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639159867
    },
    {
        "content": "<p>Oh, thank you!<br>\nIs it all right now?<br>\n<a href=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Aeh923TmsG0URUtp4_zcvN8N/image.png\"></a></div>",
        "id": 264486762,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160133
    },
    {
        "content": "<p>Well, conceptually at least yes, if you just want to use <code>g</code> to simplify the notation in your notes.</p>",
        "id": 264487366,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639160395
    },
    {
        "content": "<p>But keep in mind that won't work as actual Lean code. If you were to define <code>g := prod</code>, then <code>g.mk</code> still wouldn't exist, only <code>prod.mk</code></p>",
        "id": 264487542,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639160464
    },
    {
        "content": "<p>I am not sure whether I understand you. In my snippet,  I have <code>g = τ × δ</code> which is <code>g = prod τ δ</code> and not just <code>g = prod</code>.</p>",
        "id": 264488060,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160680
    },
    {
        "content": "<p>Does <code>g.mk</code> exists then? Or how can I write a term of the type <code>g</code> without the syntactic sugar?</p>",
        "id": 264488210,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160739
    },
    {
        "content": "<p>No, only <code>prod.mk</code> exists. You'd write <code>prod.mk bar baz</code></p>",
        "id": 264488353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639160798
    },
    {
        "content": "<p>:-o</p>",
        "id": 264488441,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160835
    },
    {
        "content": "<p>Does <code>h.mk</code> exist?</p>",
        "id": 264488515,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639160871
    },
    {
        "content": "<p>Also note that there is only one <code>prod.mk</code> for all <code>\\tau</code> and <code>\\delta</code>, it's not that for each two types you get some other <code>(prod \\tau \\delta).mk</code> (that's what your notation would suggest to me)</p>",
        "id": 264488618,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639160905
    },
    {
        "content": "<p>No, for Sigma it's the same thing, and probably for any such type definition</p>",
        "id": 264488759,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639160977
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329243\">Horatiu Cheval</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264488759\">said</a>:</p>\n<blockquote>\n<p>No, for Sigma it's the same thing, and probably for any such type definition</p>\n</blockquote>\n<p>Are you replying to <code>h.mk</code> here?</p>",
        "id": 264488983,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161068
    },
    {
        "content": "<p>Yes</p>",
        "id": 264489224,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639161174
    },
    {
        "content": "<p>Ah. Thanks a lot!</p>",
        "id": 264489257,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161191
    },
    {
        "content": "<p>When I write <code>prod.mk</code> it works but when I write <code>Σ.mk</code> it doesn't work. How can I invoke the constructor explicitly (without chevrons)?</p>",
        "id": 264490755,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639161878
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/sigma.mk\">docs#sigma.mk</a></p>",
        "id": 264490800,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639161899
    },
    {
        "content": "<p>I wrote:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">constant</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"kd\">constant</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"k\">#check</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The output is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span>\n<span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>By looking at it, I don't know what the relationship between them is. So I added:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mytype</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">sigma.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Unfortunately, the output is again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>How can I obtain <code>(sigma.mk a b) : mytype</code> please?</p>",
        "id": 264492598,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639162709
    },
    {
        "content": "<p>Does <code>#check (sigma.mk a b : mytype)</code> work? In any case, the thing is that you have to explicitly type-annotate it</p>",
        "id": 264493073,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639162894
    },
    {
        "content": "<p>By <code>#check (sigma.mk a b : mytype)</code> I obtain <code>⟨a, b⟩ : Σ (x : α), β x</code> which makes me more happy than the previous thing.</p>",
        "id": 264493287,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639162977
    },
    {
        "content": "<p>What would happen if, for concrete types, I would end up with <code>β a</code> being <code>int</code> for example? Would it still know that a term constructed by <code>sigma.mk a 5</code> is of the type <code>mytype</code>?</p>",
        "id": 264494099,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639163359
    },
    {
        "content": "<p>The way it's written here no, I don't think you will be able to do <code>def x : mtytype := sigma.mk a 5</code>, because <code>mytype</code> is just <code>Type</code>, it's not parametrized. In your definition <code>\\alpha</code> and <code>\\beta</code> are fixed constants, so they argument for the type <code>mytype</code></p>",
        "id": 264494496,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639163536
    },
    {
        "content": "<p>You would be able to do that if used <code>variable</code> instead of <code>constant</code> for example</p>",
        "id": 264494531,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639163565
    },
    {
        "content": "<p>Is it now correct?<br>\n<a href=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/6xvEjccEtaL16m3zADV3SzHV/image.png\"></a></div>",
        "id": 264495087,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639163841
    },
    {
        "content": "<p>I originally (wrongly) assumed that I could use <code>mytype.mk</code> and I would get (when provided correct arguments) a term of the type <code>mytype</code>. Now I can see that I cannot do it.</p>\n<p>As a result, it makes me uncomfortable that I must write e.g. <code>sigma.mk 5 9</code> but there are many possible sigma types which my term could be an instance of.</p>",
        "id": 264495648,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164090
    },
    {
        "content": "<p>It seems correct</p>",
        "id": 264495849,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164191
    },
    {
        "content": "<p>But I don't really understand your last statement</p>",
        "id": 264495868,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164206
    },
    {
        "content": "<p>The reason is that there are many possibly functions  that send <code>5</code> to <code>nat</code></p>",
        "id": 264495993,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164266
    },
    {
        "content": "<p>Let's say I have <code>f : int -&gt; Type</code> and <code>g : int -&gt; Type</code>. Let's say they agree on the value of <code>f 5 = nat = g 5</code>. Now I call <code>sigma.mk 5 9</code>. Do I have an instance of <code>sigma f</code> or of <code>signa g</code>?</p>",
        "id": 264496203,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164369
    },
    {
        "content": "<p>Does that even typecheck? It shouldn't</p>",
        "id": 264496231,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164387
    },
    {
        "content": "<p>I'm talking about <code>sigma.mk 5 9</code></p>",
        "id": 264496243,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164394
    },
    {
        "content": "<p>Because <code>9</code> is not a function</p>",
        "id": 264496254,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164404
    },
    {
        "content": "<p>Why should I put function on the position of <code>9</code> in my expression? I have <code>f 5 = nat</code> and not something like <code>f 5 = (nat -&gt; nat)</code>.</p>",
        "id": 264496374,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164477
    },
    {
        "content": "<p>In general you need to use type annotations to tell lean what the type family is when defining a term of a sigma type.</p>",
        "id": 264496462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164510
    },
    {
        "content": "<p>Should I write something like <code>let myvalue := (sigma.mk 5 9 : mytype)</code> ?</p>",
        "id": 264496559,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164570
    },
    {
        "content": "<p>Oh right, sorry. I thought you meant <code>sigma 5 9</code></p>",
        "id": 264496567,
        "sender_full_name": "Horațiu Cheval",
        "timestamp": 1639164573
    },
    {
        "content": "<p>What's <code>mytype</code>?</p>",
        "id": 264496601,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264496601\">said</a>:</p>\n<blockquote>\n<p>What's <code>mytype</code>?</p>\n</blockquote>\n<p>Say <code>Σ x : int, f x</code>.</p>",
        "id": 264496840,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639164685
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">does_not_typecheck</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 264496857,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164694
    },
    {
        "content": "<p>I would write <code>let myvalue : mytype := ...</code></p>",
        "id": 264496982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164746
    },
    {
        "content": "<p>If you want to define something inline, then you can do <code>(... : mytype)</code></p>",
        "id": 264497012,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639164768
    },
    {
        "content": "<p>Maybe a better example: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ℤ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">sigma</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">also_does_not_typecheck</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 264497469,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165016
    },
    {
        "content": "<p>Thank you! Your last example explains a lot!</p>",
        "id": 264497550,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165055
    },
    {
        "content": "<p>I still wasn't technically correct, was I?<br>\n<a href=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\">image.png</a> <br>\nHere <code>(prod.mk bar baz)</code> automatically becomes a term of the type <code>τ × δ</code> hence it can be used as an argument of the type <code>g</code>. This isn't true for <code>(sigma.mk bar baz)</code> because I would have to explicitly say that I want a term of the type <code>h</code> (or something definitionally equal to <code>h</code>).</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/brenY4pdggN3GD1MAgd23HMc/image.png\"></a></div>",
        "id": 264499061,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165868
    },
    {
        "content": "<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\\&lt;a,b\\&gt;</code>.</p>",
        "id": 264499195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165933
    },
    {
        "content": "<p>But it will be inferred for <code>(a,b)</code>, right?</p>",
        "id": 264499268,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639165971
    },
    {
        "content": "<p>Even if you write <code>sigma.mk a b</code>, there will be a metavariable because lean wouldn't know what the type family is without further hints</p>",
        "id": 264499274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639165974
    },
    {
        "content": "<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>",
        "id": 264499327,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639166000
    },
    {
        "content": "<p>For <code>prod.mk a b</code> I will automatically get inferred the right type.</p>",
        "id": 264499363,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166018
    },
    {
        "content": "<p>Try this out in a vscode and see what happens:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:=</span> <span class=\"n\">sigma.mk</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 264499870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639166269
    },
    {
        "content": "<p>Only the first one passes the typecheck!</p>",
        "id": 264500079,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264340519\">said</a>:</p>\n<blockquote>\n<p>I'm sure there are examples where the type inference is not as good</p>\n</blockquote>\n<p>Is [the thing we discussed today (above)] an example of what you were talking about?</p>",
        "id": 264500808,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499195\">said</a>:</p>\n<blockquote>\n<p>The type will generally not be inferred from context if you only write <code>sigma.mk a b</code> or <code>\\&lt;a,b\\&gt;</code>.</p>\n</blockquote>\n<p>highlight 1</p>",
        "id": 264500948,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166783
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 264500958,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264499327\">said</a>:</p>\n<blockquote>\n<p>For <code>(a,b)</code> you will get a term of the product, and since lean knows the type of <code>a</code> and <code>b</code>, the type of <code>(a,b)</code> is inferred correctly.</p>\n</blockquote>\n<p>highlight 2</p>",
        "id": 264501026,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> To save you some scrolling and reading, just have a look at the two comments (highlight 1 &amp; 2) above. Is it the motivation you were talking about — sigma could be used for prod but the type inference would be worse.</p>",
        "id": 264501243,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639166950
    },
    {
        "content": "<p>Apologies to derail slightly with a tangential question -- <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>",
        "id": 264530086,
        "sender_full_name": "Wojciech Nawrocki",
        "timestamp": 1639183522
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> Sure, yes that's an example. I haven't seen the trick with using a beta redex for the second pair element before, but it makes sense that it would work</p>",
        "id": 264539901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639195811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/stream/113489-new-members/topic/Existential.20quantifier.20and.20Sigma.20type/near/264530086\">said</a>:</p>\n<blockquote>\n<p>Apologies to derail slightly with a tangential question -- <span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> are you using some mind/concept mapping software in the screenshots? If so, which?</p>\n</blockquote>\n<p>Yes, it is OrgPad.<br>\n<a href=\"https://orgpad.com/\">https://orgpad.com/</a></p>\n<p>I will be glad if you give me any comments on my (current version of) study notes about Lean.<br>\n<a href=\"https://orgpad.com/s/ZBGjrzoGIBb\">https://orgpad.com/s/ZBGjrzoGIBb</a></p>",
        "id": 264689268,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1639392778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 264694748,
        "sender_full_name": "Notification Bot",
        "timestamp": 1639395945
    },
    {
        "content": "<p>TPIL chapter 7.3.<br>\n<a href=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\">image.png</a> <br>\nThis inaccuracy (<code>{α : Type*}</code> instead of <code>{α : Sort*}</code> or <code>{α : Sort u}</code>) is intentional, right?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/GaJN5uyDIzfY4qx0rMMhqoj1/image.png\"></a></div>",
        "id": 268436402,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531032
    },
    {
        "content": "<p>Actually, is there any good use case for an existential quantifier with <code>{α : Prop}</code> as the type of the quantified object?<br>\n\"There is a proof of proposition P such that (...)\"</p>",
        "id": 268437316,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531445
    },
    {
        "content": "<p>We cannot extract any information from inside the proof, right?</p>",
        "id": 268437671,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531641
    },
    {
        "content": "<p>So, would it restrict us in anything if the existential quantifier were defined really for <code>{α : Type*}</code> as TPIL says?</p>",
        "id": 268437804,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642531691
    },
    {
        "content": "<p>Yes, it is sometimes useful, if you need to pass the proof of P to a function that appears in the second part (e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.nth_le\">docs#list.nth_le</a>)</p>",
        "id": 268437850,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642531713
    },
    {
        "content": "<p>It also automatically shows up with \"collection binders\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That's short for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 268437892,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642531739
    },
    {
        "content": "<p>Note that <code>∃ (h : P), Q</code> is equivalent to <code>P ∧ Q</code>.</p>",
        "id": 268438451,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642531975
    },
    {
        "content": "<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>",
        "id": 268440517,
        "sender_full_name": "Reid Barton",
        "timestamp": 1642532881
    },
    {
        "content": "<p>Why cannot the code above be translated simply to ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 268440752,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642532978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517\">said</a>:</p>\n<blockquote>\n<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>\n</blockquote>\n<p>Every existential quantification is afaik a dependent sum type which is a generalization of the product type. Curry-Howard correspondence says that the product type models AND so yes.</p>",
        "id": 268441153,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533156
    },
    {
        "content": "<p>Probably easier to understand it is when you replace \"dependent sum type\" by \"dependent tuple\" and \"product type\" by \"tuple\".</p>",
        "id": 268441238,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440517\">said</a>:</p>\n<blockquote>\n<p>Right, so <code>∃</code> on a proposition is a kind of \"dependent AND\".</p>\n</blockquote>\n<p>TLDR: <code>∃</code> on anything is a dependent tuple; AND is a tuple. You are right.</p>",
        "id": 268441815,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642533474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268440752\">said</a>:</p>\n<blockquote>\n<p>Why cannot the code above be translated simply to ?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">/\\</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Except for the fact it should be <code>x ∈ s</code> rather than <code>s x</code> since it's a <code>set</code>, it <em>could</em> be translated to that (and in fact, once you <code>simp</code> it the inner exists becomes a conjunction), but from the Lean parser's point of view, it's simpler to do it the first way.</p>\n<p>This does not explain <em>why</em> <code>Exists</code> is the way it is. I looked into the history, and the collection binders feature was added July 2016 by Leo (who called them \"cute binders\" in the commit message). Even after this feature was introduced, the definition of <code>Exists</code> was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exists</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Exists</span> <span class=\"n\">P</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/leanprover-community/lean/blob/f461b53a7fa7477c367edddb386252b261c2014e/library/init/logic.lean#L530\">link</a>)</p>\n<p>It wouldn't be until Sep 2016 that <code>Exists</code> got universe variables</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Exists</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">intro</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">Exists</span>\n</code></pre></div>\n<p>(<a href=\"https://github.com/leanprover-community/lean/blob/5e8f2add8439226027cc9df186f3f7442f038e05/library/init/logic.lean#L574\">link</a>)</p>\n<p>I believe this is back when <code>Type 0</code> was <code>Prop</code>. Perhaps this explains the inaccuracy in TPIL?</p>",
        "id": 268451472,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642537922
    },
    {
        "content": "<p>So why is there the variable <code>(H : x ∈ s)</code> if I can write it the simpler way?</p>",
        "id": 268453092,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642538814
    },
    {
        "content": "<p>Would it be still relevant if there was the existential quantifier only?</p>",
        "id": 268453360,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642538984
    },
    {
        "content": "<p>I think the intention was to have a quantifier-polymoprhic pattern. For example, <code>(∃ (x ∈ s), P x)</code> is logically equivalent to <code>(∃ x, x ∈ s ∧ P x)</code>, and <code>(∀ (x ∈ s), P x)</code> is logically equivalent to <code>(∀ x, x ∈ s → P x)</code>. So, you would need to handle them separately when implementing the pattern (and you would already have to define conjunction to use it). On the other hand, you can write the first one as <code>(∃ x, ∃ (H : x ∈ s), P x)</code> and the second one as <code>(∀ x, ∀ (H : x ∈ s), P x)</code>. So, in general, it is translated to <code>(? x, ? (H : x ∈ s), P x)</code> for some binder <code>?</code>. So, for example, Lean can translate <code>(∃! (x ∈ s), P x)</code> to <code>(∃! x, ∃! (H : x ∈ s), P x)</code> without knowing anything about how <code>∃!</code> is implemented.</p>",
        "id": 268456493,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642540419
    },
    {
        "content": "<p>I don't know whether this works for any binder, though.</p>",
        "id": 268456518,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642540430
    },
    {
        "content": "<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>",
        "id": 268457083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540717
    },
    {
        "content": "<p>but the desugaring does work in this way uniformly for any binder, and surprisingly often it gets the mathematically right answer</p>",
        "id": 268457179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540764
    },
    {
        "content": "<p>Actually, <code>∃! (x ∈ s), P x</code> does basically work because <code>∃! (H : p), q</code> is also equivalent to <code>p /\\ q</code>, but <code>∃! x y : A, P x y</code> does not work as one would expect</p>",
        "id": 268457690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642540988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/268457083\">said</a>:</p>\n<blockquote>\n<p>it doesn't really work for <code>∃!</code> (in the sense that this isn't what multiple <code>∃!</code> is supposed to mean usually)</p>\n</blockquote>\n<p>Wait. Was multiple <code>∃!</code> actually supposed to mean _anything_?</p>",
        "id": 268458848,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642541579
    },
    {
        "content": "<p>If you say \"there exists a unique x, y such that P(x,y)\" in mathematics it usually means what you would write as <code>∃! p : A × A, P p.1 p.2</code> in lean</p>",
        "id": 268460688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642542565
    },
    {
        "content": "<p>\"there exists a unique x such that there exists a unique y such that P(x, y)\" is a very weird thing that I don't think ever comes up</p>",
        "id": 268460798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642542612
    },
    {
        "content": "<p>This is an accurate depiction of me today:<br>\n<a href=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\">I_fear_no_quantifier.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\" title=\"I_fear_no_quantifier.png\"><img src=\"/user_uploads/3121/A1g0TCag2qr35KoDUwW_LPUK/I_fear_no_quantifier.png\"></a></div>",
        "id": 268461142,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642542810
    },
    {
        "content": "<p>ORIGINAL IMAGE:<br>\nTeam Fortress 2 [teamfortress]. (2012, June 27). Meet the Pyro [Screen capture]. YouTube. Retrieved January 18, 2022, from <a href=\"https://ahseeit.com/?qa=16537/i-fear-no-man-meme\">https://ahseeit.com/?qa=16537/i-fear-no-man-meme</a></p>",
        "id": 268463043,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1642543705
    },
    {
        "content": "<p>I've never seen a meme come with a citation before <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 268467114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642546009
    },
    {
        "content": "<p>Clear difference between discord and zulip.</p>",
        "id": 268467248,
        "sender_full_name": "Julian Berman",
        "timestamp": 1642546107
    },
    {
        "content": "<p>Indeed, <code>(∃! (x y : α), P x y)</code> is not the same thing as <code>(∃! (xy : α × α), P xy.fst xy.snd)</code>. Can you actually construct a counterexample where they differ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">generalize</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">P</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">∨</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp_rw</span> <span class=\"n\">exists_unique</span><span class=\"o\">,</span> <span class=\"n\">push_neg</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hp</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">rcases</span> <span class=\"n\">h₁</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"n\">ff</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span> <span class=\"n\">cases</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">),</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">}},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 268472332,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1642549035
    },
    {
        "content": "<p>Metamath has a fascinating series of theorems about this, see <a href=\"http://us.metamath.org/mpeuni/mmtheorems26.html#2eu1\">2eu1</a> and other theorems around it</p>",
        "id": 268472762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549409
    },
    {
        "content": "<p>The only way I know to reliably write n-ary existential uniqueness without product types is</p>\n<p><code>∃ x1 ... xn, ∀ y1 ... yn, P y1 ... yn &lt;-&gt; x1 = y1 /\\ ... /\\ xn = yn</code></p>",
        "id": 268473072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549669
    },
    {
        "content": "<p>which does not lend itself well to a compositional formulation</p>",
        "id": 268473153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642549707
    },
    {
        "content": "<p>Reminds me of Euler's 36 officer problem (aka orthogonal Latin squares) whose quantum version is recently in the news is basically about finding 4-ary predicate P on <code>fin 6</code> such that <br>\n<code>P x1 x2 x3 x4 /\\ P y1 y2 y3 y4 /\\ x1 = y1 /\\ x2 = y2 -&gt; x3 = y3 /\\ x4 = y4</code> for all <code>xi, yi</code> and the same for all permutations of 1,2,3,4. Wondering whether an impossibility proof has been formalized (not sure about the least amount of computation required among proofs now known).<br>\n(edit: this isn't quite right, needs some condition to ensure there are at least 36 elements that evaluates to true. Simplest way is to say P is simultaneously a function from (xi,xj) to (xk,xl) for all permutations i,j,k,l of 1,2,3,4, which can be expressed with ∃!)</p>",
        "id": 268474834,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642550859
    },
    {
        "content": "<p>golfed Patrick Johnson's example using <code>bor</code>, and provided a proof that the latter always implies the former, intuitionistically:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">||</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">ff</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">tt</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">hx</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span><span class=\"o\">}⟩)</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tt</span><span class=\"o\">,</span><span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">xy</span><span class=\"o\">,</span><span class=\"n\">he</span><span class=\"o\">,</span><span class=\"n\">hu</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">xy.fst</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">xy.snd</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">xy.fst</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"o\">⟩,</span> <span class=\"n\">congr_arg</span> <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">hy.1</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n</div></div>\n<p>Observations: if <code>bool</code> is replaced by <code>Prop</code>, the example <del>won't work without excluded middle</del> (see below).<br>\nIf <code>example</code> is replaced by <code>lemma</code>, then it seems the statement become universe polymorphic, and one would have to write <code>{α : Type}</code>.</p>",
        "id": 268482750,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642557328
    },
    {
        "content": "<p>I would guess that you can still prove the example over <code>Prop</code> without excluded middle</p>",
        "id": 268482866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642557444
    },
    {
        "content": "<p>Hmm, I think you're right.</p>",
        "id": 268483560,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642558095
    },
    {
        "content": "<p>Now this only depends on propext:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">eq_true</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">or</span> <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y.elim</span> <span class=\"n\">false.elim</span> <span class=\"n\">eq_true_intro</span><span class=\"o\">⟩,</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">heu</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">eq_false.symm</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">heu</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hy</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">hy</span><span class=\"o\">))</span> <span class=\"n\">hy</span><span class=\"o\">)⟩)</span>\n    <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">trivial</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">trivial</span><span class=\"o\">)))</span>\n</code></pre></div>\n</div></div>",
        "id": 268485571,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642560333
    },
    {
        "content": "<p>It was tricky to find a proof not using propext, but it's possible:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">×</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hy.2</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hx</span> <span class=\"k\">with</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">hy.1.1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"n\">H'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hy.2</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"n\">hq</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">((</span><span class=\"n\">H'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">H'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"n\">h'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">P</span> <span class=\"n\">this</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n    <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">$</span> <span class=\"n\">ne.symm</span> <span class=\"n\">true_ne_false</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">(</span><span class=\"n\">prod.mk.inj</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">T</span> <span class=\"c1\">-- no axioms</span>\n</code></pre></div>\n</div></div>",
        "id": 268487420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1642562184
    },
    {
        "content": "<p>If you want an example in <code>Prop</code> without propext you can simply do this, which is a more direct translation of the <code>bor</code> example:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Solution</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">¬Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">xy.fst</span> <span class=\"n\">xy.snd</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">true_ne_false</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">false</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">))</span>\n    <span class=\"o\">⟨</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hu.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">true_ne_false</span> <span class=\"n\">he.symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span> <span class=\"n\">and.right</span><span class=\"o\">⟩,</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">heu</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hs</span><span class=\"o\">,</span><span class=\"n\">hu</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">heu</span> <span class=\"k\">in</span>\n        <span class=\"n\">hs.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"n\">heu</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">ht</span><span class=\"o\">))</span> <span class=\"n\">and.left</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)))</span>\n</code></pre></div>\n</div></div>\n<p>My last example translating <code>bor</code> to <code>or</code> is the most direct translation IMO, and I'm glad it works intuitionistically, thanks to your hint.</p>",
        "id": 268492188,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642567978
    },
    {
        "content": "<p>With propext, I've been able to show or, implication, and reverse implication are all binary predicates on Prop that serve as counterexamples: <a href=\"https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e\">https://gist.github.com/alreadydone/0d8c00290751e1d20c6eefeb6040430e</a><br>\nHowever, it seems NAND can't be shown to be a counterexample intuitionistically: not(x and y) is equivalent to y-&gt;not x, which is true when y=not x and when y=false. If there is a unique y such that y-&gt;not x, then false=not x, which is equivalent to not(not x), which doesn't imply x=true intuitionistically.<br>\nSince Prop with propext is a Heyting algebra (and maybe every Heyting algebra can serve as a model for intuitionistic Prop), this is a problem about whether a binary operation P satisfies ∃! (x y : α), P x y = ⊤ for all Heyting algebra α, where P is defined in terms of the operations of Heyting algebras (join, meet, implication, top, bot) so it makes sense for any Heyting algebra. And it would be a fun problem to classify all operations satisfying <code>eu_eu_and_not_eu_prod</code>. I don't know if anything changes if <code>(∃! (x y : α), P x y) ∧ ¬(∃! (xy : α × α), P xy.fst xy.snd)</code> is changed to <code>¬((∃! (x y : α), P x y) → (∃! (xy : α × α), P xy.fst xy.snd))</code>; the former implies the latter but not vice versa.</p>",
        "id": 269941042,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1643559062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Existential.20quantifier.20and.20Sigma.20type/near/269941042\">said</a>:</p>\n<blockquote>\n<p>maybe every Heyting algebra can serve as a model for intuitionistic Prop</p>\n</blockquote>\n<p>That was precisely Heyting's motivation!</p>",
        "id": 269944923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643563728
    }
]