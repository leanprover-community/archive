[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113489-new-members/topic/.60equiv_rw.60.20on.20hypothesis.20type.20mismatch/near/323944031\">said</a>:</p>\n<blockquote>\n<p>If you replace <code>sorry</code> with <code>x = x</code>, it won't work anymore. Do you see why?</p>\n</blockquote>\n<p>Thank you for the answer!<br>\nAh I see, yes I get that now. So this explains why it typechecks with <code>my_prop</code>.</p>\n<blockquote>\n<p>The same thing is happening in your example. Your <code>hβ</code> from <code>concat_prop</code> is a proof of equality between matrices whose second index is <code>fin u</code>, but in <code>my_theorem</code> you are trying to unify it with a proof of equality between matrices whose second index is <code>unit</code>. Unless the <code>hβ</code> from <code>concat_prop</code> and the <code>hβ</code> from <code>my_theorem</code> are definitionally equal, you get a type error.</p>\n</blockquote>\n<p>I dont quite understand this part. The <code>equiv_rw</code> should turn those indices to <code>fin 1</code>. But it also obviously rewrites the <code>hβ</code> to something that is not definitionally equivalent, as I'm getting the type-error I had mentioned in the early post.<br>\nIs there any way I could fix this type-error?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">49</span><span class=\"o\">:</span><span class=\"mi\">17</span><span class=\"o\">:</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">concat_prop</span> <span class=\"n\">hβ</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">hβ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">unit_equiv_fin1'.symm</span><span class=\"o\">)</span> <span class=\"n\">β</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(((</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">unit_equiv_fin1'.symm</span><span class=\"o\">)</span> <span class=\"n\">β₁</span><span class=\"o\">)</span><span class=\"bp\">ᵀ.</span><span class=\"n\">append_cols</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">unit_equiv_fin1'.symm</span><span class=\"o\">)</span> <span class=\"n\">β₂</span><span class=\"o\">)</span><span class=\"bp\">ᵀ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">submatrix</span> <span class=\"n\">id</span>\n         <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">fin_sum_fin_equiv.symm</span><span class=\"o\">))</span><span class=\"bp\">ᵀ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">β₁</span><span class=\"bp\">ᵀ.</span><span class=\"n\">append_cols</span> <span class=\"n\">β₂</span><span class=\"bp\">ᵀ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">submatrix</span> <span class=\"n\">id</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">fin_sum_fin_equiv.symm</span><span class=\"o\">))</span><span class=\"bp\">ᵀ</span>\n</code></pre></div>",
        "id": 325374597,
        "sender_full_name": "Aron Erben",
        "timestamp": 1675337819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> <a href=\"#narrow/stream/113489-new-members/topic/.60equiv_rw.60.20on.20hypothesis.20type.20mismatch/near/325374597\">said</a>:</p>\n<blockquote>\n<p>The <code>equiv_rw</code> should turn those indices to <code>fin 1</code>.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw\">tactic#equiv_rw</a> doesn't attempt to do that. You need to prove the desired equality manually.</p>",
        "id": 325580505,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1675416285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/113489-new-members/topic/.60equiv_rw.60.20on.20hypothesis.20type.20mismatch/near/325580505\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw\">tactic#equiv_rw</a> doesn't attempt to do that. You need to prove the desired equality manually.</p>\n</blockquote>\n<p>Ah, I misunderstood, I was referring to the rewrite of the betas from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">β₁</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p₁</span><span class=\"o\">)</span> <span class=\"n\">unit</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n<span class=\"n\">β₂</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"n\">unit</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"bp\">+</span> <span class=\"n\">p₂</span><span class=\"o\">))</span> <span class=\"n\">unit</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">β₁</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n<span class=\"n\">β₂</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n<span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"bp\">+</span> <span class=\"n\">p₂</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>after the three <code>equiv_rw</code>, but you're referring to the dimensions of the matrices in <code>hβ</code>, which stay <code>unit</code> because of the <code>⇑(unit_equiv_fin1'.symm)</code> added to each matrix in  <code>hβ</code>, right? I'm asking just so I understood correctly :)</p>",
        "id": 325634777,
        "sender_full_name": "Aron Erben",
        "timestamp": 1675432091
    },
    {
        "content": "<p>And an additional note, in case someone encounters a similar problem, this turned out to be an XY-problem, as changing <code>concat_prop</code> to simply work for both <code>unit</code> and <code>fin 1</code> allowed me to avoid dealing with <code>equiv_rw</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">concat_prop</span>\n   <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n   <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n   <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n   <span class=\"c1\">-- (hβ : my_prop β)</span>\n   <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 325642155,
        "sender_full_name": "Aron Erben",
        "timestamp": 1675433957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> has marked this topic as resolved.</p>",
        "id": 325873018,
        "sender_full_name": "Notification Bot",
        "timestamp": 1675538175
    },
    {
        "content": "<p>Hi where can I find the documentation of the lean's builtin functions and also the external standard library ? Is there something like hackage for lean ?</p>",
        "id": 342784692,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1679147005
    },
    {
        "content": "<p>Can you ask this question again in a new thread? Right now you're asking a question unrelated to the topic of this thread. And can you clarify whether you are talking about Lean 3 or Lean 4?</p>",
        "id": 342796745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679151500
    },
    {
        "content": "<p>Sorry about that, didn't understand I was in the middle of another thread, still getting the hang of zulip. Will ask again, and thanks for letting me know.</p>",
        "id": 342819969,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1679161458
    }
]