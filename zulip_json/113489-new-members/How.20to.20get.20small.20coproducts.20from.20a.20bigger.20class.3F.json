[
    {
        "content": "<p>I implemented having all coproducts up to size <code>κ</code> as having all coproducts of shapes of a subset of <code>κ</code>. This however makes it hard to actually get even initial objects as the empty set is not the same as <code>PEmpty</code>. I'm wondering if there's a nice way around this? Or should my implementation be different? E.g. require coproducts for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>J</mi><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi mathvariant=\"normal\">∣</mi><mi>κ</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|J| \\leq |\\kappa|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">κ</span><span class=\"mord\">∣</span></span></span></span>? This last option may make proving that a category satisfies this condition harder.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">has_coprods</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HasCoproductsOfShape</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasInitial</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 534219483,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1755088055
    },
    {
        "content": "<p>It's usually not a great idea to mix the set theory library with other libraries; the set theory library relies heavily on propositional membership that can't be e.g. matched on<br>\nThough I suppose if you really want coproducts up to a specific cardinality, there's probably not a lot of better ways...</p>",
        "id": 534433795,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1755160360
    },
    {
        "content": "<p>That said, while the empty set is not the same as <code>PEmpty</code>, it(s coercion to a type) is equivalent: you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.Set.pempty#doc\">docs#Equiv.Set.pempty</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.hasCoproduct_of_equiv_of_iso#doc\">docs#CategoryTheory.Limits.hasCoproduct_of_equiv_of_iso</a></p>",
        "id": 534434650,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1755160686
    },
    {
        "content": "<p>Or directly use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Limits.isColimitEquivIsInitialOfIsEmpty#doc\">docs#CategoryTheory.Limits.isColimitEquivIsInitialOfIsEmpty</a></p>",
        "id": 534435301,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1755160932
    },
    {
        "content": "<p>I would actually argue for using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>J</mi><mi mathvariant=\"normal\">∣</mi><mo>&lt;</mo><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">|J| &lt; \\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> for a cardinal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span></span></span></span> (using the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/SetTheory/Cardinal/Defs.html#Cardinal\">cardinal API</a>, which merely gives types up to equivalence). The reason is that when setting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>κ</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"double-struck\">N</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa = |\\mathbb{N}|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">κ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathbb\">N</span><span class=\"mord\">∣</span></span></span></span>, it allows indexing coproducts by <em>all finite sets</em> instead of subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, which might be useful in some cases.</p>\n<p>As for proving that a category satisfies this condition, you could still prove a lemma stating that your first condition (or something similar) implies the second stronger one.</p>",
        "id": 534444725,
        "sender_full_name": "Adrian Marti",
        "timestamp": 1755164698
    },
    {
        "content": "<p>Thanks for the comments. I think using the cardinal API is indeed better. It has also been used <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Presentable/IsCardinalFiltered.html#CategoryTheory.IsCardinalFiltered\">here</a>. The problem is that the condition <code>(hA : HasCardinalLT (Arrow A) κ)</code> can not be automatically inferred, so I'm thinking that maybe we have to bundle these things.</p>",
        "id": 534656248,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1755265728
    }
]