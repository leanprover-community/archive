[
    {
        "content": "<p>I am trying to learn Lean to formalize results on free algebraic structures (for example : free magmas). When working with the free magma over a type α, it would be natural to see the elements of α as being part of the free magma through the canonical embedding (the constructor <code>FreeMagma.of</code>). Reading the documentation, I understand that this should be done by coercion? I tried the implementation below, which correctly accepts that, in <code>FreeMagma.mul a b</code>, the letter <code>a</code> should be coerced, but unfortunately, the <code>b</code> term triggers an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Free</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">FreeMagma</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">FreeMagma.of</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">length_of_pair_eq_two</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">FreeMagma.mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>What am I doing wrong? Being able to write such statements would be a lot more natural for manipulations (avoiding to distinguish between elements of the alphabet and their image in the free structure).</p>\n<p>Error message</p>\n<blockquote>\n<p>FreeMagma.mul ?m.161 b<br>\nargument<br>\n  b<br>\nhas type<br>\n  α : Type u_1<br>\nbut is expected to have type<br>\n  FreeMagma ?m.224 : Type ?u.221</p>\n</blockquote>\n<p>Thanks,</p>",
        "id": 408344960,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1702733835
    },
    {
        "content": "<p>For some reason which I've never really understood, Lean is unable to figure out that if it's faced with a coercion from X to <code>FreeMagma ?m</code> then it should try <code>?m=X</code> and then use the only coercion which can possibly work. The consequence is that you have to explicitly tell Lean the type of the target:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">length_of_pair_eq_two</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">FreeMagma.mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">FreeMagma</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I can also not guarantee that <code>Coe</code> is correct, there are all manner of variants the differences between which I don't understand and I also don't understand the algorithm for working out which one you should use in any given case (there's CoeHead, CoeTail and probably some others).</p>",
        "id": 408346569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702735143
    },
    {
        "content": "<p>Try instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">length_of_pair_eq_two</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">FreeMagma</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">length_of_pair_eq_two'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">FreeMagma</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The way to indicate to Lean that you want a coercion is to give a type ascription on one of the terms. You should never need to use<code>FreeMagma.mul</code>, but just <code>*</code>.</p>\n<p>By the way, your <code>by exact rfl</code> can be replaced by <code>rfl</code> (or <code>by rfl</code>).</p>",
        "id": 408346599,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702735187
    },
    {
        "content": "<p>As Kevin says, the problem is that in your initial formulation, when you use <code>FreeMagma.length</code>, Lean doesn't know which free magma you want to use. If you tell it that you want to use the free magma based on <code>α</code>, then everything works fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">length_of_pair_eq_two'''</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">FreeMagma.length</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But the two suggestions above are better, this formulation here is just for educational purposes.</p>",
        "id": 408347043,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1702735425
    },
    {
        "content": "<p>Thank you both for your quick answers !</p>\n<p>I was surprised that none of these coercions seems to be currently implemented. Shouln't they be part of Mathlib4 for all free structures (free magma, monoid, semigroup, group, algebra, Lie algebra and so on)?</p>",
        "id": 408348080,
        "sender_full_name": "Frédéric Marbach",
        "timestamp": 1702736283
    },
    {
        "content": "<p>I guess we're more used to type theory than you are :-) I don't immediately see why these coercions would be a bad idea... On the other hand, maybe once you're used to type theory you like to keep track of these things explicitly :-)</p>",
        "id": 408348665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702736721
    }
]