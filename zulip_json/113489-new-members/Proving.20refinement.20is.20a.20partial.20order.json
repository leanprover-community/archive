[
    {
        "content": "<p>Hi! <br>\nI have a decomposition structure which is such that an object  <code>S : Decomp n</code> for some natural number n corresponds to a way of writing n as a sum of integers. To implement this, S has as field a multiset DecompMultiset representing the integers in the decomposition. (There should of course be a proof that the sum of those numbers is actually n, but I am leaving this aside for this question). </p>\n<p>From there, I define a relation on decompositions in the following way: if S and T are both decompositions of n, then T refines S if every integer in S.DecompMultiset is a sum of integers in T.DecompMultiset. For instance, {1,1,3} can be refined into {1,1,1,2}. </p>\n<p>Question now: I am having a lot of issues proving that this relationship is transitive, so if T refines S and U refines T, then U refines S. Each element in S corresponds to a sub-multiset in T, and each element in these sub-multisets yields another sub-multiset in U. I think it would be sufficient to take the disjoint union of all these objects, but it is really unclear to me how to actually implement this. What is the clever way of accessing all these subsets and indexing them so i can build a disjoint union? </p>\n<p>MWE for reference: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">DecompMultiset</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Multiset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"c1\">--there would of course be a 2nd property here to express that n is the sum of the elements</span>\n<span class=\"w\">  </span><span class=\"c1\">--in the multiset</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Refinement</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S₁</span><span class=\"bp\">.</span><span class=\"n\">DecompMultiset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Ssub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ssub</span><span class=\"bp\">.</span><span class=\"n\">DecompMultiset</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"bp\">.</span><span class=\"n\">DecompMultiset</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RefinementTrans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decomp</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Refinement</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Refinement</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">S₂</span><span class=\"w\"> </span><span class=\"n\">S₃</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Refinement</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">S₁</span><span class=\"w\"> </span><span class=\"n\">S₃</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Refinement</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Refinement</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Refinement</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"c1\">--doing this thrice is very inelegant...</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">hmem</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 462841506,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723834885
    },
    {
        "content": "<p>I’ve never used multisets, but from what I gathered in the docs, it seems to me that what you actually need is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.add#doc\">docs#Multiset.add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.Le#doc\">docs#Multiset.Le</a>.</p>",
        "id": 462843168,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723835631
    },
    {
        "content": "<p>For Le, this seems like a different partial order than the one I am working with. In my case, {1,1,3} &gt; {1,1,1,2}, but these sets have no relation between them in the partial order from the documentation. </p>\n<p>For add: this makes sense. How can I take a binary operation like this add and sum way more than 2 things?</p>",
        "id": 462845917,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723836812
    },
    {
        "content": "<p>I meant that your <code>Refinement</code> statement should be stated I think with <code>Le</code> rather than inclusion, namely <code>Ssub.DecompMultiset ≤ S₂.DecompMultiset</code>. As an addition is defined and it gives some structure, you should be able to write finite sums using <code>∑</code>.</p>",
        "id": 462846873,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723837278
    },
    {
        "content": "<p>Is <code>{1,2}</code> supposed to be a refinement of <code>{1,3}</code>? Because it is in the Lean definition.</p>",
        "id": 462847759,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723837765
    },
    {
        "content": "<p>And in that case, <code>{1,1}</code> is a refinement of <code>{1,2}</code>, but not of <code>{1,3}</code>. So I don't think the definition you wrote in Lean is transitive.</p>",
        "id": 462847970,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723837864
    },
    {
        "content": "<p>No - that would be excluded by the other condition, which I did not take the time to write out here but probably should have. In this case, {1,3} is a decomposition of 4, and {1,2} would be a decomposition of 3, so they would not be of compatible types for Lean.</p>",
        "id": 462848693,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723838204
    },
    {
        "content": "<p>Thank you for the comment on multiset addition, that makes a lot of sense. One additional question if that's OK: the <code>∑</code> symbol is already defined, so this is easy to deal with, but I have been in situations in the past where I had some hand-made binary operation that I needed to be able to define for large finite sets, and for which Lean had no pre-written code. In that case, what is the correct approach to define these repeated operations?</p>",
        "id": 462849035,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723838369
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.sum#doc\">docs#Multiset.sum</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a> are available as long as you proved an <code>AddCommMonoid</code> instance on the type where you take the sum. The <code>∑</code> symbol is a notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sum#doc\">docs#Finset.sum</a>. In the case of multisets for example, this instance is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.instOrderedCancelAddCommMonoid#doc\">docs#Multiset.instOrderedCancelAddCommMonoid</a> (from which Lean automatically deduces <code>AddCommMonoid</code> by typeclass inference).</p>",
        "id": 462852230,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723840174
    },
    {
        "content": "<p>Note that <code>Multiset.sum</code> and <code>Finset.sum</code> work differently. The latter takes the sum of the values taken by a function, while the former computes the sum of the elements in the multiset (counting multiplicity).</p>",
        "id": 462853243,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723840699
    },
    {
        "content": "<p>Thank you very much, I'll look into this properly! That's very helpful to know!</p>",
        "id": 462854870,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723841488
    },
    {
        "content": "<p>You’re welcome!</p>",
        "id": 462855965,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723842042
    },
    {
        "content": "<p>Oh also, about the three <code>rw</code>, you can use <code>rw [Refinement] at *</code>, which will rewrite in the goal and all the hypotheses. More generally, <code>rw [...] at h1 h2 ... hn</code> will rewrite at the given hypotheses.</p>",
        "id": 462950692,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1723880721
    }
]