[
    {
        "content": "<p>Hello, I have the following theorem I want to proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">basis_is_spanning_set_for_quot_space</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">UV</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">wq</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n      <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">wq</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"c1\">-- have w := Quot.out wq</span>\n  <span class=\"c1\">-- use b.repr w</span>\n</code></pre></div>\n<p>This (assuming I modeled it correctly) should prove that a given basis <code>b</code> for a module <code>M</code> is also a spanning set (after applying the canonical linear map to each basis vector) for the module <code>M</code> quotiented by the submodule <code>U</code>, so <code>M ⧸ U</code>. </p>\n<p>My game plan here is to pull the <code>Submodule.Quotient.mk</code> out of the <code>Finset.sum</code> using something like <code>map_sum</code>. Then I turn <code>wq</code>into <code>Submodule.Quotient.mk w</code>, where <code>w : M</code>. After that I can hopefully prove the goal <code>Submodule.Quotient.mk (∑ i, a i • (b i)) = Submodule.Quotient.mk w</code> using <code>Submodule.Quotient.eq</code> and <code>Basis.sum_repr</code>.</p>\n<p>However, I was not able to put any of these steps together, I'm already failing at pulling out <code>Submodule.Quotient.mk</code> from the sum. Any help or pointers would be much appreciated :)</p>",
        "id": 403028816,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700411652
    },
    {
        "content": "<p>This makes some progreess:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">wq</span> <span class=\"n\">using</span> <span class=\"n\">Quotient.ind</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">w</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←@</span><span class=\"n\">Quotient.mk'_eq_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">Submodule.Quotient.mk'_eq_mk'</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">Submodule.Quotient.mk_smul</span><span class=\"o\">]</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 403029294,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700411966
    },
    {
        "content": "<p>I think your problem is that <code>Submodule.Quotient.mk_sum</code> is missing, and so you should prove that by itself first</p>",
        "id": 403029345,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700411987
    },
    {
        "content": "<p>(the proof should just be <code>QuotientAddGroup.mk_sum</code>)</p>",
        "id": 403029428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700412018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403029428\">said</a>:</p>\n<blockquote>\n<p>(the proof should just be <code>QuotientAddGroup.mk_sum</code>)</p>\n</blockquote>\n<p>I figured, that's how I found <code>map_sum</code>, but I struggled with that. I'll try again, though</p>",
        "id": 403049128,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700424922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403029294\">said</a>:</p>\n<blockquote>\n<p>This makes some progreess:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">wq</span> <span class=\"n\">using</span> <span class=\"n\">Quotient.ind</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">w</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←@</span><span class=\"n\">Quotient.mk'_eq_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">Submodule.Quotient.mk'_eq_mk'</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">Submodule.Quotient.mk_smul</span><span class=\"o\">]</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks, I'm getting the strange error </p>\n<blockquote>\n<p>invalid use of field notation with <code>@</code> modifier</p>\n</blockquote>\n<p>on <code>←@Quotient.mk'_eq_mk _ (_)</code>.</p>\n<p>Not sure why, it seems valid... Does it recognize <code>Quotient</code> as an object with a field?</p>",
        "id": 403049333,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700425096
    },
    {
        "content": "<p>Nevermind, I updated mathlib and it fixed itself :)</p>",
        "id": 403049896,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700425616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403049128\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403029428\">said</a>:</p>\n<blockquote>\n<p>(the proof should just be <code>QuotientAddGroup.mk_sum</code>)</p>\n</blockquote>\n<p>I figured, that's how I found <code>map_sum</code>, but I struggled with that. I'll try again, though</p>\n</blockquote>\n<p>Were you able to <em>state</em> the lemma?</p>",
        "id": 403051239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700426917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403051239\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403049128\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403029428\">said</a>:</p>\n<blockquote>\n<p>(the proof should just be <code>QuotientAddGroup.mk_sum</code>)</p>\n</blockquote>\n<p>I figured, that's how I found <code>map_sum</code>, but I struggled with that. I'll try again, though</p>\n</blockquote>\n<p>Were you able to <em>state</em> the lemma?</p>\n</blockquote>\n<p>Here is where I get stuck, not sure if I did it correctly so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Submodule.Quotient.mk_sum</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n      <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">map_sum</span> <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">s</span>\n</code></pre></div>\n<blockquote>\n<p>failed to synthesize instance<br>\n  AddMonoidHomClass (M → M ⧸ U) M ?m.4317</p>\n</blockquote>\n<p>I was looking if there is an easy way to get that typeclass instance or if I have to make it myself.</p>\n<p>(Sidenote: Lean takes about 6-7 seconds to typecheck that specific lemma (even with just a <code>sorry</code>), not sure what's going on with that...)</p>",
        "id": 403051456,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700427213
    },
    {
        "content": "<p>The long time taken to elaborate (which occurs even if the proof is <code>sorry</code>) is a <a href=\"https://github.com/leanprover-community/mathlib4/blob/7b0cbe23464242c001ac2a2c8c8744eb6d661c6f/Mathlib/LinearAlgebra/Quotient.lean#L59-L61\">known issue</a> (which I don't understand): elaboration is really slow if you don't tell Lean the type of the quotient. Adding <code>M / U</code> at the end fixes this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Submodule.Quotient.mk_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This elaborates immediately.</p>",
        "id": 403052392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700428033
    },
    {
        "content": "<p>Here's a proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Submodule.Quotient.mk_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Submodule.mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">apply</span> <span class=\"n\">map_sum</span>\n</code></pre></div>",
        "id": 403052609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700428217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403052392\">said</a>:</p>\n<blockquote>\n<p>The long time taken to elaborate (which occurs even if the proof is <code>sorry</code>) is a <a href=\"https://github.com/leanprover-community/mathlib4/blob/7b0cbe23464242c001ac2a2c8c8744eb6d661c6f/Mathlib/LinearAlgebra/Quotient.lean#L59-L61\">known issue</a> (which I don't understand): elaboration is really slow if you don't tell Lean the type of the quotient. Adding <code>M / U</code> at the end fixes this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Submodule.Quotient.mk_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This elaborates immediately.</p>\n</blockquote>\n<p>Interesting, so I need to add the type hint to both sides of the equality... So this is related to elaboration issue is specific to quotients then, I assume?</p>",
        "id": 403052660,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700428287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Basis.20is.20spanning.20set.20of.20quotient.20space/near/403052609\">said</a>:</p>\n<blockquote>\n<p>Here's a proof:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Submodule.Quotient.mk_sum</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.sum</span> <span class=\"n\">s</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Submodule.mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">apply</span> <span class=\"n\">map_sum</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks, I will try to understand how this one works!</p>",
        "id": 403052728,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700428326
    },
    {
        "content": "<p>I've got 2 solutions, the first one using defeq abuse and the second one not. Without defeq abuse you have to use <code>simp_rw</code> since <code>rw</code> can't look inside a sum.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">linearEquivCoeFun</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FunLike.hasCoeToFun</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.mkQ_surjective</span> <span class=\"n\">U</span> <span class=\"n\">x</span>\n  <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">v</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Submodule.mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">b.repr</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">Basis.sum_repr</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hv</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.mkQ_surjective</span> <span class=\"n\">U</span> <span class=\"n\">x</span>\n  <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">v</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Submodule.mkQ_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">Basis.sum_repr</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hv</span>\n</code></pre></div>",
        "id": 403052739,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700428345
    },
    {
        "content": "<p>About 250 ms of the elaboration time is a <code>CoeFun</code> typeclass inference on things of type <code>A ≃ₗ[R] B</code>, which putting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">linearEquivCoeFun</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FunLike.hasCoeToFun</span>\n</code></pre></div>\n<p>short-circuits.</p>",
        "id": 403052779,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700428396
    },
    {
        "content": "<p>OK, just learned about the power of <code>rintro</code> by inspecting <code>Submodule.mkQ_surjective</code> and I can do away with one line in each solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">linearEquivCoeFun</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeFun</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">FunLike.hasCoeToFun</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">v</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Submodule.mkQ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">b.repr</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Submodule.mkQ</span> <span class=\"n\">U</span> <span class=\"n\">v</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">Basis.sum_repr</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">⟩</span>\n  <span class=\"n\">use</span> <span class=\"n\">b.repr</span> <span class=\"n\">v</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Submodule.mkQ_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">map_sum</span><span class=\"o\">,</span> <span class=\"n\">Basis.sum_repr</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 403053616,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700429178
    },
    {
        "content": "<p>I didn't read carefully this conversation, and hopefully it allowed to hunt down some missing lemma. But the strategy outlined by <span class=\"user-mention\" data-user-id=\"460930\">@Aron Erben</span> in the first post looks rather suboptimal to me. The proof on paper would be: the subspace spanned by the image of <code>mkQ U ∘ b</code> is the image under <code>mkQ U</code> of the span of the image of <code>b</code> since <code>mkQ U</code> is linear. Since <code>b</code> is a basis, it spans everything. Since <code>mkQ U</code> is surjective, we deduce that the image of <code>mkQ U ∘ b</code> spans everything. And then as a very last step we reformulate this in terms of existence of a linear combination (although I doubt this is really useful).</p>",
        "id": 403089154,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700453452
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span> <span class=\"n\">Quotient</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">basis_is_spanning_set_for_quot_space</span>\n    <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">wq</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n    <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">Submodule.Quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">wq</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">mkQ</span> <span class=\"n\">U</span> <span class=\"bp\">∘</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"bp\">→</span> <span class=\"n\">M</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">range_comp</span><span class=\"o\">,</span> <span class=\"n\">span_image</span><span class=\"o\">,</span> <span class=\"n\">b.span_eq</span><span class=\"o\">,</span> <span class=\"n\">Submodule.map_top</span><span class=\"o\">,</span> <span class=\"n\">range_mkQ</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mem_span_range_iff_exists_fun</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">eq_top_iff'.mp</span> <span class=\"n\">this</span> <span class=\"n\">wq</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 403089255,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700453525
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I wrote the above <code>rw</code> call by human-driven <code>rw_search</code>: using <code>rw?</code>, selecting by hand the most promising proposition and iterating. Unfortunately <code>rw_search</code> does not find it.</p>",
        "id": 403089368,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1700453636
    },
    {
        "content": "<p>Thanks for the variations! I think my game plan wasn't optimal, as pointed out, although it might've been easier if I knew of <code>Submodule.mkQ</code>, which I probably missed because I was searching for lemmas/definitions  containing <code>quot</code>...</p>",
        "id": 403131760,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700473763
    },
    {
        "content": "<p>I'm not sure if it breaks a pattern, but maybe a more apt name could be <code>Submodule.Quotient.mk_linear_map</code>?</p>\n<p>Anyway, I'm resolving, as this thread helped with this problem and also how to approach linear algebra problems in Lean in general :) Thanks again!</p>",
        "id": 403133215,
        "sender_full_name": "Aron Erben",
        "timestamp": 1700474236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"460930\">Aron Erben</span> has marked this topic as resolved.</p>",
        "id": 403133236,
        "sender_full_name": "Notification Bot",
        "timestamp": 1700474244
    }
]