[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bla</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"bp\">×</span><span class=\"n\">Nat</span><span class=\"bp\">→</span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">Ss_eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ss</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ss</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">Ss_eq</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n</code></pre></div>\n<p>I would expect rewrite to also replace <code>s</code> by <code>Ss.2</code> in the assumption <code>Ss_eq</code>, but it doesn't.<br>\nI get the proof state </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ss</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ss</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Ss</span>\n<span class=\"n\">Ss_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Ss</span>\n</code></pre></div>\n<p>if i type <code>rw [eq1] at Ss_eq</code> it replaces it there.</p>\n<p>Is this expected?<br>\nHow can i really rewrite all matches?</p>",
        "id": 526276640,
        "sender_full_name": "Moritz R",
        "timestamp": 1751210757
    },
    {
        "content": "<p>hmm that is strange</p>",
        "id": 526276881,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751210944
    },
    {
        "content": "<p>I'm guessing it rewrites <code>s = Ss.2</code> into <code>Ss.2 = Ss.2</code>, and then it fails to find an occurrence of <code>Ss.2</code> anywhere else in the tactic state (because it's now rewriting with <code>eq1 : Ss.2 = Ss.2</code>)</p>",
        "id": 526276895,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751210957
    },
    {
        "content": "<p>that would be really cursed</p>",
        "id": 526276922,
        "sender_full_name": "Moritz R",
        "timestamp": 1751210992
    },
    {
        "content": "<p>I read the code for the <code>rw</code> tactic so I know how it works</p>",
        "id": 526277015,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751211085
    },
    {
        "content": "<p>but I forgot so I'm gonna read it again to be sure</p>",
        "id": 526277032,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751211098
    },
    {
        "content": "<p>ok I just confirmed that that is exactly what it is doing</p>",
        "id": 526277145,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751211216
    },
    {
        "content": "<p>it rewrites at the goal first (and fails) and then traverses the hypotheses in reverse order</p>",
        "id": 526277172,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751211248
    },
    {
        "content": "<p>it reelaborates the rewrites to be done after every rewrite</p>",
        "id": 526277212,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751211282
    },
    {
        "content": "<p>This has to be unwanted behaviour right?</p>",
        "id": 526277898,
        "sender_full_name": "Moritz R",
        "timestamp": 1751211987
    },
    {
        "content": "<p>We should save the rewriting equation for last, or not rewrite it itself at all</p>",
        "id": 526277915,
        "sender_full_name": "Moritz R",
        "timestamp": 1751212007
    },
    {
        "content": "<p><code>rw at *</code> and <code>simp at *</code> can both behave in unexpected ways, I am generally cautious about using them. Do you ever really want to do <code>rw [h] at *</code>? In pretty much every case I've run into you don't, you know exactly what you want to rewrite.</p>",
        "id": 526281707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751216389
    },
    {
        "content": "<p>Or for example, if you have <code>s = Ss.2</code>, which has a free variable on the LHS, <code>subst s</code> or <code>subst eq1</code> (both do the same thing) is often more likely to succeed than <code>rw [...] at *</code>. It does the rewrite simultaneously at all hypotheses and the goal.</p>",
        "id": 526283212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751218067
    },
    {
        "content": "<p>(I don't think <code>s</code> will be a free variable in general, since we ask for <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> )</p>",
        "id": 526283246,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751218101
    },
    {
        "content": "<p>If it's not a variable, then it's probably best to use another <code>generalize</code> to make it be one</p>",
        "id": 526283326,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751218196
    },
    {
        "content": "<p>I'm not sure exactly how <code>rw [h] at *</code> could/should be fixed. Any of the rules I can think of are sort of convoluted.</p>\n<p>Two ideas:</p>\n<ol>\n<li>If the hypothesis being rewritten appears as one of the rewrite lemmas, then throw an error. (Recall that the <code>at *</code> system allows a tactic to fail at a particular location, and the whole tactic fails if it fails at every location).</li>\n<li>If the hypothesis being rewritten appears as one of the rewrite lemmas, then add the rewritten term as a new hypothesis but don't clear the old one.</li>\n</ol>\n<p>The second one reflects the idea that this new hypothesis depends on the old version of itself in some way. It's also more permissive, since possibly there's some obscure scenario where you do want to rewrite a hypothesis with itself.</p>",
        "id": 526283662,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751218568
    },
    {
        "content": "<p>What about rewriting in the h as last in order?, i.e. then when there are no rewrite matches but in the h itself</p>",
        "id": 526283801,
        "sender_full_name": "Moritz R",
        "timestamp": 1751218713
    },
    {
        "content": "<p>The rewrite lemmas are elaborated for each location; when choosing the order to rewrite hypotheses, you don't know what the lemmas are yet, so to speak.</p>",
        "id": 526283866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751218792
    },
    {
        "content": "<p>This is what makes this so convoluted: sure, the syntax <code>h</code> is present inside the list of lemmas, but you'd have to have a separate pass to go through the list and decide which ones are hypotheses.</p>\n<p>Then what happens if you have <code>rw [lem1, h, lem2] at *</code>? Does this <code>h</code> count as being <code>h</code> still?</p>\n<p>Or what happens if you have <code>rw [h1, h2] at *</code> with <code>h1</code> and <code>h2</code> local hypotheses? They can't both be last.</p>",
        "id": 526283976,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751218909
    },
    {
        "content": "<p>With my idea 1, the answer to <code>rw [h1, h2] at *</code> is that it doesn't rewrite at <code>h1</code> or <code>h2</code>, and to <code>rw [lem1, h, lem2] at *</code> is that it doesn't rewrite at <code>h</code>.</p>\n<p>With my idea 2, the answer to <code>rw [h1, h2] at *</code> is new versions of <code>h1</code> and <code>h2</code> shadow the old ones, if <code>rw</code> applied at all to them, and to <code>rw [lem1, h, lem2] at *</code>, you would have a copy of <code>h</code> shadowing the original <code>h</code> if it applied.</p>\n<p>Idea 2 doesn't fix your original example though, but it does fix the problem where <code>rw</code> is causing information loss. Unless idea 2 involves making sure to add the new versions only after all the rewrites are done.</p>",
        "id": 526284184,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751219134
    },
    {
        "content": "<p><strong>Idea 3:</strong> with <code>rw ... at *</code>, only modify the local context once all the rewrites are done.</p>",
        "id": 526284212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751219169
    },
    {
        "content": "<p>This one still has information loss, but at least it's easy to explain.</p>",
        "id": 526284323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751219311
    },
    {
        "content": "<p>Let me come back to this tomorrow</p>",
        "id": 526285717,
        "sender_full_name": "Moritz R",
        "timestamp": 1751220697
    },
    {
        "content": "<p>We could always ban <code>rw [h] at *</code>. Here are two potential uses for it though: first when you have hypotheses with inaccessible names, and second when you do <code>cases h with h1 | h2 &lt;;&gt; rw [hx] at *</code> when you don't actually know the name of the hypothesis because it will run more than once</p>",
        "id": 526287453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1751222727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Idea 1 makes the most sense to me. i can't really imagine a good use case for why one would ever want to rewrite the rewrite lemmas at the same time. Intuitively, i also didn't expect this to happen.<br>\nHow would Idea 3 work with recursive applications?</p>",
        "id": 526561030,
        "sender_full_name": "Moritz R",
        "timestamp": 1751360852
    }
]