[
    {
        "content": "<p>I'm trying to show that (for any universe parameter u), <code>Type u</code> is <code>Infinite</code>.  My idea was to make an inductive type family</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SortHelper</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">SortHelper</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>and use <code>Infinite.of_injective (f := SortHelper)</code> and the fact that <code>Nat</code> is infinite. However, I'm stuck on the step of showing that the type constructor <code>SortHelper</code> is an injection:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortHelper</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">SortHelper</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Intuitively, I know (think) that it is an injection, but I'm not sure how to prove it.  Any ideas (or is there a better way to show that <code>Type u</code> is infinite?)</p>",
        "id": 523663183,
        "sender_full_name": "Max Carr",
        "timestamp": 1749690908
    },
    {
        "content": "<p>I think it is not possible to prove that <code>SortHelper</code> is injective. You can use <code>ULift ∘ Fin</code> instead.</p>",
        "id": 523663809,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749691351
    },
    {
        "content": "<p>Fun fact: <code>SortHelper</code> could be noninjective according to the cardinality model of Lean (where all types with the same cardinality are propositionally equal). Since each <code>SortHelper k</code> has cardinality 1, that means this theorem is not provable.</p>",
        "id": 523663884,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749691405
    },
    {
        "content": "<p>I'm really surprised that this doesn't exist already.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">--failed</span>\n</code></pre></div>",
        "id": 523663936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749691444
    },
    {
        "content": "<p>At least there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=fin_injective#doc\">docs#fin_injective</a>, which is most of the argument.</p>",
        "id": 523664202,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749691657
    },
    {
        "content": "<p>Thanks to you both. I'm able to prove that <code>Type</code> is injective with that, but to work with higher universes, I also need to show that the type constructor ULift is itself injective, and I couldn't find a lemma in the library that would help me (and it seems like type equality is pretty hard)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">of_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">fin_injective</span>\n</code></pre></div>\n<p>Context before <code>sorry</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 523666889,
        "sender_full_name": "Max Carr",
        "timestamp": 1749694208
    },
    {
        "content": "<p>You can't show that <code>ULift</code> is injective, but you can show that <code>ULift ∘ Fin</code> is injective</p>",
        "id": 523666919,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749694238
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928443\">Max Carr</span> has marked this topic as resolved.</p>",
        "id": 523670587,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749698202
    },
    {
        "content": "<p>For posterity, this is the (not super elegant) proof I was able to make, thanks all!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">infinite_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">of_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up_down</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up_down</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- stolen from fin_injective but using equivalence instead of equality</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_congr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 523670589,
        "sender_full_name": "Max Carr",
        "timestamp": 1749698204
    },
    {
        "content": "<p>For posterity, this is the (admittedly not super elegant) proof I was able to come up with, thanks all!</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">infinite_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">of_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up_down</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">congr</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up_down</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- stolen from fin_injective but using equivalence instead of equality</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_congr</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 523670625,
        "sender_full_name": "Max Carr",
        "timestamp": 1749698242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928443\">Max Carr</span> has marked this topic as resolved.</p>",
        "id": 523670686,
        "sender_full_name": "Notification Bot",
        "timestamp": 1749698314
    },
    {
        "content": "<p>Golfed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">infinite_type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Infinite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Infinite</span><span class=\"bp\">.</span><span class=\"n\">of_injective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 523671788,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749699412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928443\">@Max Carr</span> what’s more, the trick here is that mathematically, ULift o Fin is not just “injective”, it actually has a left inverse called Nat.card</p>",
        "id": 523717263,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749721304
    }
]