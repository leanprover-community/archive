[
    {
        "content": "<p>Please can someone explain to me why, for integers, the casting from integers to upwards extended integers is not working?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Padic</span><span class=\"bp\">.</span><span class=\"n\">norm_lt_iff_addValuation_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Padic</span><span class=\"bp\">.</span><span class=\"n\">addValuation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic</span><span class=\"bp\">.</span><span class=\"n\">addValuation</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">norm_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"bp\">.</span><span class=\"n\">natCast_lt_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zpow_neg</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zpow_natCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inv_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">pow_pos</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">cast_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"bp\">.</span><span class=\"n\">pos</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic</span><span class=\"bp\">.</span><span class=\"n\">norm_eq_pow_val</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic</span><span class=\"bp\">.</span><span class=\"n\">addValuation</span><span class=\"bp\">.</span><span class=\"n\">apply</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"c1\">-- have hx' ::= solve ↑p ^ (-x.valuation) &lt; ↑p ^ (-↑m) for x.valuation</span>\n<span class=\"w\">      </span><span class=\"c1\">-- exact hx'</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">nth_rewrite</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">cast_lt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- why isn't this working?</span>\n<span class=\"w\">    </span><span class=\"n\">nth_rewrite</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">neg_lt_neg_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">pow_lt_pow_iff_right</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>",
        "id": 474097142,
        "sender_full_name": "Giulio Caflisch",
        "timestamp": 1727805988
    },
    {
        "content": "<p>it seems the issue is that the right argument you're trying to rewrite isn't <code>Nat.cast</code> but rather <code>WithTop.some</code></p>",
        "id": 474097784,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727806214
    },
    {
        "content": "<p>Does this help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"bp\">.</span><span class=\"n\">coe_natCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"bp\">.</span><span class=\"n\">coe_lt_coe</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 474098462,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1727806474
    },
    {
        "content": "<p>It works, thanks to both</p>",
        "id": 474101479,
        "sender_full_name": "Giulio Caflisch",
        "timestamp": 1727807508
    },
    {
        "content": "<p>Sorry to disturb again.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">Padic.norm_lt_iff_addValuation_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Padic.addValuation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic.addValuation.map_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">norm_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">WithTop.natCast_lt_top</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iff_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zpow_neg</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">zpow_natCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inv_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">pow_pos</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">cast_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hp.out.pos</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ne_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat.Prime.one_lt</span><span class=\"w\"> </span><span class=\"n\">hp.out</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic.norm_eq_pow_val</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Padic.addValuation.apply</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"c1\">-- have hx' ::= solution_with_proof ↑p ^ (-x.valuation) &lt; ↑p ^ (-↑m) for x.valuation</span>\n<span class=\"w\">      </span><span class=\"c1\">-- exact hx'</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">WithTop.coe_natCast</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">WithTop.coe_lt_coe</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">nth_rewrite</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">neg_lt_neg_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Real.rpow_intCast</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Real.rpow_lt_rpow_left_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int.cast_neg</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">neg_lt_neg_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- rw [Real.intCast_lt]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">one_lt_cast</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hp'</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>\n<p>I need one last line to finish the proof.<br>\nIn mathlib there is the theorem</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">ratCast_lt</span>\n</code></pre></div>\n<p>but I need the exact same thing byt of the form Real.intCast_lt but this doesn't exist as far as I looked in Mathlib</p>",
        "id": 474118062,
        "sender_full_name": "Giulio Caflisch",
        "timestamp": 1727813096
    },
    {
        "content": "<p>You want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.cast_lt#doc\">docs#Int.cast_lt</a></p>",
        "id": 474119257,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1727813538
    },
    {
        "content": "<p>I found it by typing <code>Int.cast, _ &lt; _</code> in <a href=\"https://loogle.lean-lang.org/\">#loogle</a></p>",
        "id": 474119304,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1727813567
    },
    {
        "content": "<p>Thanks a lot. I also used <a href=\"https://loogle.lean-lang.org/\">#loogle</a> and somehow, searching</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">↑?</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">↑?</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">b</span>\n</code></pre></div>\n<p>nothing useful came out.</p>",
        "id": 474122637,
        "sender_full_name": "Giulio Caflisch",
        "timestamp": 1727814877
    },
    {
        "content": "<p>I think loogle does not really know how to interpret the arrows because they can mean any coercion, so it just ignores it, thus your request is the same as <code>_ &lt; _ ↔ _ &lt; _</code>, which is too general.</p>",
        "id": 474123370,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1727815123
    },
    {
        "content": "<p>Hi Giulio! One very useful trick I find when searching for an unknown lemma is to write it down carefully as a self-contained example and then use <code>exact?</code>. In situations like this one, when your goal has things like <code>↑a</code> involved whose meaning is context-dependent, <code>exact?</code> works best if you add explicit type annotations to make sure that all the types have been elaborated correctly before searching.</p>\n<p>E.g. if you type</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact?</span>\n</code></pre></div>\n<p>in to a lean file in VSCode, it will think for a few seconds and respond <code>Try this: exact WithTop.coe_lt_coe</code>.</p>",
        "id": 474263346,
        "sender_full_name": "David Loeffler",
        "timestamp": 1727867443
    }
]