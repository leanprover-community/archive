[
    {
        "content": "<p>What's the best way to set up a lexicographic induction on a sequence of my own inductives? Concretely, I have these inductives:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᵛ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Val</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">⤳ᵛ</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᵛ</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᵛ</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Com</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">sn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">⤳ᶜ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>and a theorem of this shape:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">lem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SN</span><span class=\"bp\">ᵛ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>which I need to prove lexicographically on <code>(snm, snv)</code>, so my recursive call is either on a direct subterm of <code>snm</code> with <code>snv</code> constant, or on a direct subterm of <code>snv</code> with <code>snm</code> constant.<br>\nI was thinking I could define a third predicate that somehow combines these two, and prove that combination from their conjunction, then induct over the combined predicate, but I was wondering if there's a conventional way to do this kind of thing.</p>",
        "id": 512395743,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744744176
    },
    {
        "content": "<p>fwiw indexing the predicate by a \"depth\" index doesn't seem to work since each recursive occurrence of SN could have a different depth</p>",
        "id": 512399888,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744745718
    },
    {
        "content": "<p>Make a recursive proof and let Lean figure it out for you</p>",
        "id": 512413263,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744751065
    },
    {
        "content": "<p>If Lean is not able to figure it out you can add an explicit <code>termination_by</code></p>",
        "id": 512413312,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744751086
    },
    {
        "content": "<p>If Lean is still not able to figure it out you can add a <code>decreasing_by</code></p>",
        "id": 512413343,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744751100
    },
    {
        "content": "<p>Well it's not structurally terminating on a single argument, and I can't use <code>sizeOf</code> on <code>snm</code> and <code>snv</code> because they're in Prop</p>",
        "id": 512414469,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744751595
    },
    {
        "content": "<p>Maybe <code>induction snm generalizing snv</code> followed by <code>induction snv</code> (this worked for me before on an ordinal double induction)</p>",
        "id": 512414727,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744751700
    },
    {
        "content": "<p>Actually, maybe not, since you have a mutual inductive</p>",
        "id": 512414797,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744751733
    },
    {
        "content": "<p>they're not actually mutual, but I don't think that'll work either, since the inner induction will correspond to a recursive call on subterms of both <code>snm</code> and <code>snv</code>, while I need the recursive calls to switch between one or the other being a subterm</p>",
        "id": 512415488,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744752035
    },
    {
        "content": "<p>okay you were right, a double induction does indeed work<br>\nidk why I was so convinced it wouldn't lol</p>",
        "id": 512547244,
        "sender_full_name": "Jonathan Chan",
        "timestamp": 1744808374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407610\">Jonathan Chan</span> has marked this topic as resolved.</p>",
        "id": 512547262,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744808379
    }
]