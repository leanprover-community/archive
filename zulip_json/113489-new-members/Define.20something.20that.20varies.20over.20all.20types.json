[
    {
        "content": "<p>How do I write something down that varies over literally all types? For example, <code>x : &lt;Syntax&gt;</code> such that <code>x</code> can vary over any type at all. Strictly speaking I don't think I need such an <code>x</code> in my work, but it did make me curious as to how one would go about doing that.</p>",
        "id": 502670831,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740778558
    },
    {
        "content": "<p>Are you asking about <code>variable {T : Type} (x : T)</code>?</p>",
        "id": 502671672,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740778896
    },
    {
        "content": "<p>(Specifically that says \"let T be a type that we say nothing else about, and x is a term of type T.\")</p>",
        "id": 502672369,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740779237
    },
    {
        "content": "<p>Is that what it says? Does it not mean that <code>T</code> is a term of type <code>Type</code>?</p>",
        "id": 502672618,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740779356
    },
    {
        "content": "<p><del>Types</del> Terms of type <code>Type</code> are types</p>",
        "id": 502672970,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740779532
    },
    {
        "content": "<p><em>Terms</em> (a typo I'm sure)</p>",
        "id": 502673134,
        "sender_full_name": "Julian Berman",
        "timestamp": 1740779616
    },
    {
        "content": "<p>Examples: <code>Nat</code>, <code>List Nat</code>, <code>Real</code>, and <code>Localization ((nonZeroDivisors Int).map (Int.castRingHom (Zsqrtd (-3))))</code> all have type <code>Type</code>.</p>",
        "id": 502673295,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740779696
    },
    {
        "content": "<p>So <code>Type u</code> where <code>u</code> is a universe is not a type? What about propositions, which have type <code>Prop</code>? I've always understood them to be types, whose terms are proofs of the propositions...</p>",
        "id": 502673583,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740779832
    },
    {
        "content": "<p>There is a difference between being \"a type\", with lowercase t, and <code>Type</code>.</p>",
        "id": 502673658,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740779875
    },
    {
        "content": "<p>Being \"a type\" is not a super formal notion, we usually say that <code>T</code> is a type if <code>T</code> has terms, so <code>t : T</code> makes sense.</p>",
        "id": 502673781,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740779913
    },
    {
        "content": "<p>Very often this means that <code>T : Type</code>, but now always. Note that in Lean (practically) everything is a term, so (practically) everything has its own type, but not everything is a type. For example the term <code>2</code> is not a type.</p>",
        "id": 502673924,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740779985
    },
    {
        "content": "<p>The subtle question is what is the type of the term <code>Type</code>, but depending on what you are interested in you can safely ignore this question at the beginning.</p>",
        "id": 502674030,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740780019
    },
    {
        "content": "<p>i guess in that sense, writing down something which varies over all \"types\" rather than <code>Type</code>s would amount to something like <code>{T : Sort u}</code> as a parameter</p>",
        "id": 502674139,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740780060
    },
    {
        "content": "<p>One can quantify over all <code>T : Type</code> without any problem. What cannot be done is quantify over all universes.</p>",
        "id": 502674469,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740780166
    },
    {
        "content": "<p>You can do a sort of restricted quantification with universe polymorphism, but it's not quite the same.</p>",
        "id": 502674568,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740780202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Define.20something.20that.20varies.20over.20all.20types/near/502674030\">said</a>:</p>\n<blockquote>\n<p>The subtle question is what is the type of the term <code>Type</code>, but depending on what you are interested in you can safely ignore this question at the beginning.</p>\n</blockquote>\n<p>Is it correct to guess from this that while <code>Type</code> as a term also has its type <code>Type 1</code>, I can't create terms of type <code>Type 1</code> other than <code>Type</code>?</p>",
        "id": 502675179,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740780458
    },
    {
        "content": "<p>Why not?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SuperNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Superzero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SuperNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Supersucc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SuperNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SuperNat</span>\n</code></pre></div>\n<p>is an example of a type of type <code>Type 8</code> (that is basically a copy of the natural numbers).</p>",
        "id": 502675634,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740780651
    },
    {
        "content": "<p>More concretely, <code>Type → Type</code> has type <code>Type 1</code></p>",
        "id": 502675708,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740780698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Define.20something.20that.20varies.20over.20all.20types/near/502674568\">said</a>:</p>\n<blockquote>\n<p>You can do a sort of restricted quantification with universe polymorphism, but it's not quite the same.</p>\n</blockquote>\n<p>Okay, I take it as a no to my original question.</p>\n<p>Might I ask, in that case, when trying to define something that works for every 'reasonable' input, what do I let my input vary over? <code>Type u</code> with a <code>universe u</code> declaration or something?</p>",
        "id": 502676067,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740780845
    },
    {
        "content": "<p>Yes</p>",
        "id": 502676419,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740781014
    },
    {
        "content": "<p>We can give a better answer if you have a precise question. If you are thinking about universal properties this is something not completely trivial to solve for example.</p>",
        "id": 502676721,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740781155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"426002\">Aatman Supkar</span> <a href=\"#narrow/channel/113489-new-members/topic/Define.20something.20that.20varies.20over.20all.20types/near/502676067\">said</a>:</p>\n<blockquote>\n<p>Might I ask, in that case, when trying to define something that works for every 'reasonable' input, what do I let my input vary over? <code>Type u</code> with a <code>universe u</code> declaration or something?</p>\n</blockquote>\n<p>It would be better if you were to give an example.</p>",
        "id": 502677604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740781609
    },
    {
        "content": "<p>Nothing in mind, in particular. This question was born out of pure curiosity, not much with a particular goal in mind. I'd imagine that people want to make algebraic structures like rings over their favourite type, though. What do they do?</p>",
        "id": 502677738,
        "sender_full_name": "Aatman Supkar",
        "timestamp": 1740781675
    },
    {
        "content": "<p>You can look at the source code for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring#doc\">docs#Ring</a>.</p>",
        "id": 502677906,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740781744
    },
    {
        "content": "<p><code>Ring</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"c1\">-- 91 lines omitted</span>\n<span class=\"sd\">/-- A `Ring` is a `Semiring` with negation making it an additive group. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddGroupWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>",
        "id": 502678104,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740781837
    },
    {
        "content": "<p>What happens here is that Lean actually creates <em>a family</em> of classes, <code>Ring.{u}</code>, one for each universe <code>u</code>. This is not exactly the same as having one class that allows the universe to vary, but in practice it works like that.</p>",
        "id": 502678455,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740781988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Define.20something.20that.20varies.20over.20all.20types/near/502673781\">said</a>:</p>\n<blockquote>\n<p>Being \"a type\" is not a super formal notion</p>\n</blockquote>\n<p>Is it not? I would have said: <code>t</code> is a type if <code>t : Type u</code> for some universe <code>u</code>. No?</p>",
        "id": 502680066,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740782870
    },
    {
        "content": "<p>I say that <code>T</code> is a type if <code>T</code> has terms, so <code>1+1=2</code> is a type for me (so <code>Sort u</code> rather than <code>Type u</code> is probably a formal translation of what I have in mind for \"being a type\")</p>",
        "id": 502680548,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740783105
    },
    {
        "content": "<p>By \"not a super formal notion\" I mean that we cannot write in Lean <code>T</code> is a type</p>",
        "id": 502680663,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740783157
    },
    {
        "content": "<p>is <code>Empty</code> a type then? <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 502680839,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1740783240
    },
    {
        "content": "<p>Ahahah, well spotted. <code>T</code> is a type if I can write <code>t : T</code>.</p>",
        "id": 502680941,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740783275
    },
    {
        "content": "<p>Like <code>variable (t : False)</code>.</p>",
        "id": 502680967,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1740783294
    },
    {
        "content": "<p>Lean agrees that our definitions coincide <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Although, for newcomers both of our definitions might be confusing due to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeSort#doc\">docs#CoeSort</a>, as this works, but more is happening than is visible from the source.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 502682269,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1740784022
    },
    {
        "content": "<p>maybe worth noting that you can also do <code>Type*</code> and have Lean do the universe polymorphism for you</p>",
        "id": 502682449,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740784135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Define.20something.20that.20varies.20over.20all.20types/near/502680548\">said</a>:</p>\n<blockquote>\n<p>I say that <code>T</code> is a type if <code>T</code> has terms</p>\n</blockquote>\n<p>I find this formulation a bit confusing - wouldn't it mean that uninhabited types are not types? (of course, in some contexts, even <code>False</code> has terms)</p>",
        "id": 502736842,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1740828031
    }
]