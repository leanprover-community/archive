[
    {
        "content": "<p>HI all. I have another question comparing Lean to Swift, since Swift is the language I'm currently using in my research lab. Swift has a powerful macro system that I use to auto-generate code supporting functional programming idioms. However, Swift's macro system has several drawbacks, and I'm curious how Lean compares on each of these points.</p>\n<p>1) Swift macros have to be built in their own package.<br>\nThis is annoying when you're first getting started, but not much of an issue in the long run. I'm pretty confident Lean wins on this point.</p>\n<p>2) Swift macros don't allow you to make new syntax.<br>\nMost Swift macros come in the form of a label you write to the side of some existing code, so you can't make new syntax constructs with it, the way you can in Lisp for example. I'm not trying to write a DSL or anything, so that hasn't really been an issue for me.</p>\n<p>Now we come to the two points that for me are probably the biggest drawbacks of Swift overall...</p>\n<p>3) Swift macros don't have access to type information.<br>\nThe macros operate on the AST, prior to type inference. Even when types are provided by the programmer so no inference is necessary, there is afaik no direct access to information about a type. For example, the type might be <code>MyType</code>, and there'd be no way to know that that is an alias for an array of strings or something. All you'd have access to is the name \"MyType\". Admittedly, I haven't used macros in another strongly typed language, so I don't know how a language like Lean compares here.</p>\n<p>4) Swift macro expansions are ignored by the auto-generated documentation.<br>\nThis is maybe the biggest thing, as I use macros to generate code, including public functions. I work with a team, and unless I document things careful and explain what each macro does, the team will have no idea what code a macro is generating. It's frustrating because otherwise, Xcode generates very nice documentation for Swift code. I'm really curious how Lean's doc-gen4 compares here.</p>\n<p>Thanks.</p>",
        "id": 515706450,
        "sender_full_name": "misterdrgn",
        "timestamp": 1746190308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/channel/113489-new-members/topic/Lean.20metaprogramming.20vs.20Swift.20macros/near/515706450\">said</a>:</p>\n<blockquote>\n<p>1) Swift macros have to be built in their own package.<br>\nThis is annoying when you're first getting started, but not much of an issue in the long run. I'm pretty confident Lean wins on this point.</p>\n</blockquote>\n<p>Syntax parsers, macros, and elaborators all work in the same file, as soon as they're defined. However, options and environment extensions don't work in the same file, and must be defined in an imported file.</p>",
        "id": 515712874,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746192117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/channel/113489-new-members/topic/Lean.20metaprogramming.20vs.20Swift.20macros/near/515706450\">said</a>:</p>\n<blockquote>\n<p>2) Swift macros don't allow you to make new syntax.<br>\nMost Swift macros come in the form of a label you write to the side of some existing code, so you can't make new syntax constructs with it, the way you can in Lisp for example. I'm not trying to write a DSL or anything, so that hasn't really been an issue for me.</p>\n</blockquote>\n<p>In Lean, you can make new syntax categories and write new syntax.</p>",
        "id": 515713237,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746192233
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/channel/113489-new-members/topic/Lean.20metaprogramming.20vs.20Swift.20macros/near/515706450\">said</a>:</p>\n<blockquote>\n<p>3) Swift macros don't have access to type information.<br>\nThe macros operate on the AST, prior to type inference. Even when types are provided by the programmer so no inference is necessary, there is afaik no direct access to information about a type. For example, the type might be <code>MyType</code>, and there'd be no way to know that that is an alias for an array of strings or something. All you'd have access to is the name \"MyType\". Admittedly, I haven't used macros in another strongly typed language, so I don't know how a language like Lean compares here.</p>\n</blockquote>\n<p>Lean macros basically only have access to the syntax, macro scopes, and basic error handling. For more complicated things, like needing to know type information, you would write an elaborator, which has access to the environment, and can do type inference, typeclass synthesis, and look up definitions.</p>",
        "id": 515714794,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746192686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/channel/113489-new-members/topic/Lean.20metaprogramming.20vs.20Swift.20macros/near/515706450\">said</a>:</p>\n<blockquote>\n<p>4) Swift macro expansions are ignored by the auto-generated documentation.<br>\nThis is maybe the biggest thing, as I use macros to generate code, including public functions. I work with a team, and unless I document things careful and explain what each macro does, the team will have no idea what code a macro is generating. It's frustrating because otherwise, Xcode generates very nice documentation for Swift code. I'm really curious how Lean's doc-gen4 compares here.</p>\n</blockquote>\n<p>Let's look at an example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt8.zero_def#doc\">docs#UInt8.zero_def</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UInt16.zero_def#doc\">docs#UInt16.zero_def</a>, etc were all <a href=\"https://github.com/leanprover/lean4/blob/045d07d2349b9989278991fbcd79a6430032930d/src/Init/Data/UInt/Lemmas.lean#L273-L277\">generated by a macro</a>, but docgen4 seems to document them fine. In fact, you can even see the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=commandDeclare_uint_theorems__#doc\">docs#commandDeclare_uint_theorems__</a> at the top of the docs for that file!</p>",
        "id": 515717193,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746193354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> Thank you as always for the thorough response. Thatâ€™s what I was hoping for.</p>",
        "id": 515720640,
        "sender_full_name": "misterdrgn",
        "timestamp": 1746194326
    }
]