[
    {
        "content": "<p>I'm trying to prove some things about the vector data type but occasionally run into problems dealing with the vector size in type definitions. For example, I have the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Vector</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">infixr</span><span class=\"o\">:</span><span class=\"mi\">67</span> <span class=\"s2\">\" :: \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Vector.cons</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Vector</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.zero_add</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">ys</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nil</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>How do I define <code>nil_append</code> in a type correct way? If I could use <code>Nat.zero_add</code> in the function definition, the types would match but not sure how to proceed.</p>",
        "id": 350727071,
        "sender_full_name": "sgcs",
        "timestamp": 1681811563
    },
    {
        "content": "<p>I've tried something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">Eq.mp</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nil</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">as</span><span class=\"o\">)))</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It ypechecks, but I'm not really sure how to prove it with the cast present. And it doesn't seem like it would be useful the way it's defined (at the very least, nil ++ xs doesn't seem to simplify in other places)</p>",
        "id": 350728611,
        "sender_full_name": "sgcs",
        "timestamp": 1681811966
    },
    {
        "content": "<p>Here are two places in mathlib that implement a pattern to solve this sort of issue: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs4#SimpleGraph.Walk.copy</a> <br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver.Hom.cast#doc\">docs4#Quiver.Hom.cast</a></p>",
        "id": 350734924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681813565
    },
    {
        "content": "<p>The idea would be that you define a <code>Vector.cast</code> function that takes an equality that swaps out the size of the array with something else. This is just <code>Eq.rec</code> under the hood but it helps keep the rewrites circumscribed to just the size (otherwise you're liable to get equalities of types, which aren't great)</p>",
        "id": 350735409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681813685
    },
    {
        "content": "<p>For example, in the <code>Vector</code> namespace:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_rfl</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">v.cast</span> <span class=\"n\">rfl</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_cast</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">m'</span> <span class=\"bp\">=</span> <span class=\"n\">m''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">v.cast</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">h'</span> <span class=\"bp\">=</span> <span class=\"n\">v.cast</span> <span class=\"o\">(</span><span class=\"n\">h.trans</span> <span class=\"n\">h'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">subst_vars</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 350735934,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681813792
    },
    {
        "content": "<p>Then this typechecks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">append</span> <span class=\"n\">nil</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">as.cast</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 350736309,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681813859
    },
    {
        "content": "<p>With a new version of <code>append</code> that makes use of <code>cast</code>, <code>nil_append</code> is a one-liner:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">append</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ys.cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">append</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">])</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nil_append</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">append</span> <span class=\"n\">nil</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">as.cast</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">as</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">append</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 350736661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681813976
    },
    {
        "content": "<p>Since <code>+</code> on <code>Nat</code> is defined by recursion on the second argument, I strongly recommend that you define <code>Vector.append</code> also by recursion on the second argument. This allows you to define it without any casts. Of course, to state <code>nil_append</code> you still have to use casts or heterogenous equality.</p>",
        "id": 350737555,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1681814232
    },
    {
        "content": "<p><code>Vector.cons</code> also needs to add elements to the end of the list to be able to implement <code>Vector.append</code> efficiently if you're inducting on the second argument. (Or we need to go back to the drawing board and refine <code>Nat.add</code> to induct on the first argument too <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 350738916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681814582
    },
    {
        "content": "<p>You're right, this would need an <code>snoc</code> operation...</p>",
        "id": 350739246,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1681814673
    },
    {
        "content": "<p>Re <code>HEq</code>: this is another way to state <code>nil_append</code>, and <code>HEq</code> can sometimes be more convenient than <code>cast</code>. The downsides are (1) you can't rewrite with a <code>HEq</code> lemma and (2) the <code>HEq</code> doesn't \"know\" that the sizes are equal, unlike <code>cast</code> which records that equality.</p>",
        "id": 350739612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681814780
    },
    {
        "content": "<p>i think you are able to extract the equality of types and therefore sizes from the <code>HEq</code></p>",
        "id": 350741906,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681815446
    },
    {
        "content": "<p>I think using only type equalities, from <code>Vector Nat m</code> you can only tell whether <code>m</code> is zero or nonzero, since <code>m</code> is zero if and only if the type is a singleton and <code>m</code> is nonzero if and only if the type is countable.</p>",
        "id": 350760212,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681820055
    },
    {
        "content": "<p>Ah, yes, the constructor isn't necessarily injective on types unless alpha is a fintype.</p>",
        "id": 350765294,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681821104
    },
    {
        "content": "<p>I wonder if stating that those families are disjoint is possible in type theories</p>",
        "id": 350765438,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1681821125
    }
]