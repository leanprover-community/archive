[
    {
        "content": "<p>Is it possible in lean to syntactically separate proof obligations from the code?</p>\n<p>As an example, with the proof obligation here I know of two ways I could write that proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n<span class=\"w\">  </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">h</span>\n</code></pre></div>\n<p>But in both cases the proof is written inline together with the code. Is it possible to somehow separate it? E.g. something like that?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">proof1</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">proof1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n</code></pre></div>\n<p>Or even better, without having to give a name to the proof.</p>\n<p>Also, the question is not tied to array access only, I would want something like that for any Prop autoParam.</p>",
        "id": 502354090,
        "sender_full_name": "MrQubo",
        "timestamp": 1740681903
    },
    {
        "content": "<p>It's a bit subjective. Do you think the following is a solution?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502361854,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1740684615
    },
    {
        "content": "<p>How about this...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">prove</span>\n</code></pre></div>",
        "id": 502362210,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1740684733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"325367\">@Mauricio Collares</span> Not really. You could imagine there's more code after <code>arr[0]</code>, or one more constructor and case <code>T.t3</code>.</p>",
        "id": 502362686,
        "sender_full_name": "MrQubo",
        "timestamp": 1740684918
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">prove</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n</code></pre></div>",
        "id": 502362892,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740684989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/502362686\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> Not really. You could imagine there's more code after <code>arr[0]</code>, or one more constructor and case <code>T.t3</code>.</p>\n</blockquote>\n<p>Can you give an example? I'm not sure I'll be able to help, but I think it will help others understand the constraints. With one more constructor, you could do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?_</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'?_</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502362938,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1740685006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/502362938\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/502362686\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"325367\">Mauricio Collares</span> Not really. You could imagine there's more code after <code>arr[0]</code>, or one more constructor and case <code>T.t3</code>.</p>\n</blockquote>\n<p>Can you give an example? I'm not sure I'll be able to help, but I think it will help others understand the constraints</p>\n</blockquote>\n<p>Yes, sorry, here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>I would want something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?_</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'?_</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">admit</span>\n</code></pre></div>\n<p>As to why I want it. My goal is to make the functions easier to read. Usually I wouldn't care about proofs if I want to read the function to understand what it does.</p>",
        "id": 502364194,
        "sender_full_name": "MrQubo",
        "timestamp": 1740685434
    },
    {
        "content": "<p>Ah, yes, I can refine the whole body of a function, that looks promising!</p>",
        "id": 502364321,
        "sender_full_name": "MrQubo",
        "timestamp": 1740685473
    },
    {
        "content": "<p>I imagine one day there will be some real syntax for this. I understand Coq has such a feature.</p>\n<p>Imagine a <code>proofs</code> clause, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">proofs</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 502378896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740691163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/502378896\">said</a>:</p>\n<blockquote>\n<p>I imagine one day there will be some real syntax for this. I understand Coq has such a feature.</p>\n<p>Imagine a <code>proofs</code> clause, something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">proofs</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I implemented this with a macro:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">declaration</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">proofs</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"o\">:</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">tacticSeqIndentGt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Tactic.tacticSeq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">proofs</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">raw</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- TODO: abbrev, opaque, example</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.definition</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"c1\">-- \"def \" &gt;&gt; declId &gt;&gt; optDeclSig &gt;&gt; declVal &gt;&gt; optDefDeriving</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declValSimple</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"c1\">-- leading_parser \" :=\\n\" &gt;&gt; termParser &gt;&gt; Termination.suffix &gt;&gt; optional Term.whereDecls</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">expandWhereDeclsOpt</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">term</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">term</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">proofs</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"n\">declVal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">term</span>\n<span class=\"w\">      </span><span class=\"n\">declVal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"bp\">.</span><span class=\"n\">isOfKind</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declValEqns</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"c1\">-- leading_parser Term.matchAltsWhereDecls</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">declValEqns</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declVal</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"c1\">-- leading_parser matchAlts &gt;&gt; Termination.suffix &gt;&gt; optional whereDecls</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">expandMatchAltsWhereDecls</span><span class=\"w\"> </span><span class=\"n\">declValEqns</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TSyntax</span><span class=\"w\"> </span><span class=\"ss\">`term</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">term</span><span class=\"bp\">⟩</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">term</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">proofs</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">terminationSuffix</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">declValEqns</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">declVal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mkNode</span><span class=\"w\"> </span><span class=\"ss\">``Parser.Command.declValSimple</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">mkAtom</span><span class=\"w\"> </span><span class=\"s2\">\":=\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">terminationSuffix</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkNullNode</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"n\">declVal</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">decl</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">d</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">   </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t2</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">'?</span><span class=\"n\">pf2</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">t3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"n\">proofs</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">pf2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 502457804,
        "sender_full_name": "MrQubo",
        "timestamp": 1740697356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/502378896\">said</a>:</p>\n<blockquote>\n<p>I understand Coq has such a feature.</p>\n</blockquote>\n<p>Indeed, in Coq there is a <code>Program Definition</code> constructor which defers all proof obligations to after you've defined your function, which I think is exactly what is being asked here: <a href=\"https://coq.inria.fr/doc/v8.9/refman/addendum/program.html#program-definition\">https://coq.inria.fr/doc/v8.9/refman/addendum/program.html#program-definition</a></p>",
        "id": 503070807,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1741019239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360938\">Tomaz Gomes</span> <a href=\"#narrow/channel/113489-new-members/topic/Syntactically.20separate.20goals.20from.20code/near/503070807\">said</a>:</p>\n<blockquote>\n<p>Indeed, in Coq there is a <code>Program Definition</code> constructor which defers all proof obligations to after you've defined your function, which I think is exactly what is being asked here: <a href=\"https://coq.inria.fr/doc/v8.9/refman/addendum/program.html#program-definition\">https://coq.inria.fr/doc/v8.9/refman/addendum/program.html#program-definition</a></p>\n</blockquote>\n<p>I don't know Coq too much, but indeed, I think that's what I'm asking about.<br>\nTo apply it to Lean specifically, I think that every unsolved autoParam should generate a proof obligation automatically. And maybe even every implicit param.</p>",
        "id": 503088626,
        "sender_full_name": "MrQubo",
        "timestamp": 1741024328
    }
]