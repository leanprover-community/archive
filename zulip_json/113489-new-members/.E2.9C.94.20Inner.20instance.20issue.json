[
    {
        "content": "<p>Iâ€™m working on matrix and inner product things following a lean 3 project, It seems I canâ€™t use my RCLike lemmas to matrix without instances, and I try to achieve an instance but failed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Star</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">RCLike</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">Reflection</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">BigOperators</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Matrix</span>\n\n<span class=\"kn\">local</span><span class=\"w\"> </span><span class=\"kn\">notation</span><span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"s2\">\"â€ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">star</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">conjugate</span>\n<span class=\"c1\">-- Conjugate of a vector.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">conj</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">â€ </span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">conjugate</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">inner_product</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Inner product of two vectors, following the convention that it is conjugate linear in the first argument. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inner_product</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">dotProduct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">conj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">inner_product</span><span class=\"bp\">âŸ©</span>\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">stuck at solving universe constraint</span>\n<span class=\"cm\">  max (?u.2784+1) (?u.2790+1) =?= ?u.2784+1</span>\n<span class=\"cm\">while trying to unify</span>\n<span class=\"cm\">  Type (max ?u.2784 ?u.2790) : Type (max (?u.2784 + 1) (?u.2790 + 1))</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  Type ?u.2784 : Type (?u.2784 + 1)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>This is the lean 3 project I followed.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import data.matrix.basic</p>\n<p>import analysis.normed_space.inner_product<br>\nimport algebra.big_operators.default</p>\n<p>open_locale big_operators<br>\nopen is_R_or_C</p>\n<hr>\n<p>-- â„ lemmas</p>\n<p>lemma real.le_of_le_pow_two {a b : â„} : a^2 â‰¤ b^2 â†’ 0 â‰¤ a â†’ 0 â‰¤ b â†’ a â‰¤ b<br>\n:= begin<br>\n    intros h an bn,<br>\n    rw &lt;- real.sqrt_mul_self an,<br>\n    rw &lt;- real.sqrt_mul_self bn,<br>\n    iterate 2 { rw pow_two at h },<br>\n    apply real.sqrt_le_sqrt; assumption,<br>\nend</p>\n<hr>\n<p>-- Begining of the namespace <code>matrix</code></p>\n<p>namespace matrix</p>\n<p>-- We could use <code>has_star.star</code>, but <code>inner_product_space</code> expects <code>is_R_or_C</code> anyways.<br>\nlocal notation x <code>â€ </code>:90 := is_R_or_C.conj x<br>\nlocal notation |x| := is_R_or_C.abs x</p>\n<hr>\n<p>-- matrix.conj for vectors</p>\n<p>section conjugate</p>\n<p>variables {ğ•œ : Type} [is_R_or_C ğ•œ]<br>\nvariables {m : Type}</p>\n<p>/--<br>\nConjugate of a vector.<br>\n-/<br>\ndef conj (v : m â†’ ğ•œ) : m â†’ ğ•œ := Î» i : m, (v i)â€ </p>\n<p>end conjugate</p>\n<hr>\n<p>-- matrix.conj lemmas</p>\n<p>section conj_lemmas</p>\n<p>variables {ğ•œ : Type} [is_R_or_C ğ•œ]<br>\nvariables {m : Type}<br>\nvariables {x y : m â†’ ğ•œ}</p>\n<p>variable {s : ğ•œ}</p>\n<p>@[simp]<br>\nlemma conj_zero : conj 0 = (0 : m â†’ ğ•œ)<br>\n:= begin<br>\n    unfold conj,<br>\n    ext1 i, simp,<br>\nend</p>\n<p>lemma conj_smul : conj (s â€¢ x) = sâ€  â€¢ conj x<br>\n:= begin<br>\n    unfold conj,<br>\n    ext1 i,<br>\n    iterate 2 { rw pi.smul_apply }, simp,<br>\nend</p>\n<p>lemma conj_add : conj (x + y) = conj x + conj y<br>\n:= begin<br>\n    unfold conj,<br>\n    ext1 i,<br>\n    iterate 2 { rw pi.add_apply }, simp,<br>\nend</p>\n<p>lemma conj_neg : conj (-x) = - conj x<br>\n:= begin<br>\n    unfold conj,<br>\n    ext1 i,<br>\n    simp,<br>\nend</p>\n<p>end conj_lemmas</p>\n<hr>\n<p>-- matrix.inner_product for vectors</p>\n<p>section inner_product</p>\n<p>variables {ğ•œ : Type} [is_R_or_C ğ•œ]<br>\nvariables {m : Type} [fintype m]</p>\n<p>/--<br>\nInner product of vectors.<br>\nFollowing analysis.normed_space.inner_product's convention that<br>\ninner products are conjugate linear in the first argument and linear<br>\nin the second.<br>\n-/<br>\ndef inner_product (x y : m â†’ ğ•œ) : ğ•œ := dot_product (conj x) y</p>\n<p>instance : has_inner ğ•œ (m â†’ ğ•œ) := âŸ¨inner_productâŸ©</p>\n<p>end inner_product</p>\n<p>-- <code>âŸªx, yâŸ«</code> : inner product notation.<br>\n-- <code>âŸ¨ , âŸ©</code> is already taken in Lean. So, use  <code>âŸª , âŸ«</code>, instead.<br>\n-- Also, it's consistent with analysis.normed_space.inner_product's other notations.<br>\nlocal notation <code>âŸª</code> X <code>,</code> Y <code>âŸ«</code> := inner_product X Y```</p>\n</div></div>\n<p>I don't have much experience on instances even after studying <code> The Lean Language Reference </code> . As I check the document, has_inner and inner looks like no different in building an instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Inner</span><span class=\"o\">(</span><span class=\"n\">ğ•œ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span>\n<span class=\"n\">Syntactic</span><span class=\"w\"> </span><span class=\"n\">typeclass</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"n\">endowed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">product</span>\n\n<span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">ğ•œ</span>\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">product</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"bp\">.</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">class</span><span class=\"kd\">]</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">has_inner</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ğ•œ</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n\n<span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"w\"> </span><span class=\"n\">u_5</span><span class=\"o\">)</span>\n\n<span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"n\">ğ•œ</span>\n\n<span class=\"n\">Syntactic</span><span class=\"w\"> </span><span class=\"n\">typeclass</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"n\">endowed</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"w\"> </span><span class=\"n\">product</span>\n</code></pre></div>\n<p>Can anyone tell me how to achieve the inner instance?</p>",
        "id": 508884402,
        "sender_full_name": "polaris",
        "timestamp": 1743222378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"877733\">polaris</span> has marked this topic as resolved.</p>",
        "id": 508891743,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743228910
    },
    {
        "content": "<p>(to format code in spoiler blocks on zulip, use four backticks not three)</p>",
        "id": 508900995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743236803
    },
    {
        "content": "<p>For what it's worth you don't need to define the conjugate of a vector, it already exists as <code>star v</code></p>",
        "id": 508918954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743252052
    }
]