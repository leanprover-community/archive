[
    {
        "content": "<p>I get <code>'induction' tactic does not support mutually inductive types, the eliminator 'MyType.rec' has multiple motives</code>. If needed I can try to make an mwe, but maybe someone has a hint how to deal with this in general? Is <code>induction</code> in Lean 4 less powerful than in Lean 3? I saw <a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/induction.20on.20mutual.20inductives.20fails.html\">this discussion from 2021</a> but I am such a user that does not know what \"motives\" are. Do I need to understand it if I want to work with mutually inductive types in Lean 4?</p>",
        "id": 394906244,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696448662
    },
    {
        "content": "<p>the motive is just the thing you're trying to prove.</p>",
        "id": 394906818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696448903
    },
    {
        "content": "<p>Ah, then I guess I do not really know what the eliminator of my type is. I guess to do induction on a mutually inductive type I have to show two motives, one for each of the types?</p>",
        "id": 394908074,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696449541
    },
    {
        "content": "<p>I'll see if I can make an MWE tomorrow. thanks for now!</p>",
        "id": 394908694,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696449788
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 394909203,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1696450035
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 394909757,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1696450300
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 394909847,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1696450336
    },
    {
        "content": "<p>Here comes my example. I actually have three questions, and the second to me feels like a bug <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- MWE about Mutually Inductive Types</span>\n<span class=\"c1\">-- A bag is a thing that contains an object.</span>\n<span class=\"c1\">-- A box is an object that contains two things.</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span> <span class=\"c1\">-- comment this and sizeOfThing no longer errors O.o</span>\n\n<span class=\"c1\">-- Question 1: How do I get DecidableEq for these types?</span>\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Thing</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"o\">:</span> <span class=\"n\">Thing</span>\n    <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"o\">:</span> <span class=\"n\">Thing</span> <span class=\"bp\">→</span> <span class=\"n\">Thing</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"o\">:</span> <span class=\"n\">Object</span> <span class=\"bp\">→</span> <span class=\"n\">Thing</span>\n    <span class=\"n\">deriving</span> <span class=\"n\">Repr</span> <span class=\"c1\">-- , DecidableEq -- error \"default handlers have not been implemented yet\"</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">Object</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bike</span> <span class=\"o\">:</span> <span class=\"n\">Object</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Box</span> <span class=\"o\">:</span> <span class=\"n\">Thing</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Thing</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Object</span>\n    <span class=\"n\">deriving</span> <span class=\"n\">Repr</span> <span class=\"c1\">-- , DecidableEq</span>\n<span class=\"kd\">end</span>\n<span class=\"c1\">-- if deriving is not possible, how would I write these manually?</span>\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">instance</span> <span class=\"n\">decEqThing</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Thing</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"kd\">instance</span> <span class=\"n\">decEqObject</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Object</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c1\">-- Question 2: When I \"import Mathlib.Data.Finset.Basic\" above, then this here</span>\n<span class=\"c1\">-- fails with: \"structural recursion does not handle mutually recursive functions\".</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Thing</span> <span class=\"n\">Object</span>\n\n<span class=\"kd\">mutual</span>\n  <span class=\"kd\">def</span> <span class=\"n\">sizeOfThing</span> <span class=\"o\">:</span> <span class=\"n\">Thing</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">13</span>\n    <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">s</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span>\n  <span class=\"kd\">def</span> <span class=\"n\">sizeOfObject</span> <span class=\"o\">:</span> <span class=\"n\">Object</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bike</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">42</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Box</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t2</span>\n<span class=\"kd\">end</span>\n<span class=\"c1\">-- decreasing_by sorry -- would this help?</span>\n<span class=\"c1\">-- Should I be doing it, or just avoiding the (unrelated) import above?</span>\n\n\n\n<span class=\"c1\">-- Question 3: How do I prove things about mutually inductive types?</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">sizeOfObject</span> <span class=\"o\">(</span><span class=\"n\">Box</span> <span class=\"n\">t</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span>\n  <span class=\"c1\">-- induction t</span>\n  <span class=\"c1\">-- \"induction t\" here gives me the error:</span>\n  <span class=\"c1\">--      'induction' tactic does not support mutually inductive types,</span>\n  <span class=\"c1\">--      the eliminator 'Thing.rec' has multiple motives</span>\n  <span class=\"c1\">-- What can I use instead?</span>\n  <span class=\"c1\">-- \"cases t\" will not give me an induction hypothesis, right?</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 395082787,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696524417
    },
    {
        "content": "<p>You meant <code>Thing</code> and <code>Object</code>, not <code>Formula</code> and <code>Program</code>, right?</p>",
        "id": 395084145,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696524909
    },
    {
        "content": "<p>Ah, yes, sorry, that was copypasta leftover from my original code.</p>",
        "id": 395084248,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696524957
    },
    {
        "content": "<p>The unrelated import seems to be caused by </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Basic</span>\n</code></pre></div>\n<p>at least I can observe your issue with that, but not if I replace it with that module’s imports.</p>",
        "id": 395084790,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696525163
    },
    {
        "content": "<p>And if I change the result type of <code>sizeOfThing</code> from <code>Nat</code> to <code>Unit</code> the problem also goes away.</p>",
        "id": 395085183,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696525317
    },
    {
        "content": "<p>Ah, thanks for tracking that down. I also noticed that my code behaves differently when I used <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> instead of <code>Nat</code>, resulting in <code>failed to synthesize instance OfNat ℕ 13</code> etc. Is that related?</p>",
        "id": 395085268,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696525332
    },
    {
        "content": "<p>Could it be that importing something brings extra lemmas or simp rules in scope which make the thing that tries to prove the termination / decreasing fail?</p>",
        "id": 395085379,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696525383
    },
    {
        "content": "<p>This seems to work (although I wonder how that differs from the default):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n  <span class=\"kd\">def</span> <span class=\"n\">sizeOfThing</span> <span class=\"o\">:</span> <span class=\"n\">Thing</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">13</span>\n    <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">s</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span>\n  <span class=\"kd\">def</span> <span class=\"n\">sizeOfObject</span> <span class=\"o\">:</span> <span class=\"n\">Object</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Bike</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">42</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Box</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">10</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t2</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n  <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">o</span>\n</code></pre></div>",
        "id": 395086868,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696525967
    },
    {
        "content": "<p>Oh, what is <code>sizeOf</code> here then? A default method counting levels of nested constructors?</p>",
        "id": 395087158,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696526066
    },
    {
        "content": "<p>Yes, I think it is generated automatically whenever you define an inductive</p>",
        "id": 395087670,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696526266
    },
    {
        "content": "<p>And here is how you can proof your theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">sizeOfObject</span> <span class=\"o\">(</span><span class=\"n\">Box</span> <span class=\"n\">t</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span>  <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">sizeOfObject</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.mul_two</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_self_left</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>;-)</p>",
        "id": 395087698,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696526279
    },
    {
        "content": "<p>Your comment “  -- \"cases t\" will not give me an induction hypothesis, right?” is actually going into a possibly right direction: You can use <code>aboutThings</code> inside <code>aboutThings</code>, it’ll be like a recursive function definition, and the system (or you) can prove termination, that works as a recursive proof.</p>",
        "id": 395087920,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696526365
    },
    {
        "content": "<p>Like this (the lemma is not a good example, I guess):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">sizeOfObject</span> <span class=\"o\">(</span><span class=\"n\">Box</span> <span class=\"n\">t</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 395088280,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696526495
    },
    {
        "content": "<p>I was expecting this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">t</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfThing</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfThing</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">aboutObjects</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aboutObjects</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">o</span>\n  <span class=\"n\">cases</span> <span class=\"n\">o</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Bike</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Box</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfObject</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">aboutThings</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span><span class=\"o\">),</span> <span class=\"n\">aboutThings</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">aboutThings</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n  <span class=\"n\">aboutObjects</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">o</span>\n</code></pre></div>\n<p>but I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">unknown</span> <span class=\"kd\">constant</span> <span class=\"bp\">'</span><span class=\"n\">aboutObjects'</span>\n</code></pre></div>",
        "id": 395089322,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696526887
    },
    {
        "content": "<p>Ok, avoiding putting the recursive call inside <code>rw</code> avoids that bug:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">mutual</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Pizza</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">round</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfThing</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Bag</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfThing</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">aboutObjects</span> <span class=\"n\">o</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aboutObjects</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Bike</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Box</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">sizeOfObject</span>\n    <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t1</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t2</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span><span class=\"o\">),</span> <span class=\"n\">h1</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">termination_by</span>\n  <span class=\"n\">aboutThings</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n  <span class=\"n\">aboutObjects</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">o</span>\n</code></pre></div>",
        "id": 395089656,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696527021
    },
    {
        "content": "<p>Nice, thank you! Indeed the lemma was a silly example, as it can also be proven without induction.</p>",
        "id": 395090613,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696527424
    },
    {
        "content": "<p>You can also write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t2</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span><span class=\"o\">),</span> <span class=\"n\">aboutThings</span> <span class=\"n\">t1</span>\n</code></pre></div>\n<p>as long as you pass the parameter explicitly.</p>",
        "id": 395090671,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696527448
    },
    {
        "content": "<p>Reported the kernel error at <a href=\"https://github.com/leanprover/lean4/issues/2628\">https://github.com/leanprover/lean4/issues/2628</a></p>",
        "id": 395092928,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696528388
    },
    {
        "content": "<p>And back to your original question: As far as I know, support for structural mutual recursion is planned, but not present. At the moment, it generates the <code>sizeOf</code> function structurally recursively, thus enabling you to define stuff using well-founded recursion (and even if your definition looks structurally recursive and gets accepted without further ado, the system uses well-founded recursion internally).<br>\n<code>sizeOf</code> is defined by way of <code>Object.rec</code>, and I assume you can use that directly, if you want to.</p>",
        "id": 395093564,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696528672
    },
    {
        "content": "<p>Note to self: DecidableEq for mutual inductives is apparently not yet doable but coming up in the next Lean version: <a href=\"https://github.com/leanprover/lean4/pull/2591\">https://github.com/leanprover/lean4/pull/2591</a></p>",
        "id": 395093576,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1696528678
    },
    {
        "content": "<p>Here is a proof using the recursor directly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">aboutThings</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Thing.rec</span>\n    <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOfThing</span> <span class=\"n\">t</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">o</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOfObject</span> <span class=\"n\">o</span> <span class=\"bp\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Bag</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">o</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">dsimp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">sizeOfThing</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Bike</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Box</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">t</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">dsimp</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">sizeOfObject</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_mod</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 395094217,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1696528909
    },
    {
        "content": "<p>Late thanks again for this. This example using a recuror direclty helped me in anoher case just now <span aria-label=\"smiley cat\" class=\"emoji emoji-1f63a\" role=\"img\" title=\"smiley cat\">:smiley_cat:</span></p>",
        "id": 398142623,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1698088369
    },
    {
        "content": "<p>Is it bad pratice to do something like <code>apply Thing.rec</code> in a tactic proof?</p>",
        "id": 398142688,
        "sender_full_name": "Malvin Gattinger",
        "timestamp": 1698088396
    }
]